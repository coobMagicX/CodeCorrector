{"Compiler": "public class Compiler extends AbstractCompiler {\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<String, CompilerInput> inputsByName;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void initModules(\n      List<JSSourceFile> externs, List<JSModule> modules,\n      CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private List<CompilerInput> makeCompilerInput(\n      List<JSSourceFile> files, boolean isExtern) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByNameMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compileModules(List<JSSourceFile> externs,\n      List<JSModule> modules, CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Result compile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void compileInternal() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void parse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  PassConfig getPassConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void check() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void externExports() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  void process(CompilerPass p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n         //The specific code has been omitted, but there is no error\n        };\n\n  private void maybeSanityCheck() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void runSanityCheck() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void stopTracer(Tracer t, String passName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Node getRoot() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes an input file from AST.\n   * @param name The name of the file to be removed.\n   */\n  protected void removeExternInput(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  MemoizedScopeCreator getTypedScopeCreator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  SymbolTable buildKnownSymbolTable() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Scope getTopScope() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  TypeValidator getTypeValidator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public Node parse(JSSourceFile file) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  Node parseSyntheticCode(String js) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void initCompilerOptionsIfTesting() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  Node parseTestCode(String js) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n         //The specific code has been omitted, but there is no error\n        }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean isInliningForbidden() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void normalize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  void prepareAst(Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void recordFunctionInformation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isIdeMode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public LanguageMode languageMode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean acceptConstKeyword() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  Config getParserConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void report(JSError error) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  boolean hasHaltingErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public String getSourceLine(String sourceName, int lineNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public SourceMap getSourceMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  VariableMap getVariableMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  VariableMap getPropertyMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  CompilerOptions getOptions() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, JSSourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n\n    private IntermediateState() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  ReferenceMap getGlobalVarReferences() {\n         //The specific code has been omitted, but there is no error\n        }\n\n}", "CodeBuilder": "  public static class CodeBuilder {\n         //The specific code has been omitted, but there is no error\n        }", "IntermediateState": "  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n\n    private IntermediateState() {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}