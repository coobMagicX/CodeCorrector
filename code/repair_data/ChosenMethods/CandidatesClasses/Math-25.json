{"HarmonicFitter": "public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n    /**\n     * Simple constructor.\n     * @param optimizer Optimizer to use for the fitting.\n     */\n    public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Fit an harmonic function to the observed points.\n     *\n     * @param initialGuess First guess values in the following order:\n     * <ul>\n     *  <li>Amplitude</li>\n     *  <li>Angular frequency</li>\n     *  <li>Phase</li>\n     * </ul>\n     * @return the parameters of the harmonic function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit(double[] initialGuess) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Fit an harmonic function to the observed points.\n     * An initial guess will be automatically computed.\n     *\n     * @return the parameters of the harmonic function that best fits the\n     * observed points (see the other {@link #fit(double[]) fit} method.\n     * @throws NumberIsTooSmallException if the sample is too short for the\n     * the first guess to be computed.\n     * @throws ZeroException if the first guess cannot be computed because\n     * the abscissa range is zero.\n     */\n    public double[] fit() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * This class guesses harmonic coefficients from a sample.\n     * <p>The algorithm used to guess the coefficients is as follows:</p>\n     *\n     * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,\n     * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).\n     * </p>\n     *\n     * <p>From the analytical expression, we can compute two primitives :\n     * <pre>\n     *     If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2\n     *     If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2\n     *     where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)\n     * </pre>\n     * </p>\n     *\n     * <p>We can remove S between these expressions :\n     * <pre>\n     *     If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)\n     * </pre>\n     * </p>\n     *\n     * <p>The preceding expression shows that If'2 (t) is a linear\n     * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)\n     * </p>\n     *\n     * <p>From the primitive, we can deduce the same form for definite\n     * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :\n     * <pre>\n     *   If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))\n     * </pre>\n     * </p>\n     *\n     * <p>We can find the coefficients A and B that best fit the sample\n     * to this linear expression by computing the definite integrals for\n     * each sample points.\n     * </p>\n     *\n     * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the\n     * coefficients A and B that minimize a least square criterion\n     * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>\n     * <pre>\n     *\n     *         &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     *     A = ------------------------\n     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n     *\n     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>\n     *     B = ------------------------\n     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n     * </pre>\n     * </p>\n     *\n     *\n     * <p>In fact, we can assume both a and &omega; are positive and\n     * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that\n     * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>\n     * <pre>\n     *\n     * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:\n     *   f  (t<sub>i</sub>)\n     *   f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)\n     *   x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>\n     *   y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n     *   z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n     *   update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>\n     * end for\n     *\n     *            |--------------------------\n     *         \\  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     * a     =  \\ | ------------------------\n     *           \\| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     *\n     *\n     *            |--------------------------\n     *         \\  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     * &omega;     =  \\ | ------------------------\n     *           \\| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n     *\n     * </pre>\n     * </p>\n     *\n     * <p>Once we know &omega;, we can compute:\n     * <pre>\n     *    fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)\n     *    fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)\n     * </pre>\n     * </p>\n     *\n     * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and\n     * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these\n     * expressions to compute &phi;. The best estimate over the sample is\n     * given by averaging these expressions.\n     * </p>\n     *\n     * <p>Since integrals and means are involved in the preceding\n     * estimations, these operations run in O(n) time, where n is the\n     * number of measurements.</p>\n     */\n    public static class ParameterGuesser {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ParameterGuesser": "    public static class ParameterGuesser {\n         //The specific code has been omitted, but there is no error\n        }"}