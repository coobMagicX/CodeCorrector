{"NamedType": "class NamedType extends ProxyObjectType {\n  private static final long serialVersionUID = 1L;\n\n  private final String reference;\n  private final String sourceName;\n  private final int lineno;\n  private final int charno;\n\n  /**\n   * Validates the type resolution.\n   */\n  private Predicate<JSType> validator;\n\n  /**\n   * Property-defining continuations.\n   */\n  private List<PropertyContinuation> propertyContinuations = null;\n\n  /**\n   * Create a named type based on the reference.\n   */\n  NamedType(JSTypeRegistry registry, String reference,\n      String sourceName, int lineno, int charno) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void finishPropertyContinuations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns the type to which this refers (which is unknown if unresolved). */\n  public JSType getReferencedType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public String getReferenceName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean hasReferenceName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  boolean isNamedType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isNominalType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Resolves a named type by looking it up in the registry.\n   * @return True if we resolved successfully.\n   */\n  private boolean resolveViaRegistry(\n      ErrorReporter t, StaticScope<JSType> enclosing) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Resolves a named type by looking up its first component in the scope, and\n   * subsequent components as properties. The scope must have been fully\n   * parsed and a symbol table constructed.\n   */\n  private void resolveViaProperties(ErrorReporter t,\n                                    StaticScope<JSType> enclosing) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Resolves a type by looking up its first component in the scope, and\n   * subsequent components as properties. The scope must have been fully\n   * parsed and a symbol table constructed.\n   * @return The type of the symbol, or null if the type could not be found.\n   */\n  private JSType lookupViaProperties( ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleTypeCycle(ErrorReporter t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void checkEnumElementCycle(ErrorReporter t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // Warns about this type being unresolved iff it's not a forward-declared\n  // type name.\n  private void handleUnresolvedType(\n      ErrorReporter t, boolean ignoreForwardReferencedTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  JSType getTypedefType(ErrorReporter t, StaticSlot<JSType> slot, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean setValidator(Predicate<JSType> validator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Store enough information to define a property at a later time. */\n  private static final class PropertyContinuation {\n         //The specific code has been omitted, but there is no error\n        }\n}", "PropertyContinuation": "  private static final class PropertyContinuation {\n         //The specific code has been omitted, but there is no error\n        }"}