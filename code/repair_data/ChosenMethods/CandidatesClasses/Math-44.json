{"AbstractIntegrator": "public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n\n    /** Step handler. */\n    protected Collection<StepHandler> stepHandlers;\n\n    /** Current step start time. */\n    protected double stepStart;\n\n    /** Current stepsize. */\n    protected double stepSize;\n\n    /** Indicator for last step. */\n    protected boolean isLastStep;\n\n    /** Indicator that a state or derivative reset was triggered by some event. */\n    protected boolean resetOccurred;\n\n    /** Events states. */\n    private Collection<EventState> eventsStates;\n\n    /** Initialization indicator of events states. */\n    private boolean statesInitialized;\n\n    /** Name of the method. */\n    private final String name;\n\n    /** Counter for number of evaluations. */\n    private Incrementor evaluations;\n\n    /** Differential equations to integrate. */\n    private transient ExpandableStatefulODE expandable;\n\n    /** Build an instance.\n     * @param name name of the method\n     */\n    public AbstractIntegrator(final String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Build an instance with a null name.\n     */\n    protected AbstractIntegrator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void addStepHandler(final StepHandler handler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public Collection<StepHandler> getStepHandlers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void clearStepHandlers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void addEventHandler(final EventHandler handler,\n                                final double maxCheckInterval,\n                                final double convergence,\n                                final int maxIterationCount) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void addEventHandler(final EventHandler handler,\n                                final double maxCheckInterval,\n                                final double convergence,\n                                final int maxIterationCount,\n                                final UnivariateRealSolver solver) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public Collection<EventHandler> getEventHandlers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void clearEventHandlers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public double getCurrentStepStart() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public double getCurrentSignedStepsize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void setMaxEvaluations(int maxEvaluations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public int getMaxEvaluations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public int getEvaluations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Reset the number of evaluations to zero.\n     */\n    protected void resetEvaluations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Set the equations.\n     * @param equations equations to set\n     */\n    protected void setEquations(final ExpandableStatefulODE equations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public double integrate(final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y0, final double t, final double[] y)\n        throws MathIllegalStateException, MathIllegalArgumentException {\n\n        if (y0.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y0.length, equations.getDimension());\n        }\n        if (y.length != equations.getDimension()) {\n            throw new DimensionMismatchException(y.length, equations.getDimension());\n        }\n\n        // prepare expandable stateful equations\n        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\n        expandableODE.setTime(t0);\n        expandableODE.setPrimaryState(y0);\n\n        // perform integration\n        integrate(expandableODE, t);\n\n        // extract results back from the stateful equations\n        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\n        return expandableODE.getTime();\n\n    }\n\n    /** Integrate a set of differential equations up to the given time.\n     * <p>This method solves an Initial Value Problem (IVP).</p>\n     * <p>The set of differential equations is composed of a main set, which\n     * can be extended by some sets of secondary equations. The set of\n     * equations must be already set up with initial time and partial states.\n     * At integration completion, the final time and partial states will be\n     * available in the same object.</p>\n     * <p>Since this method stores some internal state variables made\n     * available in its public interface during integration ({@link\n     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n     * @param equations complete set of differential equations to integrate\n     * @param t target time for the integration\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\n     * @throws MathIllegalStateException if the integrator cannot perform integration\n     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n     * too small integration span)\n     */\n    public abstract void integrate(ExpandableStatefulODE equations, double t)\n        throws MathIllegalStateException, MathIllegalArgumentException;\n\n    /** Compute the derivatives and check the number of evaluations.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n     */\n    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n        throws MaxCountExceededException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }\n\n    /** Set the stateInitialized flag.\n     * <p>This method must be called by integrators with the value\n     * {@code false} before they start integration, so a proper lazy\n     * initialization is done automatically on the first step.</p>\n     * @param stateInitialized new value for the flag\n     * @since 2.2\n     */\n    protected void setStateInitialized(final boolean stateInitialized) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            resetOccurred = false;\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            });\n\n            for (final EventState state : eventsStates) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // trigger the event\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n                if (isLastStep) {\n         //The specific code has been omitted, but there is no error\n        }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n         //The specific code has been omitted, but there is no error\n        }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return currentT;\n\n    }\n\n    /** Check the integration span.\n     * @param equations set of differential equations\n     * @param t target time for the integration\n     * @exception NumberIsTooSmallException if integration span is too small\n     */\n    protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n        throws NumberIsTooSmallException {\n\n        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n                                                                  FastMath.abs(t)));\n        final double dt = FastMath.abs(equations.getTime() - t);\n        if (dt <= threshold) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n}"}