{"ProcessClosurePrimitives": "class ProcessClosurePrimitives extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n\n  static final DiagnosticType NULL_ARGUMENT_ERROR = DiagnosticType.error(\n      \"JSC_NULL_ARGUMENT_ERROR\",\n      \"method \\\"{0}\\\" called without an argument\");\n\n  static final DiagnosticType EXPECTED_OBJECTLIT_ERROR = DiagnosticType.error(\n      \"JSC_EXPECTED_OBJECTLIT_ERROR\",\n      \"method \\\"{0}\\\" expected an object literal argument\");\n\n  static final DiagnosticType EXPECTED_STRING_ERROR = DiagnosticType.error(\n      \"JSC_EXPECTED_STRING_ERROR\",\n      \"method \\\"{0}\\\" expected an object string argument\");\n\n  static final DiagnosticType INVALID_ARGUMENT_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_ARGUMENT_ERROR\",\n      \"method \\\"{0}\\\" called with invalid argument\");\n\n  static final DiagnosticType INVALID_STYLE_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_CSS_NAME_MAP_STYLE_ERROR\",\n      \"Invalid CSS name map style {0}\");\n\n  static final DiagnosticType TOO_MANY_ARGUMENTS_ERROR = DiagnosticType.error(\n      \"JSC_TOO_MANY_ARGUMENTS_ERROR\",\n      \"method \\\"{0}\\\" called with more than one argument\");\n\n  static final DiagnosticType DUPLICATE_NAMESPACE_ERROR = DiagnosticType.error(\n      \"JSC_DUPLICATE_NAMESPACE_ERROR\",\n      \"namespace \\\"{0}\\\" cannot be provided twice\");\n\n  static final DiagnosticType FUNCTION_NAMESPACE_ERROR = DiagnosticType.error(\n      \"JSC_FUNCTION_NAMESPACE_ERROR\",\n      \"\\\"{0}\\\" cannot be both provided and declared as a function\");\n\n  static final DiagnosticType MISSING_PROVIDE_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_PROVIDE_ERROR\",\n      \"required \\\"{0}\\\" namespace never provided\");\n\n  static final DiagnosticType LATE_PROVIDE_ERROR = DiagnosticType.error(\n      \"JSC_LATE_PROVIDE_ERROR\",\n      \"required \\\"{0}\\\" namespace not provided yet\");\n\n  static final DiagnosticType INVALID_PROVIDE_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_PROVIDE_ERROR\",\n      \"\\\"{0}\\\" is not a valid JS identifier name\");\n\n  static final DiagnosticType INVALID_DEFINE_NAME_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_DEFINE_NAME_ERROR\",\n      \"\\\"{0}\\\" is not a valid JS identifier name\");\n\n  static final DiagnosticType MISSING_DEFINE_ANNOTATION = DiagnosticType.error(\n      \"JSC_INVALID_MISSING_DEFINE_ANNOTATION\",\n      \"Missing @define annotation\");\n\n  static final DiagnosticType XMODULE_REQUIRE_ERROR = DiagnosticType.warning(\n      \"JSC_XMODULE_REQUIRE_ERROR\",\n      \"namespace \\\"{0}\\\" provided in module {1} \" +\n      \"but required in module {2}\");\n\n  static final DiagnosticType NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR =\n      DiagnosticType.error(\n          \"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\",\n      \"goog.setCssNameMapping only takes an object literal with string values\");\n\n  static final DiagnosticType INVALID_CSS_RENAMING_MAP = DiagnosticType.warning(\n      \"INVALID_CSS_RENAMING_MAP\",\n      \"Invalid entries in css renaming map: {0}\");\n\n  static final DiagnosticType BASE_CLASS_ERROR = DiagnosticType.error(\n      \"JSC_BASE_CLASS_ERROR\",\n      \"incorrect use of goog.base: {0}\");\n\n  /** The root Closure namespace */\n  static final String GOOG = \"goog\";\n\n  private final AbstractCompiler compiler;\n  private final JSModuleGraph moduleGraph;\n\n  // The goog.provides must be processed in a deterministic order.\n  private final Map<String, ProvidedName> providedNames =\n      Maps.newLinkedHashMap();\n\n  private final List<UnrecognizedRequire> unrecognizedRequires =\n      Lists.newArrayList();\n  private final Set<String> exportedVariables = Sets.newHashSet();\n  private final CheckLevel requiresLevel;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final List<Node> defineCalls = Lists.newArrayList();\n\n  ProcessClosurePrimitives(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      CheckLevel requiresLevel) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  Set<String> getExportedVariableNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param n\n   */\n  private void replaceGoogDefines(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Handles a goog.provide call.\n   */\n  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n   * Handles a goog.define call.\n   */\n  private void processDefineCall(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Handles a typedef definition for a goog.provided name.\n   * @param n EXPR_RESULT node.\n   */\n  private void handleTypedefDefinition(\n      NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Handles a candidate definition for a goog.provided name.\n   */\n  private void handleCandidateProvideDefinition(\n      NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Processes the base class call.\n   */\n  private void processBaseClassCall(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the qualified name node of the function whose scope we're in,\n   * or null if it cannot be found.\n   */\n  private Node getEnclosingDeclNameNode(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Reports an incorrect use of super-method calling. */\n  private void reportBadBaseClassUse(\n      NodeTraversal t, Node n, String extraMessage) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Processes the output of processed-provide from a previous pass.  This will\n   * update our data structures in the same manner as if the provide had been\n   * processed in this pass.\n   */\n  private void processProvideFromPreviousPass(\n      NodeTraversal t, String name, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Processes a call to goog.setCssNameMapping(). Either the argument to\n   * goog.setCssNameMapping() is valid, in which case it will be used to create\n   * a CssRenamingMap for the compiler of this CompilerPass, or it is invalid\n   * and a JSCompiler error will be reported.\n   * @see #visit(NodeTraversal, Node, Node)\n   */\n  private void processSetCssNameMapping(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Verifies that a provide method call has exactly one argument,\n   * and that it's a string literal and that the contents of the string are\n   * valid JS tokens. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Verifies that a provide method call has exactly one argument,\n   * and that it's a string literal and that the contents of the string are\n   * valid JS tokens. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyDefine(NodeTraversal t,\n      Node expr,\n      Node methodName, Node args) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Verifies that a method call has exactly one argument, and that it's a\n   * string literal. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node methodName, Node arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyNotNull(NodeTraversal t, Node methodName, Node arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyOfType(NodeTraversal t, Node methodName,\n      Node arg, int desiredType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyIsLast(NodeTraversal t, Node methodName, Node arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Verifies that setCssNameMapping is called with the correct methods.\n   *\n   * @return Whether the arguments checked out okay\n   */\n  private boolean verifySetCssNameMapping(NodeTraversal t, Node methodName,\n      Node firstArg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Registers ProvidedNames for prefix namespaces if they haven't\n   * already been defined. The prefix namespaces must be registered in\n   * order from shortest to longest.\n   *\n   * @param ns The namespace whose prefixes may need to be provided.\n   * @param node The EXPR of the provide call.\n   * @param module The current module.\n   */\n  private void registerAnyProvidedPrefixes(\n      String ns, Node node, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * Information required to replace a goog.provide call later in the traversal.\n   */\n  private class ProvidedName {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is namespace placeholder.\n   */\n  private static boolean isNamespacePlaceholder(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * The string in {@code n} is a reference name. Create a synthetic\n   * node for it with all the proper source info, and add it to the symbol\n   * table.\n   */\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Add the given qualified name node to the symbol table.\n   */\n  private void maybeAddToSymbolTable(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * Information required to create a {@code MISSING_PROVIDE_ERROR} warning.\n   */\n  private class UnrecognizedRequire {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ProvidedName": "  private class ProvidedName {\n         //The specific code has been omitted, but there is no error\n        }", "UnrecognizedRequire": "  private class UnrecognizedRequire {\n         //The specific code has been omitted, but there is no error\n        }"}