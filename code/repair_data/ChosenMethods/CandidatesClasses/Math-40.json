{"BracketingNthOrderBrentSolver": "public class BracketingNthOrderBrentSolver\n    extends AbstractUnivariateRealSolver\n    implements BracketedUnivariateRealSolver<UnivariateFunction> {\n\n    /** Default absolute accuracy. */\n    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n\n    /** Default maximal order. */\n    private static final int DEFAULT_MAXIMAL_ORDER = 5;\n\n    /** Maximal aging triggering an attempt to balance the bracketing interval. */\n    private static final int MAXIMAL_AGING = 2;\n\n    /** Reduction factor for attempts to balance the bracketing interval. */\n    private static final double REDUCTION_FACTOR = 1.0 / 16.0;\n\n    /** Maximal order. */\n    private final int maximalOrder;\n\n    /** The kinds of solutions that the algorithm may accept. */\n    private AllowedSolution allowed;\n\n    /**\n     * Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)\n     */\n    public BracketingNthOrderBrentSolver() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct a solver.\n     *\n     * @param absoluteAccuracy Absolute accuracy.\n     * @param maximalOrder maximal order.\n     * @exception NumberIsTooSmallException if maximal order is lower than 2\n     */\n    public BracketingNthOrderBrentSolver(final double absoluteAccuracy,\n                                         final int maximalOrder)\n        throws NumberIsTooSmallException {\n        super(absoluteAccuracy);\n        if (maximalOrder < 2) {\n         //The specific code has been omitted, but there is no error\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    /**\n     * Construct a solver.\n     *\n     * @param relativeAccuracy Relative accuracy.\n     * @param absoluteAccuracy Absolute accuracy.\n     * @param maximalOrder maximal order.\n     * @exception NumberIsTooSmallException if maximal order is lower than 2\n     */\n    public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n                                         final double absoluteAccuracy,\n                                         final int maximalOrder)\n        throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy);\n        if (maximalOrder < 2) {\n         //The specific code has been omitted, but there is no error\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    /**\n     * Construct a solver.\n     *\n     * @param relativeAccuracy Relative accuracy.\n     * @param absoluteAccuracy Absolute accuracy.\n     * @param functionValueAccuracy Function value accuracy.\n     * @param maximalOrder maximal order.\n     * @exception NumberIsTooSmallException if maximal order is lower than 2\n     */\n    public BracketingNthOrderBrentSolver(final double relativeAccuracy,\n                                         final double absoluteAccuracy,\n                                         final double functionValueAccuracy,\n                                         final int maximalOrder)\n        throws NumberIsTooSmallException {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        if (maximalOrder < 2) {\n         //The specific code has been omitted, but there is no error\n        }\n        this.maximalOrder = maximalOrder;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    /** Get the maximal order.\n     * @return maximal order\n     */\n    public int getMaximalOrder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n     * <p>\n     * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q\n     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),\n     * Q(y<sub>i</sub>) = x<sub>i</sub>.\n     * </p>\n     * @param targetY target value for y\n     * @param x reference points abscissas for interpolation,\n     * note that this array <em>is</em> modified during computation\n     * @param y reference points ordinates for interpolation\n     * @param start start index of the points to consider (inclusive)\n     * @param end end index of the points to consider (exclusive)\n     * @return guessed root (will be a NaN if two points share the same y)\n     */\n    private double guessX(final double targetY, final double[] x, final double[] y,\n                          final int start, final int end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public double solve(int maxEval, UnivariateFunction f, double min,\n                        double max, AllowedSolution allowedSolution) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public double solve(int maxEval, UnivariateFunction f, double min,\n                        double max, double startValue,\n                        AllowedSolution allowedSolution) {\n         //The specific code has been omitted, but there is no error\n        }\n\n}"}