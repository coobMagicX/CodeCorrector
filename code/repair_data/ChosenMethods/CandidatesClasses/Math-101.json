{"ComplexFormat": "public class ComplexFormat extends Format implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6337346779577272306L;\n    \n    /** The default imaginary character. */\n    private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n    \n    /** The notation used to signify the imaginary part of the complex number. */\n    private String imaginaryCharacter;\n    \n    /** The format used for the imaginary part. */\n    private NumberFormat imaginaryFormat;\n\n    /** The format used for the real part. */\n    private NumberFormat realFormat;\n    \n    /**\n     * Create an instance with the default imaginary character, 'i', and the\n     * default number format for both real and imaginary parts.\n     */\n    public ComplexFormat() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Create an instance with a custom number format for both real and\n     * imaginary parts.\n     * @param format the custom format for both real and imaginary parts.\n     */\n    public ComplexFormat(NumberFormat format) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Create an instance with a custom number format for the real part and a\n     * custom number format for the imaginary part.\n     * @param realFormat the custom format for the real part.\n     * @param imaginaryFormat the custom format for the imaginary part.\n     */\n    public ComplexFormat(NumberFormat realFormat,\n            NumberFormat imaginaryFormat) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Create an instance with a custom imaginary character, and the default\n     * number format for both real and imaginary parts.\n     * @param imaginaryCharacter The custom imaginary character.\n     */\n    public ComplexFormat(String imaginaryCharacter) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Create an instance with a custom imaginary character, and a custom number\n     * format for both real and imaginary parts.\n     * @param imaginaryCharacter The custom imaginary character.\n     * @param format the custom format for both real and imaginary parts.\n     */\n    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Create an instance with a custom imaginary character, a custom number\n     * format for the real part, and a custom number format for the imaginary\n     * part.\n     * @param imaginaryCharacter The custom imaginary character.\n     * @param realFormat the custom format for the real part.\n     * @param imaginaryFormat the custom format for the imaginary part.\n     */\n    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,\n            NumberFormat imaginaryFormat) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * This static method calls formatComplex() on a default instance of\n     * ComplexFormat.\n     *\n     * @param c Complex object to format\n     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n     */\n    public static String formatComplex( Complex c ) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Formats a {@link Complex} object to produce a string.\n     *\n     * @param complex the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     */\n    public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n            FieldPosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Formats a object to produce a string.  <code>obj</code> must be either a \n     * {@link Complex} object or a {@link Number} object.  Any other type of\n     * object will result in an {@link IllegalArgumentException} being thrown.\n     *\n     * @param obj the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n     */\n    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n            FieldPosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Formats a double value to produce a string.  In general, the value is\n     * formatted using the formatting rules of <code>format</code>.  There are\n     * three exceptions to this:\n     * <ol>\n     * <li>NaN is formatted as '(NaN)'</li>\n     * <li>Positive infinity is formatted as '(Infinity)'</li>\n     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n     * </ol>\n     *\n     * @param value the double to format.\n     * @param format the format used.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     */\n    private StringBuffer formatDouble(double value, NumberFormat format,\n            StringBuffer toAppendTo, FieldPosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Get the set of locales for which complex formats are available.  This\n     * is the same set as the {@link NumberFormat} set. \n     * @return available complex format locales.\n     */\n    public static Locale[] getAvailableLocales() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance()} with the only customizing is the\n     * maximum number of fraction digits, which is set to 2.  \n     * @return the default number format.\n     */\n    private static NumberFormat getDefaultNumberFormat() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n     * customizing is the maximum number of fraction digits, which is set to 2.  \n     * @param locale the specific locale used by the format.\n     * @return the default number format specific to the given locale.\n     */\n    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Access the imaginaryCharacter.\n     * @return the imaginaryCharacter.\n     */\n    public String getImaginaryCharacter() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Access the imaginaryFormat.\n     * @return the imaginaryFormat.\n     */\n    public NumberFormat getImaginaryFormat() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Returns the default complex format for the current locale.\n     * @return the default complex format.\n     */\n    public static ComplexFormat getInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Returns the default complex format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the complex format specific to the given locale.\n     */\n    public static ComplexFormat getInstance(Locale locale) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Access the realFormat.\n     * @return the realFormat.\n     */\n    public NumberFormat getRealFormat() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @return the parsed {@link Complex} object.\n     * @exception ParseException if the beginning of the specified string\n     *            cannot be parsed.\n     */\n    public Complex parse(String source) throws ParseException {\n        ParsePosition parsePosition = new ParsePosition(0);\n        Complex result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n                \"\\\"\", parsePosition.getErrorIndex());\n        }\n        return result;\n    }\n    \n    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Complex} object.\n     */\n    public Complex parse(String source, ParsePosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n     \n    /**\n     * Parses <code>source</code> until a non-whitespace character is found.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n     *        holds the index of the next non-whitespace character.\n     */\n    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parses <code>source</code> until a non-whitespace character is found.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the first non-whitespace character.\n     */\n    private char parseNextCharacter(String source, ParsePosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Parses <code>source</code> for a special double values.  These values\n     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n     *\n     * @param source the string to parse\n     * @param value the special value to parse.\n     * @param pos input/ouput parsing parameter.\n     * @return the special number.\n     */\n    private Number parseNumber(String source, double value, ParsePosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Parses <code>source</code> for a number.  This method can parse normal,\n     * numeric values as well as special values.  These special values include\n     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n     *\n     * @param source the string to parse\n     * @param format the number format used to parse normal, numeric values.\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed number.\n     */\n    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parses a string to produce a object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed object.\n     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n     */\n    public Object parseObject(String source, ParsePosition pos) {\n         //The specific code has been omitted, but there is no error\n        }\n    /**\n     * Modify the imaginaryCharacter.\n     * @param imaginaryCharacter The new imaginaryCharacter value.\n     * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is\n     *         <code>null</code> or an empty string.\n     */\n    public void setImaginaryCharacter(String imaginaryCharacter) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Modify the imaginaryFormat.\n     * @param imaginaryFormat The new imaginaryFormat value.\n     * @throws IllegalArgumentException if <code>imaginaryFormat</code> is\n     *         <code>null</code>.\n     */\n    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Modify the realFormat.\n     * @param realFormat The new realFormat value.\n     * @throws IllegalArgumentException if <code>realFormat</code> is\n     *         <code>null</code>.\n     */\n    public void setRealFormat(NumberFormat realFormat) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}