{"RemoveUnusedVars": "class RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n\n  private final AbstractCompiler compiler;\n\n  private final CodingConvention codingConvention;\n\n  private final boolean removeGlobals;\n\n  private boolean preserveFunctionExpressionNames;\n\n  /**\n   * Keep track of variables that we've referenced.\n   */\n  private final Set<Var> referenced = Sets.newHashSet();\n\n  /**\n   * Keep track of variables that might be unreferenced.\n   */\n  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n\n  /**\n   * Keep track of scopes that we've traversed.\n   */\n  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n\n  /**\n   * Keep track of assigns to variables that we haven't referenced.\n   */\n  private final Multimap<Var, Assign> assignsByVar =\n      ArrayListMultimap.create();\n\n  /**\n   * The assigns, indexed by the NAME node that they assign to.\n   */\n  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n\n  /**\n   * Subclass name -> class-defining call EXPR node. (like inherits)\n   */\n  private final Multimap<Var, Node> classDefiningCalls =\n      ArrayListMultimap.create();\n\n  /**\n   * Keep track of continuations that are finished iff the variable they're\n   * indexed by is referenced.\n   */\n  private final Multimap<Var, Continuation> continuations =\n      ArrayListMultimap.create();\n\n  private boolean modifyCallSites;\n\n  private CallSiteOptimizer callSiteOptimizer;\n\n  RemoveUnusedVars(\n      AbstractCompiler compiler,\n      boolean removeGlobals,\n      boolean preserveFunctionExpressionNames,\n      boolean modifyCallSites) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Traverses the root, removing all unused variables. Multiple traversals\n   * may occur to ensure all unused variables are removed.\n   */\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(\n      Node externs, Node root, SimpleDefinitionFinder defFinder) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Traverses a node recursively. Call this once per pass.\n   */\n  private void traverseAndRemoveUnusedReferences(Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Traverses everything in the current scope and marks variables that\n   * are referenced.\n   *\n   * During traversal, we identify subtrees that will only be\n   * referenced if their enclosing variables are referenced. Instead of\n   * traversing those subtrees, we create a continuation for them,\n   * and traverse them lazily.\n   */\n  private void traverseNode(Node n, Node parent, Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean isRemovableVar(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Traverses a function, which creates a new scope in JavaScript.\n   *\n   * Note that CATCH blocks also create a new scope, but only for the\n   * catch variable. Declarations within the block actually belong to the\n   * enclosing scope. Because we don't remove catch variables, there's\n   * no need to treat CATCH blocks differently like we do functions.\n   */\n  private void traverseFunction(Node n, Scope parentScope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * For each variable in this scope that we haven't found a reference\n   * for yet, add it to the list of variables to check later.\n   */\n  private void collectMaybeUnreferencedVars(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * @return the LP node containing the function parameters.\n   */\n  private static Node getFunctionArgList(Node function) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static class CallSiteOptimizer {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   */\n  private void interpretAssigns() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Remove all assigns to a var.\n   */\n  private void removeAllAssigns(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Marks a var as referenced, recursing into any values of this var\n   * that we skipped.\n   * @return True if this variable had not been referenced before.\n   */\n  private boolean markReferencedVar(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes any vars in the scope that were not referenced. Removes any\n   * assignments to those variables as well.\n   */\n  private void removeUnreferencedVars() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Our progress in a traversal can be expressed completely as the\n   * current node and scope. The continuation lets us save that\n   * information so that we can continue the traversal later.\n   */\n  private class Continuation {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static class Assign {\n         //The specific code has been omitted, but there is no error\n        }\n}", "CallSiteOptimizer": "  private static class CallSiteOptimizer {\n         //The specific code has been omitted, but there is no error\n        }", "Continuation": "  private class Continuation {\n         //The specific code has been omitted, but there is no error\n        }", "Assign": "  private static class Assign {\n         //The specific code has been omitted, but there is no error\n        }"}