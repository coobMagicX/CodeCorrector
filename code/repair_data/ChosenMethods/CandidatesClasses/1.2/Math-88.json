{"SimplexTableau": "class SimplexTableau implements Serializable {\n\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = -1369660067587938365L;\n\n    /** Linear objective function. */\n    private final LinearObjectiveFunction f;\n\n    /** Linear constraints. */\n    private final Collection<LinearConstraint> constraints;\n\n    /** Whether to restrict the variables to non-negative values. */\n    private final boolean restrictToNonNegative;\n\n    /** Simple tableau. */\n    protected transient RealMatrix tableau;\n\n    /** Number of decision variables. */\n    protected final int numDecisionVariables;\n\n    /** Number of slack variables. */\n    protected final int numSlackVariables;\n\n    /** Number of artificial variables. */\n    protected int numArtificialVariables;\n\n    /** Amount of error to accept in floating point comparisons. */ \n    protected final double epsilon;\n    \n    /**\n     * Build a tableau for a linear problem.\n     * @param f linear objective function\n     * @param constraints linear constraints\n     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n     * or {@link GoalType#MINIMIZE}\n     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n     * @param epsilon amount of error to accept in floating point comparisons\n     */\n    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType, final boolean restrictToNonNegative,\n                   final double epsilon) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Create the tableau by itself.\n     * @param maximize if true, goal is to maximize the objective function\n     * @return created tableau\n     */\n    protected double[][] createTableau(final boolean maximize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the number of variables.\n     * @return number of variables\n     */\n    public int getNumVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get new versions of the constraints which have positive right hand sides.\n     * @return new versions of the constraints\n     */\n    public List<LinearConstraint> getNormalizedConstraints() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get a new equation equivalent to this one with a positive right hand side.\n     * @param constraint reference constraint\n     * @return new equation\n     */\n    private LinearConstraint normalize(final LinearConstraint constraint) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the number of objective functions in this tableau.\n     * @return 2 for Phase 1.  1 for Phase 2.\n     */\n    protected final int getNumObjectiveFunctions() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get a count of constraints corresponding to a specified relationship.\n     * @param relationship relationship to count\n     * @return number of constraint with the specified relationship\n     */\n    private int getConstraintTypeCounts(final Relationship relationship) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Puts the tableau in proper form by zeroing out the artificial variables\n     * in the objective function via elementary row operations.\n     */\n    private void initialize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the -1 times the sum of all coefficients in the given array.\n     * @param coefficients coefficients to sum\n     * @return the -1 times the sum of all coefficients in the given array.\n     */\n    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Checks whether the given column is basic.\n     * @param col index of the column to check\n     * @return the row that the variable is basic in.  null if the column is not basic\n     */\n    private Integer getBasicRow(final int col) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Removes the phase 1 objective function and artificial variables from this tableau.\n     */\n    protected void discardArtificialVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n    /**\n     * @param src the source array\n     * @param dest the destination array\n     * @param destPos the destination position\n     */\n    private void copyArray(final double[] src, final double[] dest,\n                           final int destPos) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Subtracts a multiple of one row from another.\n     * <p>\n     * After application of this operation, the following will hold:\n     *   minuendRow = minuendRow - multiple * subtrahendRow\n     * </p>\n     * @param dividendRow index of the row\n     * @param divisor value of the divisor\n     */\n    protected void divideRow(final int dividendRow, final double divisor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Subtracts a multiple of one row from another.\n     * <p>\n     * After application of this operation, the following will hold:\n     *   minuendRow = minuendRow - multiple * subtrahendRow\n     * </p>\n     * @param minuendRow row index\n     * @param subtrahendRow row index\n     * @param multiple multiplication factor\n     */\n    protected void subtractRow(final int minuendRow, final int subtrahendRow,\n                               final double multiple) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the width of the tableau.\n     * @return width of the tableau\n     */\n    protected final int getWidth() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the height of the tableau.\n     * @return height of the tableau\n     */\n    protected final int getHeight() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get an entry of the tableau.\n     * @param row row index\n     * @param column column index\n     * @return entry at (row, column)\n     */\n    protected final double getEntry(final int row, final int column) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Set an entry of the tableau.\n     * @param row row index\n     * @param column column index\n     * @param value for the entry\n     */\n    protected final void setEntry(final int row, final int column,\n                                  final double value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the offset of the first slack variable.\n     * @return offset of the first slack variable\n     */\n    protected final int getSlackVariableOffset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the offset of the first artificial variable.\n     * @return offset of the first artificial variable\n     */\n    protected final int getArtificialVariableOffset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the offset of the right hand side.\n     * @return offset of the right hand side\n     */\n    protected final int getRhsOffset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the number of decision variables.\n     * <p>\n     * If variables are not restricted to positive values, this will include 1\n     * extra decision variable to represent the absolute value of the most\n     * negative variable.\n     * </p>\n     * @return number of decision variables\n     * @see #getOriginalNumDecisionVariables()\n     */\n    protected final int getNumDecisionVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the original number of decision variables.\n     * @return original number of decision variables\n     * @see #getNumDecisionVariables()\n     */\n    protected final int getOriginalNumDecisionVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the number of slack variables.\n     * @return number of slack variables\n     */\n    protected final int getNumSlackVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the number of artificial variables.\n     * @return number of artificial variables\n     */\n    protected final int getNumArtificialVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the tableau data.\n     * @return tableau data\n     */\n    protected final double[][] getData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /** {@inheritDoc} */\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Serialize the instance.\n     * @param oos stream where object should be written\n     * @throws IOException if object cannot be written to stream\n     */\n    private void writeObject(ObjectOutputStream oos)\n        throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(tableau, oos);\n    }\n\n    /** Deserialize the instance.\n     * @param ois stream from which the object should be read\n     * @throws ClassNotFoundException if a class in the stream cannot be found\n     * @throws IOException if object cannot be read from the stream\n     */\n    private void readObject(ObjectInputStream ois)\n      throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }\n}"}