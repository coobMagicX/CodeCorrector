{"PolygonsSet": "public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n\n    /** Vertices organized as boundary loops. */\n    private Vector2D[][] vertices;\n\n    /** Build a polygons set representing the whole real line.\n     */\n    public PolygonsSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Build a polygons set from a BSP tree.\n     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n     * {@code Boolean} attribute representing the inside status of\n     * the corresponding cell (true for inside cells, false for outside\n     * cells). In order to avoid building too many small objects, it is\n     * recommended to use the predefined constants\n     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n     * @param tree inside/outside BSP tree representing the region\n     */\n    public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Build a polygons set from a Boundary REPresentation (B-rep).\n     * <p>The boundary is provided as a collection of {@link\n     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n     * interior part of the region on its minus side and the exterior on\n     * its plus side.</p>\n     * <p>The boundary elements can be in any order, and can form\n     * several non-connected sets (like for example polygons with holes\n     * or a set of disjoint polyhedrons considered as a whole). In\n     * fact, the elements do not even need to be connected together\n     * (their topological connections are not used here). However, if the\n     * boundary does not really separate an inside open from an outside\n     * open (open having here its topological meaning), then subsequent\n     * calls to the {@link\n     * org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector)\n     * checkPoint} method will not be meaningful anymore.</p>\n     * <p>If the boundary is empty, the region will represent the whole\n     * space.</p>\n     * @param boundary collection of boundary elements, as a\n     * collection of {@link SubHyperplane SubHyperplane} objects\n     */\n    public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Build a parallellepipedic box.\n     * @param xMin low bound along the x direction\n     * @param xMax high bound along the x direction\n     * @param yMin low bound along the y direction\n     * @param yMax high bound along the y direction\n     */\n    public PolygonsSet(final double xMin, final double xMax,\n                       final double yMin, final double yMax) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create a list of hyperplanes representing the boundary of a box.\n     * @param xMin low bound along the x direction\n     * @param xMax high bound along the x direction\n     * @param yMin low bound along the y direction\n     * @param yMax high bound along the y direction\n     * @return boundary of the box\n     */\n    private static Line[] boxBoundary(final double xMin, final double xMax,\n                                      final double yMin, final double yMax) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the vertices of the polygon.\n     * <p>The polygon boundary can be represented as an array of loops,\n     * each loop being itself an array of vertices.</p>\n     * <p>In order to identify open loops which start and end by\n     * infinite edges, the open loops arrays start with a null point. In\n     * this case, the first non null point and the last point of the\n     * array do not represent real vertices, they are dummy points\n     * intended only to get the direction of the first and last edge. An\n     * open loop consisting of a single infinite line will therefore be\n     * represented by a three elements array with one null point\n     * followed by two dummy points. The open loops are always the first\n     * ones in the loops array.</p>\n     * <p>If the polygon has no boundary at all, a zero length loop\n     * array will be returned.</p>\n     * <p>All line segments in the various loops have the inside of the\n     * region on their left side and the outside on their right side\n     * when moving in the underlying line direction. This means that\n     * closed loops surrounding finite areas obey the direct\n     * trigonometric orientation.</p>\n     * @return vertices of the polygon, organized as oriented boundary\n     * loops with the open loops first (the returned value is guaranteed\n     * to be non-null)\n     */\n    public Vector2D[][] getVertices() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Follow a boundary loop.\n     * @param node node containing the segment starting the loop\n     * @param sorted set of segments belonging to the boundary, sorted by\n     * start points (contains {@code node})\n     * @return a list of connected sub-hyperplanes starting at\n     * {@code node}\n     */\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Private extension of Segment allowing comparison. */\n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n\n        /** Sorting key. */\n        private OrderedTuple sortingKey;\n\n        /** Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         */\n        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         */\n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(final ComparableSegment o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(final Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n    /** Visitor building segments. */\n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n\n        /** Sorted segments. */\n        private AVLTree<ComparableSegment> sorted;\n\n        /** Simple constructor. */\n        public SegmentsBuilder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         */\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Get the sorted segments.\n         * @return sorted segments\n         */\n        public AVLTree<ComparableSegment> getSorted() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n}", "ComparableSegment": "    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n\n        /** Sorting key. */\n        private OrderedTuple sortingKey;\n\n        /** Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         */\n        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         */\n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(final ComparableSegment o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(final Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }", "SegmentsBuilder": "    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n\n        /** Sorted segments. */\n        private AVLTree<ComparableSegment> sorted;\n\n        /** Simple constructor. */\n        public SegmentsBuilder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         */\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Get the sorted segments.\n         * @return sorted segments\n         */\n        public AVLTree<ComparableSegment> getSorted() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }"}