{"FunctionInjector": "class FunctionInjector {class FunctionInjector {\n\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n\n  /**\n   * @param allowDecomposition Whether an effort should be made to break down\n   * expressions into simpler expressions to allow functions to be injected\n   * where they would otherwise be disallowed.\n   */\n  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** The type of inlining to perform. */\n  enum InliningMode {\n    /**\n     * Directly replace the call expression. Only functions of meeting\n     * strict preconditions can be inlined.\n     */\n    DIRECT,\n\n    /**\n     * Replaces the call expression with a block of statements. Conditions\n     * on the function are looser in mode, but stricter on the call site.\n     */\n    BLOCK\n  }\n\n  /** Holds a reference to the call node of a function call */\n  static class Reference {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * In order to estimate the cost of lining, we make the assumption that\n   * Identifiers are reduced 2 characters. For the call arguments, the important\n   * thing is that the cost is assumed to be the same in the call and the\n   * function, so the actual length doesn't matter in most cases.\n   */\n  private static final int NAME_COST_ESTIMATE =\n      InlineCostEstimator.ESTIMATED_IDENTIFIER_COST;\n\n  /** The cost of a argument separator (a comma). */\n  private static final int COMMA_COST = 1;\n\n  /** The cost of the parentheses needed to make a call.*/\n  private static final int PAREN_COST = 2;\n\n\n  /**\n   * @param fnName The name of this function. This either the name of the\n   *  variable to which the function is assigned or the name from the FUNCTION\n   *  node.\n   * @param fnNode The FUNCTION node of the function to inspect.\n   * @return Whether the function node meets the minimum requirements for\n   * inlining.\n   */\n  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Only \".call\" calls and direct calls to functions are supported.\n   * @param callNode The call evaluate.\n   * @return Whether the call is of a type that is supported.\n   */\n  private boolean isSupportedCallType(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Inline a function into the call site.\n   */\n  Node inline(\n      Node callNode, String fnName, Node fnNode, InliningMode mode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Inline a function that fulfills the requirements of\n   * canInlineReferenceDirectly into the call site, replacing only the CALL\n   * node.\n   */\n  private Node inlineReturnValue(Node callNode, Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Supported call site types.\n   */\n  private enum CallSiteType {\n\n    /**\n     * Used for a call site for which there does not exist a method\n     * to inline it.\n     */\n    UNSUPPORTED() {\n         //The specific code has been omitted, but there is no error\n        },\n\n    /**\n     * A call as a statement. For example: \"foo();\".\n     *   EXPR_RESULT\n     *     CALL\n     */\n    SIMPLE_CALL() {\n         //The specific code has been omitted, but there is no error\n        },\n\n    /**\n     * An assignment, where the result of the call is assigned to a simple\n     * name. For example: \"a = foo();\".\n     *   EXPR_RESULT\n     *     NAME A\n     *     CALL\n     *       FOO\n     */\n    SIMPLE_ASSIGNMENT() {\n         //The specific code has been omitted, but there is no error\n        },\n    /**\n     * An var declaration and initialization, where the result of the call is\n     * assigned to the declared name\n     * name. For example: \"a = foo();\".\n     *   VAR\n     *     NAME A\n     *       CALL\n     *         FOO\n     */\n    VAR_DECL_SIMPLE_ASSIGNMENT() {\n         //The specific code has been omitted, but there is no error\n        },\n    /**\n     * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n     * RETURN, SWITCH or VAR.  The call must be the first side-effect in\n     * the expression.\n     *\n     * Examples include:\n     *   \"if (foo()) {...\"\n     *   \"return foo();\"\n     *   \"var a = 1 + foo();\"\n     *   \"a = 1 + foo()\"\n     *   \"foo() ? 1:0\"\n     *   \"foo() && x\"\n     */\n    EXPRESSION() {\n         //The specific code has been omitted, but there is no error\n        },\n\n    /**\n     * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n     * RETURN, SWITCH or VAR.  Where the call is not the first side-effect in\n     * the expression.\n     */\n    DECOMPOSABLE_EXPRESSION() {\n         //The specific code has been omitted, but there is no error\n        };\n\n    public abstract void prepare(FunctionInjector injector, Node callNode);\n  }\n\n  /**\n   * Determine which, if any, of the supported types the call site is.\n   */\n  private CallSiteType classifyCallSite(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private ExpressionDecomposer getDecomposer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If required, rewrite the statement containing the call expression.\n   * @see ExpressionDecomposer#canExposeExpression\n   */\n  void maybePrepareCall(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Inline a function which fulfills the requirements of\n   * canInlineReferenceAsStatementBlock into the call site, replacing the\n   * parent expression.\n   */\n  private Node inlineFunction(\n      Node callNode, Node fnNode, String fnName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks if the given function matches the criteria for an inlinable\n   * function, and if so, adds it to our set of inlinable functions.\n   */\n  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  enum CanInlineResult {\n    YES,\n    AFTER_PREPARATION,\n    NO\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * - It must be a simple call, or assignment, or var initialization.\n   * <pre>\n   *    f();\n   *    a = foo();\n   *    var a = foo();\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceAsStatementBlock(\n      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) {\n         //The specific code has been omitted, but there is no error\n        }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determine if inlining the function is likely to reduce the code size.\n   * @param namesToAlias\n   */\n  boolean inliningLowersCost(\n      JSModule fnModule, Node fnNode, Collection<? extends Reference> refs,\n      Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether inlining will lower cost.\n   */\n  private boolean doesLowerCost(\n      Node fnNode, int callCost,\n      int directInlines, int costDeltaDirect,\n      int blockInlines, int costDeltaBlock,\n      boolean removable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets an estimate of the cost in characters of making the function call:\n   * the sum of the identifiers and the separators.\n   * @param referencesThis\n   */\n  private static int estimateCallCost(Node fnNode, boolean referencesThis) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The difference between the function definition cost and\n   *     inline cost.\n   */\n  private static int inlineCostDelta(\n      Node fnNode, Set<String> namesToAlias, InliningMode mode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Store the names of known constants to be used when classifying call-sites\n   * in expressions.\n   */\n  public void setKnownConstants(Set<String> knownConstants) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "Reference": "  static class Reference {\n         //The specific code has been omitted, but there is no error\n        }"}