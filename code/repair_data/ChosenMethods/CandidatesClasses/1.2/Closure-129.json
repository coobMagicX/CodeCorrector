{"PrepareAst": "class PrepareAst implements CompilerPass {\n\n  private final AbstractCompiler compiler;\n  private final boolean checkOnly;\n\n  PrepareAst(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void reportChange() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code.\n   */\n  private void normalizeNodeTypes(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Add blocks to IF, WHILE, DO, etc.\n   */\n  private void normalizeBlocks(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Normalize where annotations appear on the AST. Copies\n   * around existing JSDoc annotations as well as internal annotations.\n   */\n  static class PrepareAnnotations\n      implements NodeTraversal.Callback {\n\n    PrepareAnnotations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void normalizeObjectLiteralAnnotations(Node objlit) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Translate dispatcher info into the property expected node.\n     */\n    private void annotateDispatchers(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * In the AST that Rhino gives us, it needs to make a distinction\n     * between JsDoc on the object literal node and JsDoc on the object literal\n     * value. For example,\n     * <pre>\n     * var x = {\n     *   / JSDOC /\n     *   a: 'b',\n     *   c: / JSDOC / 'd'\n     * };\n     * </pre>\n     *\n     * But in few narrow cases (in particular, function literals), it's\n     * a lot easier for us if the doc is attached to the value.\n     */\n    private void normalizeObjectLiteralKeyAnnotations(\n        Node objlit, Node key, Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "PrepareAnnotations": "  static class PrepareAnnotations\n      implements NodeTraversal.Callback {\n\n    PrepareAnnotations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void normalizeObjectLiteralAnnotations(Node objlit) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Translate dispatcher info into the property expected node.\n     */\n    private void annotateDispatchers(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * In the AST that Rhino gives us, it needs to make a distinction\n     * between JsDoc on the object literal node and JsDoc on the object literal\n     * value. For example,\n     * <pre>\n     * var x = {\n     *   / JSDOC /\n     *   a: 'b',\n     *   c: / JSDOC / 'd'\n     * };\n     * </pre>\n     *\n     * But in few narrow cases (in particular, function literals), it's\n     * a lot easier for us if the doc is attached to the value.\n     */\n    private void normalizeObjectLiteralKeyAnnotations(\n        Node objlit, Node key, Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}