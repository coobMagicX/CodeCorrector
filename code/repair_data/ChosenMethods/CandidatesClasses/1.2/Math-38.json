{"BOBYQAOptimizer": "public class BOBYQAOptimizer\n    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n    implements MultivariateOptimizer {\n    /** Minimum dimension of the problem: {@value} */\n    public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n    /** Default value for {@link #initialTrustRegionRadius}: {@value} . */\n    public static final double DEFAULT_INITIAL_RADIUS = 10.0;\n    /** Default value for {@link #stoppingTrustRegionRadius}: {@value} . */\n    public static final double DEFAULT_STOPPING_RADIUS = 1E-8;\n\n    private static final double ZERO = 0d;\n    private static final double ONE = 1d;\n    private static final double TWO = 2d;\n    private static final double TEN = 10d;\n    private static final double SIXTEEN = 16d;\n    private static final double TWO_HUNDRED_FIFTY = 250d;\n    private static final double MINUS_ONE = -ONE;\n    private static final double HALF = ONE / 2;\n    private static final double ONE_OVER_FOUR = ONE / 4;\n    private static final double ONE_OVER_EIGHT = ONE / 8;\n    private static final double ONE_OVER_TEN = ONE / 10;\n    private static final double ONE_OVER_A_THOUSAND = ONE / 1000;\n\n    /**\n     * numberOfInterpolationPoints XXX\n     */\n    private final int numberOfInterpolationPoints;\n    /**\n     * initialTrustRegionRadius XXX\n     */\n    private double initialTrustRegionRadius;\n    /**\n     * stoppingTrustRegionRadius XXX\n     */\n    private final double stoppingTrustRegionRadius;\n    /** Goal type (minimize or maximize). */\n    private boolean isMinimize;\n    /**\n     * Current best values for the variables to be optimized.\n     * The vector will be changed in-place to contain the values of the least\n     * calculated objective function values.\n     */\n    private ArrayRealVector currentBest;\n    /** Differences between the upper and lower bounds. */\n    private double[] boundDifference;\n    /**\n     * Index of the interpolation point at the trust region center.\n     */\n    private int trustRegionCenterInterpolationPointIndex;\n    /**\n     * Last <em>n</em> columns of matrix H (where <em>n</em> is the dimension\n     * of the problem).\n     * XXX \"bmat\" in the original code.\n     */\n    private Array2DRowRealMatrix bMatrix;\n    /**\n     * Factorization of the leading <em>npt</em> square submatrix of H, this\n     * factorization being Z Z<sup>T</sup>, which provides both the correct\n     * rank and positive semi-definiteness.\n     * XXX \"zmat\" in the original code.\n     */\n    private Array2DRowRealMatrix zMatrix;\n    /**\n     * Coordinates of the interpolation points relative to {@link #originShift}.\n     * XXX \"xpt\" in the original code.\n     */\n    private Array2DRowRealMatrix interpolationPoints;\n    /**\n     * Shift of origin that should reduce the contributions from rounding\n     * errors to values of the model and Lagrange functions.\n     * XXX \"xbase\" in the original code.\n     */\n    private ArrayRealVector originShift;\n    /**\n     * Values of the objective function at the interpolation points.\n     * XXX \"fval\" in the original code.\n     */\n    private ArrayRealVector fAtInterpolationPoints;\n    /**\n     * Displacement from {@link #originShift} of the trust region center.\n     * XXX \"xopt\" in the original code.\n     */\n    private ArrayRealVector trustRegionCenterOffset;\n    /**\n     * Gradient of the quadratic model at {@link #originShift} +\n     * {@link #trustRegionCenterOffset}.\n     * XXX \"gopt\" in the original code.\n     */\n    private ArrayRealVector gradientAtTrustRegionCenter;\n    /**\n     * Differences {@link #getLowerBound()} - {@link #originShift}.\n     * All the components of every {@link #trustRegionCenterOffset} are going\n     * to satisfy the bounds<br/>\n     * {@link #getLowerBound() lowerBound}<sub>i</sub> &le;\n     * {@link #trustRegionCenterOffset}<sub>i</sub>,<br/>\n     * with appropriate equalities when {@link #trustRegionCenterOffset} is\n     * on a constraint boundary.\n     * XXX \"sl\" in the original code.\n     */\n    private ArrayRealVector lowerDifference;\n    /**\n     * Differences {@link #getUpperBound()} - {@link #originShift}\n     * All the components of every {@link #trustRegionCenterOffset} are going\n     * to satisfy the bounds<br/>\n     *  {@link #trustRegionCenterOffset}<sub>i</sub> &le;\n     *  {@link #getUpperBound() upperBound}<sub>i</sub>,<br/>\n     * with appropriate equalities when {@link #trustRegionCenterOffset} is\n     * on a constraint boundary.\n     * XXX \"su\" in the original code.\n     */\n    private ArrayRealVector upperDifference;\n    /** \n     * Parameters of the implicit second derivatives of the quadratic model.\n     * XXX \"pq\" in the original code.\n     */\n    private ArrayRealVector modelSecondDerivativesParameters;\n    /**\n     * Point chosen by function {@link #trsbox(double,ArrayRealVector,\n     * ArrayRealVector, ArrayRealVector,ArrayRealVector,ArrayRealVector) trsbox}\n     * or {@link #altmov(int,double) altmov}.\n     * Usually {@link #originShift} + {@link #newPoint} is the vector of\n     * variables for the next evaluation of the objective function.\n     * It also satisfies the constraints indicated in {@link #lowerDifference}\n     * and {@link #upperDifference}.\n     * XXX \"xnew\" in the original code.\n     */\n    private ArrayRealVector newPoint;\n    /**\n     * Alternative to {@link #newPoint}, chosen by\n     * {@link #altmov(int,double) altmov}.\n     * It may replace {@link #newPoint} in order to increase the denominator\n     * in the {@link #update() updating procedure}.\n     * XXX \"xalt\" in the original code.\n     */\n    private ArrayRealVector alternativeNewPoint;\n    /**\n     * Trial step from {@link #trustRegionCenterOffset} which is usually\n     * {@link #newPoint} - {@link #trustRegionCenterOffset}.\n     * XXX \"d__\" in the original code.\n     */\n    private ArrayRealVector trialStepPoint;\n    /**\n     * Values of the Lagrange functions at a new point.\n     * XXX \"vlag\" in the original code.\n     */\n    private ArrayRealVector lagrangeValuesAtNewPoint;\n    /**\n     * Explicit second derivatives of the quadratic model.\n     * XXX \"hq\" in the original code.\n     */\n    private ArrayRealVector modelSecondDerivativesValues;\n\n    /**\n     * @param numberOfInterpolationPoints Number of interpolation conditions.\n     * For a problem of dimension {@code n}, its value must be in the interval\n     * {@code [n+2, (n+1)(n+2)/2]}.\n     * Choices that exceed {@code 2n+1} are not recommended.\n     */\n    public BOBYQAOptimizer(int numberOfInterpolationPoints) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param numberOfInterpolationPoints Number of interpolation conditions.\n     * For a problem of dimension {@code n}, its value must be in the interval\n     * {@code [n+2, (n+1)(n+2)/2]}.\n     * Choices that exceed {@code 2n+1} are not recommended.\n     * @param initialTrustRegionRadius Initial trust region radius.\n     * @param stoppingTrustRegionRadius Stopping trust region radius.\n     */\n    public BOBYQAOptimizer(int numberOfInterpolationPoints,\n                           double initialTrustRegionRadius,\n                           double stoppingTrustRegionRadius) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    protected RealPointValuePair doOptimize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     *     This subroutine seeks the least value of a function of many variables,\n     *     by applying a trust region method that forms quadratic models by\n     *     interpolation. There is usually some freedom in the interpolation\n     *     conditions, which is taken up by minimizing the Frobenius norm of\n     *     the change to the second derivative of the model, beginning with the\n     *     zero matrix. The values of the variables are constrained by upper and\n     *     lower bounds. The arguments of the subroutine are as follows.\n     *\n     *     N must be set to the number of variables and must be at least two.\n     *     NPT is the number of interpolation conditions. Its value must be in\n     *       the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n     *       recommended.\n     *     Initial values of the variables must be set in X(1),X(2),...,X(N). They\n     *       will be changed to the values that give the least calculated F.\n     *     For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper\n     *       bounds, respectively, on X(I). The construction of quadratic models\n     *       requires XL(I) to be strictly less than XU(I) for each I. Further,\n     *       the contribution to a model from changes to the I-th variable is\n     *       damaged severely by rounding errors if XU(I)-XL(I) is too small.\n     *     RHOBEG and RHOEND must be set to the initial and final values of a trust\n     *       region radius, so both must be positive with RHOEND no greater than\n     *       RHOBEG. Typically, RHOBEG should be about one tenth of the greatest\n     *       expected change to a variable, while RHOEND should indicate the\n     *       accuracy that is required in the final values of the variables. An\n     *       error return occurs if any of the differences XU(I)-XL(I), I=1,...,N,\n     *       is less than 2*RHOBEG.\n     *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.\n     *     The array W will be used for working space. Its length must be at least\n     *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     * @return the value of the objective at the optimum.\n     */\n    private double bobyqa(double[] lowerBound,\n                          double[] upperBound) {\n         //The specific code has been omitted, but there is no error\n        } // bobyqa\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN\n     *       are identical to the corresponding arguments in SUBROUTINE BOBYQA.\n     *     XBASE holds a shift of origin that should reduce the contributions\n     *       from rounding errors to values of the model and Lagrange functions.\n     *     XPT is a two-dimensional array that holds the coordinates of the\n     *       interpolation points relative to XBASE.\n     *     FVAL holds the values of F at the interpolation points.\n     *     XOPT is set to the displacement from XBASE of the trust region centre.\n     *     GOPT holds the gradient of the quadratic model at XBASE+XOPT.\n     *     HQ holds the explicit second derivatives of the quadratic model.\n     *     PQ contains the parameters of the implicit second derivatives of the\n     *       quadratic model.\n     *     BMAT holds the last N columns of H.\n     *     ZMAT holds the factorization of the leading NPT by NPT submatrix of H,\n     *       this factorization being ZMAT times ZMAT^T, which provides both the\n     *       correct rank and positive semi-definiteness.\n     *     NDIM is the first dimension of BMAT and has the value NPT+N.\n     *     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively.\n     *       All the components of every XOPT are going to satisfy the bounds\n     *       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when\n     *       XOPT is on a constraint boundary.\n     *     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the\n     *       vector of variables for the next call of CALFUN. XNEW also satisfies\n     *       the SL and SU constraints in the way that has just been mentioned.\n     *     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW\n     *       in order to increase the denominator in the updating of UPDATE.\n     *     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT.\n     *     VLAG contains the values of the Lagrange functions at a new point X.\n     *       They are part of a product that requires VLAG to be of length NDIM.\n     *     W is a one-dimensional array that is used for working space. Its length\n     *       must be at least 3*NDIM = 3*(NPT+N).\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     * @return the value of the objective at the optimum.\n     */\n    private double bobyqb(double[] lowerBound,\n                          double[] upperBound) {\n         //The specific code has been omitted, but there is no error\n        } // bobyqb\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have\n     *       the same meanings as the corresponding arguments of BOBYQB.\n     *     KOPT is the index of the optimal interpolation point.\n     *     KNEW is the index of the interpolation point that is going to be moved.\n     *     ADELT is the current trust region bound.\n     *     XNEW will be set to a suitable new position for the interpolation point\n     *       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region\n     *       bounds and it should provide a large denominator in the next call of\n     *       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the\n     *       straight lines through XOPT and another interpolation point.\n     *     XALT also provides a large value of the modulus of the KNEW-th Lagrange\n     *       function subject to the constraints that have been mentioned, its main\n     *       difference from XNEW being that XALT-XOPT is a constrained version of\n     *       the Cauchy step within the trust region. An exception is that XALT is\n     *       not calculated if all components of GLAG (see below) are zero.\n     *     ALPHA will be set to the KNEW-th diagonal element of the H matrix.\n     *     CAUCHY will be set to the square of the KNEW-th Lagrange function at\n     *       the step XALT-XOPT from XOPT for the vector XALT that is returned,\n     *       except that CAUCHY is set to zero if XALT is not calculated.\n     *     GLAG is a working space vector of length N for the gradient of the\n     *       KNEW-th Lagrange function at XOPT.\n     *     HCOL is a working space vector of length NPT for the second derivative\n     *       coefficients of the KNEW-th Lagrange function.\n     *     W is a working space vector of length 2N that is going to hold the\n     *       constrained Cauchy step from XOPT of the Lagrange function, followed\n     *       by the downhill version of XALT when the uphill step is calculated.\n     *\n     *     Set the first NPT components of W to the leading elements of the\n     *     KNEW-th column of the H matrix.\n     * @param knew\n     * @param adelt\n     */\n    private double[] altmov(\n            int knew,\n            double adelt\n    ) {\n         //The specific code has been omitted, but there is no error\n        } // altmov\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n         //The specific code has been omitted, but there is no error\n        } // prelim\n\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     A version of the truncated conjugate gradient is applied. If a line\n     *     search is restricted by a constraint, then the procedure is restarted,\n     *     the values of the variables that are at their bounds being fixed. If\n     *     the trust region boundary is reached, then further changes may be made\n     *     to D, each one being in the two dimensional space that is spanned\n     *     by the current D and the gradient of Q at XOPT+D, staying on the trust\n     *     region boundary. Termination occurs when the reduction in Q seems to\n     *     be close to the greatest reduction that can be achieved.\n     *     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same\n     *       meanings as the corresponding arguments of BOBYQB.\n     *     DELTA is the trust region radius for the present calculation, which\n     *       seeks a small value of the quadratic model within distance DELTA of\n     *       XOPT subject to the bounds on the variables.\n     *     XNEW will be set to a new vector of variables that is approximately\n     *       the one that minimizes the quadratic model within the trust region\n     *       subject to the SL and SU constraints on the variables. It satisfies\n     *       as equations the bounds that become active during the calculation.\n     *     D is the calculated trial step from XOPT, generated iteratively from an\n     *       initial value of zero. Thus XNEW is XOPT+D after the final iteration.\n     *     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated\n     *       when D is updated.\n     *     xbdi.get( is a working space vector. For I=1,2,...,N, the element xbdi.get((I) is\n     *       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the\n     *       I-th variable has become fixed at a bound, the bound being SL(I) or\n     *       SU(I) in the case xbdi.get((I)=-1.0 or xbdi.get((I)=1.0, respectively. This\n     *       information is accumulated during the construction of XNEW.\n     *     The arrays S, HS and HRED are also used for working space. They hold the\n     *       current search direction, and the changes in the gradient of Q along S\n     *       and the reduced D, respectively, where the reduced D is the same as D,\n     *       except that the components of the fixed variables are zero.\n     *     DSQ will be set to the square of the length of XNEW-XOPT.\n     *     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise\n     *       it is set to the least curvature of H that occurs in the conjugate\n     *       gradient searches that are not restricted by any constraints. The\n     *       value CRVMIN=-1.0D0 is set, however, if all of these searches are\n     *       constrained.\n     * @param delta\n     * @param gnew\n     * @param xbdi\n     * @param s\n     * @param hs\n     * @param hred\n     */\n    private double[] trsbox(\n            double delta,\n            ArrayRealVector gnew,\n            ArrayRealVector xbdi,\n            ArrayRealVector s,\n            ArrayRealVector hs,\n            ArrayRealVector hred\n    ) {\n         //The specific code has been omitted, but there is no error\n        } // trsbox\n\n    // ----------------------------------------------------------------------------------------\n\n    /**\n     *     The arrays BMAT and ZMAT are updated, as required by the new position\n     *     of the interpolation point that has the index KNEW. The vector VLAG has\n     *     N+NPT components, set on entry to the first NPT and last N components\n     *     of the product Hw in equation (4.11) of the Powell (2006) paper on\n     *     NEWUOA. Further, BETA is set on entry to the value of the parameter\n     *     with that name, and DENOM is set to the denominator of the updating\n     *     formula. Elements of ZMAT may be treated as zero if their moduli are\n     *     at most ZTEST. The first NDIM elements of W are used for working space.\n     * @param beta\n     * @param denom\n     * @param knew\n     */\n    private void update(\n            double beta,\n            double denom,\n            int knew\n    ) {\n         //The specific code has been omitted, but there is no error\n        } // update\n\n    /**\n     * Performs validity checks.\n     *\n     * @param lowerBound Lower bounds (constraints) of the objective variables.\n     * @param upperBound Upperer bounds (constraints) of the objective variables.\n     */\n    private void setup(double[] lowerBound,\n                       double[] upperBound) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new array.\n     *\n     * @param n Dimension of the returned array.\n     * @param value Value for each element.\n     * @return an array containing {@code n} elements set to the given\n     * {@code value}.\n     */\n    private static double[] fillNewArray(int n,\n                                         double value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // XXX utility for figuring out call sequence.\n    private static String caller(int n) {\n         //The specific code has been omitted, but there is no error\n        }\n    // XXX utility for figuring out call sequence.\n    private static void printState(int s) {\n         //The specific code has been omitted, but there is no error\n        }\n    // XXX utility for figuring out call sequence.\n    private static void printMethod() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Marker for code paths that are not explored with the current unit tests.\n     * If the path becomes explored, it should just be removed from the code.\n     */\n    private static class PathIsExploredException extends RuntimeException {\n        private static final long serialVersionUID = 745350979634801853L;\n\n        private static final String PATH_IS_EXPLORED\n            = \"If this exception is thrown, just remove it from the code\";\n\n        PathIsExploredException() {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n}", "PathIsExploredException": "    private static class PathIsExploredException extends RuntimeException {\n        private static final long serialVersionUID = 745350979634801853L;\n\n        private static final String PATH_IS_EXPLORED\n            = \"If this exception is thrown, just remove it from the code\";\n\n        PathIsExploredException() {\n         //The specific code has been omitted, but there is no error\n        }\n    }"}