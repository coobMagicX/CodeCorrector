{"FDistributionImpl": "public class FDistributionImpl\n    extends AbstractContinuousDistribution\n    implements FDistribution, Serializable  {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -8516354193418641566L;\n\n    /** The numerator degrees of freedom*/\n    private double numeratorDegreesOfFreedom;\n\n    /** The numerator degrees of freedom*/\n    private double denominatorDegreesOfFreedom;\n    \n    /**\n     * Create a F distribution using the given degrees of freedom.\n     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n     */\n    public FDistributionImpl(double numeratorDegreesOfFreedom,\n            double denominatorDegreesOfFreedom) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * For this distribution, X, this method returns P(X &lt; x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n     * F-Distribution</a>, equation (4).</li>\n     * </ul>\n     * \n     * @param x the value at which the CDF is evaluated.\n     * @return CDF for this distribution. \n     * @throws MathException if the cumulative probability can not be\n     *            computed due to convergence or other numerical errors.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        double ret;\n        if (x <= 0.0) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            double n = getNumeratorDegreesOfFreedom();\n            double m = getDenominatorDegreesOfFreedom();\n            \n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n    \n    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     * <p>\n     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p) \n        throws MathException {\n        if (p == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (p == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n        \n    /**\n     * Access the domain value lower bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value lower bound, i.e.\n     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n     */\n    protected double getDomainLowerBound(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the domain value upper bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value upper bound, i.e.\n     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n     */\n    protected double getDomainUpperBound(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Modify the numerator degrees of freedom.\n     * @param degreesOfFreedom the new numerator degrees of freedom.\n     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n     *         positive.\n     */\n    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Access the numerator degrees of freedom.\n     * @return the numerator degrees of freedom.\n     */\n    public double getNumeratorDegreesOfFreedom() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Modify the denominator degrees of freedom.\n     * @param degreesOfFreedom the new denominator degrees of freedom.\n     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n     *         positive.\n     */\n    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Access the denominator degrees of freedom.\n     * @return the denominator degrees of freedom.\n     */\n    public double getDenominatorDegreesOfFreedom() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}