{"TypeCheck": "public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n\n  //\n  // Internal errors\n  //\n  static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error(\n      \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\",\n      \"Internal Error: Don't know how to handle {0}\");\n\n\n  //\n  // User errors\n  //\n  // TODO(nicksantos): delete this\n  static final DiagnosticType BAD_DELETE =\n      DiagnosticType.warning(\n          \"JSC_BAD_DELETE_OPERAND\",\n          \"delete operator needs a reference operand\");\n\n\n  //\n  // User warnings\n  //\n\n  protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT =\n      \"overriding prototype with non-object\";\n\n  // TODO(user): make all the non private messages private once the\n  // TypedScopeCreator has been merged with the type checker.\n  static final DiagnosticType DETERMINISTIC_TEST =\n      DiagnosticType.warning(\n          \"JSC_DETERMINISTIC_TEST\",\n          \"condition always evaluates to {2}\\n\" +\n          \"left : {0}\\n\" +\n          \"right: {1}\");\n\n  static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT =\n      DiagnosticType.warning(\n          \"JSC_DETERMINISTIC_TEST_NO_RESULT\",\n          \"condition always evaluates to the same value\\n\" +\n          \"left : {0}\\n\" +\n          \"right: {1}\");\n\n  static final DiagnosticType INEXISTENT_ENUM_ELEMENT =\n      DiagnosticType.warning(\n          \"JSC_INEXISTENT_ENUM_ELEMENT\",\n          \"element {0} does not exist on this enum\");\n\n  // disabled by default. This one only makes sense if you're using\n  // well-typed externs.\n  static final DiagnosticType INEXISTENT_PROPERTY =\n      DiagnosticType.disabled(\n          \"JSC_INEXISTENT_PROPERTY\",\n          \"Property {0} never defined on {1}\");\n\n  protected static final DiagnosticType NOT_A_CONSTRUCTOR =\n      DiagnosticType.warning(\n          \"JSC_NOT_A_CONSTRUCTOR\",\n          \"cannot instantiate non-constructor\");\n\n  static final DiagnosticType BIT_OPERATION =\n      DiagnosticType.warning(\n          \"JSC_BAD_TYPE_FOR_BIT_OPERATION\",\n          \"operator {0} cannot be applied to {1}\");\n\n  static final DiagnosticType NOT_CALLABLE =\n      DiagnosticType.warning(\n          \"JSC_NOT_FUNCTION_TYPE\",\n          \"{0} expressions are not callable\");\n\n  static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE =\n      DiagnosticType.warning(\n          \"JSC_CONSTRUCTOR_NOT_CALLABLE\",\n          \"Constructor {0} should be called with the \\\"new\\\" keyword\");\n\n  static final DiagnosticType FUNCTION_MASKS_VARIABLE =\n      DiagnosticType.warning(\n          \"JSC_FUNCTION_MASKS_VARIABLE\",\n          \"function {0} masks variable (IE bug)\");\n\n  static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning(\n      \"JSC_MULTIPLE_VAR_DEF\",\n      \"declaration of multiple variables with shared type information\");\n\n  static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\",\n      \"enum element {0} already defined\");\n\n  static final DiagnosticType ENUM_NOT_CONSTANT =\n      DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\",\n          \"enum key {0} must be a syntactic constant\");\n\n  static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION =\n      DiagnosticType.warning(\n          \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\",\n          \"interface members can only be empty property declarations,\"\n          + \" empty functions{0}\");\n\n  static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY =\n      DiagnosticType.warning(\n          \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\",\n          \"interface member functions must have an empty body\");\n\n  static final DiagnosticType CONFLICTING_EXTENDED_TYPE =\n      DiagnosticType.warning(\n          \"JSC_CONFLICTING_EXTENDED_TYPE\",\n          \"{1} cannot extend this type; {0}s can only extend {0}s\");\n\n  static final DiagnosticType CONFLICTING_IMPLEMENTED_TYPE =\n    DiagnosticType.warning(\n        \"JSC_CONFLICTING_IMPLEMENTED_TYPE\",\n        \"{0} cannot implement this type; \" +\n        \"an interface can only extend, but not implement interfaces\");\n\n  static final DiagnosticType BAD_IMPLEMENTED_TYPE =\n      DiagnosticType.warning(\n          \"JSC_IMPLEMENTS_NON_INTERFACE\",\n          \"can only implement interfaces\");\n\n  static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY =\n      DiagnosticType.warning(\n          \"JSC_HIDDEN_SUPERCLASS_PROPERTY\",\n          \"property {0} already defined on superclass {1}; \" +\n          \"use @override to override it\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY =\n      DiagnosticType.warning(\n          \"JSC_HIDDEN_INTERFACE_PROPERTY\",\n          \"property {0} already defined on interface {1}; \" +\n          \"use @override to override it\");\n\n  static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH =\n      DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\",\n          \"mismatch of the {0} property type and the type \" +\n          \"of the property it overrides from superclass {1}\\n\" +\n          \"original: {2}\\n\" +\n          \"override: {3}\");\n\n  static final DiagnosticType UNKNOWN_OVERRIDE =\n      DiagnosticType.warning(\n          \"JSC_UNKNOWN_OVERRIDE\",\n          \"property {0} not defined on any superclass of {\n         //The specific code has been omitted, but there is no error\n        }\");\n\n  static final DiagnosticType INTERFACE_METHOD_OVERRIDE =\n      DiagnosticType.warning(\n          \"JSC_INTERFACE_METHOD_OVERRIDE\",\n          \"property {0} is already defined by the {1} extended interface\");\n\n  static final DiagnosticType UNKNOWN_EXPR_TYPE =\n      DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\",\n          \"could not determine the type of this expression\");\n\n  static final DiagnosticType UNRESOLVED_TYPE =\n      DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\",\n          \"could not resolve the name {0} to a type\");\n\n  static final DiagnosticType WRONG_ARGUMENT_COUNT =\n      DiagnosticType.warning(\n          \"JSC_WRONG_ARGUMENT_COUNT\",\n          \"Function {0}: called with {1} argument(s). \" +\n          \"Function requires at least {2} argument(s){\n         //The specific code has been omitted, but there is no error\n        }.\");\n\n  static final DiagnosticType ILLEGAL_IMPLICIT_CAST =\n      DiagnosticType.warning(\n          \"JSC_ILLEGAL_IMPLICIT_CAST\",\n          \"Illegal annotation on {0}. @implicitCast may only be used in \" +\n          \"externs.\");\n\n  static final DiagnosticType INCOMPATIBLE_EXTENDED_PROPERTY_TYPE =\n      DiagnosticType.warning(\n          \"JSC_INCOMPATIBLE_EXTENDED_PROPERTY_TYPE\",\n          \"Interface {0} has a property {1} with incompatible types in \" +\n          \"its super interfaces {2} and {3}\");\n\n  static final DiagnosticType EXPECTED_THIS_TYPE =\n      DiagnosticType.warning(\n          \"JSC_EXPECTED_THIS_TYPE\",\n          \"\\\"{0}\\\" must be called with a \\\"this\\\" type\");\n\n  static final DiagnosticType IN_USED_WITH_STRUCT =\n      DiagnosticType.warning(\"JSC_IN_USED_WITH_STRUCT\",\n                             \"Cannot use the IN operator with structs\");\n\n  static final DiagnosticType ILLEGAL_PROPERTY_CREATION =\n      DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_CREATION\",\n                             \"Cannot add a property to a struct instance \" +\n                             \"after it is constructed.\");\n\n  static final DiagnosticType ILLEGAL_OBJLIT_KEY =\n      DiagnosticType.warning(\n          \"ILLEGAL_OBJLIT_KEY\",\n          \"Illegal key, the object literal is a {0}\");\n\n  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n      DETERMINISTIC_TEST,\n      DETERMINISTIC_TEST_NO_RESULT,\n      INEXISTENT_ENUM_ELEMENT,\n      INEXISTENT_PROPERTY,\n      NOT_A_CONSTRUCTOR,\n      BIT_OPERATION,\n      NOT_CALLABLE,\n      CONSTRUCTOR_NOT_CALLABLE,\n      FUNCTION_MASKS_VARIABLE,\n      MULTIPLE_VAR_DEF,\n      ENUM_DUP,\n      ENUM_NOT_CONSTANT,\n      INVALID_INTERFACE_MEMBER_DECLARATION,\n      INTERFACE_FUNCTION_NOT_EMPTY,\n      CONFLICTING_EXTENDED_TYPE,\n      CONFLICTING_IMPLEMENTED_TYPE,\n      BAD_IMPLEMENTED_TYPE,\n      HIDDEN_SUPERCLASS_PROPERTY,\n      HIDDEN_INTERFACE_PROPERTY,\n      HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n      UNKNOWN_OVERRIDE,\n      INTERFACE_METHOD_OVERRIDE,\n      UNKNOWN_EXPR_TYPE,\n      UNRESOLVED_TYPE,\n      WRONG_ARGUMENT_COUNT,\n      ILLEGAL_IMPLICIT_CAST,\n      INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n      EXPECTED_THIS_TYPE,\n      IN_USED_WITH_STRUCT,\n      ILLEGAL_PROPERTY_CREATION,\n      ILLEGAL_OBJLIT_KEY,\n      RhinoErrorReporter.TYPE_PARSE_ERROR,\n      TypedScopeCreator.UNKNOWN_LENDS,\n      TypedScopeCreator.LENDS_ON_NON_OBJECT,\n      TypedScopeCreator.CTOR_INITIALIZER,\n      TypedScopeCreator.IFACE_INITIALIZER,\n      FunctionTypeBuilder.THIS_TYPE_NON_OBJECT);\n\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n\n  private final ReverseAbstractInterpreter reverseInterpreter;\n\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n\n  private MemoizedScopeCreator scopeCreator;\n\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n\n  // This may be expensive, so don't emit these warnings if they're\n  // explicitly turned off.\n  private boolean reportMissingProperties = true;\n\n  private InferJSDocInfo inferJSDocInfo = null;\n\n  // These fields are used to calculate the percentage of expressions typed.\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n\n  // A state boolean to see we are currently in @notypecheck section of the\n  // code.\n  private int noTypeCheckSection = 0;\n\n  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      MemoizedScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Turn on the missing property check. Returns this for easy chaining. */\n  TypeCheck reportMissingProperties(boolean report) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  @Override\n  public void process(Node externsRoot, Node jsRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  public void check(Node node, boolean externs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n      String... arguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void checkTypeofString(NodeTraversal t, Node n, String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Counts the given node in the typed statistics.\n   * @param n a node that should be typed\n   */\n  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits an assignment <code>lvalue = rvalue</code>. If the\n   * <code>lvalue</code> is a prototype modification, we change the schema\n   * of the object type it is referring to.\n   * @param t the traversal\n   * @param assign the assign node\n   * (<code>assign.isAssign()</code> is an implicit invariant)\n   */\n  private void visitAssign(NodeTraversal t, Node assign) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Check that we don't create new properties on structs. */\n  private void checkPropCreation(NodeTraversal t, Node lvalue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void checkPropertyInheritanceOnGetpropAssign(\n      NodeTraversal t, Node assign, Node object, String property,\n      JSDocInfo info, JSType propertyType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits an object literal field definition <code>key : value</code>.\n   *\n   * If the <code>lvalue</code> is a prototype modification, we change the\n   * schema of the object type it is referring to.\n   *\n   * @param t the traversal\n   * @param key the assign node\n   */\n  private void visitObjLitKey(\n      NodeTraversal t, Node key, Node objlit, JSType litType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if any type in the chain has an implicitCast annotation for\n   * the given property.\n   */\n  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   */\n  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given a constructor or an interface type, find out whether the unknown\n   * type is a supertype of the current type.\n   */\n  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits an ASSIGN node for cases such as\n   * <pre>\n   * interface.property2.property = ...;\n   * </pre>\n   */\n  private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object,\n      String property, Node lvalue, Node rvalue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a NAME node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   * @return whether the node is typeable or not\n   */\n  boolean visitName(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Emit a warning if we can prove that a property cannot possibly be\n   * defined on an object. Note the difference between JS and a strictly\n   * statically typed language: we're checking if the property\n   * *cannot be defined*, whereas a java compiler would check if the\n   * property *can be undefined*.\n   */\n  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void checkPropertyAccessHelper(JSType objectType, String propName,\n      NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a GETELEM node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitGetElem(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a VAR node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitVar(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a {@link Token#FUNCTION} node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitFunction(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This function unifies the type checking involved in the core binary\n   * operators and the corresponding assignment operators.  The representation\n   * used internally is such that common code can handle both kinds of\n   * operators easily.\n   *\n   * @param op The operator.\n   * @param t The traversal object, needed to report errors.\n   * @param n The node being checked.\n   */\n  private void visitBinaryOperator(int op, NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * <p>Checks enum aliases.\n   *\n   * <p>We verify that the enum element type of the enum used\n   * for initialization is a subtype of the enum element type of\n   * the enum the value is being copied in.</p>\n   *\n   * <p>Example:</p>\n   * <pre>var myEnum = myOtherEnum;</pre>\n   *\n   * <p>Enum aliases are irregular, so we need special code for this :(</p>\n   *\n   * @param value the value used for initialization of the enum\n   */\n  private void checkEnumAlias(\n      NodeTraversal t, JSDocInfo declInfo, Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // TODO(nicksantos): TypeCheck should never be attaching types to nodes.\n  // All types should be attached by TypeInference. This is not true today\n  // for legacy reasons. There are a number of places where TypeInference\n  // doesn't attach a type, as a signal to TypeCheck that it needs to check\n  // that node's type.\n\n  /**\n   * Ensure that the given node has a type. If it does not have one,\n   * attach the UNKNOWN_TYPE.\n   */\n  private void ensureTyped(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Enforces type casts, and ensures the node is typed.\n   *\n   * A cast in the way that we use it in JSDoc annotations never\n   * alters the generated code and therefore never can induce any runtime\n   * operation. What this means is that a 'cast' is really just a compile\n   * time constraint on the underlying value. In the future, we may add\n   * support for run-time casts for compiled tests.\n   *\n   * To ensure some shred of sanity, we enforce the notion that the\n   * type you are casting to may only meaningfully be a narrower type\n   * than the underlying declared type. We also invalidate optimizations\n   * on bad type casts.\n   *\n   * @param t The traversal object needed to report errors.\n   * @param n The node getting a type assigned to it.\n   * @param type The type to be assigned.\n   */\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}