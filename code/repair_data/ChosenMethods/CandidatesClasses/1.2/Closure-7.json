{"ChainableReverseAbstractInterpreter": "public abstract class ChainableReverseAbstractInterpreter\n    implements ReverseAbstractInterpreter {\n  protected final CodingConvention convention;\n  final JSTypeRegistry typeRegistry;\n  private ChainableReverseAbstractInterpreter firstLink;\n  private ChainableReverseAbstractInterpreter nextLink;\n\n  /**\n   * Constructs an interpreter, which is the only link in a chain. Interpreters\n   * can be appended using {@link #append}.\n   */\n  public ChainableReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Appends a link to {@code this}, returning the updated last link.\n   * <p>\n   * The pattern {@code new X().append(new Y())...append(new Z())} forms a\n   * chain starting with X, then Y, then ... Z.\n   * @param lastLink a chainable interpreter, with no next link\n   * @return the updated last link\n   */\n  public ChainableReverseAbstractInterpreter append(\n      ChainableReverseAbstractInterpreter lastLink) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the first link of this chain.\n   */\n  public ChainableReverseAbstractInterpreter getFirst() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Calculates the preciser scope starting with the first link.\n   */\n  protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Delegates the calculation of the preciser scope to the next link.\n   * If there is no next link, returns the blind scope.\n   */\n  protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the type of a node in the given scope if the node corresponds to a\n   * name whose type is capable of being refined.\n   * @return The current type of the node if it can be refined, null otherwise.\n   */\n  protected JSType getTypeIfRefinable(Node node, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Declares a refined type in {@code scope} for the name represented by\n   * {@code node}. It must be possible to refine the type of the given node in\n   * the given scope, as determined by {@link #getTypeIfRefinable}.\n   */\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see #getRestrictedWithoutUndefined(JSType)\n   */\n  private final Visitor<JSType> restrictUndefinedVisitor =\n    new Visitor<JSType>() {\n      @Override\n      public JSType caseEnumElementType(EnumElementType enumElementType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseAllType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNoType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseUnionType(UnionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseParameterizedType(ParameterizedType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseTemplateType(TemplateType templateType) {\n         //The specific code has been omitted, but there is no error\n        }\n    };\n\n\n  /**\n   * @see #getRestrictedWithoutNull(JSType)\n   */\n  private final Visitor<JSType> restrictNullVisitor =\n    new Visitor<JSType>() {\n      @Override\n      public JSType caseEnumElementType(EnumElementType enumElementType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseAllType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNoType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseUnionType(UnionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseParameterizedType(ParameterizedType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public JSType caseTemplateType(TemplateType templateType) {\n         //The specific code has been omitted, but there is no error\n        }\n    };\n\n  /**\n   * A class common to all visitors that need to restrict the type based on\n   * {@code typeof}-like conditions.\n   */\n  abstract class RestrictByTypeOfResultVisitor\n      implements Visitor<JSType> {\n\n    /**\n     * Abstracts away the similarities between visiting the unknown type and the\n     * all type.\n     * @param topType {@code UNKNOWN_TYPE} or {@code ALL_TYPE}\n     * @return the restricted type\n     * @see #caseAllType\n     * @see #caseUnknownType\n     */\n    protected abstract JSType caseTopType(JSType topType);\n\n    @Override\n    public JSType caseAllType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseUnionType(UnionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNoType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseEnumElementType(EnumElementType enumElementType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseParameterizedType(ParameterizedType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseTemplateType(TemplateType templateType) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * A class common to all visitors that need to restrict the type based on\n   * some {@code typeof}-like condition being true. All base cases return\n   * {@code null}. It is up to the subclasses to override the appropriate ones.\n   */\n  abstract class RestrictByTrueTypeOfResultVisitor\n      extends RestrictByTypeOfResultVisitor {\n    @Override\n    public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * A class common to all visitors that need to restrict the type based on\n   * some {@code typeof}-like condition being false. All base cases return\n   * their type. It is up to the subclasses to override the appropriate ones.\n   */\n  abstract class RestrictByFalseTypeOfResultVisitor\n      extends RestrictByTypeOfResultVisitor {\n    @Override\n    protected JSType caseTopType(JSType topType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * @see ChainableReverseAbstractInterpreter#getRestrictedByTypeOfResult\n   */\n  private class RestrictByOneTypeOfResultVisitor\n      extends RestrictByTypeOfResultVisitor {\n    /**\n     * A value known to be equal or not equal to the result of the\n     * {@code typeOf} operation.\n     */\n    private final String value;\n\n    /**\n     * {@code true} if the {@code typeOf} result is known to equal\n     * {@code value}; {@code false} if it is known <em>not</em> to equal\n     * {@code value}.\n     */\n    private final boolean resultEqualsValue;\n\n    RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes whether the given result of a {@code typeof} operator matches\n     * expectations, i.e. whether a type that gives such a result should be\n     * kept.\n     */\n    private boolean matchesExpectation(String result) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    protected JSType caseTopType(JSType topType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Returns a version of type where undefined is not present.\n   */\n  protected final JSType getRestrictedWithoutUndefined(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a version of type where null is not present.\n   */\n  protected final JSType getRestrictedWithoutNull(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a version of {@code type} that is restricted by some knowledge\n   * about the result of the {@code typeof} operation.\n   * <p>\n   * The behavior of the {@code typeof} operator can be summarized by the\n   * following table:\n   * <table>\n   * <tr><th>type</th><th>result</th></tr>\n   * <tr><td>{@code undefined}</td><td>\"undefined\"</td></tr>\n   * <tr><td>{@code null}</td><td>\"object\"</td></tr>\n   * <tr><td>{@code boolean}</td><td>\"boolean\"</td></tr>\n   * <tr><td>{@code number}</td><td>\"number\"</td></tr>\n   * <tr><td>{@code string}</td><td>\"string\"</td></tr>\n   * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>\n   *     <td>\"object\"</td></tr>\n   * <tr><td>{@code Object} (which implements [[Call]])</td>\n   *     <td>\"function\"</td></tr>\n   * </table>\n   * @param type the type to restrict\n   * @param value A value known to be equal or not equal to the result of the\n   *        {@code typeof} operation\n   * @param resultEqualsValue {@code true} if the {@code typeOf} result is known\n   *        to equal {@code value}; {@code false} if it is known <em>not</em> to\n   *        equal {@code value}\n   * @return the restricted type or null if no version of the type matches the\n   *         restriction\n   */\n  JSType getRestrictedByTypeOfResult(JSType type, String value,\n                                     boolean resultEqualsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  JSType getNativeType(JSTypeNative typeId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If we definitely know what a type is based on the typeof result,\n   * return it.  Otherwise, return null.\n   *\n   * The typeof operation in JS is poorly defined, and this function works\n   * for both the native typeof and goog.typeOf. It should not be made public,\n   * because its semantics are informally defined, and would be wrong in\n   * the general case.\n   */\n  private JSType getNativeTypeForTypeOf(String value) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "RestrictByTypeOfResultVisitor": "  abstract class RestrictByTypeOfResultVisitor\n      implements Visitor<JSType> {\n\n    /**\n     * Abstracts away the similarities between visiting the unknown type and the\n     * all type.\n     * @param topType {@code UNKNOWN_TYPE} or {@code ALL_TYPE}\n     * @return the restricted type\n     * @see #caseAllType\n     * @see #caseUnknownType\n     */\n    protected abstract JSType caseTopType(JSType topType);\n\n    @Override\n    public JSType caseAllType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseUnionType(UnionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNoType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseEnumElementType(EnumElementType enumElementType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseParameterizedType(ParameterizedType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseTemplateType(TemplateType templateType) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "RestrictByTrueTypeOfResultVisitor": "  abstract class RestrictByTrueTypeOfResultVisitor\n      extends RestrictByTypeOfResultVisitor {\n    @Override\n    public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "RestrictByFalseTypeOfResultVisitor": "  abstract class RestrictByFalseTypeOfResultVisitor\n      extends RestrictByTypeOfResultVisitor {\n    @Override\n    protected JSType caseTopType(JSType topType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "RestrictByOneTypeOfResultVisitor": "  private class RestrictByOneTypeOfResultVisitor\n      extends RestrictByTypeOfResultVisitor {\n    /**\n     * A value known to be equal or not equal to the result of the\n     * {@code typeOf} operation.\n     */\n    private final String value;\n\n    /**\n     * {@code true} if the {@code typeOf} result is known to equal\n     * {@code value}; {@code false} if it is known <em>not</em> to equal\n     * {@code value}.\n     */\n    private final boolean resultEqualsValue;\n\n    RestrictByOneTypeOfResultVisitor(String value, boolean resultEqualsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes whether the given result of a {@code typeof} operator matches\n     * expectations, i.e. whether a type that gives such a result should be\n     * kept.\n     */\n    private boolean matchesExpectation(String result) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    protected JSType caseTopType(JSType topType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseBooleanType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseFunctionType(FunctionType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseNumberType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseObjectType(ObjectType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseStringType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}