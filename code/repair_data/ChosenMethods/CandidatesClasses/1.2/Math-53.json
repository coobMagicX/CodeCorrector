{"Complex": "public class Complex implements FieldElement<Complex>, Serializable  {\n\n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n    public static final Complex I = new Complex(0.0, 1.0);\n\n    // CHECKSTYLE: stop ConstantName\n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n\n    /** A complex number representing \"1.0 + 0.0i\" */\n    public static final Complex ONE = new Complex(1.0, 0.0);\n\n    /** A complex number representing \"0.0 + 0.0i\" */\n    public static final Complex ZERO = new Complex(0.0, 0.0);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6195664516687396620L;\n\n    /** The imaginary part. */\n    private final double imaginary;\n\n    /** The real part. */\n    private final double real;\n\n    /** Record whether this complex number is equal to NaN. */\n    private final transient boolean isNaN;\n\n    /** Record whether this complex number is infinite. */\n    private final transient boolean isInfinite;\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real the real part\n     * @param imaginary the imaginary part\n     */\n    public Complex(double real, double imaginary) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the absolute value of this complex number.\n     * <p>\n     * Returns <code>NaN</code> if either real or imaginary part is\n     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n     * neither part is <code>NaN</code>, but at least one part takes an infinite\n     * value.</p>\n     *\n     * @return the absolute value\n     */\n    public double abs() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n\n    /**\n     * Return the conjugate of this complex number. The conjugate of\n     * \"A + Bi\" is \"A - Bi\".\n     * <p>\n     * {@link #NaN} is returned if either the real or imaginary\n     * part of this Complex number equals <code>Double.NaN</code>.</p>\n     * <p>\n     * If the imaginary part is infinite, and the real part is not NaN,\n     * the returned value has infinite imaginary part of the opposite\n     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n     * is <code>1 - NEGATIVE_INFINITY i</code></p>\n     *\n     * @return the conjugate of this Complex object\n     */\n    public Complex conjugate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the quotient of this complex number and the given complex number.\n     * <p>\n     * Implements the definitional formula\n     * <pre><code>\n     *    a + bi          ac + bd + (bc - ad)i\n     *    ----------- = -------------------------\n     *    c + di         c<sup>2</sup> + d<sup>2</sup>\n     * </code></pre>\n     * but uses\n     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n     * prescaling of operands</a> to limit the effects of overflows and\n     * underflows in the computation.</p>\n     * <p>\n     * Infinite and NaN values are handled / returned according to the\n     * following rules, applied in the order presented:\n     * <ul>\n     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n     *  {@link #NaN} is returned.</li>\n     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n     * </li>\n     * <li>If this and <code>rhs</code> are both infinite,\n     * {@link #NaN} is returned.</li>\n     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n     *  <code>rhs</code> is infinite (one or both parts infinite),\n     * {@link #ZERO} is returned.</li>\n     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n     * returned in the parts of the result if the {@link java.lang.Double}\n     * rules applied to the definitional formula force NaN results.</li>\n     * </ul></p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number quotient\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex divide(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to\n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     *\n     */\n    @Override\n    public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get a hashCode for the complex number.\n     * <p>\n     * All NaN values have the same hash code.</p>\n     *\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the imaginary part.\n     *\n     * @return the imaginary part\n     */\n    public double getImaginary() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the real part.\n     *\n     * @return the real part\n     */\n    public double getReal() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if either or both parts of this complex number is NaN;\n     * false otherwise\n     *\n     * @return  true if either or both parts of this complex number is NaN;\n     * false otherwise\n     */\n    public boolean isNaN() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if either the real or imaginary part of this complex number\n     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or\n     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n     * is <code>NaN</code>.\n     *\n     * @return true if one or both parts of this complex number are infinite\n     * and neither part is <code>NaN</code>\n     */\n    public boolean isInfinite() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the product of this complex number and the given complex number.\n     * <p>\n     * Implements preliminary checks for NaN and infinity followed by\n     * the definitional formula:\n     * <pre><code>\n     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     * </code></pre>\n     * </p>\n     * <p>\n     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n     * NaN parts.\n     * </p>\n     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n     * NaN parts and if either this or <code>rhs</code> has one or more\n     * infinite parts (same result is returned regardless of the sign of the\n     * components).\n     * </p>\n     * <p>\n     * Returns finite values in components of the result per the\n     * definitional formula in all remaining cases.\n     *  </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number product\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex multiply(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n\n    /**\n     * Return the product of this complex number and the given scalar number.\n     * <p>\n     * Implements preliminary checks for NaN and infinity followed by\n     * the definitional formula:\n     * <pre><code>\n     * c(a + bi) = (ca) + (cb)i\n     * </code></pre>\n     * </p>\n     * <p>\n     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n     * NaN parts.\n     * </p>\n     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n     * NaN parts and if either this or <code>rhs</code> has one or more\n     * infinite parts (same result is returned regardless of the sign of the\n     * components).\n     * </p>\n     * <p>\n     * Returns finite values in components of the result per the\n     * definitional formula in all remaining cases.\n     *  </p>\n     *\n     * @param rhs the scalar number\n     * @return the complex number product\n     */\n    public Complex multiply(double rhs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the additive inverse of this complex number.\n     * <p>\n     * Returns <code>Complex.NaN</code> if either real or imaginary\n     * part of this Complex number equals <code>Double.NaN</code>.</p>\n     *\n     * @return the negation of this complex number\n     */\n    public Complex negate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n      * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n     * inverse cosine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite.</p>\n     *\n     * @return the inverse cosine of this complex number\n     * @since 1.2\n     */\n    public Complex acos() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n     * inverse sine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite.</p>\n     *\n     * @return the inverse sine of this complex number.\n     * @since 1.2\n     */\n    public Complex asin() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n     * inverse tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite.</p>\n     *\n     * @return the inverse tangent of this complex number\n     * @since 1.2\n     */\n    public Complex atan() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n     * cosine</a>\n     * of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the cosine of this complex number\n     * @since 1.2\n     */\n    public Complex cos() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n     * hyperbolic cosine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the hyperbolic cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cosh() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n     * exponential function</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n     * {@link java.lang.Math#sin}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n     * exp(INFINITY + i) = INFINITY + INFINITY i\n     * exp(-INFINITY + i) = 0 + 0i\n     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return <i>e</i><sup><code>this</code></sup>\n     * @since 1.2\n     */\n    public Complex exp() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n     * natural logarithm</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n     * where ln on the right hand side is {@link java.lang.Math#log},\n     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n     * log(INFINITY + i) = INFINITY + 0i\n     * log(-INFINITY + i) = INFINITY + &pi;i\n     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n     * log(0 + 0i) = -INFINITY + 0i\n     * </code></pre></p>\n     *\n     * @return ln of this complex number.\n     * @since 1.2\n     */\n    public Complex log() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns of value of this complex number raised to the power of <code>x</code>.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>\n     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n     * {@link #log}, respectively.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n     * equals {@link Complex#ZERO}.</p>\n     *\n     * @param x the exponent.\n     * @return <code>this</code><sup><code>x</code></sup>\n     * @throws NullArgumentException if x is null\n     * @since 1.2\n     */\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n     * sine</a>\n     * of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the sine of this complex number.\n     * @since 1.2\n     */\n    public Complex sin() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n     * hyperbolic sine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the hyperbolic sine of this complex number\n     * @since 1.2\n     */\n    public Complex sinh() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of this complex number.\n     * <p>\n     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:\n     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n     * </ol>\n     * where <ul>\n     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n     * </ul></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n     * sqrt(INFINITY + i) = INFINITY + 0i\n     * sqrt(-INFINITY + i) = 0 + INFINITY i\n     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n     * </code></pre></p>\n     *\n     * @return the square root of this complex number\n     * @since 1.2\n     */\n    public Complex sqrt() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n     * number.\n     * <p>\n     * Computes the result directly as\n     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.</p>\n     *\n     * @return the square root of 1 - <code>this</code><sup>2</sup>\n     * @since 1.2\n     */\n    public Complex sqrt1z() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n     * tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n     *\n     * @return the tangent of this complex number\n     * @since 1.2\n     */\n    public Complex tan() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n     * hyperbolic tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>\n     *\n     * @return the hyperbolic tangent of this complex number\n     * @since 1.2\n     */\n    public Complex tanh() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n\n    /**\n     * <p>Compute the argument of this complex number.\n     * </p>\n     * <p>The argument is the angle phi between the positive real axis and the point\n     * representing this number in the complex plane. The value returned is between -PI (not inclusive)\n     * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.\n     * </p>\n     * <p>If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled\n     * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of\n     * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite\n     * parts.  See the javadoc for java.Math.atan2 for full details.</p>\n     *\n     * @return the argument of this complex number\n     */\n    public double getArgument() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>Computes the n-th roots of this complex number.\n     * </p>\n     * <p>The nth roots are defined by the formula: <pre>\n     * <code> z<sub>k</sub> = abs<sup> 1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))</code></pre>\n     * for <i><code>k=0, 1, ..., n-1</code></i>, where <code>abs</code> and <code>phi</code> are\n     * respectively the {@link #abs() modulus} and {@link #getArgument() argument} of this complex number.\n     * </p>\n     * <p>If one or both parts of this complex number is NaN, a list with just one element,\n     *  {@link #NaN} is returned.</p>\n     * <p>if neither part is NaN, but at least one part is infinite, the result is a one-element\n     * list containing {@link #INF}.</p>\n     *\n     * @param n degree of root\n     * @return List<Complex> all nth roots of this complex number\n     * @throws IllegalArgumentException if parameter n is less than or equal to 0\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n\n        if (n <= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument()/n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart the real part\n     * @param imaginaryPart the imaginary part\n     * @return a new complex number instance\n     * @since 1.2\n     */\n    protected Complex createComplex(double realPart, double imaginaryPart) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>Resolve the transient fields in a deserialized Complex Object.</p>\n     * <p>Subclasses will need to override {@link #createComplex} to deserialize properly</p>\n     * @return A Complex instance with all fields resolved.\n     * @since 2.0\n     */\n    protected final Object readResolve() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public ComplexField getField() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}