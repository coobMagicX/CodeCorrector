{"PeepholeFoldConstants": "class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n\n  static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n      DiagnosticType.error(\n          \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n          \"Array index not integer: {0}\");\n\n  static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n      DiagnosticType.error(\n          \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n          \"Array index out of bounds: {0}\");\n\n  static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n      DiagnosticType.error(\n          \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n          \"Can't negate non-numeric value: {0}\");\n\n  static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n      DiagnosticType.error(\n          \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n          \"Operand out of range, bitwise operation will lose information: {0}\");\n\n  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n      \"Shift amount out of bounds: {0}\");\n\n  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n      \"Fractional bitwise operand: {0}\");\n\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n\n  private final boolean late;\n\n  /**\n   * @param late When late is false, this mean we are currently running before\n   * most of the other optimizations. In this case we would avoid optimizations\n   * that would make the code harder to analyze. When this is true, we would\n   * do anything to minimize for size.\n   */\n  PeepholeFoldConstants(boolean late) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  Node optimizeSubtree(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldBinaryOperator(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryReduceVoid(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryReduceOperandsForOp(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryConvertOperandsToNumber(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryConvertToNumber(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Folds 'typeof(foo)' if foo is a literal, e.g.\n   * typeof(\"bar\") --> \"string\"\n   * typeof(6) --> \"number\"\n   */\n  private Node tryFoldTypeof(Node originalTypeofNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldUnaryOperator(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold {@code left instanceof right} into {@code true}\n   * or {@code false}.\n   */\n  private Node tryFoldInstanceof(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldAssign(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryUnfoldAssignOp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold a AND/OR node.\n   */\n  private Node tryFoldAndOr(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n   * where no node has two const children ((foo() + 'a') + 'b'), so\n   * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n   * Specifically, it folds Add expressions where:\n   *  - The left child is also and add expression\n   *  - The right child is a constant value\n   *  - The left child's right child is a STRING constant.\n   */\n  private Node tryFoldChildAddString(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold an ADD node with constant operands\n   */\n  private Node tryFoldAddConstantString(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Expressions such as [foo() * 10 * 20] generate parse trees\n   * where no node has two const children ((foo() * 10) * 20), so\n   * performArithmeticOp() won't fold it -- tryFoldLeftChildOp() will.\n   * Specifically, it folds associative expressions where:\n   *  - The left child is also an associative expression of the same time.\n   *  - The right child is a constant NUMBER constant.\n   *  - The left child's right child is a NUMBER constant.\n   */\n  private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldAdd(Node node, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold comparison nodes, e.g ==\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryFoldComparison(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns whether two JS strings are equal. */\n  private TernaryValue areStringsEqual(String a, String b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Translate NOT expressions into TRUE or FALSE when possible.\n   */\n  private int getNormalizedNodeType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * The result of the comparison as a Boolean or null if the\n   * result could not be determined.\n   */\n  private Boolean compareAsNumbers(int op, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param value The value to compare to \"undefined\"\n   * @param op The boolean op to compare with\n   * @return Whether the boolean op is true or false\n   */\n  private boolean compareToUndefined(Node value, int op) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean isEqualityOp(int op) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param value The value to compare to \"null\"\n   * @param op The boolean op to compare with\n   * @return Whether the boolean op is true or false\n   */\n  private boolean compareToNull(Node value, int op) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold away unnecessary object instantiation.\n   * e.g. this[new String('eval')] -> this.eval\n   */\n  private Node tryFoldCtorCall(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns whether this node must be coerced to a string. */\n  private boolean inForcedStringContext(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldInForcedStringContext(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-element. e.g [1, 2, 3][10];\n   */\n  private Node tryFoldGetElem(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n   */\n  private Node tryFoldGetProp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean isAssignmentTarget(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldObjectPropAccess(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}