{"JsDocInfoParser": "public final class JsDocInfoParser {class JsDocInfoParser {\n\n  private final JsDocTokenStream stream;\n  private final JSDocInfoBuilder jsdocBuilder;\n  private final StaticSourceFile sourceFile;\n  private final Node associatedNode;\n  private final ErrorReporter errorReporter;\n  private final ErrorReporterParser parser = new ErrorReporterParser();\n\n  // Use a template node for properties set on all nodes to minimize the\n  // memory footprint associated with these (similar to IRFactory).\n  private final Node templateNode;\n\n  private class ErrorReporterParser {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // The DocInfo with the fileoverview tag for the whole file.\n  private JSDocInfo fileOverviewJSDocInfo = null;\n  private State state;\n\n  private final Map<String, Annotation> annotationNames;\n  private final Set<String> suppressionNames;\n  static private final Set<String> modifiesAnnotationKeywords =\n      ImmutableSet.<String>of(\"this\", \"arguments\");\n\n  private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;\n\n  /**\n   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n   * parser uses the builder to append any preserve annotations it encounters\n   * in jsdoc comments.\n   *\n   * @param fileLevelJsDocBuilder\n   */\n  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the file overview JSDocInfo, in order to warn about multiple uses of\n   * the @fileoverview tag in a file.\n   */\n  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private enum State {\n    SEARCHING_ANNOTATION,\n    SEARCHING_NEWLINE,\n    NEXT_IS_ANNOTATION\n  }\n\n  JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  Node associatedNode,\n                  Config config,\n                  ErrorReporter errorReporter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private String getSourceName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Parses a string containing a JsDoc type declaration, returning the\n   * type if the parsing succeeded or {@code null} if it failed.\n   */\n  public static Node parseTypeString(String typeString) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Parse a {@code @suppress} tag of the form\n   * {@code @suppress&#123;warning1|warning2&#125;}.\n   *\n   * @param token The current token.\n   */\n  private JsDocToken parseSuppressTag(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Parse a {@code @modifies} tag of the form\n   * {@code @modifies&#123;this|arguments|param&#125;}.\n   *\n   * @param token The current token.\n   */\n  private JsDocToken parseModifiesTag(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * Parameter type expressions are special for two reasons:\n   * <ol>\n   *   <li>They must begin with '{', to distinguish type names from param names.\n   *   <li>They may end in '=', to denote optionality.\n   * </ol>\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Looks for a parameter type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\n   *     (via a call to parseTypeNameAnnotation instead of\n   *     parseTypeExpressionAnnotation).\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Converts a JSDoc token to its string representation.\n   */\n  private String toString(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Constructs a new {@code JSTypeExpression}.\n   * @param n A node. May be null.\n   */\n  private JSTypeExpression createJSTypeExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tuple for returning both the string extracted and the\n   * new token following a call to any of the extract*Block\n   * methods.\n   */\n  private static class ExtractionInfo {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tuple for recording extended types\n   */\n  private static class ExtendedTypeInfo {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Extracts the text found on the current line starting at token. Note that\n   * token = token.info; should be called after this method is used to update\n   * the token properly in the parser.\n   *\n   * @return The extraction information.\n   */\n  private ExtractionInfo extractSingleLineBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private enum WhitespaceOption {\n    /**\n     * Preserves all whitespace and formatting. Needed for licenses and\n     * purposely formatted text.\n     */\n    PRESERVE,\n\n    /** Preserves newlines but trims the output. */\n    TRIM,\n\n    /** Removes newlines and turns the output into a single line string. */\n    SINGLE_LINE\n  }\n\n  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Extracts the top-level block comment from the JsDoc comment, if any.\n   * This method differs from the extractMultilineTextualBlock in that it\n   * terminates under different conditions (it doesn't have the same\n   * prechecks), it does not first read in the remaining of the current\n   * line and its conditions for ignoring the \"*\" (STAR) are different.\n   *\n   * @param token The starting token.\n   *\n   * @return The extraction information.\n   */\n  private ExtractionInfo extractBlockComment(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Trim characters from only the end of a string.\n   * This method will remove all whitespace characters\n   * (defined by Character.isWhitespace(char), in addition to the characters\n   * provided, from the end of the provided string.\n   *\n   * @param s String to be trimmed\n   * @return String with whitespace and characters in extraChars removed\n   *                   from the end.\n   */\n  private static String trimEnd(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // Based on ES4 grammar proposed on July 10, 2008.\n  // http://wiki.ecmascript.org/doku.php?id=spec:spec\n  // Deliberately written to line up with the actual grammar rules,\n  // for maximum flexibility.\n\n  // TODO(nicksantos): The current implementation tries to maintain backwards\n  // compatibility with previous versions of the spec whenever we can.\n  // We should try to gradually withdraw support for these.\n\n  /**\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   */\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * ParamTypeExpressionAnnotation :=\n   *     '{' OptionalParameterType '}' |\n   *     '{' TopLevelTypeExpression '}' |\n   *     '{' '...' TopLevelTypeExpression '}'\n   *\n   * OptionalParameterType :=\n   *     TopLevelTypeExpression '='\n   */\n  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * TypeNameAnnotation := TypeName | '{' TypeName '}'\n   */\n  private Node parseTypeNameAnnotation(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   */\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * TypeExpressionList := TopLevelTypeExpression\n   *     | TopLevelTypeExpression ',' TypeExpressionList\n   */\n  private Node parseTypeExpressionList(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * TypeName := NameExpression | NameExpression TypeApplication\n   * TypeApplication := '.<' TypeExpressionList '>'\n   * TypeExpressionList := TypeExpression // a white lie\n   */\n  private Node parseTypeName(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n  private Node parseFunctionType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * ParametersType := RestParameterType | NonRestParametersType\n   *     | NonRestParametersType ',' RestParameterType\n   * RestParameterType := '...' Identifier\n   * NonRestParametersType := ParameterType ',' NonRestParametersType\n   *     | ParameterType\n   *     | OptionalParametersType\n   * OptionalParametersType := OptionalParameterType\n   *     | OptionalParameterType, OptionalParametersType\n   * OptionalParameterType := ParameterType=\n   * ParameterType := TypeExpression | Identifier ':' TypeExpression\n   */\n  // NOTE(nicksantos): The official ES4 grammar forces optional and rest\n  // arguments to come after the required arguments. Our parser does not\n  // enforce this. Instead we allow them anywhere in the function at parse-time,\n  // and then warn about them during type resolution.\n  //\n  // In theory, it might be mathematically nicer to do the order-checking here.\n  // But in practice, the order-checking for structural functions is exactly\n  // the same as the order-checking for @param annotations. And the latter\n  // has to happen during type resolution. Rather than duplicate the\n  // order-checking in two places, we just do all of it in type resolution.\n  private Node parseParametersType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * ResultType := <empty> | ':' void | ':' TypeExpression\n   */\n  private Node parseResultType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   *\n   * We've removed the empty union type.\n   */\n  private Node parseUnionType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Create a new union type, with an alternate that has already been\n   * parsed. The alternate may be null.\n   */\n  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * ArrayType := '[' ElementTypeList ']'\n   * ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n   *     | TypeExpression ',' ElementTypeList\n   */\n  private Node parseArrayType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * RecordType := '{' FieldTypeList '}'\n   */\n  private Node parseRecordType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * FieldTypeList := FieldType | FieldType ',' FieldTypeList\n   */\n  private Node parseFieldTypeList(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * FieldType := FieldName | FieldName ':' TypeExpression\n   */\n  private Node parseFieldType(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * FieldName := NameExpression | StringLiteral | NumberLiteral |\n   * ReservedIdentifier\n   */\n  private Node parseFieldName(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node wrapNode(int type, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node newNode(int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node newStringNode(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node newStringNode(String s, int lineno, int charno) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // This is similar to IRFactory.createTemplateNode to share common props\n  // e.g., source-name, between all nodes.\n  private Node createTemplateNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node reportTypeSyntaxWarning(String warning) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node reportGenericTypeSyntaxWarning() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n   * state to {@link State#SEARCHING_ANNOTATION}.\n   */\n  private JsDocToken eatTokensUntilEOL() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n   * state to {@link State#SEARCHING_ANNOTATION}.\n   */\n  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Specific value indicating that the {@link #unreadToken} contains no token.\n   */\n  private static final JsDocToken NO_UNREAD_TOKEN = null;\n\n  /**\n   * One token buffer.\n   */\n  private JsDocToken unreadToken = NO_UNREAD_TOKEN;\n\n  /** Restores the lookahead token to the token stream */\n  private void restoreLookAhead(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether the next symbol of the token stream matches the specific\n   * token.\n   */\n  private boolean match(JsDocToken token) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests that the next symbol of the token stream matches one of the specified\n   * tokens.\n   */\n  private boolean match(JsDocToken token1, JsDocToken token2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the next token of the token stream or the buffered token if a matching\n   * was previously made.\n   */\n  private JsDocToken next() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the current token, invalidating it in the process.\n   */\n  private JsDocToken current() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n   * want the JSDoc entry to span multiple lines.\n   */\n  private void skipEOLs() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the parser has been populated with docinfo with a\n   * fileoverview tag.\n   */\n  private boolean hasParsedFileOverviewDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean hasParsedJSDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the fileoverview JSDocInfo, if any.\n   */\n  JSDocInfo getFileOverviewJSDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Look ahead for a type annotation by advancing the character stream.\n   * Does not modify the token stream.\n   * This is kind of a hack, and is only necessary because we use the token\n   * stream to parse types, but need the underlying character stream to get\n   * JsDoc descriptions.\n   * @return Whether we found a type annotation.\n   */\n  private boolean lookAheadForTypeAnnotation() {\n         //The specific code has been omitted, but there is no error\n        }", "ErrorReporterParser": "  private class ErrorReporterParser {\n         //The specific code has been omitted, but there is no error\n        }", "ExtractionInfo": "  private static class ExtractionInfo {\n         //The specific code has been omitted, but there is no error\n        }", "ExtendedTypeInfo": "  private static class ExtendedTypeInfo {\n         //The specific code has been omitted, but there is no error\n        }"}