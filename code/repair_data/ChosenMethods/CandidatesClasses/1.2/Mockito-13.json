{"MockHandler": "public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n\n    private static final long serialVersionUID = -2917871070982574165L;\n\n    InvocationContainerImpl invocationContainerImpl;\n    MatchersBinder matchersBinder = new MatchersBinder();\n    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n\n    private final MockSettingsImpl mockSettings;\n\n    public MockHandler(MockSettingsImpl mockSettings) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // for tests\n    MockHandler() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }\n\n    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public MockSettingsImpl getMockSettings() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @SuppressWarnings(\"unchecked\")\n    public void setAnswersForStubbing(List<Answer> answers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public InvocationContainer getInvocationContainer() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}