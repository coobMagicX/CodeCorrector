{"EmbeddedRungeKuttaIntegrator": "public abstract class EmbeddedRungeKuttaIntegrator\n  extends AdaptiveStepsizeIntegrator {\n\n    /** Indicator for <i>fsal</i> methods. */\n    private final boolean fsal;\n\n    /** Time steps from Butcher array (without the first zero). */\n    private final double[] c;\n\n    /** Internal weights from Butcher array (without the first empty row). */\n    private final double[][] a;\n\n    /** External weights for the high order method from Butcher array. */\n    private final double[] b;\n\n    /** Prototype of the step interpolator. */\n    private final RungeKuttaStepInterpolator prototype;\n\n    /** Stepsize control exponent. */\n    private final double exp;\n\n    /** Safety factor for stepsize control. */\n    private double safety;\n\n    /** Minimal reduction factor for stepsize control. */\n    private double minReduction;\n\n    /** Maximal growth factor for stepsize control. */\n    private double maxGrowth;\n\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param scalAbsoluteTolerance allowed absolute error\n   * @param scalRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Build a Runge-Kutta integrator with the given Butcher array.\n   * @param name name of the method\n   * @param fsal indicate that the method is an <i>fsal</i>\n   * @param c time steps from Butcher array (without the first zero)\n   * @param a internal weights from Butcher array (without the first empty row)\n   * @param b propagation weights for the high order method from Butcher array\n   * @param prototype prototype of the step interpolator to use\n   * @param minStep minimal step (must be positive even for backward\n   * integration), the last step can be smaller than this\n   * @param maxStep maximal step (must be positive even for backward\n   * integration)\n   * @param vecAbsoluteTolerance allowed absolute error\n   * @param vecRelativeTolerance allowed relative error\n   */\n  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double   minStep, final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Get the order of the method.\n   * @return order of the method\n   */\n  public abstract int getOrder();\n\n  /** Get the safety factor for stepsize control.\n   * @return safety factor\n   */\n  public double getSafety() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Set the safety factor for stepsize control.\n   * @param safety safety factor\n   */\n  public void setSafety(final double safety) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n         //The specific code has been omitted, but there is no error\n        }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n         //The specific code has been omitted, but there is no error\n        }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n  /** Get the minimal reduction factor for stepsize control.\n   * @return minimal reduction factor\n   */\n  public double getMinReduction() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Set the minimal reduction factor for stepsize control.\n   * @param minReduction minimal reduction factor\n   */\n  public void setMinReduction(final double minReduction) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Get the maximal growth factor for stepsize control.\n   * @return maximal growth factor\n   */\n  public double getMaxGrowth() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Set the maximal growth factor for stepsize control.\n   * @param maxGrowth maximal growth factor\n   */\n  public void setMaxGrowth(final double maxGrowth) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Compute the error ratio.\n   * @param yDotK derivatives computed during the first stages\n   * @param y0 estimate of the step at the start of the step\n   * @param y1 estimate of the step at the end of the step\n   * @param h  current step\n   * @return error ratio, greater than 1 if step should be rejected\n   */\n  protected abstract double estimateError(double[][] yDotK,\n                                          double[] y0, double[] y1,\n                                          double h);\n\n}"}