{"AbstractLeastSquaresOptimizer": "public abstract class AbstractLeastSquaresOptimizer\n    extends BaseAbstractMultivariateVectorOptimizer<DifferentiableMultivariateVectorFunction>\n    implements DifferentiableMultivariateVectorOptimizer {\n    /**\n     * Singularity threshold (cf. {@link #getCovariances(double)}).\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    private static final double DEFAULT_SINGULARITY_THRESHOLD = 1e-14;\n    /**\n     * Jacobian matrix of the weighted residuals.\n     * This matrix is in canonical form just after the calls to\n     * {@link #updateJacobian()}, but may be modified by the solver\n     * in the derived class (the {@link LevenbergMarquardtOptimizer\n     * Levenberg-Marquardt optimizer} does this).\n     * @deprecated As of 3.1. To be removed in 4.0. Please use\n     * {@link #computeWeightedJacobian(double[])} instead.\n     */\n    @Deprecated\n    protected double[][] weightedResidualJacobian;\n    /** Number of columns of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int cols;\n    /** Number of rows of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int rows;\n    /** Current point.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] point;\n    /** Current objective function value.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] objective;\n    /** Weighted residuals\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] weightedResiduals;\n    /** Cost value (square root of the sum of the residuals).\n     * @deprecated As of 3.1. Field to become \"private\" in 4.0.\n     * Please use {@link #setCost(double)}.\n     */\n    @Deprecated\n    protected double cost;\n    /** Objective function derivatives. */\n    private MultivariateDifferentiableVectorFunction jF;\n    /** Number of evaluations of the Jacobian. */\n    private int jacobianEvaluations;\n    /** Square-root of the weight matrix. */\n    private RealMatrix weightMatrixSqrt;\n\n    /**\n     * Simple constructor with default settings.\n     * The convergence check is set to a {@link\n     * org.apache.commons.math3.optimization.SimpleVectorValueChecker}.\n     * @deprecated See {@link org.apache.commons.math3.optimization.SimpleValueChecker#SimpleValueChecker()}\n     */\n    @Deprecated\n    protected AbstractLeastSquaresOptimizer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param checker Convergence checker.\n     */\n    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return the number of evaluations of the Jacobian function.\n     */\n    public int getJacobianEvaluations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Update the jacobian matrix.\n     *\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @deprecated As of 3.1. Please use {@link #computeWeightedJacobian(double[])}\n     * instead.\n     */\n    @Deprecated\n    protected void updateJacobian() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes the Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @since 3.1\n     */\n    protected RealMatrix computeWeightedJacobian(double[] params) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Update the residuals array and cost function value.\n     * @throws DimensionMismatchException if the dimension does not match the\n     * problem dimension.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @deprecated As of 3.1. Please use {@link #computeResiduals(double[])},\n     * {@link #computeObjectiveValue(double[])}, {@link #computeCost(double[])}\n     * and {@link #setCost(double)} instead.\n     */\n    @Deprecated\n    protected void updateResidualsAndCost() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes the cost.\n     *\n     * @param residuals Residuals.\n     * @return the cost.\n     * @see #computeResiduals(double[])\n     * @since 3.1\n     */\n    protected double computeCost(double[] residuals) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the Root Mean Square value.\n     * Get the Root Mean Square value, i.e. the root of the arithmetic\n     * mean of the square of all weighted residuals. This is related to the\n     * criterion that is minimized by the optimizer as follows: if\n     * <em>c</em> if the criterion, and <em>n</em> is the number of\n     * measurements, then the RMS is <em>sqrt (c/n)</em>.\n     *\n     * @return RMS value\n     */\n    public double getRMS() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get a Chi-Square-like value assuming the N residuals follow N\n     * distinct normal distributions centered on 0 and whose variances are\n     * the reciprocal of the weights.\n     * @return chi-square value\n     */\n    public double getChiSquare() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the square-root of the weight matrix.\n     *\n     * @return the square-root of the weight matrix.\n     * @since 3.1\n     */\n    public RealMatrix getWeightSquareRoot() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the cost.\n     *\n     * @param cost Cost value.\n     * @since 3.1\n     */\n    protected void setCost(double cost) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     *\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     * @see #getCovariances(double)\n     * @deprecated As of 3.1. Please use {@link #computeCovariances(double[],double)}\n     * instead.\n     */\n    @Deprecated\n    public double[][] getCovariances() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     * <br/>\n     * Note that this operation involves the inversion of the\n     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n     * Jacobian matrix.\n     * The {@code threshold} parameter is a way for the caller to specify\n     * that the result of this computation should be considered meaningless,\n     * and thus trigger an exception.\n     *\n     * @param threshold Singularity threshold.\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     * @deprecated As of 3.1. Please use {@link #computeCovariances(double[],double)}\n     * instead.\n     */\n    @Deprecated\n    public double[][] getCovariances(double threshold) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     * <br/>\n     * Note that this operation involves the inversion of the\n     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n     * Jacobian matrix.\n     * The {@code threshold} parameter is a way for the caller to specify\n     * that the result of this computation should be considered meaningless,\n     * and thus trigger an exception.\n     *\n     * @param params Model parameters.\n     * @param threshold Singularity threshold.\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     * @since 3.1\n     */\n    public double[][] computeCovariances(double[] params,\n                                         double threshold) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Returns an estimate of the standard deviation of each parameter. The\n     * returned values are the so-called (asymptotic) standard errors on the\n     * parameters, defined as {@code sd(a[i]) = sqrt(S / (n - m) * C[i][i])},\n     * where {@code a[i]} is the optimized value of the {@code i}-th parameter,\n     * {@code S} is the minimized value of the sum of squares objective function\n     * (as returned by {@link #getChiSquare()}), {@code n} is the number of\n     * observations, {@code m} is the number of parameters and {@code C} is the\n     * covariance matrix.\n     * </p>\n     * <p>\n     * See also\n     * <a href=\"http://en.wikipedia.org/wiki/Least_squares\">Wikipedia</a>,\n     * or\n     * <a href=\"http://mathworld.wolfram.com/LeastSquaresFitting.html\">MathWorld</a>,\n     * equations (34) and (35) for a particular case.\n     * </p>\n     *\n     * @return an estimate of the standard deviation of the optimized parameters\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed.\n     * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n     * positive, i.e. the number of measurements is less or equal to the number of\n     * parameters.\n     * @deprecated as of version 3.1, {@link #computeSigma(double[],double)} should be used\n     * instead. It should be emphasized that {@code guessParametersErrors} and\n     * {@code computeSigma} are <em>not</em> strictly equivalent.\n     */\n    @Deprecated\n    public double[] guessParametersErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes an estimate of the standard deviation of the parameters. The\n     * returned values are the square root of the diagonal coefficients of the\n     * covariance matrix, {@code sd(a[i]) ~= sqrt(C[i][i])}, where {@code a[i]}\n     * is the optimized value of the {@code i}-th parameter, and {@code C} is\n     * the covariance matrix.\n     *\n     * @param params Model parameters.\n     * @param covarianceSingularityThreshold Singularity threshold (see\n     * {@link #computeCovariances(double[],double) computeCovariances}).\n     * @return an estimate of the standard deviation of the optimized parameters\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed.\n     * @since 3.1\n     */\n    public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc}\n     * @deprecated As of 3.1. Please use\n     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n     * instead.\n     */\n    @Override\n    @Deprecated\n    public PointVectorValuePair optimize(int maxEval,\n                                         final DifferentiableMultivariateVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Optimize an objective function.\n     * Optimization is considered to be a weighted least-squares minimization.\n     * The cost function to be minimized is\n     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n     *\n     * @param f Objective function.\n     * @param target Target value for the objective functions at optimum.\n     * @param weights Weights for the least squares cost computation.\n     * @param startPoint Start point for optimization.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @param maxEval Maximum number of function evaluations.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * any argument is {@code null}.\n     * @deprecated As of 3.1. Please use\n     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n     * instead.\n     */\n    @Deprecated\n    public PointVectorValuePair optimize(final int maxEval,\n                                         final MultivariateDifferentiableVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Optimize an objective function.\n     * Optimization is considered to be a weighted least-squares minimization.\n     * The cost function to be minimized is\n     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n     *\n     * @param maxEval Allowed number of evaluations of the objective function.\n     * @param f Objective function.\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link InitialGuess}</li>\n     * </ul>\n     * @return the point/value pair giving the optimal value of the objective\n     * function.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n     * the maximal number of evaluations is exceeded.\n     * @throws DimensionMismatchException if the target, and weight arguments\n     * have inconsistent dimensions.\n     * @see BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])\n     * @since 3.1\n     * @deprecated As of 3.1. Override is necessary only until this class's generic\n     * argument is changed to {@code MultivariateDifferentiableVectorFunction}.\n     */\n    @Deprecated\n    protected PointVectorValuePair optimizeInternal(final int maxEval,\n                                                    final MultivariateDifferentiableVectorFunction f,\n                                                    OptimizationData... optData) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void setUp() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes the residuals.\n     * The residual is the difference between the observed (target)\n     * values and the model (objective function) value.\n     * There is one residual for each element of the vector-valued\n     * function.\n     *\n     * @param objectiveValue Value of the the objective function. This is\n     * the value returned from a call to\n     * {@link #computeObjectiveValue(double[]) computeObjectiveValue}\n     * (whose array argument contains the model parameters).\n     * @return the residuals.\n     * @throws DimensionMismatchException if {@code params} has a wrong\n     * length.\n     * @since 3.1\n     */\n    protected double[] computeResiduals(double[] objectiveValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}