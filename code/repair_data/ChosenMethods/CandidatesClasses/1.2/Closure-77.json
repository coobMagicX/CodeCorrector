{"CodeGenerator": "class CodeGenerator {class CodeGenerator {\n\n  private static final char[] HEX_CHARS\n      = { '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n  private final CodeConsumer cc;\n\n  private final CharsetEncoder outputCharsetEncoder;\n\n  CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  CodeGenerator(CodeConsumer consumer) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Insert a ECMASCRIPT 5 strict annotation.\n   */\n  public void tagAsStrict() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void add(String str) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addIdentifier(String identifier) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void add(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void add(Node n, Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n   * @param n The node to print.\n   * @param context The context to determine how the node should be printed.\n   */\n  private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the Node is a DO or FUNCTION (with or without\n   * labels).\n   */\n  private boolean isOneExactlyFunctionOrDo(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Adds a node at the left-hand side of an expression. Unlike\n   * {@link #addExpr(Node,int)}, this preserves information about the context.\n   *\n   * The left side of an expression is special because in the JavaScript\n   * grammar, certain tokens may be parsed differently when they are at\n   * the beginning of a statement. For example, \"{}\" is parsed as a block,\n   * but \"{'x': 'y'}\" is parsed as an object literal.\n   */\n  void addLeftExpr(Node n, int minPrecedence, Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addExpr(Node n, int minPrecedence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addExpr(Node n, int minPrecedence, Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addList(Node firstInList) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addList(Node firstInList, boolean isArrayOrFunctionArgument) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This function adds a comma-separated list as is specified by an ARRAYLIT\n   * node with the associated skipIndexes array.  This is a space optimization\n   * since we avoid creating a whole Node object for each empty array literal\n   * slot.\n   * @param firstInList The first in the node list (chained through the next\n   * property).\n   */\n  void addArrayList(Node firstInList) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addCaseBody(Node caseBody) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addAllSiblings(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Outputs a js string, using the optimal (single/double) quote character */\n  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Escapes regular expression */\n  static String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Escapes the given string to a double quoted (\") JavaScript/JSON string\n   */\n  static String escapeToDoubleQuotedJsString(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /* If the user doesn't want to specify an output charset encoder, assume\n     they want Latin/ASCII characters only.\n   */\n  static String regexpEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Helper to escape javascript string as well as regular expression */\n  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static String identifierEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n  /**\n   * @param maxCount The maximum number of children to look for.\n   * @return The number of children of this node that are non empty up to\n   * maxCount.\n   */\n  private static int getNonEmptyChildCount(Node n, int maxCount) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets the first non-empty child of the given node. */\n  private static Node getFirstNonEmptyChild(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // Information on the current context. Used for disambiguating special cases.\n  // For example, a \"{\" could indicate the start of an object literal or a\n  // block, depending on the current context.\n  enum Context {\n    STATEMENT,\n    BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity\n    START_OF_EXPR,\n    PRESERVE_BLOCK,\n    // Are we inside the init clause of a for loop?  If so, the containing\n    // expression can't contain an in operator.  Pass this context flag down\n    // until we reach expressions which no longer have the limitation.\n    IN_FOR_INIT_CLAUSE,\n    OTHER\n  }\n\n  private Context getContextForNonEmptyExpression(Context currentContext) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If we're in a IN_FOR_INIT_CLAUSE, we can't permit in operators in the\n   * expression.  Pass on the IN_FOR_INIT_CLAUSE flag through subexpressions.\n   */\n  private  Context getContextForNoInOperator(Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If we're in a IN_FOR_INIT_CLAUSE, (and thus can't permit in operators\n   * in the expression), but have added parentheses, the expressions within\n   * the parens have no limits.  Clear the context flag  Be safe and don't\n   * clear the flag if it held another value.\n   */\n  private  Context clearContextForNoInOperator(Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see #appendHexJavaScriptRepresentation(int, Appendable)\n   */\n  private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a javascript representation of the character in a hex escaped\n   * format.\n   *\n   * @param codePoint The codepoint to append.\n   * @param out The buffer to which the hex representation should be appended.\n   */\n  private static void appendHexJavaScriptRepresentation(\n      int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary unicode values which are not representable in\n      // javascript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from java to javascript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);\n  }\n}"}