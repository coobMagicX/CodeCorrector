{"PeepholeSubstituteAlternateSyntax": "class PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n\n  private final boolean late;\n\n  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n\n  static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n    DiagnosticType.error(\n        \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n        \"Invalid flags to RegExp constructor: {0}\");\n\n  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n      = new Predicate<Node>() {\n    @Override\n    public boolean apply(Node input) {\n         //The specific code has been omitted, but there is no error\n        }\n  };\n\n  /**\n   * @param late When late is false, this mean we are currently running before\n   * most of the other optimizations. In this case we would avoid optimizations\n   * that would make the code harder to analyze (such as using string splitting,\n   * merging statements with commas, etc). When this is true, we would\n   * do anything to minimize for size.\n   */\n  PeepholeSubstituteAlternateSyntax(boolean late) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryJoinForCondition(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldSimpleFunctionCall(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldImmediateCallToBoundFunction(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addParameterAfter(Node parameterList, Node after) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node trySplitComma(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Use \"return x?1:2;\" in place of \"if(x)return 1;return 2;\"\n   */\n  private Node tryReplaceIf(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean statementMustExitParent(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Use \"void 0\" in place of \"undefined\"\n   */\n  private Node tryReplaceUndefined(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n   *\n   * @return The original node, maybe simplified.\n   */\n  private Node tryReduceReturn(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replace duplicate exits in control structures.  If the node following\n   * the exit node expression has the same effect as exit node, the node can\n   * be replaced or removed.\n   * For example:\n   *   \"while (a) {\n         //The specific code has been omitted, but there is no error\n        } return f();\" ==> \"while (a) {\n         //The specific code has been omitted, but there is no error\n        } return f();\"\n   *   \"while (a) {\n         //The specific code has been omitted, but there is no error\n        } throw 'ow';\" ==> \"while (a) {\n         //The specific code has been omitted, but there is no error\n        } throw 'ow';\"\n   *\n   * @param n An follow control exit expression (a THROW or RETURN node)\n   * @return The replacement for n, or the original if no change was made.\n   */\n  private Node tryReplaceExitWithBreak(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Remove duplicate exits.  If the node following the exit node expression\n   * has the same effect as exit node, the node can be removed.\n   * For example:\n   *   \"if (a) {\n         //The specific code has been omitted, but there is no error\n        } return f();\" ==> \"if (a) {\n         //The specific code has been omitted, but there is no error\n        } return f();\"\n   *   \"if (a) {\n         //The specific code has been omitted, but there is no error\n        } throw 'ow';\" ==> \"if (a) {\n         //The specific code has been omitted, but there is no error\n        } throw 'ow';\"\n   *\n   * @param n An follow control exit expression (a THROW or RETURN node)\n   * @return The replacement for n, or the original if no change was made.\n   */\n  private Node tryRemoveRedundantExit(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the expression does not produces and can not be affected\n   * by side-effects.\n   */\n  boolean isPure(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return n or the node following any following finally nodes.\n   */\n  Node skipFinallyNodes(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Check whether one exit can be replaced with another. Verify:\n   * 1) They are identical expressions\n   * 2) If an exception is possible that the statements, the original\n   * and the potential replacement are in the same exception handler.\n   */\n  boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean isExceptionPossible(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  Node getExceptionHandler(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to minimize NOT nodes such as !(x==y).\n   *\n   * Returns the replacement for n or the original if no change was made\n   */\n  private Node tryMinimizeNot(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to remove duplicate statements from IF blocks. For example:\n   *\n   * if (a) {\n         //The specific code has been omitted, but there is no error\n        } else {\n   *   x = 2;\n   *   return true;\n   * }\n   *\n   * becomes:\n   *\n   * if (a) {\n         //The specific code has been omitted, but there is no error\n        } else {\n   *   x = 2;\n   * }\n   * return true;\n   *\n   * @param n The IF node to examine.\n   */\n  private void tryRemoveRepeatedStatements(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The expression node.\n   */\n  private Node getBlockExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an return with or without an expression.\n   */\n  private boolean isReturnBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an return.\n   */\n  private boolean isReturnExpressBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a single return statement.\n   */\n  private boolean isReturnExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The expression that is part of the return.\n   */\n  private Node getBlockReturnExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     a VAR declaration of a single variable.\n   */\n  private boolean isVarBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The var node.\n   */\n  private Node getBlockVar(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does a statement consume a 'dangling else'? A statement consumes\n   * a 'dangling else' if an 'else' token following the statement\n   * would be considered by the parser to be part of the statement.\n   */\n  private boolean consumesDanglingElse(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does the expression contain an operator with lower precedence than\n   * the argument?\n   */\n  private boolean isLowerPrecedenceInExpression(Node n,\n      final int precedence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether the node type has lower precedence than \"precedence\"\n   */\n  private boolean isLowerPrecedence(Node n, final int precedence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether the node type has higher precedence than \"precedence\"\n   */\n  private boolean isHigherPrecedence(Node n, final int precedence) {\n         //The specific code has been omitted, but there is no error\n        }\n  /**\n   * Does the expression contain a property assignment?\n   */\n  private boolean isPropertyAssignmentInExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to minimize conditions expressions, as there are additional\n   * assumptions that can be made when it is known that the final result\n   * is a boolean.\n   *\n   * The following transformations are done recursively:\n   *   !(x||y) --> !x&&!y\n   *   !(x&&y) --> !x||!y\n   *   !!x     --> x\n   * Thus:\n   *   !(x&&!y) --> !x||!!y --> !x||y\n   *\n   *   Returns the replacement for n, or the original if no change was made\n   */\n  private Node tryMinimizeCondition(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replaces a node with a number node if the new number node is not equivalent\n   * to the current node.\n   *\n   * Returns the replacement for n if it was replaced, otherwise returns n.\n   */\n  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n    // String, Number, and Boolean functions return non-object types, whereas\n    // new String, new Number, and new Boolean return object types, so don't\n    // include them here.\n    ImmutableSet.of(\n      \"Object\",\n      \"Array\",\n      \"RegExp\",\n      \"Error\"\n      );\n\n  /**\n   * Fold \"new Object()\" to \"Object()\".\n   */\n  private Node tryFoldStandardConstructors(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replaces a new Array or Object node with an object literal, unless the\n   * call to Array or Object is to a local function with the same name.\n   */\n  private Node tryFoldLiteralConstructor(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static enum FoldArrayAction {\n    NOT_SAFE_TO_FOLD, SAFE_TO_FOLD_WITH_ARGS, SAFE_TO_FOLD_WITHOUT_ARGS}\n\n  /**\n   * Checks if it is safe to fold Array() constructor into []. It can be\n   * obviously done, if the initial constructor has either no arguments or\n   * at least two. The remaining case may be unsafe since Array(number)\n   * actually reserves memory for an empty array which contains number elements.\n   */\n  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldRegularExpressionConstructor(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node reduceTrueFalse(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryMinimizeArrayLiteral(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryMinimizeStringArrayLiteral(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Find a delimiter that does not occur in the given strings\n   * @param strings The strings that must be separated.\n   * @return a delimiter string or null\n   */\n  private String pickDelimiter(String[] strings) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n\n  /**\n   * are the given flags valid regular expression flags?\n   * JavaScript recognizes several suffix flags for regular expressions,\n   * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n   * They are case insensitive, and JavaScript does not recognize the extended\n   * syntax mode, single-line mode, or expression replacement mode from Perl 5.\n   */\n  private static boolean areValidRegexpFlags(String flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * are the given flags safe to fold?\n   * We don't fold the regular expression if global ('g') flag is on,\n   * because in this case it isn't really a constant: its 'lastIndex'\n   * property contains the state of last execution, so replacing\n   * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n   * the program if the RegExp is used inside a loop, for example.\n   * <p>\n   * ECMAScript 5 explicitly disallows pooling of regular expression literals so\n   * in ECMAScript 5, {@code /foo/g} and {@code new RegExp('foo', 'g')} are\n   * equivalent.\n   * From section 7.8.5:\n   * \"Then each time the literal is evaluated, a new object is created as if by\n   * the expression new RegExp(Pattern, Flags) where RegExp is the standard\n   * built-in constructor with that name.\"\n   */\n  private boolean areSafeFlagsToFold(String flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * returns a string node that can safely be rendered inside /brackets/.\n   */\n  private static Node makeForwardSlashBracketSafe(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * true if the JavaScript string would contain a Unicode escape when written\n   * out as the body of a regular expression literal.\n   */\n  static boolean containsUnicodeEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}