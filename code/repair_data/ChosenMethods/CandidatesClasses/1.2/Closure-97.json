{"PeepholeFoldConstants": "public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n\n  static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error(\n      \"JSC_DIVIDE_BY_0_ERROR\",\n      \"Divide by 0\");\n\n  static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n      DiagnosticType.error(\n          \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n          \"Array index not integer: {0}\");\n\n  static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n      DiagnosticType.error(\n          \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n          \"Array index out of bounds: {0}\");\n\n  static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n      DiagnosticType.error(\n          \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n          \"Can't negate non-numeric value: {0}\");\n\n  static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n      DiagnosticType.error(\n          \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n          \"Operand out of range, bitwise operation will lose information: {0}\");\n\n  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n      \"Shift amount out of bounds: {0}\");\n\n  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n      \"Fractional bitwise operand: {0}\");\n\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n\n  @Override\n  Node optimizeSubtree(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldBinaryOperator(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Folds 'typeof(foo)' if foo is a literal, e.g.\n   * typeof(\"bar\") --> \"string\"\n   * typeof(6) --> \"number\"\n   */\n  private Node tryFoldTypeof(Node originalTypeofNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldUnaryOperator(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold {@code left instanceof right} into {@code true}\n   * or {@code false}.\n   */\n  private Node tryFoldInstanceof(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldAssign(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold a AND/OR node.\n   */\n  private Node tryFoldAndOr(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n   * where no node has two const children ((foo() + 'a') + 'b'), so\n   * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n   * Specifically it folds Add exprssions where:\n   *  - The left child is also and add expression\n   *  - The right child is a constant value\n   *  - The left child's right child is a STRING constant.\n   *\n   * WARNING: If javascript ever adds operator overloading, this will\n   * probably stop being correct.\n   */\n  private Node tryFoldLeftChildAdd(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold an ADD node with constant operands\n   */\n  private Node tryFoldAddConstant(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node tryFoldArithmetic(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldAdd(Node node, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node tryFoldBitAndOr(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold comparison nodes, e.g ==\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryFoldComparison(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldKnownMethods(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to evaluate String.indexOf/lastIndexOf:\n   *     \"abcdef\".indexOf(\"bc\") -> 1\n   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n   */\n  private Node tryFoldStringIndexOf(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldStringJoin(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-element. e.g [1, 2, 3][10];\n   */\n  private Node tryFoldGetElem(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n   */\n  private Node tryFoldGetProp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n}"}