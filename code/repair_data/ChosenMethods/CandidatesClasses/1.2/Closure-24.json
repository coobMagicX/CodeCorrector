{"ScopedAliases": "class ScopedAliases implements HotSwapCompilerPass {\n  /** Name used to denote an scoped function block used for aliasing. */\n  static final String SCOPING_METHOD_NAME = \"goog.scope\";\n\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n\n  // Errors\n  static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\");\n\n  static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS =\n      DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\");\n\n  static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\");\n\n  static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\");\n\n  static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\");\n\n  ScopedAliases(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      AliasTransformationHandler transformationHandler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private interface AliasUsage {\n    public void applyAlias();\n  }\n\n  private class AliasedNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final Node aliasDefinition;\n\n    AliasedNode(Node aliasReference, Node aliasDefinition) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void applyAlias() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private class AliasedTypeNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final String correctedType;\n\n    AliasedTypeNode(Node aliasReference, String correctedType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void applyAlias() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n\n  private class Traversal implements NodeTraversal.ScopedCallback {\n    // The job of this class is to collect these three data sets.\n\n    // The order of this list determines the order that aliases are applied.\n    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n\n    private final List<Node> scopeCalls = Lists.newArrayList();\n\n    private final List<AliasUsage> aliasUsages = Lists.newArrayList();\n\n    // This map is temporary and cleared for each scope.\n    private final Map<String, Var> aliases = Maps.newHashMap();\n\n    private boolean hasErrors = false;\n\n    private AliasTransformation transformation = null;\n\n    Collection<Node> getAliasDefinitionsInOrder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private List<AliasUsage> getAliasUsages() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    List<Node> getScopeCalls() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean hasErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isCallToScopeMethod(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void findAliases(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void fixTypeNode(Node typeNode) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "AliasedNode": "  private class AliasedNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final Node aliasDefinition;\n\n    AliasedNode(Node aliasReference, Node aliasDefinition) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void applyAlias() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "AliasedTypeNode": "  private class AliasedTypeNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final String correctedType;\n\n    AliasedTypeNode(Node aliasReference, String correctedType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void applyAlias() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Traversal": "  private class Traversal implements NodeTraversal.ScopedCallback {\n    // The job of this class is to collect these three data sets.\n\n    // The order of this list determines the order that aliases are applied.\n    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n\n    private final List<Node> scopeCalls = Lists.newArrayList();\n\n    private final List<AliasUsage> aliasUsages = Lists.newArrayList();\n\n    // This map is temporary and cleared for each scope.\n    private final Map<String, Var> aliases = Maps.newHashMap();\n\n    private boolean hasErrors = false;\n\n    private AliasTransformation transformation = null;\n\n    Collection<Node> getAliasDefinitionsInOrder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private List<AliasUsage> getAliasUsages() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    List<Node> getScopeCalls() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean hasErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isCallToScopeMethod(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void findAliases(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void fixTypeNode(Node typeNode) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}