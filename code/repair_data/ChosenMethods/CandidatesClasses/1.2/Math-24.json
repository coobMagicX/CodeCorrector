{"BrentOptimizer": "public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n    /**\n     * Golden section.\n     */\n    private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n    /**\n     * Minimum relative tolerance.\n     */\n    private static final double MIN_RELATIVE_TOLERANCE = 2 * FastMath.ulp(1d);\n    /**\n     * Relative threshold.\n     */\n    private final double relativeThreshold;\n    /**\n     * Absolute threshold.\n     */\n    private final double absoluteThreshold;\n\n    /**\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Additional, user-defined, convergence checking\n     * procedure.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */\n    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The arguments are used for implementing the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */\n    public BrentOptimizer(double rel,\n                          double abs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Selects the best of two points.\n     *\n     * @param a Point and value.\n     * @param b Point and value.\n     * @param isMinim {@code true} if the selected point must be the one with\n     * the lowest value.\n     * @return the best point, or {@code null} if {@code a} and {@code b} are\n     * both {@code null}.\n     */\n    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                          UnivariatePointValuePair b,\n                                          boolean isMinim) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}