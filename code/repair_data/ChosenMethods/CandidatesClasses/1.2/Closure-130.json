{"CollapseProperties": "class CollapseProperties implements CompilerPass {\n\n  // Warnings\n  static final DiagnosticType UNSAFE_NAMESPACE_WARNING =\n      DiagnosticType.warning(\n          \"JSC_UNSAFE_NAMESPACE\",\n          \"incomplete alias created for namespace {0}\");\n\n  static final DiagnosticType NAMESPACE_REDEFINED_WARNING =\n      DiagnosticType.warning(\n          \"JSC_NAMESPACE_REDEFINED\",\n          \"namespace {0} should not be redefined\");\n\n  static final DiagnosticType UNSAFE_THIS = DiagnosticType.warning(\n      \"JSC_UNSAFE_THIS\",\n      \"dangerous use of 'this' in static method {0}\");\n\n  private AbstractCompiler compiler;\n\n  /** Global namespace tree */\n  private List<Name> globalNames;\n\n  /** Maps names (e.g. \"a.b.c\") to nodes in the global namespace tree */\n  private Map<String, Name> nameMap;\n\n  private final boolean collapsePropertiesOnExternTypes;\n  private final boolean inlineAliases;\n\n  /**\n   * Creates an instance.\n   *\n   * @param compiler The JSCompiler, for reporting code changes\n   * @param collapsePropertiesOnExternTypes if true, will rename user-defined\n   *     static properties on externed typed. E.g. String.foo.\n   * @param inlineAliases Whether we're allowed to inline local aliases of\n   *     namespaces, etc.\n   */\n  CollapseProperties(AbstractCompiler compiler,\n      boolean collapsePropertiesOnExternTypes, boolean inlineAliases) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * For each qualified name N in the global scope, we check if:\n   * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n   *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n   * (b) N has exactly one write, and it lives in the global scope.\n   * (c) N is aliased in a local scope.\n   *\n   * If (a) is true, then GlobalNamespace must know all the writes to N.\n   * If (a) and (b) are true, then N cannot change during the execution of\n   *    a local scope.\n   * If (a) and (b) and (c) are true, then the alias can be inlined if the\n   *    alias obeys the usual rules for how we decide whether a variable is\n   *    inlineable.\n   * @see InlineVariables\n   */\n  private void inlineAliases(GlobalNamespace namespace) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Runs through all namespaces (prefixes of classes and enums), and checks if\n   * any of them have been used in an unsafe way.\n   */\n  private void checkNamespaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Reports a warning because a namespace was aliased.\n   *\n   * @param nameObj A namespace that is being aliased\n   * @param ref The reference that forced the alias\n   */\n  private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Reports a warning because a namespace was redefined.\n   *\n   * @param nameObj A namespace that is being redefined\n   * @param ref The reference that set the namespace\n   */\n  private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Flattens all references to collapsible properties of a global name except\n   * their initial definitions. Recurses on subnames.\n   *\n   * @param n An object representing a global name\n   * @param alias The flattened name for {@code n}\n   */\n  private void flattenReferencesToCollapsibleDescendantNames(\n      Name n, String alias) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Flattens a stub declaration.\n   * This is mostly a hack to support legacy users.\n   */\n  private void flattenSimpleStubDeclaration(Name name, String alias) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Flattens all references to a collapsible property of a global name except\n   * its initial definition.\n   *\n   * @param n A global property name (e.g. \"a.b\" or \"a.b.c.d\")\n   * @param alias The flattened name (e.g. \"a$b\" or \"a$b$c$d\")\n   */\n  private void flattenReferencesTo(Name n, String alias) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Flattens all occurrences of a name as a prefix of subnames beginning\n   * with a particular subname.\n   *\n   * @param n A global property name (e.g. \"a.b.c.d\")\n   * @param alias A flattened prefix name (e.g. \"a$b\")\n   * @param depth The difference in depth between the property name and\n   *    the prefix name (e.g. 2)\n   */\n  private void flattenPrefixes(String alias, Name n, int depth) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Flattens a particular prefix of a single name reference.\n   *\n   * @param alias A flattened prefix name (e.g. \"a$b\")\n   * @param n The node corresponding to a subproperty name (e.g. \"a.b.c.d\")\n   * @param depth The difference in depth between the property name and\n   *    the prefix name (e.g. 2)\n   * @param originalName String version of the property name.\n   */\n  private void flattenNameRefAtDepth(String alias, Node n, int depth,\n      String originalName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replaces a GETPROP a.b.c with a NAME a$b$c.\n   *\n   * @param alias A flattened prefix name (e.g. \"a$b\")\n   * @param n The GETPROP node corresponding to the original name (e.g. \"a.b\")\n   * @param parent {@code n}'s parent\n   * @param originalName String version of the property name.\n   */\n  private void flattenNameRef(String alias, Node n, Node parent,\n      String originalName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Collapses definitions of the collapsible properties of a global name.\n   * Recurses on subnames that also represent JavaScript objects with\n   * collapsible properties.\n   *\n   * @param n A node representing a global name\n   * @param alias The flattened name for {@code n}\n   */\n  private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name.\n   * This involves flattening the global name (if it's not just a global\n   * variable name already), collapsing object literal keys into global\n   * variables, declaring stub global variables for properties added later\n   * in a local scope.\n   *\n   * It may seem odd that this function also takes care of declaring stubs\n   * for direct children. The ultimate goal of this function is to eliminate\n   * the global name entirely (when possible), so that \"middlemen\" namespaces\n   * disappear, and to do that we need to make sure that all the direct children\n   * will be collapsed as well.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n   * @param canCollapseChildNames Whether it's possible to collapse children of\n   *     this name. (This is mostly passed for convenience; it's equivalent to\n   *     n.canCollapseChildNames()).\n   */\n  private void updateObjLitOrFunctionDeclaration(\n      Name n, String alias, boolean canCollapseChildNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at an ASSIGN node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n   */\n  private void updateObjLitOrFunctionDeclarationAtAssignNode(\n      Name n, String alias, boolean canCollapseChildNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Warns about any references to \"this\" in the given FUNCTION. The function\n   * is getting collapsed, so the references will change.\n   */\n  private void checkForHosedThisReferences(Node function, JSDocInfo docInfo,\n      final Name name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at a VAR node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\")\n   */\n  private void updateObjLitOrFunctionDeclarationAtVarNode(\n      Name n, boolean canCollapseChildNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates the first initialization (a.k.a \"declaration\") of a global name\n   * that occurs at a FUNCTION node. See comment for\n   * {@link #updateObjLitOrFunctionDeclaration}.\n   *\n   * @param n An object representing a global name (e.g. \"a\")\n   */\n  private void updateFunctionDeclarationAtFunctionNode(\n      Name n, boolean canCollapseChildNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Declares global variables to serve as aliases for the values in an object\n   * literal, optionally removing all of the object literal's keys and values.\n   *\n   * @param alias The object literal's flattened name (e.g. \"a$b$c\")\n   * @param objlit The OBJLIT node\n   * @param varNode The VAR node to which new global variables should be added\n   *     as children\n   * @param nameToAddAfter The child of {@code varNode} after which new\n   *     variables should be added (may be null)\n   * @param varParent {@code varNode}'s parent\n   * @return The number of variables added\n   */\n  private int declareVarsForObjLitValues(\n      Name objlitName, String alias, Node objlit, Node varNode,\n      Node nameToAddAfter, Node varParent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Adds global variable \"stubs\" for any properties of a global name that are\n   * only set in a local scope or read but never set.\n   *\n   * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n   * @param alias The flattened name of the object whose properties we are\n   *     adding stubs for (e.g. \"a$b$c\")\n   * @param parent The node to which new global variables should be added\n   *     as children\n   * @param addAfter The child of after which new\n   *     variables should be added (may be null)\n   * @return The number of variables added\n   */\n  private int addStubsForUndeclaredProperties(\n      Name n, String alias, Node parent, Node addAfter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static String appendPropForAlias(String root, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}