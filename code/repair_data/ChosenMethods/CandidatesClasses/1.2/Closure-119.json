{"GlobalNamespace": "class GlobalNamespace\n    implements StaticScope<JSType>,\n    StaticSymbolTable<GlobalNamespace.Name, GlobalNamespace.Ref> {\n\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n\n  /**\n   * Each reference has an index in post-order.\n   * Notice that some nodes are represented by 2 Ref objects, so\n   * this index is not necessarily unique.\n   */\n  private int currentPreOrderIndex = 0;\n\n  /** Global namespace tree */\n  private List<Name> globalNames = new ArrayList<Name>();\n\n  /** Maps names (e.g. \"a.b.c\") to nodes in the global namespace tree */\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n\n  /**\n   * Creates an instance that may emit warnings when building the namespace.\n   *\n   * @param compiler The AbstractCompiler, for reporting code changes\n   * @param root The root of the rest of the code to build a namespace for.\n   */\n  GlobalNamespace(AbstractCompiler compiler, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates an instance that may emit warnings when building the namespace.\n   *\n   * @param compiler The AbstractCompiler, for reporting code changes\n   * @param externsRoot The root of the externs to build a namespace for. If\n   *     this is null, externs and properties defined on extern types will not\n   *     be included in the global namespace.  If non-null, it allows\n   *     user-defined function on extern types to be included in the global\n   *     namespace.  E.g. String.foo.\n   * @param root The root of the rest of the code to build a namespace for.\n   */\n  GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean hasExternsRoot() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Node getRootNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public StaticScope<JSType> getParentScope() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Name getSlot(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Name getOwnSlot(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType getTypeOfThis() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Iterable<Ref> getReferences(Name slot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public StaticScope<JSType> getScope(Name slot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Iterable<Name> getAllSymbols() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void ensureGenerated() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets a list of the roots of the forest of the global names, where the\n   * roots are the top-level names.\n   */\n  List<Name> getNameForest() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets an index of all the global names, indexed by full qualified name\n   * (as in \"a\", \"a.b.c\", etc.).\n   */\n  Map<String, Name> getNameIndex() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A simple data class that contains the information necessary to inspect\n   * a node for changes to the global namespace.\n   */\n  static class AstChange {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If the client adds new nodes to the AST, scan these new nodes\n   * to see if they've added any references to the global namespace.\n   * @param newNodes New nodes to check.\n   */\n  void scanNewNodes(List<AstChange> newNodes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void scanFromNode(\n    BuildGlobalNamespace builder, JSModule module, Scope scope, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Builds the namespace lazily.\n   */\n  private void process() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a name reference in a particular scope is a global name\n   * reference.\n   *\n   * @param name A variable or property name (e.g. \"a\" or \"a.b.c.d\")\n   * @param s The scope in which the name is referenced\n   * @return Whether the name reference is a global name reference\n   */\n  private boolean isGlobalNameReference(String name, Scope s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the top variable name from a possibly namespaced name.\n   *\n   * @param name A variable or qualified property name (e.g. \"a\" or \"a.b.c.d\")\n   * @return The top variable name (e.g. \"a\")\n   */\n  private String getTopVarName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a variable name reference in a particular scope is a\n   * global variable reference.\n   *\n   * @param name A variable name (e.g. \"a\")\n   * @param s The scope in which the name is referenced\n   * @return Whether the name reference is a global variable reference\n   */\n  private boolean isGlobalVarReference(String name, Scope s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets whether a scope is the global scope.\n   *\n   * @param s A scope\n   * @return Whether the scope is the global scope\n   */\n  private boolean isGlobalScope(Scope s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds a tree representation of the global namespace. Omits prototypes.\n   */\n  private class BuildGlobalNamespace implements NodeTraversal.Callback {\n\n    BuildGlobalNamespace() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Collect the references in pre-order. */\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void collect(JSModule module, Scope scope, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the fully qualified name corresponding to an object literal key,\n     * as long as it and its prefix property names are valid JavaScript\n     * identifiers. The object literal may be nested inside of other object\n     * literals.\n     *\n     * For example, if called with node {@code n} representing \"z\" in any of\n     * the following expressions, the result would be \"w.x.y.z\":\n     * <code> var w = {x: {y: {z: 0}}}; </code>\n     * <code> w.x = {y: {z: 0}}; </code>\n     * <code> w.x.y = {'a': 0, 'z': 0}; </code>\n     *\n     * @param n A child of an OBJLIT node\n     * @return The global name, or null if {@code n} doesn't correspond to the\n     *   key of an object literal that can be named\n     */\n    String getNameForObjLitKey(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the type of a value or simple expression.\n     *\n     * @param n An r-value in an assignment or variable declaration (not null)\n     * @return A {@link Name.Type}\n     */\n    Name.Type getValueType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect an\n     * assignment to a global name in global scope.\n     *\n     * @param module the current module\n     * @param scope the current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param isPropAssign Whether this set corresponds to a property\n     *     assignment of the form <code>a.b.c = ...;</code>\n     * @param type The type of the value that the name is being assigned\n     */\n    void handleSetFromGlobal(JSModule module, Scope scope,\n        Node n, Node parent, String name,\n        boolean isPropAssign, Name.Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether a set operation is a constructor or enumeration\n     * or interface declaration. The set operation may either be an assignment\n     * to a name, a variable declaration, or an object literal key mapping.\n     *\n     * @param n The node that represents the name being set\n     * @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node)\n     * @return Whether the set operation is either a constructor or enum\n     *     declaration\n     */\n    private boolean isTypeDeclaration(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect an\n     * assignment to a global name in a local scope.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     */\n    void handleSetFromLocal(JSModule module, Scope scope, Node n, Node parent,\n                            String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     */\n    void handleGet(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isClassDefiningCall(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the result of a hook (x?y:z) or boolean expression\n     * (x||y) or (x&&y) is assigned to a specific global name.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param parent The parent of the current node in the traversal. This node\n     *     should already be known to be a HOOK, AND, or OR node.\n     * @param name A name that is already known to be global in the current\n     *     scope (e.g. \"a\" or \"a.b.c.d\")\n     * @return The expression's get type, either {@link Ref.Type#DIRECT_GET} or\n     *     {@link Ref.Type#ALIASING_GET}\n     */\n    Ref.Type determineGetTypeForHookOrBooleanExpr(\n        JSModule module, Scope scope, Node parent, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param type The reference type\n     */\n    void handleGet(JSModule module, Scope scope, Node n, Node parent,\n        String name, Ref.Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name's longest prefix before the \"prototype\" property if the\n     * name includes the \"prototype\" property. Does nothing otherwise.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @return Whether the name was handled\n     */\n    boolean maybeHandlePrototypePrefix(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether an assignment is nested (i.e. whether its return\n     * value is used).\n     *\n     * @param parent The parent of the current traversal node (not null)\n     * @return Whether it appears that the return value of the assignment is\n     *     used\n     */\n    boolean isNestedAssign(Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets a {@link Name} instance for a global name. Creates it if necessary,\n     * as well as instances for any of its prefixes that are not yet defined.\n     *\n     * @param name A global name (e.g. \"a\", \"a.b.c.d\")\n     * @return The {@link Name} instance for {@code name}\n     */\n    Name getOrCreateName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * A name defined in global scope (e.g. \"a\" or \"a.b.c.d\"). These form a tree.\n   * As the parse tree traversal proceeds, we'll discover that some names\n   * correspond to JavaScript objects whose properties we should consider\n   * collapsing.\n   */\n  static class Name implements StaticSlot<JSType> {\n    enum Type {\n      OBJECTLIT,\n      FUNCTION,\n      GET,\n      SET,\n      OTHER,\n    }\n\n    private final String baseName;\n    final Name parent;\n    List<Name> props;\n\n    /** The first global assignment to a name. */\n    private Ref declaration;\n\n    /** All references to a name. This must contain {@code declaration}. */\n    private List<Ref> refs;\n\n    Type type;\n    private boolean declaredType = false;\n    private boolean hasDeclaredTypeDescendant = false;\n    int globalSets = 0;\n    int localSets = 0;\n    int aliasingGets = 0;\n    int totalGets = 0;\n    int callGets = 0;\n    int deleteProps = 0;\n    final boolean inExterns;\n\n    JSDocInfo docInfo = null;\n\n    Name(String name, Name parent, boolean inExterns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Name addProperty(String name, boolean inExterns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String getBaseName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String getFullName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Ref getDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean isTypeInferred() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType getType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void addRef(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void removeRef(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    List<Ref> getRefs() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void addRefInternal(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean canEliminate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isSimpleStubDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean canCollapse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isGetOrSetDefinition() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean canCollapseUnannotatedChildNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Whether this is an object literal that needs to keep its keys. */\n    boolean shouldKeepKeys() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean needsToBeStubbed() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void setDeclaredType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isDeclaredType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether this name is a prefix of at least one class or enum\n     * name. Because classes and enums are always collapsed, the namespace will\n     * have different properties in compiled code than in uncompiled code.\n     *\n     * For example, if foo.bar.DomHelper is a class, then foo and foo.bar are\n     * considered namespaces.\n     */\n    boolean isNamespace() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether this is a simple name (as opposed to a qualified\n     * name).\n     */\n    boolean isSimpleName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSDocInfo getJSDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Tries to get the doc info for a given declaration ref.\n     */\n    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * A global name reference. Contains references to the relevant parse tree\n   * node and its ancestors that may be affected.\n   */\n  static class Ref implements StaticReference<JSType> {\n\n    // Note: we are more aggressive about collapsing @enum and @constructor\n    // declarations than implied here, see Name#canCollapse\n    enum Type {\n      SET_FROM_GLOBAL,\n      SET_FROM_LOCAL,\n      PROTOTYPE_GET,\n      ALIASING_GET,     // Prevents a name's properties from being collapsed\n      DIRECT_GET,       // Prevents a name from being completely eliminated\n      CALL_GET,         // Prevents a name from being collapsed if never set\n      DELETE_PROP,      // Prevents a name from being collapsed at all.\n    }\n\n    Node node;\n    final JSModule module;\n    final StaticSourceFile source;\n    final Name name;\n    final Type type;\n    final Scope scope;\n    final int preOrderIndex;\n\n    /**\n     * Certain types of references are actually double-refs. For example,\n     * var a = b = 0;\n     * counts as both a \"set\" of b and an \"alias\" of b.\n     *\n     * We create two Refs for this node, and mark them as twins of each other.\n     */\n    private Ref twin = null;\n\n    /**\n     * Creates a reference at the current node.\n     */\n    Ref(JSModule module, Scope scope, Node node, Name name, Type type, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Ref(Ref original, Type type, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Ref(Type type, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StaticSourceFile getSourceFile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StaticSlot<JSType> getSymbol() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String getSourceName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Ref getTwin() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    static void markTwins(Ref a, Ref b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Create a new ref that is the same as this one, but of\n     * a different class.\n     */\n    Ref cloneAndReclassify(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    static Ref createRefForTesting(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n\n  /**\n   * An experimental compiler pass for tracking what symbols were added/removed\n   * at each stage of compilation.\n   *\n   * When \"global namespace tracker\" mode is on, we rebuild the global namespace\n   * after each pass, and diff it against the last namespace built.\n   */\n  static class Tracker implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final PrintStream stream;\n    private final Predicate<String> isInterestingSymbol;\n\n    private Set<String> previousSymbolsInTree = ImmutableSet.of();\n\n    /**\n       @param stream The stream to print logs to.\n     * @param isInterestingSymbol A predicate to determine which symbols\n     *     we care about.\n     */\n    Tracker(AbstractCompiler compiler, PrintStream stream,\n        Predicate<String> isInterestingSymbol) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "AstChange": "  static class AstChange {\n         //The specific code has been omitted, but there is no error\n        }", "BuildGlobalNamespace": "  private class BuildGlobalNamespace implements NodeTraversal.Callback {\n\n    BuildGlobalNamespace() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Collect the references in pre-order. */\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void collect(JSModule module, Scope scope, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the fully qualified name corresponding to an object literal key,\n     * as long as it and its prefix property names are valid JavaScript\n     * identifiers. The object literal may be nested inside of other object\n     * literals.\n     *\n     * For example, if called with node {@code n} representing \"z\" in any of\n     * the following expressions, the result would be \"w.x.y.z\":\n     * <code> var w = {x: {y: {z: 0}}}; </code>\n     * <code> w.x = {y: {z: 0}}; </code>\n     * <code> w.x.y = {'a': 0, 'z': 0}; </code>\n     *\n     * @param n A child of an OBJLIT node\n     * @return The global name, or null if {@code n} doesn't correspond to the\n     *   key of an object literal that can be named\n     */\n    String getNameForObjLitKey(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the type of a value or simple expression.\n     *\n     * @param n An r-value in an assignment or variable declaration (not null)\n     * @return A {@link Name.Type}\n     */\n    Name.Type getValueType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect an\n     * assignment to a global name in global scope.\n     *\n     * @param module the current module\n     * @param scope the current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param isPropAssign Whether this set corresponds to a property\n     *     assignment of the form <code>a.b.c = ...;</code>\n     * @param type The type of the value that the name is being assigned\n     */\n    void handleSetFromGlobal(JSModule module, Scope scope,\n        Node n, Node parent, String name,\n        boolean isPropAssign, Name.Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether a set operation is a constructor or enumeration\n     * or interface declaration. The set operation may either be an assignment\n     * to a name, a variable declaration, or an object literal key mapping.\n     *\n     * @param n The node that represents the name being set\n     * @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node)\n     * @return Whether the set operation is either a constructor or enum\n     *     declaration\n     */\n    private boolean isTypeDeclaration(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect an\n     * assignment to a global name in a local scope.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     */\n    void handleSetFromLocal(JSModule module, Scope scope, Node n, Node parent,\n                            String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     */\n    void handleGet(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isClassDefiningCall(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the result of a hook (x?y:z) or boolean expression\n     * (x||y) or (x&&y) is assigned to a specific global name.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param parent The parent of the current node in the traversal. This node\n     *     should already be known to be a HOOK, AND, or OR node.\n     * @param name A name that is already known to be global in the current\n     *     scope (e.g. \"a\" or \"a.b.c.d\")\n     * @return The expression's get type, either {@link Ref.Type#DIRECT_GET} or\n     *     {@link Ref.Type#ALIASING_GET}\n     */\n    Ref.Type determineGetTypeForHookOrBooleanExpr(\n        JSModule module, Scope scope, Node parent, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param type The reference type\n     */\n    void handleGet(JSModule module, Scope scope, Node n, Node parent,\n        String name, Ref.Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Updates our representation of the global namespace to reflect a read\n     * of a global name's longest prefix before the \"prototype\" property if the\n     * name includes the \"prototype\" property. Does nothing otherwise.\n     *\n     * @param module The current module\n     * @param scope The current scope\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @return Whether the name was handled\n     */\n    boolean maybeHandlePrototypePrefix(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether an assignment is nested (i.e. whether its return\n     * value is used).\n     *\n     * @param parent The parent of the current traversal node (not null)\n     * @return Whether it appears that the return value of the assignment is\n     *     used\n     */\n    boolean isNestedAssign(Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets a {@link Name} instance for a global name. Creates it if necessary,\n     * as well as instances for any of its prefixes that are not yet defined.\n     *\n     * @param name A global name (e.g. \"a\", \"a.b.c.d\")\n     * @return The {@link Name} instance for {@code name}\n     */\n    Name getOrCreateName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Name": "  static class Name implements StaticSlot<JSType> {\n    enum Type {\n      OBJECTLIT,\n      FUNCTION,\n      GET,\n      SET,\n      OTHER,\n    }\n\n    private final String baseName;\n    final Name parent;\n    List<Name> props;\n\n    /** The first global assignment to a name. */\n    private Ref declaration;\n\n    /** All references to a name. This must contain {@code declaration}. */\n    private List<Ref> refs;\n\n    Type type;\n    private boolean declaredType = false;\n    private boolean hasDeclaredTypeDescendant = false;\n    int globalSets = 0;\n    int localSets = 0;\n    int aliasingGets = 0;\n    int totalGets = 0;\n    int callGets = 0;\n    int deleteProps = 0;\n    final boolean inExterns;\n\n    JSDocInfo docInfo = null;\n\n    Name(String name, Name parent, boolean inExterns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Name addProperty(String name, boolean inExterns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String getBaseName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String getFullName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Ref getDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean isTypeInferred() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType getType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void addRef(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void removeRef(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    List<Ref> getRefs() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void addRefInternal(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean canEliminate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isSimpleStubDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean canCollapse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isGetOrSetDefinition() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean canCollapseUnannotatedChildNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Whether this is an object literal that needs to keep its keys. */\n    boolean shouldKeepKeys() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean needsToBeStubbed() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void setDeclaredType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isDeclaredType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether this name is a prefix of at least one class or enum\n     * name. Because classes and enums are always collapsed, the namespace will\n     * have different properties in compiled code than in uncompiled code.\n     *\n     * For example, if foo.bar.DomHelper is a class, then foo and foo.bar are\n     * considered namespaces.\n     */\n    boolean isNamespace() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether this is a simple name (as opposed to a qualified\n     * name).\n     */\n    boolean isSimpleName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSDocInfo getJSDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Tries to get the doc info for a given declaration ref.\n     */\n    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Ref": "  static class Ref implements StaticReference<JSType> {\n\n    // Note: we are more aggressive about collapsing @enum and @constructor\n    // declarations than implied here, see Name#canCollapse\n    enum Type {\n      SET_FROM_GLOBAL,\n      SET_FROM_LOCAL,\n      PROTOTYPE_GET,\n      ALIASING_GET,     // Prevents a name's properties from being collapsed\n      DIRECT_GET,       // Prevents a name from being completely eliminated\n      CALL_GET,         // Prevents a name from being collapsed if never set\n      DELETE_PROP,      // Prevents a name from being collapsed at all.\n    }\n\n    Node node;\n    final JSModule module;\n    final StaticSourceFile source;\n    final Name name;\n    final Type type;\n    final Scope scope;\n    final int preOrderIndex;\n\n    /**\n     * Certain types of references are actually double-refs. For example,\n     * var a = b = 0;\n     * counts as both a \"set\" of b and an \"alias\" of b.\n     *\n     * We create two Refs for this node, and mark them as twins of each other.\n     */\n    private Ref twin = null;\n\n    /**\n     * Creates a reference at the current node.\n     */\n    Ref(JSModule module, Scope scope, Node node, Name name, Type type, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Ref(Ref original, Type type, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Ref(Type type, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StaticSourceFile getSourceFile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StaticSlot<JSType> getSymbol() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String getSourceName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Ref getTwin() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    static void markTwins(Ref a, Ref b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Create a new ref that is the same as this one, but of\n     * a different class.\n     */\n    Ref cloneAndReclassify(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    static Ref createRefForTesting(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Tracker": "  static class Tracker implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final PrintStream stream;\n    private final Predicate<String> isInterestingSymbol;\n\n    private Set<String> previousSymbolsInTree = ImmutableSet.of();\n\n    /**\n       @param stream The stream to print logs to.\n     * @param isInterestingSymbol A predicate to determine which symbols\n     *     we care about.\n     */\n    Tracker(AbstractCompiler compiler, PrintStream stream,\n        Predicate<String> isInterestingSymbol) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}