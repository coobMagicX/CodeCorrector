{"NormalDistributionImpl": "public class NormalDistributionImpl extends AbstractContinuousDistribution\n        implements NormalDistribution, Serializable {\n    /**\n     * Default inverse cumulative probability accuracy.\n     * @since 2.1\n     */\n    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 8589540077390120676L;\n    /** &sqrt;(2 &pi;) */\n    private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n    /** Mean of this distribution. */\n    private final double mean;\n    /** Standard deviation of this distribution. */\n    private final double standardDeviation;\n    /** Inverse cumulative probability accuracy. */\n    private final double solverAbsoluteAccuracy;\n\n    /**\n     * Create a normal distribution using the given mean and standard deviation.\n     *\n     * @param mean Mean for this distribution.\n     * @param sd Standard deviation for this distribution.\n     */\n    public NormalDistributionImpl(double mean, double sd){\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Create a normal distribution using the given mean, standard deviation and\n     * inverse cumulative distribution accuracy.\n     *\n     * @param mean Mean for this distribution.\n     * @param sd Standard deviation for this distribution.\n     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n     * @since 2.1\n     */\n    public NormalDistributionImpl(double mean, double sd, double inverseCumAccuracy) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Create a normal distribution with mean equal to zero and standard\n     * deviation equal to one.\n     */\n    public NormalDistributionImpl(){\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    public double getMean() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    public double getStandardDeviation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double density(double x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n     * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n     *\n     * @param x Value at which the CDF is evaluated.\n     * @return CDF evaluated at {@code x}.\n     * @throws MathException if the algorithm fails to converge\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        final double dev = x - mean;\n        try {\n        return 0.5 * (1.0 + Erf.erf((dev) /\n                    (standardDeviation * FastMath.sqrt(2.0))));\n        } catch (MaxIterationsExceededException ex) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Return the absolute accuracy setting of the solver used to estimate\n     * inverse cumulative probabilities.\n     *\n     * @return the solver absolute accuracy.\n     * @since 2.1\n     */\n    @Override\n    protected double getSolverAbsoluteAccuracy() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * For this distribution, X, this method returns the critical point\n     * {@code x}, such that {@code P(X < x) = p}.\n     * It will return {@code Double.NEGATIVE_INFINITY} when p = 0 and\n     * {@code Double.POSITIVE_INFINITY} for p = 1.\n     *\n     * @param p Desired probability.\n     * @return {@code x}, such that {@code P(X < x) = p}.\n     * @throws MathException if the inverse cumulative probability cannot be\n     * computed due to convergence or other numerical errors.\n     * @throws org.apache.commons.math.exception.OutOfRangeException if\n     * {@code p} is not a valid probability.\n     */\n    @Override\n    public double inverseCumulativeProbability(final double p)\n    throws MathException {\n        if (p == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (p == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n\n    /**\n     * Generate a random value sampled from this distribution.\n     *\n     * @return a random value.\n     * @since 2.2\n     * @throws MathException if an error occurs generating the random value.\n     */\n    @Override\n    public double sample() throws MathException {\n        return randomData.nextGaussian(mean, standardDeviation);\n    }\n\n    /**\n     * Access the domain value lower bound, based on {@code p}, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     *\n     * @param p Desired probability for the critical value.\n     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n     */\n    @Override\n    protected double getDomainLowerBound(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the domain value upper bound, based on {@code p}, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     *\n     * @param p Desired probability for the critical value.\n     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n     */\n    @Override\n    protected double getDomainUpperBound(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the initial domain value, based on {@code p}, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     *\n     * @param p Desired probability for the critical value.\n     * @return the initial domain value.\n     */\n    @Override\n    protected double getInitialDomain(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}