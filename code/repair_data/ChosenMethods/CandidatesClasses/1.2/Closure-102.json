{"Normalize": "class Normalize implements CompilerPass, Callback {\n\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n\n  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void reportCodeChange(String changeDescription) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static class PropogateConstantAnnotations\n      extends AbstractPostOrderCallback\n      implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    public PropogateConstantAnnotations(\n        AbstractCompiler compiler, boolean forbidChanges) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Walk the AST tree and verify that constant names are used consistently.\n   */\n  static class VerifyConstants extends AbstractPostOrderCallback\n      implements CompilerPass {\n\n    final private AbstractCompiler compiler;\n    final private boolean checkUserDeclarations;\n\n    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Map<String,Boolean> constantMap = Maps.newHashMap();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Do normalizations that introduce new siblings or parents.\n   */\n  private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n  // fixed.\n  /**\n   * Limit the number of special cases where LABELs need to be handled. Only\n   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n   * place as the named continues are not allowed for labeled blocks.\n   */\n  private void normalizeLabels(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Bring the initializers out of FOR loops.  These need to be placed\n   * before any associated LABEL nodes. This needs to be done from the top\n   * level label first so this is called as a pre-order callback (from\n   * shouldTraverse).\n   *\n   * @param n The node to inspect.\n   * @param before The node to insert the initializer before.\n   * @param beforeParent The parent of the node before which the initializer\n   *     will be inserted.\n   */\n  private void extractForInitializer(\n      Node n, Node before, Node beforeParent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Split a var node such as:\n   *   var a, b;\n   * into individual statements:\n   *   var a;\n   *   var b;\n   * @param n The whose children we should inspect.\n   */\n  private void splitVarDeclarations(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Move all the functions that are valid at the execution of the first\n   * statement of the function to the beginning of the function definition.\n   */\n  private void moveNamedFunctions(Node functionBody) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param after The child node to insert the newChild after, or null if\n   *     newChild should be added to the front of parent's child list.\n   * @return The inserted child node.\n   */\n  private Node addToFront(Node parent, Node newChild, Node after) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Remove duplicate VAR declarations.\n   */\n  private void removeDuplicateDeclarations(Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * ScopeCreator duplicate declaration handler.\n   */\n  private final class DuplicateDeclarationHandler implements\n      SyntacticScopeCreator.RedeclarationHandler {\n\n    /**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  }\n\n  /**\n   * A simple class that causes scope to be created.\n   */\n  private final class ScopeTicklingCallback\n      implements NodeTraversal.ScopedCallback {\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n}", "PropogateConstantAnnotations": "  public static class PropogateConstantAnnotations\n      extends AbstractPostOrderCallback\n      implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    public PropogateConstantAnnotations(\n        AbstractCompiler compiler, boolean forbidChanges) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "VerifyConstants": "  static class VerifyConstants extends AbstractPostOrderCallback\n      implements CompilerPass {\n\n    final private AbstractCompiler compiler;\n    final private boolean checkUserDeclarations;\n\n    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Map<String,Boolean> constantMap = Maps.newHashMap();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "DuplicateDeclarationHandler": "  private final class DuplicateDeclarationHandler implements\n      SyntacticScopeCreator.RedeclarationHandler {\n\n    /**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  }", "ScopeTicklingCallback": "  private final class ScopeTicklingCallback\n      implements NodeTraversal.ScopedCallback {\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}