{"UnionType": "public class UnionType extends JSType {\n  private static final long serialVersionUID = 1L;\n\n  Set<JSType> alternates;\n\n  /**\n   * Creates a union type.\n   *\n   * @param alternates the alternates of the union\n   */\n  UnionType(JSTypeRegistry registry, Set<JSType> alternates) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the alternate types of this union type.\n   * @return The alternate types of this union type. The returned set is\n   *     immutable.\n   */\n  public Iterable<JSType> getAlternates() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void forgiveUnknownNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in a\n   * numeric context, such as an operand of a multiply operator.\n   *\n   * @return true if the type can appear in a numeric context.\n   */\n  @Override\n  public boolean matchesNumberContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in a\n   * {@code String} context, such as an operand of a string concat ({@code +})\n   * operator.<p>\n   *\n   * All types have at least the potential for converting to {@code String}.\n   * When we add externally defined types, such as a browser OM, we may choose\n   * to add types that do not automatically convert to {@code String}.\n   *\n   * @return {@code true} if not {@link VoidType}\n   */\n  @Override\n  public boolean matchesStringContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in an\n   * {@code Object} context, such as the expression in a {@code with}\n   * statement.<p>\n   *\n   * Most types we will encounter, except notably {@code null}, have at least\n   * the potential for converting to {@code Object}.  Host defined objects can\n   * get peculiar.<p>\n   *\n   * VOID type is included here because while it is not part of the JavaScript\n   * language, functions returning 'void' type can't be used as operands of\n   * any operator or statement.<p>\n   *\n   * @return {@code true} if the type is not {@link NullType} or\n   *         {@link VoidType}\n   */\n  @Override\n  public boolean matchesObjectContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType findPropertyType(String propertyName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean canAssignTo(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean canBeCalled() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType restrictByNotNullOrUndefined() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public TernaryValue testForEquality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate determines whether objects of this type can have the\n   * {@code null} value, and therefore can appear in contexts where\n   * {@code null} is expected.\n   *\n   * @return {@code true} for everything but {@code Number} and\n   *         {@code Boolean} types.\n   */\n  @Override\n  public boolean isNullable() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType getLeastSupertype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  JSType meet(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */\n  @Override\n  public boolean equals(Object object) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isUnionType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isObject() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A {@link UnionType} contains a given type (alternate) iff the member\n   * vector contains it.  Since the {@link #equals} method above conforms to\n   * the necessary semantics for the collection, everything works out just\n   * fine.\n   *\n   * @param alternate The alternate which might be in this union.\n   *\n   * @return {@code true} if the alternate is in the union\n   */\n  public boolean contains(JSType alternate) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a more restricted union type than {@code this} one, in which all\n   * subtypes of {@code type} have been removed.<p>\n   *\n   * Examples:\n   * <ul>\n   * <li>{@code (number,string)} restricted by {@code number} is\n   *     {@code string}</li>\n   * <li>{@code (null, EvalError, URIError)} restricted by\n   *     {@code Error} is {@code null}</li>\n   * </ul>\n   *\n   * @param type the supertype of the types to remove from this union type\n   */\n  public JSType getRestrictedUnion(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isSubtype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public BooleanLiteralSet getPossibleToBooleanOutcomes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public TypePair getTypesUnderEquality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public TypePair getTypesUnderInequality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public TypePair getTypesUnderShallowInequality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}