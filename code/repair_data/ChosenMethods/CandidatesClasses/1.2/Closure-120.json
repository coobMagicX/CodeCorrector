{"ReferenceCollectingCallback": "class ReferenceCollectingCallback implements ScopedCallback,\n    HotSwapCompilerPass,\n    StaticSymbolTable<Var, ReferenceCollectingCallback.Reference> {\n\n  /**\n   * Maps a given variable to a collection of references to that name. Note that\n   * Var objects are not stable across multiple traversals (unlike scope root or\n   * name).\n   */\n  private final Map<Var, ReferenceCollection> referenceMap =\n      Maps.newHashMap();\n\n  /**\n   * The stack of basic blocks and scopes the current traversal is in.\n   */\n  private final Deque<BasicBlock> blockStack = new ArrayDeque<BasicBlock>();\n\n  /**\n   * Source of behavior at various points in the traversal.\n   */\n  private final Behavior behavior;\n\n  /**\n   * JavaScript compiler to use in traversing.\n   */\n  private final AbstractCompiler compiler;\n\n  /**\n   * Only collect references for filtered variables.\n   */\n  private final Predicate<Var> varFilter;\n\n  /**\n   * Constructor initializes block stack.\n   */\n  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Constructor only collects references that match the given variable.\n   *\n   * The test for Var equality uses reference equality, so it's necessary to\n   * inject a scope when you traverse.\n   */\n  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior,\n      Predicate<Var> varFilter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Convenience method for running this pass over a tree with this\n   * class as a callback.\n   */\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Same as process but only runs on a part of AST associated to one script.\n   */\n  @Override\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the variables that were referenced in this callback.\n   */\n  @Override\n  public Iterable<Var> getAllSymbols() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public Scope getScope(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the reference collection for the given variable.\n   */\n  @Override\n  public ReferenceCollection getReferences(Var v) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * For each node, update the block stack and reference collection\n   * as appropriate.\n   */\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates block stack and invokes any additional behavior.\n   */\n  @Override\n  public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates block stack and invokes any additional behavior.\n   */\n  @Override\n  public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates block stack.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n      Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return true if this node marks the start of a new basic block\n   */\n  private static boolean isBlockBoundary(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addReference(Var v, Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  interface ReferenceMap {\n    ReferenceCollection getReferences(Var var);\n  }\n\n  private static class ReferenceMapWrapper implements ReferenceMap {\n    private final Map<Var, ReferenceCollection> referenceMap;\n\n    public ReferenceMapWrapper(Map<Var, ReferenceCollection> referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceCollection getReferences(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Way for callers to add specific behavior during traversal that\n   * utilizes the built-up reference information.\n   */\n  interface Behavior {\n    /**\n     * Called after we finish with a scope.\n     */\n    void afterExitScope(NodeTraversal t, ReferenceMap referenceMap);\n  }\n\n  static final Behavior DO_NOTHING_BEHAVIOR = new Behavior() {\n         //The specific code has been omitted, but there is no error\n        };\n\n  /**\n   * A collection of references. Can be subclassed to apply checks or\n   * store additional state when adding.\n   */\n  static class ReferenceCollection implements Iterable<Reference> {\n\n    List<Reference> references = Lists.newArrayList();\n\n    @Override\n    public Iterator<Reference> iterator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void add(Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines if the variable for this reference collection is\n     * \"well-defined.\" A variable is well-defined if we can prove at\n     * compile-time that it's assigned a value before it's used.\n     *\n     * Notice that if this function returns false, this doesn't imply that the\n     * variable is used before it's assigned. It just means that we don't\n     * have enough information to make a definitive judgment.\n     */\n    protected boolean isWellDefined() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Whether the variable is escaped into an inner scope.\n     */\n    boolean isEscaped() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param index The index into the references array to look for an\n     * assigning declaration.\n     *\n     * This is either the declaration if a value is assigned (such as\n     * \"var a = 2\", \"function a()...\", \"... catch (a)...\").\n     */\n    private boolean isInitializingDeclarationAt(int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param index The index into the references array to look for an\n     * initialized assignment reference. That is, an assignment immediately\n     * follow a variable declaration that itself does not initialize the\n     * variable.\n     */\n    private boolean isInitializingAssignmentAt(int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return The reference that provides the value for the variable at the\n     * time of the first read, if known, otherwise null.\n     *\n     * This is either the variable declaration (\"var a = ...\") or first\n     * reference following the declaration if it is an assignment.\n     */\n    Reference getInitializingReference() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constants are allowed to be defined after their first use.\n     */\n    Reference getInitializingReferenceForConstants() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return The one and only assignment. Returns if there are 0 or 2+\n     *    assignments.\n     */\n    private Reference getOneAndOnlyAssignment() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether the variable is never assigned a value.\n     */\n    boolean isNeverAssigned() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean firstReferenceIsAssigningDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Represents a single declaration or reference to a variable.\n   */\n  static final class Reference implements StaticReference<JSType> {\n\n    private static final Set<Integer> DECLARATION_PARENTS =\n        ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH);\n\n    private final Node nameNode;\n    private final BasicBlock basicBlock;\n    private final Scope scope;\n    private final InputId inputId;\n    private final StaticSourceFile sourceFile;\n\n    Reference(Node nameNode, NodeTraversal t,\n        BasicBlock basicBlock) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // Bleeding functions are weird, because the declaration does\n    // not appear inside their scope. So they need their own constructor.\n    static Reference newBleedingFunction(NodeTraversal t,\n        BasicBlock basicBlock, Node func) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a variable reference in a given script file name, used in tests.\n     *\n     * @return The created reference.\n     */\n    @VisibleForTesting\n    static Reference createRefForTest(CompilerInput input) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Reference(Node nameNode,\n        BasicBlock basicBlock, Scope scope, InputId inputId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Makes a copy of the current reference using a new Scope instance.\n     */\n    Reference cloneWithNewScope(Scope newScope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Var getSymbol() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public InputId getInputId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StaticSourceFile getSourceFile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isVarDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isHoistedFunction() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the variable is initialized at the declaration.\n     */\n    boolean isInitializingDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n   /**\n    * @return For an assignment, variable declaration, or function declaration\n    * return the assigned value, otherwise null.\n    */\n    Node getAssignedValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    BasicBlock getBasicBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getParent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getGrandparent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static boolean isLhsOfForInExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isSimpleAssignmentToName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isLvalue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Scope getScope() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Represents a section of code that is uninterrupted by control structures\n   * (conditional or iterative logic).\n   */\n  static final class BasicBlock {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ReferenceMapWrapper": "  private static class ReferenceMapWrapper implements ReferenceMap {\n    private final Map<Var, ReferenceCollection> referenceMap;\n\n    public ReferenceMapWrapper(Map<Var, ReferenceCollection> referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceCollection getReferences(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "ReferenceCollection": "  static class ReferenceCollection implements Iterable<Reference> {\n\n    List<Reference> references = Lists.newArrayList();\n\n    @Override\n    public Iterator<Reference> iterator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void add(Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines if the variable for this reference collection is\n     * \"well-defined.\" A variable is well-defined if we can prove at\n     * compile-time that it's assigned a value before it's used.\n     *\n     * Notice that if this function returns false, this doesn't imply that the\n     * variable is used before it's assigned. It just means that we don't\n     * have enough information to make a definitive judgment.\n     */\n    protected boolean isWellDefined() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Whether the variable is escaped into an inner scope.\n     */\n    boolean isEscaped() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param index The index into the references array to look for an\n     * assigning declaration.\n     *\n     * This is either the declaration if a value is assigned (such as\n     * \"var a = 2\", \"function a()...\", \"... catch (a)...\").\n     */\n    private boolean isInitializingDeclarationAt(int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param index The index into the references array to look for an\n     * initialized assignment reference. That is, an assignment immediately\n     * follow a variable declaration that itself does not initialize the\n     * variable.\n     */\n    private boolean isInitializingAssignmentAt(int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return The reference that provides the value for the variable at the\n     * time of the first read, if known, otherwise null.\n     *\n     * This is either the variable declaration (\"var a = ...\") or first\n     * reference following the declaration if it is an assignment.\n     */\n    Reference getInitializingReference() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constants are allowed to be defined after their first use.\n     */\n    Reference getInitializingReferenceForConstants() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return The one and only assignment. Returns if there are 0 or 2+\n     *    assignments.\n     */\n    private Reference getOneAndOnlyAssignment() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether the variable is never assigned a value.\n     */\n    boolean isNeverAssigned() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean firstReferenceIsAssigningDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Reference": "  static final class Reference implements StaticReference<JSType> {\n\n    private static final Set<Integer> DECLARATION_PARENTS =\n        ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH);\n\n    private final Node nameNode;\n    private final BasicBlock basicBlock;\n    private final Scope scope;\n    private final InputId inputId;\n    private final StaticSourceFile sourceFile;\n\n    Reference(Node nameNode, NodeTraversal t,\n        BasicBlock basicBlock) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // Bleeding functions are weird, because the declaration does\n    // not appear inside their scope. So they need their own constructor.\n    static Reference newBleedingFunction(NodeTraversal t,\n        BasicBlock basicBlock, Node func) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a variable reference in a given script file name, used in tests.\n     *\n     * @return The created reference.\n     */\n    @VisibleForTesting\n    static Reference createRefForTest(CompilerInput input) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Reference(Node nameNode,\n        BasicBlock basicBlock, Scope scope, InputId inputId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Makes a copy of the current reference using a new Scope instance.\n     */\n    Reference cloneWithNewScope(Scope newScope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Var getSymbol() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public InputId getInputId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StaticSourceFile getSourceFile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isVarDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isHoistedFunction() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the variable is initialized at the declaration.\n     */\n    boolean isInitializingDeclaration() {\n         //The specific code has been omitted, but there is no error\n        }\n\n   /**\n    * @return For an assignment, variable declaration, or function declaration\n    * return the assigned value, otherwise null.\n    */\n    Node getAssignedValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    BasicBlock getBasicBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getParent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getGrandparent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static boolean isLhsOfForInExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isSimpleAssignmentToName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    boolean isLvalue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Scope getScope() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "BasicBlock": "  static final class BasicBlock {\n         //The specific code has been omitted, but there is no error\n        }"}