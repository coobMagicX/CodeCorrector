{"DisambiguateProperties": "class DisambiguateProperties<T> implements CompilerPass {\n  // To prevent the logs from filling up, we cap the number of warnings\n  // that we tell the user to fix per-property.\n  private static final int MAX_INVALDIATION_WARNINGS_PER_PROPERTY = 10;\n\n  private static final Logger logger = Logger.getLogger(\n      DisambiguateProperties.class.getName());\n\n  static class Warnings {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private final AbstractCompiler compiler;\n  private final TypeSystem<T> typeSystem;\n\n  /**\n   * Map of a type to all the related errors that invalidated the type\n   * for disambiguation. It has be Object because of the generic nature of\n   * this pass.\n   */\n  private Multimap<Object, JSError> invalidationMap;\n\n  /**\n   * In practice any large code base will have thousands and thousands of\n   * type invalidations, which makes reporting all of the errors useless.\n   * However, certain properties are worth specifically guarding because of the\n   * large amount of code that can be removed as dead code. This list contains\n   * the properties (eg: \"toString\") that we care about; if any of these\n   * properties is invalidated it causes an error.\n   */\n  private final Map<String, CheckLevel> propertiesToErrorFor;\n\n  private class Property {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Map<String, Property> properties = Maps.newHashMap();\n\n  static DisambiguateProperties<JSType> forJSTypeSystem(\n      AbstractCompiler compiler,\n      Map<String, CheckLevel> propertiesToErrorFor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(\n      AbstractCompiler compiler, TightenTypes tt,\n      Map<String, CheckLevel> propertiesToErrorFor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This constructor should only be called by one of the helper functions\n   * above for either the JSType system, or the concrete type system.\n   */\n  private DisambiguateProperties(AbstractCompiler compiler,\n      TypeSystem<T> typeSystem, Map<String, CheckLevel> propertiesToErrorFor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void recordInvalidationError(JSType t, JSError error) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Invalidates the given type, so that no properties on it will be renamed.\n   */\n  private void addInvalidatingType(JSType type, JSError error) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /** Returns the property for the given name, creating it if necessary. */\n  protected Property getProperty(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Public for testing. */\n  T getTypeWithProperty(String field, T type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Tracks the current type system scope while traversing. */\n  private abstract class AbstractScopingCallback implements ScopedCallback {\n    protected final Stack<StaticScope<T>> scopes =\n        new Stack<StaticScope<T>>();\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Returns the current scope at this point in the file. */\n    protected StaticScope<T> getScope() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Finds all properties defined in the externs file and sets them as\n   * ineligible for renaming from the type on which they are defined.\n   */\n  private class FindExternProperties extends AbstractScopingCallback {\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Traverses the tree, building a map from field names to Nodes for all\n   * fields that can be renamed.\n   */\n  private class FindRenameableProperties extends AbstractScopingCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a GETPROP node.\n     */\n    private void handleGetProp(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void printErrorLocations(List<String> errors, JSType t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a property, adding it to the list of properties to rename.\n     * @return a representative type for the property reference, which will be\n     *   the highest type on the prototype chain of the provided type.  In the\n     *   case of a union type, it will be the highest type on the prototype\n     *   chain of one of the members of the union.\n     */\n    private T processProperty(\n        NodeTraversal t, Property prop, T type, T relatedType) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /** Renames all properties with references on more than one type. */\n  void renameProperties() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Chooses a name to use for renaming in each equivalence class and maps\n   * each type in that class to it.\n   */\n  private Map<T, String> buildPropNames(UnionFind<T> types, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns a map from field name to types for which it will be renamed. */\n  Multimap<String, Collection<T>> getRenamedTypesForTesting() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Interface for providing the type information needed by this pass. */\n  private interface TypeSystem<T> {\n    // TODO(user): add a getUniqueName(T type) method that is guaranteed\n    // to be unique, performant and human-readable.\n\n    /** Returns the top-most scope used by the type system (if any). */\n    StaticScope<T> getRootScope();\n\n    /** Returns the new scope started at the given function node. */\n    StaticScope<T> getFunctionScope(Node node);\n\n    /**\n     * Returns the type of the given node.\n     * @param prop Only types with this property need to be returned. In general\n     *     with type tightening, this will require no special processing, but in\n     *     the case of an unknown JSType, we might need to add in the native\n     *     types since we don't track them, but only if they have the given\n     *     property.\n     */\n    T getType(StaticScope<T> scope, Node node, String prop);\n\n    /**\n     * Returns true if a field reference on this type will invalidate all\n     * references to that field as candidates for renaming. This is true if the\n     * type is unknown or all-inclusive, as variables with such a type could be\n     * references to any object.\n     */\n    boolean isInvalidatingType(T type);\n\n    /**\n     * Informs the given type system that a type is invalidating due to a type\n     * mismatch found during type checking.\n     */\n    void addInvalidatingType(JSType type);\n\n    /**\n     * Returns a set of types that should be skipped given the given type.\n     * This is necessary for interfaces when using JSTypes, as all super\n     * interfaces must also be skipped.\n     */\n    ImmutableSet<T> getTypesToSkipForType(T type);\n\n    /**\n     * Determines whether the given type is one whose properties should not be\n     * considered for renaming.\n     */\n    boolean isTypeToSkip(T type);\n\n    /** Remove null and undefined from the options in the given type. */\n    T restrictByNotNullOrUndefined(T type);\n\n    /**\n     * Returns the alternatives if this is a type that represents multiple\n     * types, and null if not. Union and interface types can correspond to\n     * multiple other types.\n     */\n    Iterable<T> getTypeAlternatives(T type);\n\n    /**\n     * Returns the type in the chain from the given type that contains the given\n     * field or null if it is not found anywhere.\n     */\n    T getTypeWithProperty(String field, T type);\n\n    /**\n     * Returns the type of the instance of which this is the prototype or null\n     * if this is not a function prototype.\n     */\n    T getInstanceFromPrototype(T type);\n\n    /**\n     * Records that this property could be referenced from any interface that\n     * this type, or any type in its superclass chain, implements.\n     */\n    void recordInterfaces(T type, T relatedType,\n                          DisambiguateProperties<T>.Property p);\n  }\n\n  /** Implementation of TypeSystem using JSTypes. */\n  private static class JSTypeSystem implements TypeSystem<JSType> {\n    private final Set<JSType> invalidatingTypes;\n    private JSTypeRegistry registry;\n\n    public JSTypeSystem(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void addInvalidatingType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<JSType> getRootScope() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<JSType> getFunctionScope(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JSType getType(\n        StaticScope<JSType> scope, Node node, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isInvalidatingType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isTypeToSkip(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JSType restrictByNotNullOrUndefined(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public Iterable<JSType> getTypeAlternatives(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JSType getInstanceFromPrototype(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void recordInterfaces(JSType type, JSType relatedType,\n                                 DisambiguateProperties<JSType>.Property p) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /** Implementation of TypeSystem using concrete types. */\n  private static class ConcreteTypeSystem implements TypeSystem<ConcreteType> {\n    private final TightenTypes tt;\n    private int nextUniqueId;\n    private CodingConvention codingConvention;\n    private final Set<JSType> invalidatingTypes = Sets.newHashSet();\n\n    // An array of native types that are not tracked by type tightening, and\n    // thus need to be added in if an unknown type is encountered.\n    private static final JSTypeNative [] nativeTypes = new JSTypeNative[] {\n        JSTypeNative.BOOLEAN_OBJECT_TYPE,\n        JSTypeNative.NUMBER_OBJECT_TYPE,\n        JSTypeNative.STRING_OBJECT_TYPE\n    };\n\n    public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void addInvalidatingType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<ConcreteType> getRootScope() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<ConcreteType> getFunctionScope(Node decl) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ConcreteType getType(\n        StaticScope<ConcreteType> scope, Node node, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Add concrete types for autoboxing types if necessary. The concrete type\n     * system does not track native types, like string, so add them if they are\n     * present in the JSType for the node.\n     */\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, Node node, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, JSType jsType, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isInvalidatingType(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isTypeToSkip(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ConcreteType getTypeWithProperty(String field,\n                                                      ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ConcreteType getInstanceFromPrototype(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void recordInterfaces(ConcreteType type, ConcreteType relatedType,\n        DisambiguateProperties<ConcreteType>.Property p) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "Warnings": "  static class Warnings {\n         //The specific code has been omitted, but there is no error\n        }", "Property": "  private class Property {\n         //The specific code has been omitted, but there is no error\n        }", "AbstractScopingCallback": "  private abstract class AbstractScopingCallback implements ScopedCallback {\n    protected final Stack<StaticScope<T>> scopes =\n        new Stack<StaticScope<T>>();\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Returns the current scope at this point in the file. */\n    protected StaticScope<T> getScope() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FindExternProperties": "  private class FindExternProperties extends AbstractScopingCallback {\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FindRenameableProperties": "  private class FindRenameableProperties extends AbstractScopingCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a GETPROP node.\n     */\n    private void handleGetProp(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void printErrorLocations(List<String> errors, JSType t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a property, adding it to the list of properties to rename.\n     * @return a representative type for the property reference, which will be\n     *   the highest type on the prototype chain of the provided type.  In the\n     *   case of a union type, it will be the highest type on the prototype\n     *   chain of one of the members of the union.\n     */\n    private T processProperty(\n        NodeTraversal t, Property prop, T type, T relatedType) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "JSTypeSystem": "  private static class JSTypeSystem implements TypeSystem<JSType> {\n    private final Set<JSType> invalidatingTypes;\n    private JSTypeRegistry registry;\n\n    public JSTypeSystem(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void addInvalidatingType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<JSType> getRootScope() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<JSType> getFunctionScope(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JSType getType(\n        StaticScope<JSType> scope, Node node, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isInvalidatingType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isTypeToSkip(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JSType restrictByNotNullOrUndefined(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public Iterable<JSType> getTypeAlternatives(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JSType getInstanceFromPrototype(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void recordInterfaces(JSType type, JSType relatedType,\n                                 DisambiguateProperties<JSType>.Property p) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "ConcreteTypeSystem": "  private static class ConcreteTypeSystem implements TypeSystem<ConcreteType> {\n    private final TightenTypes tt;\n    private int nextUniqueId;\n    private CodingConvention codingConvention;\n    private final Set<JSType> invalidatingTypes = Sets.newHashSet();\n\n    // An array of native types that are not tracked by type tightening, and\n    // thus need to be added in if an unknown type is encountered.\n    private static final JSTypeNative [] nativeTypes = new JSTypeNative[] {\n        JSTypeNative.BOOLEAN_OBJECT_TYPE,\n        JSTypeNative.NUMBER_OBJECT_TYPE,\n        JSTypeNative.STRING_OBJECT_TYPE\n    };\n\n    public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void addInvalidatingType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<ConcreteType> getRootScope() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public StaticScope<ConcreteType> getFunctionScope(Node decl) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ConcreteType getType(\n        StaticScope<ConcreteType> scope, Node node, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Add concrete types for autoboxing types if necessary. The concrete type\n     * system does not track native types, like string, so add them if they are\n     * present in the JSType for the node.\n     */\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, Node node, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, JSType jsType, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isInvalidatingType(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean isTypeToSkip(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ConcreteType getTypeWithProperty(String field,\n                                                      ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public ConcreteType getInstanceFromPrototype(ConcreteType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void recordInterfaces(ConcreteType type, ConcreteType relatedType,\n        DisambiguateProperties<ConcreteType>.Property p) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}