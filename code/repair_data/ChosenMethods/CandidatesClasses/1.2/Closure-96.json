{"TypeCheck": "public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n\n  //\n  // Internal errors\n  //\n  static final DiagnosticType UNEXPECTED_TOKEN = DiagnosticType.error(\n      \"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\",\n      \"Internal Error: Don't know how to handle {0}\");\n\n\n  //\n  // User errors\n  //\n  static final DiagnosticType BAD_DELETE =\n      // TODO(user): make this an error\n      DiagnosticType.warning(\n          \"JSC_BAD_DELETE_OPERAND\",\n          \"delete operator needs a reference operand\");\n\n\n  //\n  // User warnings\n  //\n\n  protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT =\n      \"overriding prototype with non-object\";\n\n  // TODO(user): make all the non private messages private once the\n  // TypedScopeCreator has been merged with the type checker.\n  static final DiagnosticType DETERMINISTIC_TEST =\n      DiagnosticType.warning(\n          \"JSC_DETERMINISTIC_TEST\",\n          \"condition always evaluates to {2}\\n\" +\n          \"left : {0}\\n\" +\n          \"right: {1}\");\n\n  static final DiagnosticType DETERMINISTIC_TEST_NO_RESULT =\n      DiagnosticType.warning(\n          \"JSC_DETERMINISTIC_TEST_NO_RESULT\",\n          \"condition always evaluates to the same value\\n\" +\n          \"left : {0}\\n\" +\n          \"right: {1}\");\n\n  static final DiagnosticType INEXISTENT_ENUM_ELEMENT =\n      DiagnosticType.warning(\n          \"JSC_INEXISTENT_ENUM_ELEMENT\",\n          \"element {0} does not exist on this enum\");\n\n  // disabled by default. This one only makes sense if you're using\n  // well-typed externs.\n  static final DiagnosticType INEXISTENT_PROPERTY =\n      DiagnosticType.disabled(\n          \"JSC_INEXISTENT_PROPERTY\",\n          \"Property {0} never defined on {1}\");\n\n  protected static final DiagnosticType NOT_A_CONSTRUCTOR =\n      DiagnosticType.warning(\n          \"JSC_NOT_A_CONSTRUCTOR\",\n          \"cannot instantiate non-constructor\");\n\n  static final DiagnosticType BIT_OPERATION =\n      DiagnosticType.warning(\n          \"JSC_BAD_TYPE_FOR_BIT_OPERATION\",\n          \"operator {0} cannot be applied to {1}\");\n\n  static final DiagnosticType NOT_CALLABLE =\n      DiagnosticType.warning(\n          \"JSC_NOT_FUNCTION_TYPE\",\n          \"{0} expressions are not callable\");\n\n  static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE =\n      DiagnosticType.warning(\n          \"JSC_CONSTRUCTOR_NOT_CALLABLE\",\n          \"Constructor {0} should be called with the \\\"new\\\" keyword\");\n\n  static final DiagnosticType FUNCTION_MASKS_VARIABLE =\n      DiagnosticType.warning(\n          \"JSC_FUNCTION_MASKS_VARIABLE\",\n          \"function {0} masks variable (IE bug)\");\n\n  static final DiagnosticType MULTIPLE_VAR_DEF = DiagnosticType.warning(\n      \"JSC_MULTIPLE_VAR_DEF\",\n      \"declaration of multiple variables with shared type information\");\n\n  static final DiagnosticType ENUM_DUP = DiagnosticType.error(\"JSC_ENUM_DUP\",\n      \"enum element {0} already defined\");\n\n  static final DiagnosticType ENUM_NOT_CONSTANT =\n      DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\",\n          \"enum key {0} must be a syntactic constant\");\n\n  static final DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION =\n      DiagnosticType.warning(\n          \"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\",\n          \"interface members can only be empty property declarations,\"\n          + \" empty functions{0}\");\n\n  static final DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY =\n      DiagnosticType.warning(\n          \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\",\n          \"interface member functions must have an empty body\");\n\n  static final DiagnosticType CONFLICTING_EXTENDED_TYPE =\n      DiagnosticType.warning(\n          \"JSC_CONFLICTING_EXTENDED_TYPE\",\n          \"{0} cannot extend this type; \" +\n          \"a constructor can only extend objects \" +\n          \"and an interface can only extend interfaces\");\n\n  static final DiagnosticType BAD_IMPLEMENTED_TYPE =\n      DiagnosticType.warning(\n          \"JSC_IMPLEMENTS_NON_INTERFACE\",\n          \"can only implement interfaces\");\n\n  static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY =\n      DiagnosticType.warning(\n          \"JSC_HIDDEN_SUPERCLASS_PROPERTY\",\n          \"property {0} already defined on superclass {1}; \" +\n          \"use @override to override it\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY =\n      DiagnosticType.warning(\n          \"JSC_HIDDEN_INTERFACE_PROPERTY\",\n          \"property {0} already defined on interface {1}; \" +\n          \"use @override to override it\");\n\n  static final DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH =\n      DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\",\n          \"mismatch of the {0} property type and the type \" +\n          \"of the property it overrides from superclass {1}\\n\" +\n          \"original: {2}\\n\" +\n          \"override: {3}\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =\n      DiagnosticType.warning(\n          \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\",\n          \"mismatch of the {0} property type and the type \" +\n          \"of the property it overrides from interface {1}\\n\" +\n          \"original: {2}\\n\" +\n          \"override: {3}\");\n\n  static final DiagnosticType UNKNOWN_OVERRIDE =\n      DiagnosticType.warning(\n          \"JSC_UNKNOWN_OVERRIDE\",\n          \"property {0} not defined on any superclass of {\n         //The specific code has been omitted, but there is no error\n        }\");\n\n  static final DiagnosticType INTERFACE_METHOD_OVERRIDE =\n      DiagnosticType.warning(\n          \"JSC_INTERFACE_METHOD_OVERRIDE\",\n          \"property {0} is already defined by the {1} extended interface\");\n\n  static final DiagnosticType UNKNOWN_EXPR_TYPE =\n      DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\",\n          \"could not determine the type of this expression\");\n\n  static final DiagnosticType UNRESOLVED_TYPE =\n      DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\",\n          \"could not resolve the name {0} to a type\");\n\n  static final DiagnosticType WRONG_ARGUMENT_COUNT =\n      DiagnosticType.warning(\n          \"JSC_WRONG_ARGUMENT_COUNT\",\n          \"Function {0}: called with {1} argument(s). \" +\n          \"Function requires at least {2} argument(s){\n         //The specific code has been omitted, but there is no error\n        }.\");\n\n  static final DiagnosticType ILLEGAL_IMPLICIT_CAST =\n      DiagnosticType.warning(\n          \"JSC_ILLEGAL_IMPLICIT_CAST\",\n          \"Illegal annotation on {0}. @implicitCast may only be used in \" +\n          \"externs.\");\n\n  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n      DETERMINISTIC_TEST,\n      DETERMINISTIC_TEST_NO_RESULT,\n      INEXISTENT_ENUM_ELEMENT,\n      INEXISTENT_PROPERTY,\n      NOT_A_CONSTRUCTOR,\n      BIT_OPERATION,\n      NOT_CALLABLE,\n      CONSTRUCTOR_NOT_CALLABLE,\n      FUNCTION_MASKS_VARIABLE,\n      MULTIPLE_VAR_DEF,\n      ENUM_DUP,\n      ENUM_NOT_CONSTANT,\n      INVALID_INTERFACE_MEMBER_DECLARATION,\n      INTERFACE_FUNCTION_NOT_EMPTY,\n      CONFLICTING_EXTENDED_TYPE,\n      BAD_IMPLEMENTED_TYPE,\n      HIDDEN_SUPERCLASS_PROPERTY,\n      HIDDEN_INTERFACE_PROPERTY,\n      HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n      HIDDEN_INTERFACE_PROPERTY_MISMATCH,\n      UNKNOWN_OVERRIDE,\n      INTERFACE_METHOD_OVERRIDE,\n      UNKNOWN_EXPR_TYPE,\n      UNRESOLVED_TYPE,\n      WRONG_ARGUMENT_COUNT,\n      ILLEGAL_IMPLICIT_CAST);\n\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n\n  private final ReverseAbstractInterpreter reverseInterpreter;\n\n  private final JSTypeRegistry typeRegistry;\n  private Scope topScope;\n\n  private ScopeCreator scopeCreator;\n\n  private final CheckLevel reportMissingOverride;\n  private final CheckLevel reportUnknownTypes;\n\n  // This may be expensive, so don't emit these warnings if they're\n  // explicitly turned off.\n  private boolean reportMissingProperties = true;\n\n  private InferJSDocInfo inferJSDocInfo = null;\n\n  // These fields are used to calculate the percentage of expressions typed.\n  private int typedCount = 0;\n  private int nullCount = 0;\n  private int unknownCount = 0;\n  private boolean inExterns;\n\n  // A state boolean to see we are currently in @notypecheck section of the\n  // code.\n  private int noTypeCheckSection = 0;\n\n  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      ScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Turn on the missing property check. Returns this for easy chaining. */\n  TypeCheck reportMissingProperties(boolean report) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Main entry point for this phase of processing. This follows the pattern for\n   * JSCompiler phases.\n   *\n   * @param externsRoot The root of the externs parse tree.\n   * @param jsRoot The root of the input parse tree to be checked.\n   */\n  public void process(Node externsRoot, Node jsRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  public void check(Node node, boolean externs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n      String... arguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This is the meat of the type checking.  It is basically one big switch,\n   * with each case representing one type of parse tree node.  The individual\n   * cases are usually pretty straightforward.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   */\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Counts the given node in the typed statistics.\n   * @param n a node that should be typed\n   */\n  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits an assignment <code>lvalue = rvalue</code>. If the\n   * <code>lvalue</code> is a prototype modification, we change the schema\n   * of the object type it is referring to.\n   * @param t the traversal\n   * @param assign the assign node\n   * (<code>assign.getType() == Token.ASSIGN</code> is an implicit invariant)\n   */\n  private void visitAssign(NodeTraversal t, Node assign) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if any type in the chain has an implictCast annotation for\n   * the given property.\n   */\n  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given a constructor type and a property name, check that the property has\n   * the JSDoc annotation @override iff the property is declared on a\n   * superclass. Several checks regarding inheritance correctness are also\n   * performed.\n   */\n  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits an ASSIGN node for cases such as\n   * <pre>\n   * interface.property2.property = ...;\n   * </pre>\n   */\n  private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object,\n      String property, Node lvalue, Node rvalue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits an ASSIGN node for cases such as\n   * <pre>\n   * object.property = ...;\n   * </pre>\n   * that have an {@code @type} annotation.\n   */\n  private void visitAnnotatedAssignGetprop(NodeTraversal t,\n      Node assign, JSType type, Node object, String property, Node rvalue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a NAME node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of the node n.\n   * @return whether the node is typeable or not\n   */\n  boolean visitName(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a GETPROP node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   * @param parent The parent of <code>n</code>\n   */\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Make sure that the access of this property is ok.\n   */\n  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether this node is testing for the existence of a property.\n   * If true, we will not emit warnings about a missing property.\n   *\n   * @param getProp The GETPROP being tested.\n   */\n  private boolean isPropertyTest(Node getProp) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a GETELEM node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitGetElem(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a VAR node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitVar(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a {@link Token#FUNCTION} node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitFunction(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a CALL node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitCall(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits the parameters of a CALL or a NEW node.\n   */\n  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This function unifies the type checking involved in the core binary\n   * operators and the corresponding assignment operators.  The representation\n   * used internally is such that common code can handle both kinds of\n   * operators easily.\n   *\n   * @param op The operator.\n   * @param t The traversal object, needed to report errors.\n   * @param n The node being checked.\n   */\n  private void visitBinaryOperator(int op, NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * <p>Checks the initializer of an enum. An enum can be initialized with an\n   * object literal whose values must be subtypes of the declared enum element\n   * type, or by copying another enum.</p>\n   *\n   * <p>In the case of an enum copy, we verify that the enum element type of the\n   * enum used for initialization is a subtype of the enum element type of\n   * the enum the value is being copied in.</p>\n   *\n   * <p>Examples:</p>\n   * <pre>var myEnum = {FOO: ..., BAR: ...};\n   * var myEnum = myOtherEnum;</pre>\n   *\n   * @param value the value used for initialization of the enum\n   * @param primitiveType The type of each element of the enum.\n   */\n  private void checkEnumInitializer(\n      NodeTraversal t, Node value, JSType primitiveType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * This predicate is used to determine if the node represents an expression\n   * that is a Reference according to JavaScript definitions.\n   *\n   * @param n The node being checked.\n   * @return true if the sub-tree n is a reference, false otherwise.\n   */\n  private static boolean isReference(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the type of the node or {@code null} if the node's type is not a\n   * function.\n   */\n  private FunctionType getFunctionType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // TODO(nicksantos): TypeCheck should never be attaching types to nodes.\n  // All types should be attached by TypeInference. This is not true today\n  // for legacy reasons. There are a number of places where TypeInference\n  // doesn't attach a type, as a signal to TypeCheck that it needs to check\n  // that node's type.\n\n  /**\n   * Ensure that the given node has a type. If it does not have one,\n   * attach the UNKNOWN_TYPE.\n   */\n  private void ensureTyped(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Enforces type casts, and ensures the node is typed.\n   *\n   * A cast in the way that we use it in JSDoc annotations never\n   * alters the generated code and therefore never can induce any runtime\n   * operation. What this means is that a 'cast' is really just a compile\n   * time constraint on the underlying value. In the future, we may add\n   * support for run-time casts for compiled tests.\n   *\n   * To ensure some shred of sanity, we enforce the notion that the\n   * type you are casting to may only meaningfully be a narrower type\n   * than the underlying declared type. We also invalidate optimizations\n   * on bad type casts.\n   *\n   * @param t The traversal object needed to report errors.\n   * @param n The node getting a type assigned to it.\n   * @param type The type to be assigned.\n   */\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the percentage of nodes typed by the type checker.\n   * @return a number between 0.0 and 100.0\n   */\n  double getTypedPercent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}