{"CheckAccessControls": "class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n\n  static final DiagnosticType DEPRECATED_NAME = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_VAR\",\n      \"Variable {0} has been deprecated.\");\n\n  static final DiagnosticType DEPRECATED_NAME_REASON = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_VAR_REASON\",\n      \"Variable {0} has been deprecated: {1}\");\n\n  static final DiagnosticType DEPRECATED_PROP = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_PROP\",\n      \"Property {0} of type {1} has been deprecated.\");\n\n  static final DiagnosticType DEPRECATED_PROP_REASON = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_PROP_REASON\",\n      \"Property {0} of type {1} has been deprecated: {2}\");\n\n  static final DiagnosticType DEPRECATED_CLASS = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_CLASS\",\n      \"Class {0} has been deprecated.\");\n\n  static final DiagnosticType DEPRECATED_CLASS_REASON = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_CLASS_REASON\",\n      \"Class {0} has been deprecated: {1}\");\n\n  static final DiagnosticType BAD_PRIVATE_GLOBAL_ACCESS =\n      DiagnosticType.disabled(\n          \"JSC_BAD_PRIVATE_GLOBAL_ACCESS\",\n          \"Access to private variable {0} not allowed outside file {1}.\");\n\n  static final DiagnosticType BAD_PRIVATE_PROPERTY_ACCESS =\n      DiagnosticType.disabled(\n          \"JSC_BAD_PRIVATE_PROPERTY_ACCESS\",\n          \"Access to private property {0} of {1} not allowed here.\");\n\n  static final DiagnosticType BAD_PROTECTED_PROPERTY_ACCESS =\n      DiagnosticType.disabled(\n          \"JSC_BAD_PROTECTED_PROPERTY_ACCESS\",\n          \"Access to protected property {0} of {1} not allowed here.\");\n\n  static final DiagnosticType PRIVATE_OVERRIDE =\n      DiagnosticType.disabled(\n          \"JSC_PRIVATE_OVERRIDE\",\n          \"Overriding private property of {0}.\");\n\n  static final DiagnosticType VISIBILITY_MISMATCH =\n      DiagnosticType.disabled(\n          \"JSC_VISIBILITY_MISMATCH\",\n          \"Overriding {0} property of {1} with {2} property.\");\n\n  static final DiagnosticType CONST_PROPERTY_REASSIGNED_VALUE =\n      DiagnosticType.warning(\n        \"JSC_CONSTANT_PROPERTY_REASSIGNED_VALUE\",\n        \"constant property {0} assigned a value more than once\");\n\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n\n  // State about the current traversal.\n  private int deprecatedDepth = 0;\n  private int methodDepth = 0;\n  private JSType currentClass = null;\n\n  private final Multimap<String, String> initializedConstantProperties;\n\n  CheckAccessControls(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void hotSwapScript(Node scriptRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the type of the class that \"owns\" a method, or null if\n   * we know that its un-owned.\n   */\n  private JSType getClassOfMethod(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Normalize the type of a constructor, its instance, and its prototype\n   * all down to the same type (the instance type).\n   */\n  private JSType normalizeClassType(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks the given NEW node to ensure that access restrictions are obeyed.\n   */\n  private void checkConstructorDeprecation(NodeTraversal t, Node n,\n      Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks the given NAME node to ensure that access restrictions are obeyed.\n   */\n  private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks the given GETPROP node to ensure that access restrictions are\n   * obeyed.\n   */\n  private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given name is visible in the current context.\n   * @param t The current traversal.\n   * @param name The name node.\n   */\n  private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given property with @const tag got reassigned\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkConstantProperty(NodeTraversal t,\n      Node getprop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether the given access of a private constructor is legal.\n   *\n   * For example,\n   * new PrivateCtor_(); // not legal\n   * PrivateCtor_.newInstance(); // legal\n   * x instanceof PrivateCtor_ // legal\n   *\n   * This is a weird special case, because our visibility system is inherited\n   * from Java, and JavaScript has no distinction between classes and\n   * constructors like Java does.\n   *\n   * We may want to revisit this if we decide to make the restrictions tighter.\n   */\n  private static boolean isValidPrivateConstructorAccess(Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a deprecation warning should be emitted.\n   * @param t The current traversal.\n   * @param n The node which we are checking.\n   * @param parent The parent of the node which we are checking.\n   */\n  private boolean shouldEmitDeprecationWarning(\n      NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns whether it's currently ok to access deprecated names and\n   * properties.\n   *\n   * There are 3 exceptions when we're allowed to use a deprecated\n   * type or property:\n   * 1) When we're in a deprecated function.\n   * 2) When we're in a deprecated class.\n   * 3) When we're in a static method of a deprecated class.\n   */\n  private boolean canAccessDeprecatedTypes(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.\n   */\n  private static boolean isDeprecatedFunction(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the deprecation reason for the type if it is marked\n   * as being deprecated. Returns empty string if the type is deprecated\n   * but no reason was given. Returns null if the type is not deprecated.\n   */\n  private static String getTypeDeprecationInfo(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the deprecation reason for the property if it is marked\n   * as being deprecated. Returns empty string if the property is deprecated\n   * but no reason was given. Returns null if the property is not deprecated.\n   */\n  private static String getPropertyDeprecationInfo(ObjectType type,\n                                                   String prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Dereference a type, autoboxing it and filtering out null.\n   */\n  private static JSType dereference(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}