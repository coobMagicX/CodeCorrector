{"NormalDistributionImpl": "public class NormalDistributionImpl extends AbstractContinuousDistribution \n        implements NormalDistribution, Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = 8589540077390120676L;\n\n    /** The mean of this distribution. */\n    private double mean = 0;\n    \n    /** The standard deviation of this distribution. */\n    private double standardDeviation = 1;\n    \n    /**\n     * Create a normal distribution using the given mean and standard deviation.\n     * @param mean mean for this distribution\n     * @param sd standard deviation for this distribution\n     */\n    public NormalDistributionImpl(double mean, double sd){\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Creates normal distribution with the mean equal to zero and standard\n     * deviation equal to one. \n     */\n    public NormalDistributionImpl(){\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Access the mean.\n     * @return mean for this distribution\n     */ \n    public double getMean() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Modify the mean.\n     * @param mean for this distribution\n     */\n    public void setMean(double mean) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the standard deviation.\n     * @return standard deviation for this distribution\n     */\n    public double getStandardDeviation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Modify the standard deviation.\n     * @param sd standard deviation for this distribution\n     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n     */\n    public void setStandardDeviation(double sd) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n     * @param x the value at which the CDF is evaluated.\n     * @return CDF evaluted at <code>x</code>. \n     * @throws MathException if the algorithm fails to converge; unless\n     * x is more than 20 standard deviations from the mean, in which case the\n     * convergence exception is caught and 0 or 1 is returned.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n            return 0.5 * (1.0 + Erf.erf((x - mean) /\n                    (standardDeviation * Math.sqrt(2.0))));\n    }\n    \n    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     * <p>\n     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p) \n    throws MathException {\n        if (p == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (p == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n    \n    /**\n     * Access the domain value lower bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value lower bound, i.e.\n     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n     */\n    protected double getDomainLowerBound(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the domain value upper bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value upper bound, i.e.\n     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n     */\n    protected double getDomainUpperBound(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}