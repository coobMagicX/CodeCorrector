{"TypedScopeCreator": "final class TypedScopeCreator implements ScopeCreator {\n  /**\n   * A suffix for naming delegate proxies differently from their base.\n   */\n  static final String DELEGATE_PROXY_SUFFIX =\n      ObjectType.createDelegateSuffix(\"Proxy\");\n\n  static final DiagnosticType MALFORMED_TYPEDEF =\n      DiagnosticType.warning(\n          \"JSC_MALFORMED_TYPEDEF\",\n          \"Typedef for {0} does not have any type information\");\n\n  static final DiagnosticType ENUM_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_ENUM_INITIALIZER_NOT_ENUM\",\n          \"enum initializer must be an object literal or an enum\");\n\n  static final DiagnosticType CTOR_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_CTOR_INITIALIZER_NOT_CTOR\",\n          \"Constructor {0} must be initialized at declaration\");\n\n  static final DiagnosticType IFACE_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_IFACE_INITIALIZER_NOT_IFACE\",\n          \"Interface {0} must be initialized at declaration\");\n\n  static final DiagnosticType CONSTRUCTOR_EXPECTED =\n      DiagnosticType.warning(\n          \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\",\n          \"Constructor expected as first argument\");\n\n  static final DiagnosticType UNKNOWN_LENDS =\n      DiagnosticType.warning(\n          \"JSC_UNKNOWN_LENDS\",\n          \"Variable {0} not declared before @lends annotation.\");\n\n  static final DiagnosticType LENDS_ON_NON_OBJECT =\n      DiagnosticType.warning(\n          \"JSC_LENDS_ON_NON_OBJECT\",\n          \"May only lend properties to object types. {0} has type {1}.\");\n\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n  private final Map<String, String> delegateCallingConventions =\n      Maps.newHashMap();\n\n  // Simple properties inferred about functions.\n  private final Map<Node, AstFunctionContents> functionAnalysisResults =\n      Maps.newHashMap();\n\n  /**\n   * Defer attachment of types to nodes until all type names\n   * have been resolved. Then, we can resolve the type and attach it.\n   */\n  private class DeferredSetType {\n         //The specific code has been omitted, but there is no error\n        }\n\n  TypedScopeCreator(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  @Override\n  public Scope createScope(Node root, Scope parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Patches a given global scope by removing variables previously declared in\n   * a script and re-traversing a new version of that script.\n   *\n   * @param globalScope The global scope generated by {@code createScope}.\n   * @param scriptRoot The script that is modified.\n   */\n  void patchGlobalScope(Scope globalScope, Node scriptRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Create the outermost scope. This scope contains native binding such as\n   * {@code Object}, {@code Date}, etc.\n   */\n  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void declareNativeType(Scope scope, String name, JSType t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static class DiscoverEnumsAndTypedefs\n      extends AbstractShallowStatementCallback {\n    private final JSTypeRegistry registry;\n\n    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private JSType getNativeType(JSTypeNative nativeType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private abstract class AbstractScopeBuilder\n      implements NodeTraversal.Callback {\n\n    /**\n     * The scope that we're builidng.\n     */\n    final Scope scope;\n\n    private final List<DeferredSetType> deferredSetTypes =\n        Lists.newArrayList();\n\n    /**\n     * Functions that we found in the global scope and not in externs.\n     */\n    private final List<Node> nonExternFunctions = Lists.newArrayList();\n\n    /**\n     * Type-less stubs.\n     *\n     * If at the end of traversal, we still don't have types for these\n     * stubs, then we should declare UNKNOWN types.\n     */\n    private final List<StubDeclaration> stubDeclarations =\n        Lists.newArrayList();\n\n    /**\n     * The current source file that we're in.\n     */\n    private String sourceName = null;\n\n    /**\n     * The InputId of the current node.\n     */\n    private InputId inputId;\n\n    private AbstractScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void setDeferredType(Node node, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void resolveTypes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n,\n        Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void attachLiteralTypes(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Process an object literal and all the types on it.\n     * @param objLit The OBJECTLIT node.\n     * @param objLitType The type of the OBJECTLIT node. This might be a named\n     *     type, because of the lends annotation.\n     * @param declareOnOwner If true, declare properties on the objLitType as\n     *     well. If false, the caller should take crae of this.\n     */\n    void processObjectLitProperties(\n        NodeTraversal t, Node objLit, ObjectType objLitType,\n        boolean declareOnOwner) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     */\n    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Asserts that it's ok to define this node's name.\n     * The node should have a source name and be of the specified type.\n     */\n    void assertDefinitionNode(Node n, int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a catch parameter.\n     */\n    void defineCatch(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a VAR initialization.\n     */\n    void defineVar(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a function literal.\n     */\n    void defineFunctionLiteral(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param parent {@code var}'s parent.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     */\n    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If a variable is assigned a function literal in the global scope,\n     * make that a declared type (even if there's no doc info).\n     * There's only one exception to this rule:\n     * if the return type is inferred, and we're in a local\n     * scope, we should assume the whole function is inferred.\n     */\n    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new function type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - A function literal that needs a type attached to it.\n     * - An assignment expression with function-type info in the jsdoc.\n     *\n     * All parameters are optional, and we will do the best we can to create\n     * a function type.\n     *\n     * This function will always create a function type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The function node.\n     * @param name the function's name\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */\n    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the function that's being overridden on this type, if any.\n     */\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new enum type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - An object literal that needs an enum type attached to it.\n     * - An assignment expression with an enum tag in the jsdoc.\n     *\n     * This function will always create an enum type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The node of the enum.\n     * @param name The enum's name\n     * @param info The {@link JSDocInfo} attached to the enum definition.\n     * @param lValueNode The node where this function is being\n     *     assigned.\n     */\n    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n        JSDocInfo info, Node lValueNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     */\n    private void defineSlot(Node name, Node parent, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n    /**\n     * Defines a symbol in the current scope.\n     *\n     * @param n the defining NAME or GETPROP or object literal key node.\n     * @param parent the {@code n}'s parent.\n     * @param variableName The name that this should be known by.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     * @param inferred Whether the type is inferred or declared.\n     */\n    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if the given node is a property of a name in the global scope.\n     */\n    private boolean isQnameRootedInGlobalScope(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the scope for the name of the given node.\n     */\n    private Scope getQnameRootScope(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private FunctionType getFunctionType(@Nullable Var v) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for calls that set a delegate method's calling convention.\n     */\n    private void checkForCallingConventionDefiningCalls(\n        Node n, Map<String, String> delegateCallingConventions) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     */\n    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Apply special properties that only apply to delegates.\n     */\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     */\n    private ObjectType getObjectSlot(String slotName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Resolve any stub delcarations to unknown types if we could not\n     * find types for them during traversal.\n     */\n    void resolveStubDeclarations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Collects all declared properties in a function, and\n     * resolves them relative to the global scope.\n     */\n    private final class CollectProperties\n        extends AbstractShallowStatementCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n    } // end CollectProperties\n  }\n\n  /**\n   * A stub declaration without any type information.\n   */\n  private static final class StubDeclaration {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A shallow traversal of the global scope to build up all classes,\n   * functions, and methods.\n   */\n  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n\n    private GlobalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     */\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n  } // end GlobalScopeBuilder\n\n  /**\n   * A shallow traversal of a local scope to find all arguments and\n   * local variables.\n   */\n  private final class LocalScopeBuilder extends AbstractScopeBuilder {\n    /**\n     * @param scope The scope that we're builidng.\n     */\n    private LocalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Traverse the scope root and build it.\n     */\n    void build() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Handle bleeding functions and function parameters. */\n    private void handleFunctionInputs(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n         //The specific code has been omitted, but there is no error\n        } // end declareArguments\n  } // end LocalScopeBuilder\n\n  /**\n   * Does a first-order function analysis that just looks at simple things\n   * like what variables are escaped, and whether 'this' is used.\n   */\n  private static class FirstOrderFunctionAnalyzer\n      extends AbstractScopedCallback implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final Map<Node, AstFunctionContents> data;\n\n    FirstOrderFunctionAnalyzer(\n        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "DeferredSetType": "  private class DeferredSetType {\n         //The specific code has been omitted, but there is no error\n        }", "DiscoverEnumsAndTypedefs": "  private static class DiscoverEnumsAndTypedefs\n      extends AbstractShallowStatementCallback {\n    private final JSTypeRegistry registry;\n\n    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "AbstractScopeBuilder": "  private abstract class AbstractScopeBuilder\n      implements NodeTraversal.Callback {\n\n    /**\n     * The scope that we're builidng.\n     */\n    final Scope scope;\n\n    private final List<DeferredSetType> deferredSetTypes =\n        Lists.newArrayList();\n\n    /**\n     * Functions that we found in the global scope and not in externs.\n     */\n    private final List<Node> nonExternFunctions = Lists.newArrayList();\n\n    /**\n     * Type-less stubs.\n     *\n     * If at the end of traversal, we still don't have types for these\n     * stubs, then we should declare UNKNOWN types.\n     */\n    private final List<StubDeclaration> stubDeclarations =\n        Lists.newArrayList();\n\n    /**\n     * The current source file that we're in.\n     */\n    private String sourceName = null;\n\n    /**\n     * The InputId of the current node.\n     */\n    private InputId inputId;\n\n    private AbstractScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void setDeferredType(Node node, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void resolveTypes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n,\n        Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void attachLiteralTypes(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Process an object literal and all the types on it.\n     * @param objLit The OBJECTLIT node.\n     * @param objLitType The type of the OBJECTLIT node. This might be a named\n     *     type, because of the lends annotation.\n     * @param declareOnOwner If true, declare properties on the objLitType as\n     *     well. If false, the caller should take crae of this.\n     */\n    void processObjectLitProperties(\n        NodeTraversal t, Node objLit, ObjectType objLitType,\n        boolean declareOnOwner) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     */\n    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Asserts that it's ok to define this node's name.\n     * The node should have a source name and be of the specified type.\n     */\n    void assertDefinitionNode(Node n, int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a catch parameter.\n     */\n    void defineCatch(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a VAR initialization.\n     */\n    void defineVar(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a function literal.\n     */\n    void defineFunctionLiteral(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param parent {@code var}'s parent.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     */\n    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If a variable is assigned a function literal in the global scope,\n     * make that a declared type (even if there's no doc info).\n     * There's only one exception to this rule:\n     * if the return type is inferred, and we're in a local\n     * scope, we should assume the whole function is inferred.\n     */\n    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new function type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - A function literal that needs a type attached to it.\n     * - An assignment expression with function-type info in the jsdoc.\n     *\n     * All parameters are optional, and we will do the best we can to create\n     * a function type.\n     *\n     * This function will always create a function type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The function node.\n     * @param name the function's name\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */\n    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the function that's being overridden on this type, if any.\n     */\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new enum type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - An object literal that needs an enum type attached to it.\n     * - An assignment expression with an enum tag in the jsdoc.\n     *\n     * This function will always create an enum type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The node of the enum.\n     * @param name The enum's name\n     * @param info The {@link JSDocInfo} attached to the enum definition.\n     * @param lValueNode The node where this function is being\n     *     assigned.\n     */\n    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n        JSDocInfo info, Node lValueNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     */\n    private void defineSlot(Node name, Node parent, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n    /**\n     * Defines a symbol in the current scope.\n     *\n     * @param n the defining NAME or GETPROP or object literal key node.\n     * @param parent the {@code n}'s parent.\n     * @param variableName The name that this should be known by.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     * @param inferred Whether the type is inferred or declared.\n     */\n    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if the given node is a property of a name in the global scope.\n     */\n    private boolean isQnameRootedInGlobalScope(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the scope for the name of the given node.\n     */\n    private Scope getQnameRootScope(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private FunctionType getFunctionType(@Nullable Var v) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for calls that set a delegate method's calling convention.\n     */\n    private void checkForCallingConventionDefiningCalls(\n        Node n, Map<String, String> delegateCallingConventions) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     */\n    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Apply special properties that only apply to delegates.\n     */\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     */\n    private ObjectType getObjectSlot(String slotName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Resolve any stub delcarations to unknown types if we could not\n     * find types for them during traversal.\n     */\n    void resolveStubDeclarations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Collects all declared properties in a function, and\n     * resolves them relative to the global scope.\n     */\n    private final class CollectProperties\n        extends AbstractShallowStatementCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n    } // end CollectProperties\n  }", "CollectProperties": "    private final class CollectProperties\n        extends AbstractShallowStatementCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n    } // end CollectProperties", "StubDeclaration": "  private static final class StubDeclaration {\n         //The specific code has been omitted, but there is no error\n        }", "GlobalScopeBuilder": "  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n\n    private GlobalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     */\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n  } // end GlobalScopeBuilder", "LocalScopeBuilder": "  private final class LocalScopeBuilder extends AbstractScopeBuilder {\n    /**\n     * @param scope The scope that we're builidng.\n     */\n    private LocalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Traverse the scope root and build it.\n     */\n    void build() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Handle bleeding functions and function parameters. */\n    private void handleFunctionInputs(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n         //The specific code has been omitted, but there is no error\n        } // end declareArguments\n  } // end LocalScopeBuilder", "FirstOrderFunctionAnalyzer": "  private static class FirstOrderFunctionAnalyzer\n      extends AbstractScopedCallback implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final Map<Node, AstFunctionContents> data;\n\n    FirstOrderFunctionAnalyzer(\n        AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}