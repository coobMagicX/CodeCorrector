{"LevenbergMarquardtOptimizer": "public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n\n    /** Number of solved point. */\n    private int solvedCols;\n\n    /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n    private double[] diagR;\n\n    /** Norms of the columns of the jacobian matrix. */\n    private double[] jacNorm;\n\n    /** Coefficients of the Householder transforms vectors. */\n    private double[] beta;\n\n    /** Columns permutation array. */\n    private int[] permutation;\n\n    /** Rank of the jacobian matrix. */\n    private int rank;\n\n    /** Levenberg-Marquardt parameter. */\n    private double lmPar;\n\n    /** Parameters evolution direction associated with lmPar. */\n    private double[] lmDir;\n\n    /** Positive input variable used in determining the initial step bound. */\n    private double initialStepBoundFactor;\n\n    /** Desired relative error in the sum of squares. */\n    private double costRelativeTolerance;\n\n    /**  Desired relative error in the approximate solution parameters. */\n    private double parRelativeTolerance;\n\n    /** Desired max cosine on the orthogonality between the function vector\n     * and the columns of the jacobian. */\n    private double orthoTolerance;\n\n    /** Threshold for QR ranking. */\n    private double qrRankingThreshold;\n\n    /**\n     * Build an optimizer for least squares problems.\n     * <p>The default values for the algorithm settings are:\n     *   <ul>\n     *    <li>{@link #setConvergenceChecker(VectorialConvergenceChecker) vectorial convergence checker}: null</li>\n     *    <li>{@link #setInitialStepBoundFactor(double) initial step bound factor}: 100.0</li>\n     *    <li>{@link #setMaxIterations(int) maximal iterations}: 1000</li>\n     *    <li>{@link #setCostRelativeTolerance(double) cost relative tolerance}: 1.0e-10</li>\n     *    <li>{@link #setParRelativeTolerance(double) parameters relative tolerance}: 1.0e-10</li>\n     *    <li>{@link #setOrthoTolerance(double) orthogonality tolerance}: 1.0e-10</li>\n     *    <li>{@link #setQRRankingThreshold(double) QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n     *   </ul>\n     * </p>\n     * <p>These default values may be overridden after construction. If the {@link\n     * #setConvergenceChecker vectorial convergence checker} is set to a non-null value, it\n     * will be used instead of the {@link #setCostRelativeTolerance cost relative tolerance}\n     * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n     */\n    public LevenbergMarquardtOptimizer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the positive input variable used in determining the initial step bound.\n     * This bound is set to the product of initialStepBoundFactor and the euclidean\n     * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n     * cases factor should lie in the interval (0.1, 100.0). 100.0 is a generally\n     * recommended value.\n     *\n     * @param initialStepBoundFactor initial step bound factor\n     */\n    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the desired relative error in the sum of squares.\n     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n     * convergence checker} is set to null.</p>\n     * @param costRelativeTolerance desired relative error in the sum of squares\n     */\n    public void setCostRelativeTolerance(double costRelativeTolerance) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the desired relative error in the approximate solution parameters.\n     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n     * convergence checker} is set to null.</p>\n     * @param parRelativeTolerance desired relative error\n     * in the approximate solution parameters\n     */\n    public void setParRelativeTolerance(double parRelativeTolerance) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the desired max cosine on the orthogonality.\n     * <p>This setting is always used, regardless of the {@link #setConvergenceChecker\n     * vectorial convergence checker} being null or non-null.</p>\n     * @param orthoTolerance desired max cosine on the orthogonality\n     * between the function vector and the columns of the jacobian\n     */\n    public void setOrthoTolerance(double orthoTolerance) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the desired threshold for QR ranking.\n     * <p>\n     * If the squared norm of a column vector is smaller or equal to this threshold\n     * during QR decomposition, it is considered to be a zero vector and hence the\n     * rank of the matrix is reduced.\n     * </p>\n     * @param threshold threshold for QR ranking\n     */\n    public void setQRRankingThreshold(final double threshold) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n    /**\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     */\n    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Solve a*x = b and d*x = 0 in the least squares sense.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n     * routine.</p>\n     * <p>This method sets the lmDir and lmDiag attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param diag diagonal matrix\n     * @param lmDiag diagonal elements associated with lmDir\n     * @param work work array\n     */\n    private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Decompose a matrix A as A.P = Q.R using Householder transforms.\n     * <p>As suggested in the P. Lascaux and R. Theodor book\n     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n     * the Householder transforms with u<sub>k</sub> unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n     * </pre>\n     * we use <sub>k</sub> non-unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n     * </pre>\n     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n     * them from the v<sub>k</sub> vectors would be costly.</p>\n     * <p>This decomposition handles rank deficient cases since the tranformations\n     * are performed in non-increasing columns norms order thanks to columns\n     * pivoting. The diagonal elements of the R matrix are therefore also in\n     * non-increasing absolute values order.</p>\n     * @exception OptimizationException if the decomposition cannot be performed\n     */\n    private void qrDecomposition() throws OptimizationException {\n\n        // initializations\n        for (int k = 0; k < cols; ++k) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // transform the matrix column after column\n        for (int k = 0; k < cols; ++k) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        rank = solvedCols;\n\n    }\n\n    /**\n     * Compute the product Qt.y for some Q.R. decomposition.\n     *\n     * @param y vector to multiply (will be overwritten with the result)\n     */\n    private void qTy(double[] y) {\n         //The specific code has been omitted, but there is no error\n        }\n\n}"}