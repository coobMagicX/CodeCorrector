{"NameAnalyzer": "final class NameAnalyzer implements CompilerPass {\n\n  /** Reference to the JS compiler */\n  private final AbstractCompiler compiler;\n\n  /** Map of all JS names found */\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n\n  /** Reference dependency graph */\n  private DiGraph<JsName, RefType> referenceGraph =\n      LinkedDirectedGraph.createWithoutAnnotations();\n\n  /**\n   * Map of name scopes - all children of the Node key have a dependency on the\n   * name value.\n   *\n   * If scopes.get(node).equals(name) && node2 is a child of node, then node2\n   * will not get executed unless name is referenced via a get operation\n   */\n  private final ListMultimap<Node, NameInformation> scopes =\n      LinkedListMultimap.create();\n\n  /** Used to parse prototype names */\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n\n  private static final int PROTOTYPE_SUBSTRING_LEN =\n      PROTOTYPE_SUBSTRING.length();\n\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n\n  /** Window root */\n  private static final String WINDOW = \"window\";\n\n  /** Function class name */\n  private static final String FUNCTION = \"Function\";\n\n  /** All of these refer to global scope. These can be moved to config */\n  static final Set<String> DEFAULT_GLOBAL_NAMES = ImmutableSet.of(\n      \"window\", \"goog.global\");\n\n  /** Whether to remove unreferenced variables in main pass */\n  private final boolean removeUnreferenced;\n\n  /** Names that refer to the global scope */\n  private final Set<String> globalNames;\n\n  /** Ast change helper */\n  private final AstChangeProxy changeProxy;\n\n  /** Names that are externally defined */\n  private final Set<String> externalNames = Sets.newHashSet();\n\n  /** Name declarations or assignments, in post-order traversal order */\n  private final List<RefNode> refNodes = Lists.newArrayList();\n\n  /**\n   * When multiple names in the global scope point to the same object, we\n   * call them aliases. Store a map from each alias name to the alias set.\n   */\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n\n  /**\n   * All the aliases in a program form a graph, where each global name is\n   * a node in the graph, and two names are connected if one directly aliases\n   * the other.\n   *\n   * An {@code AliasSet} represents a connected component in that graph. We do\n   * not explicitly track the graph--we just track the connected components.\n   */\n  private static class AliasSet {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Relationship between the two names.\n   * Currently only two different reference types exists:\n   * goog.inherits class relations and all other references.\n   */\n  private static enum RefType {\n    REGULAR,\n    INHERITANCE,\n  }\n\n  /**\n   * Callback that propagates reference information.\n   */\n  private static class ReferencePropagationCallback\n      implements EdgeCallback<JsName, RefType> {\n    @Override\n    public boolean traverseEdge(JsName from,\n                                RefType callSite,\n                                JsName to) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Class to hold information that can be determined from a node tree about a\n   * given name\n   */\n  private static class NameInformation {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Struct to hold information about a fully qualified JS name\n   */\n  private static class JsName implements Comparable<JsName> {\n    /** Fully qualified name */\n    String name;\n\n    /** Name of prototype functions attached to this name */\n    List<String> prototypeNames = Lists.newArrayList();\n\n    /** Whether this is an externally defined name */\n    boolean externallyDefined = false;\n\n    /** Whether this node is referenced */\n    boolean referenced = false;\n\n    /** Whether the name has descendants that are written to. */\n    boolean hasWrittenDescendants = false;\n\n    /** Whether the name is used in a instanceof check */\n    boolean hasInstanceOfReference = false;\n\n    /**\n     * Output the node as a string\n     *\n     * @return Node as a string\n     */\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int compareTo(JsName rhs) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Interface to get information about and remove unreferenced names.\n   */\n  interface RefNode {\n    JsName name();\n    void remove();\n  }\n\n  /**\n   * Class for nodes that reference a fully-qualified JS name. Fully qualified\n   * names are of form A or A.B (A.B.C, etc.). References can get the value or\n   * set the value of the JS name.\n   */\n  private class JsNameRefNode implements RefNode {\n    /** JsName node for this reference */\n    JsName name;\n\n    /**\n     * Top GETPROP or NAME or STRING [objlit key] node defining the name of\n     * this node\n     */\n    @SuppressWarnings(\"unused\")\n    Node node;\n\n    /**\n     * Parent node of the name access\n     * (ASSIGN, VAR, FUNCTION, OBJECTLIT, or CALL)\n     */\n    Node parent;\n\n\n    /**\n     * Create a node that refers to a name\n     *\n     * @param name The name\n     * @param node The top node representing the name (GETPROP, NAME, STRING)\n     */\n    JsNameRefNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsName name() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n\n  /**\n   * Class for nodes that set prototype properties or methods.\n   */\n  private class PrototypeSetNode extends JsNameRefNode {\n    /**\n     * Create a set node from the name & setter node\n     *\n     * @param name The name\n     * @param parent Parent node that assigns the expression (an ASSIGN)\n     */\n    PrototypeSetNode(JsName name, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Base class for special reference nodes.\n   */\n  private abstract class SpecialReferenceNode implements RefNode {\n    /** JsName node for the function */\n    JsName name;\n\n    /** The CALL node */\n    Node node;\n\n    /**\n     * Create a special reference node.\n     *\n     * @param name The name\n     * @param node The CALL node\n     */\n    SpecialReferenceNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsName name() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getParent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getGramps() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n\n\n  /**\n   * Class for nodes that are function calls that may change a function's\n   * prototype\n   */\n  private class ClassDefiningFunctionNode extends SpecialReferenceNode {\n    /**\n     * Create a class defining function node from the name & setter node\n     *\n     * @param name The name\n     * @param node The CALL node\n     */\n    ClassDefiningFunctionNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n\n\n  /**\n   * Class for nodes that check instanceof\n   */\n  private class InstanceOfCheckNode extends SpecialReferenceNode {\n    /**\n     * Create an instanceof node from the name and parent node\n     *\n     * @param name The name\n     * @param node The qualified name node\n     */\n    InstanceOfCheckNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Walk through externs and mark nodes as externally declared if declared\n   */\n  private class ProcessExternals extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * <p>Identifies all dependency scopes.\n   *\n   * <p>A dependency scope is a relationship between a node tree and a name that\n   * implies that the node tree will not execute (and thus can be eliminated) if\n   * the name is never referenced.\n   *\n   * <p>The entire parse tree is ultimately in a dependency scope relationship\n   * with <code>window</code> (or an equivalent name for the global scope), but\n   * the goal here is to find finer-grained relationships. This callback creates\n   * dependency scopes for every assignment statement, variable declaration, and\n   * function call in the global scope.\n   *\n   * <p>Note that dependency scope node trees aren't necessarily disjoint.\n   * In the following code snippet, for example, the function definition\n   * forms a dependency scope with the name <code>f</code> and the assignment\n   * inside the function forms a dependency scope with the name <code>x</code>.\n   * <pre>\n   * var x; function f() {\n         //The specific code has been omitted, but there is no error\n        }\n   * </pre>\n   */\n  private class FindDependencyScopes extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Create JsName objects for variable and function declarations in\n   * the global scope before computing name references.  In JavaScript\n   * it is legal to refer to variable and function names before the\n   * actual declaration.\n   */\n  private class HoistVariableAndFunctionDeclarations\n      extends NodeTraversal.AbstractShallowCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Identifies all declarations of global names and setter statements\n   * affecting global symbols (assignments to global names).\n   *\n   * All declarations and setters must be gathered in a single\n   * traversal and stored in traversal order so \"removeUnreferenced\"\n   * can perform modifications in traversal order.\n   */\n  private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Records the assignment of a value to a global name.\n     *\n     * @param name Fully qualified name\n     * @param node The top node representing the name (GETPROP, NAME, or STRING\n     * [objlit key])\n     */\n    private void recordSet(String name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Records the assignment to a prototype property of a global name,\n     * if possible.\n     *\n     * @param className The name of the class.\n     * @param prototypeProperty The name of the prototype property.\n     * @param node The top node representing the name (GETPROP)\n     */\n    private void recordPrototypeSet(String className, String prototypeProperty,\n        Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Record that the properties of this name have been written to.\n     */\n    private void recordWriteOnProperties(String parentName) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private static final Predicate<Node> NON_LOCAL_RESULT_PREDICATE =\n      new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n         //The specific code has been omitted, but there is no error\n        }\n      };\n\n  /**\n   * <p>Identifies all references between global names.\n   *\n   * <p>A reference from a name <code>f</code> to a name <code>g</code> means\n   * that if the name <code>f</code> must be defined, then the name\n   * <code>g</code> must also be defined. This would be the case if, for\n   * example, <code>f</code> were a function that called <code>g</code>.\n   */\n  private class FindReferences implements Callback {\n    Set<Node> nodesToKeep;\n    FindReferences() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addAllChildren(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addSimplifiedChildren(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addSimplifiedExpression(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void maybeRecordReferenceOrAlias(\n        NodeTraversal t, Node n, Node parent,\n        NameInformation nameInfo, NameInformation referring) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void recordAliases(List<NameInformation> referers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * A value whose result is the return value of a function call\n     * can be an alias to global object. The dependency on the call target will\n     * prevent the removal of the function and its dependent values, but won't\n     * prevent the alias' removal.\n     */\n    private boolean maybeHiddenAlias(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether the alias was recorded.\n     */\n    private boolean maybeRecordAlias(\n        String name, Node parent,\n        NameInformation referring, String referringName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Helper class that gathers the list of nodes that would be left\n     * behind after simplification.\n     */\n    private class NodeAccumulator\n        implements SideEffectAccumulator {\n\n      @Override\n      public boolean classDefiningCallsHaveSideEffects() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSubTree(Node original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSimplifiedShortCircuitExpression(Node original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSimplifiedHookExpression(Node hook,\n                                               boolean thenHasSideEffects,\n                                               boolean elseHasSideEffects) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n  }\n\n  private class RemoveListener implements AstChangeProxy.ChangeListener {\n    @Override\n    public void nodeRemoved(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Creates a name analyzer, with option to remove unreferenced variables when\n   * calling process().\n   *\n   * The analyzer make a best guess at whether functions affect global scope\n   * based on usage (no assignment of return value means that a function has\n   * side effects).\n   *\n   * @param compiler The AbstractCompiler\n   * @param removeUnreferenced If true, remove unreferenced variables during\n   *        process()\n   */\n  NameAnalyzer(AbstractCompiler compiler, boolean removeUnreferenced) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Records an alias of one name to another name.\n   */\n  private void recordAlias(String fromName, String toName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Records a reference from one name to another name.\n   */\n  private void recordReference(String fromName, String toName,\n                               RefType depType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes all unreferenced variables.\n   */\n  void removeUnreferenced() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Generates an HTML report\n   *\n   * @return The report\n   */\n  String getHtmlReport() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void appendListItem(StringBuilder sb, String text) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private String nameLink(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private String nameAnchor(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Looks up a {@link JsName} by name, optionally creating one if it doesn't\n   * already exist.\n   *\n   * @param name A fully qualified name\n   * @param canCreate Whether to create the object if necessary\n   * @return The {@code JsName} object, or null if one can't be found and\n   *   can't be created.\n   */\n  private JsName getName(String name, boolean canCreate) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a {@link JsName} for the given name if it doesn't already\n   * exist.\n   *\n   * @param name A fully qualified name\n   */\n  private void createName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * The NameAnalyzer algorithm works best when all objects have a canonical\n   * name in the global scope. When multiple names in the global scope\n   * point to the same object, things start to break down.\n   *\n   * For example, if we have\n   * <code>\n   * var a = {};\n   * var b = a;\n   * a.foo = 3;\n   * alert(b.foo);\n   * </code>\n   * then a.foo and b.foo are the same name, even though NameAnalyzer doesn't\n   * represent them as such.\n   *\n   * To handle this case, we look at all the aliases in the program.\n   * If descendant properties of that alias are assigned, then we create a\n   * directional reference from the original name to the alias. For example,\n   * in this case, the assign to {@code a.foo} triggers a reference from\n   * {@code b} to {@code a}, but NOT from a to b.\n   *\n   * Similarly, \"instanceof\" checks do not prevent the removal\n   * of a unaliased name but an instanceof check on an alias can only be removed\n   * if the other aliases are also removed, so we add a connection here.\n   */\n  private void referenceAliases() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Adds mutual references between all known global names and their parent\n   * names. (e.g. between <code>a.b.c</code> and <code>a.b</code>).\n   */\n  private void referenceParentNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates name information for the current node during a traversal.\n   *\n   * @param t The node traversal\n   * @param n The current node\n   * @return The name information, or null if the name is irrelevant to this\n   *     pass\n   */\n  private NameInformation createNameInformation(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates name information for a particular qualified name that occurs in a\n   * particular scope.\n   *\n   * @param name A qualified name (e.g. \"x\" or \"a.b.c\")\n   * @param scope The scope in which {@code name} occurs\n   * @param rootNameNode The NAME node for the first token of {@code name}\n   * @return The name information, or null if the name is irrelevant to this\n   *     pass\n   */\n  private NameInformation createNameInformation(\n      String name, Scope scope, Node rootNameNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks whether a name can be referenced outside of the compiled code.\n   * These names will be the root of dependency trees.\n   *\n   * @param scope The current variable scope\n   * @param name The name\n   * @return True if can be referenced outside\n   */\n  private boolean isExternallyReferenceable(Scope scope, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the nearest enclosing dependency scope, or null if there isn't one.\n   */\n  private List<NameInformation> getDependencyScope(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Get dependency scope defined by the enclosing function, or null.\n   * If enclosing function is a function expression, determine scope based on\n   * its parent if the parent node is a variable declaration or\n   * assignment.\n   */\n  private List<NameInformation> getEnclosingFunctionDependencyScope(\n      NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Propagate \"referenced\" property down the graph.\n   */\n  private void calculateReferences() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Enum for saying a value can be true, false, or either (cleaner than using a\n   * Boolean with null)\n   */\n  private enum TriState {\n    /** If value is true */\n    TRUE,\n    /** If value is false */\n    FALSE,\n    /** If value can be true or false */\n    BOTH\n  }\n\n  /**\n   * Gets the count of nodes matching the criteria\n   *\n   * @param isClass Whether the node is a class\n   * @param referenced Whether the node is referenced\n   * @return Number of matches\n   */\n  private int countOf(TriState isClass, TriState referenced) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Extract a list of replacement nodes to use.\n   */\n  private List<Node> getSideEffectNodes(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replace n with a simpler expression, while preserving program\n   * behavior.\n   *\n   * If the n's value is used, replace it with its RHS; otherwise\n   * replace it with the subexpressions that have side effects.\n   */\n  private void replaceWithRhs(Node parent, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Simplify a toplevel expression, while preserving program\n   * behavior.\n   */\n  private void replaceTopLevelExpressionWithRhs(Node parent, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determine if the parent reads the value of a child expression\n   * directly.  This is true children used in predicates, RETURN\n   * statements and, RHS of variable declarations and assignments.\n   *\n   * In the case of:\n   * if (a) b else c\n   *\n   * This method returns true for \"a\", and false for \"b\" and \"c\": the\n   * IF expression does something special based on \"a\"'s value.  \"b\"\n   * and \"c\" are effectively outputs.  Same logic applies to FOR,\n   * WHILE and DO loop predicates.  AND/OR/HOOK expressions are\n   * syntactic sugar for IF statements; therefore this method returns\n   * true for the predicate and false otherwise.\n   */\n  private boolean valueConsumedByParent(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Merge a list of nodes into a single expression.  The value of the\n   * new expression is determined by the last expression in the list.\n   */\n  private Node collapseReplacements(List<Node> replacements) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Extract a list of subexpressions that act as right hand sides.\n   */\n  private List<Node> getRhsSubexpressions(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "AliasSet": "  private static class AliasSet {\n         //The specific code has been omitted, but there is no error\n        }", "ReferencePropagationCallback": "  private static class ReferencePropagationCallback\n      implements EdgeCallback<JsName, RefType> {\n    @Override\n    public boolean traverseEdge(JsName from,\n                                RefType callSite,\n                                JsName to) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "NameInformation": "  private static class NameInformation {\n         //The specific code has been omitted, but there is no error\n        }", "JsName": "  private static class JsName implements Comparable<JsName> {\n    /** Fully qualified name */\n    String name;\n\n    /** Name of prototype functions attached to this name */\n    List<String> prototypeNames = Lists.newArrayList();\n\n    /** Whether this is an externally defined name */\n    boolean externallyDefined = false;\n\n    /** Whether this node is referenced */\n    boolean referenced = false;\n\n    /** Whether the name has descendants that are written to. */\n    boolean hasWrittenDescendants = false;\n\n    /** Whether the name is used in a instanceof check */\n    boolean hasInstanceOfReference = false;\n\n    /**\n     * Output the node as a string\n     *\n     * @return Node as a string\n     */\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int compareTo(JsName rhs) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "JsNameRefNode": "  private class JsNameRefNode implements RefNode {\n    /** JsName node for this reference */\n    JsName name;\n\n    /**\n     * Top GETPROP or NAME or STRING [objlit key] node defining the name of\n     * this node\n     */\n    @SuppressWarnings(\"unused\")\n    Node node;\n\n    /**\n     * Parent node of the name access\n     * (ASSIGN, VAR, FUNCTION, OBJECTLIT, or CALL)\n     */\n    Node parent;\n\n\n    /**\n     * Create a node that refers to a name\n     *\n     * @param name The name\n     * @param node The top node representing the name (GETPROP, NAME, STRING)\n     */\n    JsNameRefNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsName name() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "PrototypeSetNode": "  private class PrototypeSetNode extends JsNameRefNode {\n    /**\n     * Create a set node from the name & setter node\n     *\n     * @param name The name\n     * @param parent Parent node that assigns the expression (an ASSIGN)\n     */\n    PrototypeSetNode(JsName name, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "SpecialReferenceNode": "  private abstract class SpecialReferenceNode implements RefNode {\n    /** JsName node for the function */\n    JsName name;\n\n    /** The CALL node */\n    Node node;\n\n    /**\n     * Create a special reference node.\n     *\n     * @param name The name\n     * @param node The CALL node\n     */\n    SpecialReferenceNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsName name() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getParent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Node getGramps() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "ClassDefiningFunctionNode": "  private class ClassDefiningFunctionNode extends SpecialReferenceNode {\n    /**\n     * Create a class defining function node from the name & setter node\n     *\n     * @param name The name\n     * @param node The CALL node\n     */\n    ClassDefiningFunctionNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "InstanceOfCheckNode": "  private class InstanceOfCheckNode extends SpecialReferenceNode {\n    /**\n     * Create an instanceof node from the name and parent node\n     *\n     * @param name The name\n     * @param node The qualified name node\n     */\n    InstanceOfCheckNode(JsName name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "ProcessExternals": "  private class ProcessExternals extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FindDependencyScopes": "  private class FindDependencyScopes extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "HoistVariableAndFunctionDeclarations": "  private class HoistVariableAndFunctionDeclarations\n      extends NodeTraversal.AbstractShallowCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FindDeclarationsAndSetters": "  private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Records the assignment of a value to a global name.\n     *\n     * @param name Fully qualified name\n     * @param node The top node representing the name (GETPROP, NAME, or STRING\n     * [objlit key])\n     */\n    private void recordSet(String name, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Records the assignment to a prototype property of a global name,\n     * if possible.\n     *\n     * @param className The name of the class.\n     * @param prototypeProperty The name of the prototype property.\n     * @param node The top node representing the name (GETPROP)\n     */\n    private void recordPrototypeSet(String className, String prototypeProperty,\n        Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Record that the properties of this name have been written to.\n     */\n    private void recordWriteOnProperties(String parentName) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FindReferences": "  private class FindReferences implements Callback {\n    Set<Node> nodesToKeep;\n    FindReferences() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addAllChildren(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addSimplifiedChildren(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addSimplifiedExpression(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void maybeRecordReferenceOrAlias(\n        NodeTraversal t, Node n, Node parent,\n        NameInformation nameInfo, NameInformation referring) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void recordAliases(List<NameInformation> referers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * A value whose result is the return value of a function call\n     * can be an alias to global object. The dependency on the call target will\n     * prevent the removal of the function and its dependent values, but won't\n     * prevent the alias' removal.\n     */\n    private boolean maybeHiddenAlias(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether the alias was recorded.\n     */\n    private boolean maybeRecordAlias(\n        String name, Node parent,\n        NameInformation referring, String referringName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Helper class that gathers the list of nodes that would be left\n     * behind after simplification.\n     */\n    private class NodeAccumulator\n        implements SideEffectAccumulator {\n\n      @Override\n      public boolean classDefiningCallsHaveSideEffects() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSubTree(Node original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSimplifiedShortCircuitExpression(Node original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSimplifiedHookExpression(Node hook,\n                                               boolean thenHasSideEffects,\n                                               boolean elseHasSideEffects) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n  }", "NodeAccumulator": "    private class NodeAccumulator\n        implements SideEffectAccumulator {\n\n      @Override\n      public boolean classDefiningCallsHaveSideEffects() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSubTree(Node original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSimplifiedShortCircuitExpression(Node original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public void keepSimplifiedHookExpression(Node hook,\n                                               boolean thenHasSideEffects,\n                                               boolean elseHasSideEffects) {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "RemoveListener": "  private class RemoveListener implements AstChangeProxy.ChangeListener {\n    @Override\n    public void nodeRemoved(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}