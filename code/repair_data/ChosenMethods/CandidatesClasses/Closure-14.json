{"ControlFlowAnalysis": "final class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n         //The specific code has been omitted, but there is no error\n        }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n  private final boolean edgeAnnotations;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n         //The specific code has been omitted, but there is no error\n        }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  ControlFlowGraph<Node> getCfg() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleIf(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleWhile(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleDo(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleFor(Node forNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleSwitch(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleCase(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleDefault(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleWith(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleStmtList(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleFunction(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleExpr(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleThrow(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleTry(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleCatch(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleBreak(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleContinue(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleReturn(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void handleStmt(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static Node computeFollowNode(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n         //The specific code has been omitted, but there is no error\n        }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  public static boolean mayThrowException(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Get the TRY block with a CATCH that would be run if n throws an exception.\n   * @return The CATCH node or null if it there isn't a CATCH before the\n   *     the function terminates.\n   */\n  static Node getExceptionHandler(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Locate the catch BLOCK given the first block in a TRY.\n   * @return The CATCH node or null there is no catch handler.\n   */\n  static Node getCatchHandlerForBlock(Node block) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "AstControlFlowGraph": "  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}