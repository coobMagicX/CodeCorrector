{"Variance": "public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -9111962718267217978L;\n\n    /** SecondMoment is used in incremental calculation of Variance*/\n    protected SecondMoment moment = null;\n\n    /**\n     * Whether or not {@link #increment(double)} should increment\n     * the internal second moment. When a Variance is constructed with an\n     * external SecondMoment as a constructor parameter, this property is\n     * set to false and increments must be applied to the second moment\n     * directly.\n     */\n    protected boolean incMoment = true;\n\n    /**\n     * Whether or not bias correction is applied when computing the\n     * value of the statistic. True means that bias is corrected.  See\n     * {@link Variance} for details on the formula.\n     */\n    private boolean isBiasCorrected = true;\n\n    /**\n     * Constructs a Variance with default (true) <code>isBiasCorrected</code>\n     * property.\n     */\n    public Variance() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructs a Variance based on an external second moment.\n     * When this constructor is used, the statistic may only be\n     * incremented via the moment, i.e., {@link #increment(double)}\n     * does nothing; whereas {@code m2.increment(value)} increments\n     * both {@code m2} and the Variance instance constructed from it.\n     *\n     * @param m2 the SecondMoment (Third or Fourth moments work\n     * here as well.)\n     */\n    public Variance(final SecondMoment m2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructs a Variance with the specified <code>isBiasCorrected</code>\n     * property\n     *\n     * @param isBiasCorrected  setting for bias correction - true means\n     * bias will be corrected and is equivalent to using the argumentless\n     * constructor\n     */\n    public Variance(boolean isBiasCorrected) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructs a Variance with the specified <code>isBiasCorrected</code>\n     * property and the supplied external second moment.\n     *\n     * @param isBiasCorrected  setting for bias correction - true means\n     * bias will be corrected\n     * @param m2 the SecondMoment (Third or Fourth moments work\n     * here as well.)\n     */\n    public Variance(boolean isBiasCorrected, SecondMoment m2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy constructor, creates a new {@code Variance} identical\n     * to the {@code original}\n     *\n     * @param original the {@code Variance} instance to copy\n     */\n    public Variance(Variance original) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     * <p>If all values are available, it is more accurate to use\n     * {@link #evaluate(double[])} rather than adding values one at a time\n     * using this method and then executing {@link #getResult}, since\n     * <code>evaluate</code> leverages the fact that is has the full\n     * list of values together to execute a two-pass algorithm.\n     * See {@link Variance}.</p>\n     *\n     * <p>Note also that when {@link #Variance(SecondMoment)} is used to\n     * create a Variance, this method does nothing. In that case, the\n     * SecondMoment should be incremented directly.</p>\n     */\n    @Override\n    public void increment(final double d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getResult() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    public long getN() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void clear() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the variance of the entries in the input array, or\n     * <code>Double.NaN</code> if the array is empty.\n     * <p>\n     * See {@link Variance} for details on the computing algorithm.</p>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the array is null\n     */\n    @Override\n    public double evaluate(final double[] values) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the variance of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.\n     * <p>\n     * See {@link Variance} for details on the computing algorithm.</p>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n     *\n     * @param values the input array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the array is null or the array index\n     *  parameters are not valid\n     */\n    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>Returns the weighted variance of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre>\n     * where weightedMean is the weighted mean</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the weighted variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final int begin, final int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Returns the weighted variance of the entries in the the input array.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre>\n     * where weightedMean is the weighted mean</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @return the weighted variance of the values\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the variance of the entries in the specified portion of\n     * the input array, using the precomputed mean value.  Returns\n     * <code>Double.NaN</code> if the designated subarray is empty.\n     * <p>\n     * See {@link Variance} for details on the computing algorithm.</p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the arithmetic\n     * mean of the sample data, not a known population parameter.  This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param mean the precomputed mean value\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the array is null or the array index\n     *  parameters are not valid\n     */\n    public double evaluate(final double[] values, final double mean,\n            final int begin, final int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the variance of the entries in the input array, using the\n     * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n     * is empty.\n     * <p>\n     * See {@link Variance} for details on the computing algorithm.</p>\n     * <p>\n     * If <code>isBiasCorrected</code> is <code>true</code> the formula used\n     * assumes that the supplied mean value is the arithmetic mean of the\n     * sample data, not a known population parameter.  If the mean is a known\n     * population parameter, or if the \"population\" version of the variance is\n     * desired, set <code>isBiasCorrected</code> to <code>false</code> before\n     * invoking this method.</p>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param mean the precomputed mean value\n     * @return the variance of the values or Double.NaN if the array is empty\n     * @throws IllegalArgumentException if the array is null\n     */\n    public double evaluate(final double[] values, final double mean) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the weighted variance of the entries in the specified portion of\n     * the input array, using the precomputed weighted mean value.  Returns\n     * <code>Double.NaN</code> if the designated subarray is empty.\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     *     <li>the start and length arguments do not determine a valid array</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @param begin index of the first array element to include\n     * @param length the number of elements to include\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights, final double mean) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Returns the isBiasCorrected.\n     */\n    public boolean isBiasCorrected() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param biasCorrected The isBiasCorrected to set.\n     */\n    public void setBiasCorrected(boolean biasCorrected) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Variance copy() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copies source to dest.\n     * <p>Neither source nor dest can be null.</p>\n     *\n     * @param source Variance to copy\n     * @param dest Variance to copy to\n     * @throws NullArgumentException if either source or dest is null\n     */\n    public static void copy(Variance source, Variance dest)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(source);\n        MathUtils.checkNotNull(dest);\n        dest.setData(source.getDataRef());\n        dest.moment = source.moment.copy();\n        dest.isBiasCorrected = source.isBiasCorrected;\n        dest.incMoment = source.incMoment;\n    }\n}"}