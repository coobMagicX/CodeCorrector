{"GenericMetadataSupport": "public abstract class GenericMetadataSupport {\n         //The specific code has been omitted, but there is no error\n        }", "FromClassGenericMetadataSupport": "    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n        private final Class<?> clazz;\n\n        public FromClassGenericMetadataSupport(Class<?> clazz) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Class superClassOf(Class currentExploredClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Class<?> rawType() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "FromParameterizedTypeGenericMetadataSupport": "    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n\n        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private void readActualTypeParameters() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Class<?> rawType() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "ParameterizedReturnType": "    private static class ParameterizedReturnType extends GenericMetadataSupport {\n        private final ParameterizedType parameterizedType;\n        private final TypeVariable[] typeParameters;\n\n        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private void readTypeParameters() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private void readTypeVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Class<?> rawType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }", "TypeVariableReturnType": "    private static class TypeVariableReturnType extends GenericMetadataSupport {\n        private final TypeVariable typeVariable;\n        private final TypeVariable[] typeParameters;\n        private Class<?> rawType;\n\n\n\n        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private void readTypeParameters() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private void readTypeVariables() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Class<?> rawType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Class<?> extractRawTypeOf(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public List<Type> extraInterfaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n         * @see #extractRawTypeOf(java.lang.reflect.Type)\n         */\n        public Class<?>[] rawExtraInterfaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Type extractActualBoundedTypeOf(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "NotGenericReturnTypeSupport": "    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n        private final Class<?> returnType;\n\n        public NotGenericReturnTypeSupport(Type genericReturnType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Class<?> rawType() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "TypeVarBoundedType": "    public static class TypeVarBoundedType implements BoundedType {\n        private final TypeVariable typeVariable;\n\n\n        public TypeVarBoundedType(TypeVariable typeVariable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n         */\n        public Type firstBound() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n         * containing I_1 and I_2.\n         *\n         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n         * empty array if no other bound declared.\n         */\n        public Type[] interfaceBounds() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public boolean equals(Object o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public TypeVariable typeVariable() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "WildCardBoundedType": "    public static class WildCardBoundedType implements BoundedType {\n        private final WildcardType wildcard;\n\n\n        public WildCardBoundedType(WildcardType wildcard) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * @return The first bound, either a type or a reference to a TypeVariable\n         */\n        public Type firstBound() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * @return An empty array as, wildcard don't support multiple bounds.\n         */\n        public Type[] interfaceBounds() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public boolean equals(Object o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public WildcardType wildCard() {\n         //The specific code has been omitted, but there is no error\n        }\n    }"}