{"PeepholeFoldConstants": "class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n\n  static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n      DiagnosticType.error(\n          \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n          \"Array index not integer: {0}\");\n\n  static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n      DiagnosticType.error(\n          \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n          \"Array index out of bounds: {0}\");\n\n  static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n      DiagnosticType.error(\n          \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n          \"Can't negate non-numeric value: {0}\");\n\n  static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n      DiagnosticType.error(\n          \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n          \"Operand out of range, bitwise operation will lose information: {0}\");\n\n  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n      \"Shift amount out of bounds: {0}\");\n\n  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n      \"Fractional bitwise operand: {0}\");\n\n  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n\n  // The LOCALE independent \"locale\"\n  private static final Locale ROOT_LOCALE = new Locale(\"\");\n\n  @Override\n  Node optimizeSubtree(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldBinaryOperator(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryReduceVoid(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryReduceOperandsForOp(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryConvertOperandsToNumber(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryConvertToNumber(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Folds 'typeof(foo)' if foo is a literal, e.g.\n   * typeof(\"bar\") --> \"string\"\n   * typeof(6) --> \"number\"\n   */\n  private Node tryFoldTypeof(Node originalTypeofNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldUnaryOperator(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold {@code left instanceof right} into {@code true}\n   * or {@code false}.\n   */\n  private Node tryFoldInstanceof(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldAssign(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold a AND/OR node.\n   */\n  private Node tryFoldAndOr(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n   * where no node has two const children ((foo() + 'a') + 'b'), so\n   * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n   * Specifically it folds Add exprssions where:\n   *  - The left child is also and add expression\n   *  - The right child is a constant value\n   *  - The left child's right child is a STRING constant.\n   */\n  private Node tryFoldChildAddString(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold an ADD node with constant operands\n   */\n  private Node tryFoldAddConstantString(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Expressions such as [foo() * 10 * 20] generate parse trees\n   * where no node has two const children ((foo() * 10) * 20), so\n   * performArithmeticOp() won't fold it -- tryFoldLeftChildOp() will.\n   * Specifically it folds associative expressions where:\n   *  - The left child is also an associative expression of the same time.\n   *  - The right child is a constant NUMBER constant.\n   *  - The left child's right child is a NUMBER constant.\n   */\n  private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldAdd(Node node, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold shift operations\n   */\n  private Node tryFoldShift(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold comparison nodes, e.g ==\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private Node tryFoldComparison(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * The result of the comparison as a Boolean or null if the\n   * result could not be determined.\n   */\n  private Boolean compareAsNumbers(int op, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param value The value to compare to \"undefined\"\n   * @param op The boolean op to compare with\n   * @return Whether the boolean op is true or false\n   */\n  private boolean compareToUndefined(Node value, int op) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold away unnecessary object instantiation.\n   * e.g. this[new String('eval')] -> this.eval\n   */\n  private Node tryFoldCtorCall(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns whether this node must be coerced to a string. */\n  private boolean inForcedStringContext(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldInForcedStringContext(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldKnownMethods(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to eveluate known String methods\n   *    .indexOf(), .substr(), .substring()\n   */\n  private Node tryFoldKnownStringMethods(Node subtree) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The lowered string Node.\n   */\n  private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The uppered string Node.\n   */\n  private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to evaluate String.indexOf/lastIndexOf:\n   *     \"abcdef\".indexOf(\"bc\") -> 1\n   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n   */\n  private Node tryFoldStringIndexOf(\n      Node n, String functionName, Node lstringNode, Node firstArg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold .substr() calls on strings\n   */\n  private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold .substring() calls on strings\n   */\n  private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-element. e.g [1, 2, 3][10];\n   */\n  private Node tryFoldGetElem(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n   */\n  private Node tryFoldGetProp(Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}