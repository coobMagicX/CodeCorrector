{"BeanDeserializer": "public class BeanDeserializer\n    extends BeanDeserializerBase\n    implements java.io.Serializable\n{\n    /* TODOs for future versions:\n     * \n     * For 2.9?\n     *\n     * - New method in JsonDeserializer (deserializeNext()) to allow use of more\n     *   efficient 'nextXxx()' method `JsonParser` provides.\n     *\n     * Also: need to ensure efficient impl of those methods for Smile, CBOR\n     * at least (in addition to JSON)\n     */\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Lazily constructed exception used as root cause if reporting problem\n     * with creator method that returns <code>null</code> (which is not allowed)\n     *\n     * @since 2.8\n     */\n    protected transient Exception _nullFromCreator;\n\n    /**\n     * State marker we need in order to avoid infinite recursion for some cases\n     * (not very clean, alas, but has to do for now)\n     *\n     * @since 2.9\n     */\n    private volatile transient NameTransformer _currentlyTransforming;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     */\n    public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write style copying of settings of an existing instance.\n     */\n    protected BeanDeserializer(BeanDeserializerBase src) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BeanDeserializer(BeanDeserializerBase src, Set<String> ignorableProps) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BeanDeserializer(BeanDeserializerBase src, BeanPropertyMap props) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer transformer)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public BeanDeserializer withIgnorableProperties(Set<String> ignorableProps) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n         //The specific code has been omitted, but there is no error\n        }\n            // 23-Sep-2015, tatu: This is wrong at some many levels, but for now... it is\n            //    what it is, including \"expected behavior\".\n            p.nextToken();\n            if (_objectIdReader != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            return deserializeFromObject(p, ctxt);\n        }\n        return _deserializeOther(p, ctxt, p.getCurrentToken());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    @Deprecated // since 2.8; remove unless getting used\n    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_unwrappedPropertyHandler != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_externalTypeIdHandler != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n         //The specific code has been omitted, but there is no error\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [databind#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if ((_objectIdReader != null) && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n         //The specific code has been omitted, but there is no error\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        if (_injectables != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_needViewProcesing) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer unknown = null;\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        JsonToken t = p.getCurrentToken();\n        List<BeanReferring> referrings = null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (referrings != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (unknown != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return bean;\n    }\n\n    /**\n     * @since 2.8\n     */\n    private BeanReferring handleUnresolvedReference(DeserializationContext ctxt,\n            SettableBeanProperty prop, PropertyValueBuffer buffer,\n            UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        BeanReferring referring = new BeanReferring(ctxt, reference,\n                prop.getType(), buffer, prop);\n        reference.getRoid().appendReferring(referring);\n        return referring;\n    }\n\n    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Helper method called for rare case of pointing to {@link JsonToken#VALUE_NULL}\n     * token. While this is most often an erroneous condition, there is one specific\n     * case with XML handling where polymorphic type with no properties is exposed\n     * as such, and should be handled same as empty Object.\n     *\n     * @since 2.7\n     */\n    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic\n        //   \"empty\" POJOs deserialized from XML, where empty XML tag synthesizes a\n        //   `VALUE_NULL` token.\n        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tb = new TokenBuffer(p, ctxt);\n            tb.writeEndObject();\n            JsonParser p2 = tb.asParser(p);\n            p2.nextToken(); // to point to END_OBJECT\n            // note: don't have ObjectId to consider at this point, so:\n            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)\n                    : deserializeFromObject(p2, ctxt);\n            p2.close();\n            return ob;\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n    \n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_propertyBasedCreator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n\n        if (_injectables != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        String propName = p.hasTokenId(JsonTokenId.ID_FIELD_NAME) ? p.getCurrentName() : null;\n\n        for (; propName != null; propName = p.nextFieldName()) {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Need to copy to a separate buffer first\n            TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n            tokens.writeFieldName(propName);\n            tokens.append(b2);\n            try {\n                _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n            } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n                } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n        \n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n                continue;\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_delegateDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        tokens.writeEndObject();\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Helper method for getting a lazily construct exception to be reported\n     * to {@link DeserializationContext#handleInstantiationProblem(Class, Object, Throwable)}.\n     *\n     * @since 2.8\n     */\n    protected Exception _creatorReturnedNullException() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.8\n     */\n    static class BeanReferring extends Referring\n    {\n        private final DeserializationContext _context;\n        private final SettableBeanProperty _prop;\n        private Object _bean;\n\n        BeanReferring(DeserializationContext ctxt, UnresolvedForwardReference ref,\n                JavaType valueType, PropertyValueBuffer buffer, SettableBeanProperty prop)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public void setBean(Object bean) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n        {\n            if (_bean == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            _prop.set(_bean, value);\n        }\n    }\n}", "BeanReferring": "    static class BeanReferring extends Referring\n    {\n        private final DeserializationContext _context;\n        private final SettableBeanProperty _prop;\n        private Object _bean;\n\n        BeanReferring(DeserializationContext ctxt, UnresolvedForwardReference ref,\n                JavaType valueType, PropertyValueBuffer buffer, SettableBeanProperty prop)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public void setBean(Object bean) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n        {\n            if (_bean == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            _prop.set(_bean, value);\n        }\n    }"}