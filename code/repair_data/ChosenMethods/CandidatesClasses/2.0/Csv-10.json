{"CSVPrinter": "public final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // write last segment\n        if (pos > start) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (quotePolicy) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n         //The specific code has been omitted, but there is no error\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n         //The specific code has been omitted, but there is no error\n        }\n        println();\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n         //The specific code has been omitted, but there is no error\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n            println();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}