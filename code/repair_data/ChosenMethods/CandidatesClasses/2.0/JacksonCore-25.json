{"ReaderBasedJsonParser": "public class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n    @Override public void setCodec(ObjectCodec c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (t == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (t != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n         //The specific code has been omitted, but there is no error\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n         //The specific code has been omitted, but there is no error\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n         //The specific code has been omitted, but there is no error\n        } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n         //The specific code has been omitted, but there is no error\n        }\n        _currToken = t;\n        return t;\n    }"}