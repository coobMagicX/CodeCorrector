{"ObjectReader": "public class ObjectReader\n    extends ObjectCodec\n    implements Versioned, java.io.Serializable // since 2.1\n{\n    private static final long serialVersionUID = 1L; // since 2.5\n\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    /*\n    /**********************************************************\n    /* Immutable configuration from ObjectMapper\n    /**********************************************************\n     */\n\n    /**\n     * General serialization configuration settings; while immutable,\n     * can use copy-constructor to create modified instances as necessary.\n     */\n    protected final DeserializationConfig _config;\n\n    /**\n     * Blueprint instance of deserialization context; used for creating\n     * actual instance when needed.\n     */\n    protected final DefaultDeserializationContext _context;\n\n    /**\n     * Factory used for constructing {@link JsonGenerator}s\n     */\n    protected final JsonFactory _parserFactory;\n\n    /**\n     * Flag that indicates whether root values are expected to be unwrapped or not\n     */\n    protected final boolean _unwrapRoot;\n\n    /**\n     * Filter to be consider for JsonParser.  \n     * Default value to be null as filter not considered.\n     */\n    private final TokenFilter _filter;\n    \n    /*\n    /**********************************************************\n    /* Configuration that can be changed during building\n    /**********************************************************\n     */\n\n    /**\n     * Declared type of value to instantiate during deserialization.\n     * Defines which deserializer to use; as well as base type of instance\n     * to construct if an updatable value is not configured to be used\n     * (subject to changes by embedded type information, for polymorphic\n     * types). If {@link #_valueToUpdate} is non-null, only used for\n     * locating deserializer.\n     */\n    protected final JavaType _valueType;\n\n    /**\n     * We may pre-fetch deserializer as soon as {@link #_valueType}\n     * is known, and if so, reuse it afterwards.\n     * This allows avoiding further deserializer lookups and increases\n     * performance a bit on cases where readers are reused.\n     * \n     * @since 2.1\n     */\n    protected final JsonDeserializer<Object> _rootDeserializer;\n    \n    /**\n     * Instance to update with data binding; if any. If null,\n     * a new instance is created, if non-null, properties of\n     * this value object will be updated instead.\n     * Note that value can be of almost any type, except not\n     * {@link com.fasterxml.jackson.databind.type.ArrayType}; array\n     * types can not be modified because array size is immutable.\n     */\n    protected final Object _valueToUpdate;\n\n    /**\n     * When using data format that uses a schema, schema is passed\n     * to parser.\n     */\n    protected final FormatSchema _schema;\n\n    /**\n     * Values that can be injected during deserialization, if any.\n     */\n    protected final InjectableValues _injectableValues;\n\n    /**\n     * Optional detector used for auto-detecting data format that byte-based\n     * input uses.\n     *<p>\n     * NOTE: If defined non-null, <code>readValue()</code> methods that take\n     * {@link Reader} or {@link String} input <b>will fail with exception</b>,\n     * because format-detection only works on byte-sources. Also, if format\n     * can not be detect reliably (as per detector settings),\n     * a {@link JsonParseException} will be thrown).\n     * \n     * @since 2.1\n     */\n    protected final DataFormatReaders _dataFormatReaders;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * Root-level cached deserializers.\n     * Passed by {@link ObjectMapper}, shared with it.\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link ObjectMapper} for initial instantiation\n     */\n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor called when a root deserializer should be fetched based\n     * on other configuration.\n     */\n    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,\n            JavaType valueType, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Copy constructor used for building variations.\n     */\n    protected ObjectReader(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy constructor used when modifying simple feature flags\n     */\n    protected ObjectReader(ObjectReader base, DeserializationConfig config)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    protected ObjectReader(ObjectReader base, JsonFactory f)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    protected ObjectReader(ObjectReader base, TokenFilter filter) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes MUST override, used for constructing\n    /* reader instances, (re)configuring parser instances\n    /* Added in 2.5\n    /**********************************************************\n     */\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Overridable factory method called by various \"withXxx()\" methods\n     * \n     * @since 2.5\n     */\n    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method used to create {@link MappingIterator} instances;\n     * either default, or custom subtype.\n     * \n     * @since 2.5\n     */\n    protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt,\n            JsonDeserializer<?> deser, boolean parserManaged)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Methods sub-classes may choose to override, if customized\n    /* initialization is needed.\n    /**********************************************************\n     */\n\n    /**\n     * NOTE: changed from static to non-static in 2.5; unfortunate but\n     * necessary change to support overridability\n     */\n    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        if (_schema != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        _config.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return t;\n    }\n\n    /**\n     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n     * of multiple values means that we may or may not want to advance the stream,\n     * but need to do other initialization.\n     *<p>\n     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n     * \n     * @since 2.5\n     */\n    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        _config.initialize(p); // since 2.5\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for DeserializationFeatures\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     */\n    public ObjectReader with(DeserializationFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader with(DeserializationFeature first,\n            DeserializationFeature... other)\n    {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader withFeatures(DeserializationFeature... features) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     */\n    public ObjectReader without(DeserializationFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader without(DeserializationFeature first,\n            DeserializationFeature... other) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for JsonParser.Features\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     */\n    public ObjectReader with(JsonParser.Feature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     */\n    public ObjectReader withFeatures(JsonParser.Feature... features) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     */\n    public ObjectReader without(JsonParser.Feature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     */\n    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods for FormatFeature (2.7)\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature enabled.\n     *\n     * @since 2.7\n     */\n    public ObjectReader with(FormatFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features enabled.\n     *\n     * @since 2.7\n     */\n    public ObjectReader withFeatures(FormatFeature... features) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified feature disabled.\n     *\n     * @since 2.7\n     */\n    public ObjectReader without(FormatFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * with specified features disabled.\n     *\n     * @since 2.7\n     */\n    public ObjectReader withoutFeatures(FormatFeature... features) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Life-cycle, fluent factory methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Mutant factory method that will construct a new instance that has\n     * specified underlying {@link DeserializationConfig}.\n     *<p>\n     * NOTE: use of this method is not recommended, as there are many other\n     * re-configuration methods available.\n     */\n    public ObjectReader with(DeserializationConfig config) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new instance with configuration that uses\n     * passed {@link InjectableValues} to provide injectable values.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(InjectableValues injectableValues)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonNodeFactory} for constructing {@link JsonNode}\n     * instances.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(JsonNodeFactory f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance with configuration that uses\n     * passed {@link JsonFactory} for constructing underlying Readers.\n     *<p>\n     * NOTE: only factories that <b>DO NOT REQUIRE SPECIAL MAPPERS</b>\n     * (that is, ones that return <code>false</code> for\n     * {@link JsonFactory#requiresCustomCodec()}) can be used: trying\n     * to use one that requires custom codec will throw exception\n     * \n     * @since 2.1\n     */\n    public ObjectReader with(JsonFactory f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a new instance with configuration that\n     * specifies what root name to expect for \"root name unwrapping\".\n     * See {@link DeserializationConfig#withRootName(String)} for\n     * details.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withRootName(String rootName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.6\n     */\n    public ObjectReader withRootName(PropertyName rootName) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Convenience method that is same as calling:\n     *<code>\n     *   withRootName(\"\")\n     *</code>\n     * which will forcibly prevent use of root name wrapping when writing\n     * values with this {@link ObjectReader}.\n     * \n     * @since 2.6\n     */\n    public ObjectReader withoutRootName() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a new instance with configuration that\n     * passes specified {@link FormatSchema} to {@link JsonParser} that\n     * is constructed for parsing content.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader with(FormatSchema schema)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     * \n     * @since 2.5\n     */\n    public ObjectReader forType(JavaType valueType)\n    {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     *\n     * @since 2.5\n     */\n    public ObjectReader forType(Class<?> valueType) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new reader instance that is configured\n     * to data bind into specified type.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     *\n     * @since 2.5\n     */\n    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(JavaType valueType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(Class<?> valueType) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(java.lang.reflect.Type valueType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n     */\n    @Deprecated\n    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    /**\n     * Method for constructing a new instance with configuration that\n     * updates passed Object (as root value), instead of constructing \n     * a new value.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withValueToUpdate(Object value)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a new instance with configuration that\n     * uses specified View for filtering.\n     *<p>\n     * Note that the method does NOT change state of this reader, but\n     * rather construct and returns a newly configured instance.\n     */\n    public ObjectReader withView(Class<?> activeView) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public ObjectReader with(Locale l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public ObjectReader with(TimeZone tz) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public ObjectReader withHandler(DeserializationProblemHandler h) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public ObjectReader with(Base64Variant defaultBase64) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified list of\n     * {@link JsonFactory} instances, and default {@link DataFormatReaders} settings\n     * (for customized {@link DataFormatReaders}, you can construct instance yourself).\n     * to construct appropriate {@link JsonParser} for actual parsing.\n     *<p>\n     * Note: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     *<p>\n     * Note: not all {@link JsonFactory} types can be passed: specifically, ones that\n     * require \"custom codec\" (like XML factory) will not work. Instead, use\n     * method that takes {@link ObjectReader} instances instead of factories.\n     * \n     * @param readers Data formats accepted, in decreasing order of priority (that is,\n     *   matches checked in listed order, first match wins)\n     * \n     * @return Newly configured writer instance\n     * \n     * @since 2.1\n     */\n    public ObjectReader withFormatDetection(ObjectReader... readers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Fluent factory method for constructing a reader that will try to\n     * auto-detect underlying data format, using specified\n     * {@link DataFormatReaders}.\n     *<p>\n     * NOTE: since format detection only works with byte sources, it is possible to\n     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n     * (enough) detected as one of specified types, an exception will be thrown.\n     * \n     * @param readers DataFormatReaders to use for detecting underlying format.\n     * \n     * @return Newly configured writer instance\n     * \n     * @since 2.1\n     */\n    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader with(ContextAttributes attrs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withAttributes(Map<?,?> attrs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withAttribute(Object key, Object value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public ObjectReader withoutAttribute(Object key) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Overridable factory methods may override\n    /**********************************************************\n     */\n    \n    protected ObjectReader _with(DeserializationConfig newConfig) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Simple accessors\n    /**********************************************************\n     */\n    \n    public boolean isEnabled(DeserializationFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean isEnabled(MapperFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean isEnabled(JsonParser.Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.2\n     */\n    public DeserializationConfig getConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * @since 2.1\n     */\n    @Override\n    public JsonFactory getFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public TypeFactory getTypeFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public ContextAttributes getAttributes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.6\n     */\n    public InjectableValues getInjectableValues() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods; basic ones to support ObjectCodec first\n    /* (ones that take JsonParser)\n    /**********************************************************\n     */\n\n    /**\n     * Method that binds content read using given parser, using\n     * configuration of this reader, including expected result type.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p) throws IOException\n    {\n        return (T) _bind(p, _valueToUpdate);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser p, Class<T> valueType) throws IOException\n    {\n        return (T) forType(valueType).readValue(p);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef) throws IOException\n    {\n        return (T) forType(valueTypeRef).readValue(p);\n    }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that expected value type\n     * is specified with the call (instead of currently configured root type).\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, ResolvedType valueType) throws IOException, JsonProcessingException {\n        return (T) forType((JavaType)valueType).readValue(p);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser p, JavaType valueType) throws IOException {\n        return (T) forType(valueType).readValue(p);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, Class<T> valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueTypeRef).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef) throws IOException {\n        return forType(valueTypeRef).readValues(p);\n    }\n    \n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @Override\n    public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {\n        return readValues(p, (JavaType) valueType);\n    }\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *   withType(valueType).readValues(p);\n     *</pre>\n     *<p>\n     * Method reads a sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} <b>MUST</b> point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> (one that\n     * contains values to read) but rather to the token following it which is the first\n     * token of the first value to read.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    public <T> Iterator<T> readValues(JsonParser p, JavaType valueType) throws IOException {\n        return forType(valueType).readValues(p);\n    }\n\n    /*\n    /**********************************************************\n    /* TreeCodec impl\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode createArrayNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonNode createObjectNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonParser treeAsTokens(TreeNode n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method that binds content read using given parser, using\n     * configuration of this reader, except that content is bound as\n     * JSON tree instead of configured root value type.\n     *<p>\n     * Note: if an object was specified with {@link #withValueToUpdate}, it\n     * will be ignored.\n     *<p>\n     * NOTE: this method never tries to auto-detect format, since actual\n     * (data-format specific) parser is given.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n        return (T) _bindAsTree(p);\n    }\n     \n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Deserialization methods; others similar to what ObjectMapper has\n    /**********************************************************\n     */\n    \n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n    \n    /**\n     * Method that binds content read from given JSON string,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    /**\n     * Method that binds content read from given byte array,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src, offset, length),\n                false));\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    /**\n     * Method that binds content read from given input source,\n     * using configuration of this reader.\n     * Value return is either newly constructed, or root value that\n     * was specified with {@link #withValueToUpdate(Object)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));\n    }\n\n    /**\n     * Convenience method for converting results from given JSON tree into given\n     * value type. Basically short-cut for:\n     *<pre>\n     *   objectReader.readValue(src.traverse())\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonNode src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(in), false));\n    }\n    \n    /**\n     * Method that reads content from given input source,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(r), false));\n    }\n\n    /**\n     * Method that reads content from given JSON input String,\n     * using configuration of this reader, and binds it as JSON Tree.\n     *<p>\n     * Note that if an object was specified with a call to\n     * {@link #withValueToUpdate(Object)}\n     * it will just be ignored; result is always a newly constructed\n     * {@link JsonNode} instance.\n     */\n    public JsonNode readTree(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(json), false));\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization methods; reading sequence of values\n    /**********************************************************\n     */\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser p)\n        throws IOException, JsonProcessingException\n    {\n        DeserializationContext ctxt = createDeserializationContext(p);\n        // false -> do not close as caller gave parser instance\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), false);\n    }\n    \n    /**\n     * Method for reading sequence of Objects from parser stream.\n     *<p>\n     * Sequence can be either wrapped or unwrapped root-level sequence:\n     * wrapped means that the elements are enclosed in JSON Array;\n     * and unwrapped that elements are directly accessed at main level.\n     * Assumption is that iff the first token of the document is\n     * <code>START_ARRAY</code>, we have a wrapped sequence; otherwise\n     * unwrapped. For wrapped sequences, leading <code>START_ARRAY</code>\n     * is skipped, so that for both cases, underlying {@link JsonParser}\n     * will point to what is expected to be the first token of the first\n     * element.\n     *<p>\n     * Note that the wrapped vs unwrapped logic means that it is NOT\n     * possible to use this method for reading an unwrapped sequence\n     * of elements written as JSON Arrays: to read such sequences, one\n     * has to use {@link #readValues(JsonParser)}, making sure parser\n     * points to the first token of the first element (i.e. the second\n     * <code>START_ARRAY</code> which is part of the first element).\n     */\n    public <T> MappingIterator<T> readValues(InputStream src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(Reader src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(src), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     * \n     * @param src URL to read to access JSON content to parse.\n     */\n    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /*\n    /**********************************************************\n    /* Implementation of rest of ObjectCodec methods\n    /**********************************************************\n     */\n\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n    {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n         //The specific code has been omitted, but there is no error\n        } catch (IOException e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }    \n\n    @Override\n    public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, data-binding\n    /**********************************************************\n     */\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException\n    {\n        /* First: may need to read the next token, to initialize state (either\n         * before first read from parser, or after previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n            if (_unwrapRoot) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                if (valueToUpdate == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    deser.deserialize(p, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        // Need to consume the token too\n        p.clearCurrentToken();\n        return result;\n    }\n    \n    /**\n     * Consider filter when creating JsonParser.  \n     */\n    protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    protected Object _bindAndClose(JsonParser p) throws IOException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(p);\n            if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n                if (_unwrapRoot) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    if (_valueToUpdate == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                        deser.deserialize(p, ctxt, _valueToUpdate);\n                        result = _valueToUpdate;                    \n                    }\n                }\n            }\n            return result;\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n\n    protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException {\n        try {\n            return _bindAsTree(p);\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    protected JsonNode _bindAsTree(JsonParser p) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                result = (JsonNode) deser.deserialize(p, ctxt);\n            }\n        }\n        // Need to consume the token too\n        p.clearCurrentToken();\n        return result;\n    }\n    \n    /**\n     * @since 2.1\n     */\n    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException\n    {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt,\n            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n    {\n        PropertyName expRootName = _config.findRootName(rootType);\n        // 12-Jun-2015, tatu: Should try to support namespaces etc but...\n        String expSimpleName = expRootName.getSimpleName();\n\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        if (p.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        String actualName = p.getCurrentName();\n        if (!expSimpleName.equals(actualName)) {\n            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expSimpleName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        p.nextToken();\n        Object result;\n        if (_valueToUpdate == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            deser.deserialize(p, ctxt, _valueToUpdate);\n            result = _valueToUpdate;                    \n        }\n        // and last, verify that we now get matching END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expSimpleName+\"'), but \"+p.getCurrentToken());\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, format auto-detection\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(byte[] src, int offset, int length) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(src, offset, length);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        return match.getReader()._bindAndClose(p);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n         //The specific code has been omitted, but there is no error\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndClose(p);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException, JsonProcessingException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n         //The specific code has been omitted, but there is no error\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndReadValues(p);\n    }\n    \n    @SuppressWarnings(\"resource\")\n    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }\n    \n    /**\n     * Method called to indicate that format detection failed to detect format\n     * of given input\n     */\n    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException\n    {\n        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:\n        throw new JsonParseException(null, \"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString());\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n    {\n        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:\n        throw new JsonParseException(null, \"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\");\n    }\n\n    protected InputStream _inputStream(URL src) throws IOException {\n        return src.openStream();\n    }\n\n    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, locating deserializers etc\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        if (_rootDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Sanity check: must have actual type...\n        JavaType t = _valueType;\n        if (t == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(t);\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(t);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        _rootDeserializers.put(t, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    /**\n     * Method called to locate deserializer ahead of time, if permitted\n     * by configuration. Method also is NOT to throw an exception if\n     * access fails.\n     */\n    protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method to bind from {@link JsonPointer}.  \n     * {@link JsonPointerBasedFilter} is registered and will be used for parsing later. \n     * @since 2.6\n     */\n    public ObjectReader at(final String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method to bind from {@link JsonPointer}\n\t * {@link JsonPointerBasedFilter} is registered and will be used for parsing later.\n     * @since 2.6\n     */\n    public ObjectReader at(final JsonPointer pointer) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}