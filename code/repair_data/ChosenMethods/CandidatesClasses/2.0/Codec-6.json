{"Base64InputStream": "public class Base64InputStream extends FilterInputStream {\n\n    private final boolean doEncode;\n\n    private final Base64 base64;\n\n    private final byte[] singleByte = new byte[1];\n\n    /**\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     */\n    public Base64InputStream(InputStream in) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n     * provided InputStream.\n     * \n     * @param in\n     *            InputStream to wrap.\n     * @param doEncode\n     *            true if we should encode all data read from us, false if we should decode.\n     * @param lineLength\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n     *            false, lineLength is ignored.\n     * @param lineSeparator\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n     */\n    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Reads one <code>byte</code> from this input stream.\n     * \n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n     * @throws IOException\n     *             if an I/O error occurs.\n     */\n    public int read() throws IOException {\n        int r = read(singleByte, 0, 1);\n        while (r == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (r > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return -1;\n    }\n\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n         //The specific code has been omitted, but there is no error\n        } else if (offset < 0 || len < 0) {\n         //The specific code has been omitted, but there is no error\n        } else if (offset > b.length || offset + len > b.length) {\n         //The specific code has been omitted, but there is no error\n        } else if (len == 0) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    // A little optimization to avoid System.arraycopy()\n                    // when possible.\n                    if (c > 0 && b.length == len) {\n         //The specific code has been omitted, but there is no error\n        }\n                    if (doEncode) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            return base64.readResults(b, offset, len);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * \n     * @return false\n     */\n    public boolean markSupported() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}