{"CSVRecord": "public final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    String[] values() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n}"}