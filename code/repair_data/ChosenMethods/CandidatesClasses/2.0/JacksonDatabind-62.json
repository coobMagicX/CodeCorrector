{"CollectionDeserializer": "public class CollectionDeserializer\n    extends ContainerDeserializerBase<Collection<Object>>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = -1L; // since 2.5\n\n    // // Configuration\n\n    protected final JavaType _collectionType;\n    \n    /**\n     * Value deserializer.\n     */\n    protected final JsonDeserializer<Object> _valueDeserializer;\n\n    /**\n     * If element instances have polymorphic type information, this\n     * is the type deserializer that can handle it\n     */\n    protected final TypeDeserializer _valueTypeDeserializer;\n\n    // // Instance construction settings:\n\n    protected final ValueInstantiator _valueInstantiator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected final JsonDeserializer<Object> _delegateDeserializer;\n\n    /**\n     * Specific override for this instance (from proper, or global per-type overrides)\n     * to indicate whether single value may be taken to mean an unwrapped one-element array\n     * or not. If null, left to global defaults.\n     *\n     * @since 2.7\n     */\n    protected final Boolean _unwrapSingle;\n\n    // NOTE: no PropertyBasedCreator, as JSON Arrays have no properties\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor for context-free instances, where we do not yet know\n     * which property is using this deserializer.\n     */\n    public CollectionDeserializer(JavaType collectionType,\n            JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor used when creating contextualized instances.\n     */\n    protected CollectionDeserializer(JavaType collectionType,\n            JsonDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser,\n            ValueInstantiator valueInstantiator,\n            JsonDeserializer<Object> delegateDeser,\n            Boolean unwrapSingle)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write styling copying of settings of an existing instance.\n     */\n    protected CollectionDeserializer(CollectionDeserializer src)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Fluent-factory method call to construct contextual instance.\n     *\n     * @since 2.7\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd,\n            JsonDeserializer<?> vd, TypeDeserializer vtd,\n            Boolean unwrapSingle)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.7 as it does not pass `unwrapSingle`\n     */\n    @Deprecated // since 2.7 -- will not retain \"unwrapSingle\" setting\n    protected CollectionDeserializer withResolved(JsonDeserializer<?> dd,\n            JsonDeserializer<?> vd, TypeDeserializer vtd)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // Important: do NOT cache if polymorphic values\n    @Override // since 2.5\n    public boolean isCachable() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Validation, post-processing (ResolvableDeserializer)\n    /**********************************************************\n     */\n\n    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed\n     * for.\n     */\n    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegateDeser = null;\n        if (_valueInstantiator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        // also, often value deserializer is resolved here:\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (valueDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n        }\n        // and finally, type deserializer needs context as well\n        TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n        if (valueTypeDeser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n    }\n\n    /*\n    /**********************************************************\n    /* ContainerDeserializerBase API\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializer API\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        /* Empty String may be ok; bit tricky to check, however, since\n         * there is also possibility of \"auto-wrapping\" of single-element arrays.\n         * Hence we only accept empty String here.\n         */\n        if (p.hasToken(JsonToken.VALUE_STRING)) {\n            String str = p.getText();\n            if (str.length() == 0) {\n                return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n            }\n        }\n        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    @Override\n    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt,\n            Collection<Object> result)\n        throws IOException\n    {\n        // Ok: must point to START_ARRAY (or equivalent)\n        if (!p.isExpectedStartArrayToken()) {\n            return handleNonArray(p, ctxt, result);\n        }\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(result);\n\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        CollectionReferringAccumulator referringAccumulator =\n            (valueDes.getObjectIdReader() == null) ? null :\n                new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n\n        JsonToken t;\n        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n            try {\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (typeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                }\n                if (referringAccumulator != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    result.add(value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n         //The specific code has been omitted, but there is no error\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n    }\n\n    /**\n     * Helper method called when current token is no START_ARRAY. Will either\n     * throw an exception, or try to handle value as if member of implicit\n     * array, depending on configuration.\n     */\n    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt,\n            Collection<Object> result)\n        throws IOException\n    {\n        // Implicit arrays from single values?\n        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||\n                ((_unwrapSingle == null) &&\n                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));\n        if (!canWrap) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        JsonToken t = p.getCurrentToken();\n\n        Object value;\n\n        try {\n            if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (typeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n            }\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        result.add(value);\n        return result;\n    }\n\n    public final static class CollectionReferringAccumulator {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Helper class to maintain processing order of value. The resolved\n     * object associated with {@link #_id} comes before the values in\n     * {@link #next}.\n     */\n    private final static class CollectionReferring extends Referring {\n        private final CollectionReferringAccumulator _parent;\n        public final List<Object> next = new ArrayList<Object>();\n        \n        CollectionReferring(CollectionReferringAccumulator parent,\n                UnresolvedForwardReference reference, Class<?> contentType)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}", "CollectionReferringAccumulator": "    public final static class CollectionReferringAccumulator {\n         //The specific code has been omitted, but there is no error\n        }", "CollectionReferring": "    private final static class CollectionReferring extends Referring {\n        private final CollectionReferringAccumulator _parent;\n        public final List<Object> next = new ArrayList<Object>();\n        \n        CollectionReferring(CollectionReferringAccumulator parent,\n                UnresolvedForwardReference reference, Class<?> contentType)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }"}