{"TarArchiveOutputStream": "public class TarArchiveOutputStream extends ArchiveOutputStream {\n    /** Fail if a long file name is required in the archive. */\n    public static final int LONGFILE_ERROR = 0;\n\n    /** Long paths will be truncated in the archive. */\n    public static final int LONGFILE_TRUNCATE = 1;\n\n    /** GNU tar extensions are used to store long file names in the archive. */\n    public static final int LONGFILE_GNU = 2;\n\n    /** POSIX/PAX extensions are used to store long file names in the archive. */\n    public static final int LONGFILE_POSIX = 3;\n\n    /** Fail if a big number (e.g. size &gt; 8GiB) is required in the archive. */\n    public static final int BIGNUMBER_ERROR = 0;\n\n    /** star/GNU tar/BSD tar extensions are used to store big number in the archive. */\n    public static final int BIGNUMBER_STAR = 1;\n\n    /** POSIX/PAX extensions are used to store big numbers in the archive. */\n    public static final int BIGNUMBER_POSIX = 2;\n\n    private long      currSize;\n    private String    currName;\n    private long      currBytes;\n    private final byte[]    recordBuf;\n    private int       assemLen;\n    private final byte[]    assemBuf;\n    protected final TarBuffer buffer;\n    private int       longFileMode = LONGFILE_ERROR;\n    private int       bigNumberMode = BIGNUMBER_ERROR;\n\n    private boolean closed = false;\n\n    /** Indicates if putArchiveEntry has been called without closeArchiveEntry */\n    private boolean haveUnclosedEntry = false;\n\n    /** indicates if this archive is finished */\n    private boolean finished = false;\n\n    private final OutputStream out;\n\n    private final ZipEncoding encoding;\n\n    private boolean addPaxHeadersForNonAsciiNames = false;\n    private static final ZipEncoding ASCII =\n        ZipEncodingHelper.getZipEncoding(\"ASCII\");\n\n    /**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     */\n    public TarArchiveOutputStream(OutputStream os) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     * @param encoding name of the encoding to use for file names\n     * @since Commons Compress 1.4\n     */\n    public TarArchiveOutputStream(OutputStream os, String encoding) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     * @param blockSize the block size to use\n     */\n    public TarArchiveOutputStream(OutputStream os, int blockSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     * @param blockSize the block size to use\n     * @param encoding name of the encoding to use for file names\n     * @since Commons Compress 1.4\n     */\n    public TarArchiveOutputStream(OutputStream os, int blockSize,\n                                  String encoding) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     * @param blockSize the block size to use\n     * @param recordSize the record size to use\n     */\n    public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param os the output stream to use\n     * @param blockSize the block size to use\n     * @param recordSize the record size to use\n     * @param encoding name of the encoding to use for file names\n     * @since Commons Compress 1.4\n     */\n    public TarArchiveOutputStream(OutputStream os, int blockSize,\n                                  int recordSize, String encoding) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the long file mode.\n     * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).\n     * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).\n     * Default is LONGFILE_ERROR.\n     * @param longFileMode the mode to use\n     */\n    public void setLongFileMode(int longFileMode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the big number mode.\n     * This can be BIGNUMBER_ERROR(0), BIGNUMBER_POSIX(1) or BIGNUMBER_STAR(2).\n     * This specifies the treatment of big files (sizes &gt; TarConstants.MAXSIZE) and other numeric values to big to fit into a traditional tar header.\n     * Default is BIGNUMBER_ERROR.\n     * @param bigNumberMode the mode to use\n     * @since 1.4\n     */\n    public void setBigNumberMode(int bigNumberMode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Whether to add a PAX extension header for non-ASCII file names.\n     * @since 1.4\n     */\n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Deprecated\n    @Override\n    public int getCount() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public long getBytesWritten() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Ends the TAR archive without closing the underlying OutputStream.\n     * \n     * An archive consists of a series of file entries terminated by an\n     * end-of-archive entry, which consists of two 512 blocks of zero bytes. \n     * POSIX.1 requires two EOF records, like some other implementations.\n     * \n     * @throws IOException on error\n     */\n    @Override\n    public void finish() throws IOException {\n        if (finished) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (haveUnclosedEntry) {\n         //The specific code has been omitted, but there is no error\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        buffer.flushBlock();\n        finished = true;\n    }\n\n    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException {\n        if(!finished) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (!closed) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Get the record size being used by this stream's TarBuffer.\n     *\n     * @return The TarBuffer record size.\n     */\n    public int getRecordSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Put an entry on the output stream. This writes the entry's\n     * header record and positions the output stream for writing\n     * the contents of the entry. Once this method is called, the\n     * stream is ready for calls to write() to write the entry's\n     * contents. Once the contents are written, closeArchiveEntry()\n     * <B>MUST</B> be called to ensure that all buffered data\n     * is completely written to the output stream.\n     *\n     * @param archiveEntry The TarEntry to be written to the archive.\n     * @throws IOException on error\n     * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\n     */\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n         //The specific code has been omitted, but there is no error\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        final ByteBuffer encodedName = encoding.encode(entryName);\n        final int nameLen = encodedName.limit() - encodedName.position();\n        boolean paxHeaderContainsPath = false;\n        if (nameLen >= TarConstants.NAMELEN) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n         //The specific code has been omitted, but there is no error\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(entry.getLinkName())) {\n            paxHeaders.put(\"linkpath\", entry.getLinkName());\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, encoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n    /**\n     * Close an entry. This method MUST be called for all file\n     * entries that contain data. The reason is that we must\n     * buffer data written to the stream in order to satisfy\n     * the buffer's record based writes. Thus, there may be\n     * data fragments still being assembled that must be written\n     * to the output stream before this entry is closed and the\n     * next entry written.\n     * @throws IOException on error\n     */\n    @Override\n    public void closeArchiveEntry() throws IOException {\n        if (finished) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (!haveUnclosedEntry){\n         //The specific code has been omitted, but there is no error\n        }\n        if (assemLen > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (currBytes < currSize) {\n         //The specific code has been omitted, but there is no error\n        }\n        haveUnclosedEntry = false;\n    }\n\n    /**\n     * Writes bytes to the current tar archive entry. This method\n     * is aware of the current entry and will throw an exception if\n     * you attempt to write bytes past the length specified for the\n     * current entry. The method is also (painfully) aware of the\n     * record buffering required by TarBuffer, and manages buffers\n     * that are not a multiple of recordsize in length, including\n     * assembling records from small buffers.\n     *\n     * @param wBuf The buffer to write to the archive.\n     * @param wOffset The offset in the buffer from which to get bytes.\n     * @param numToWrite The number of bytes to write.\n     * @throws IOException on error\n     */\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (assemLen > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n         //The specific code has been omitted, but there is no error\n        }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n\n    private String stripTo7Bits(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Write an EOF (end of archive) record to the tar archive.\n     * An EOF record consists of a record of all zeros.\n     */\n    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        buffer.writeRecord(recordBuf);\n    }\n\n    @Override\n    public void flush() throws IOException {\n        out.flush();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        if(finished) {\n         //The specific code has been omitted, but there is no error\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }\n\n    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\n                                            TarArchiveEntry entry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders,\n                                          String header, long value,\n                                          long maxValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void failForBigNumbers(TarArchiveEntry entry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void failForBigNumber(String field, long value, long maxValue) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}