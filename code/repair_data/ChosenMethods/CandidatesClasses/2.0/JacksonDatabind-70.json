{"BeanPropertyMap": "public class BeanPropertyMap\n    implements Iterable<SettableBeanProperty>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 2L;\n\n    /**\n     * @since 2.5\n     */\n    protected final boolean _caseInsensitive;\n\n    private int _hashMask;\n\n    /**\n     * Number of entries stored in the hash area.\n     */\n    private int _size;\n    \n    private int _spillCount;\n\n    /**\n     * Hash area that contains key/property pairs in adjacent elements.\n     */\n    private Object[] _hashArea;\n\n    /**\n     * Array of properties in the exact order they were handed in. This is\n     * used by as-array serialization, deserialization.\n     */\n    private SettableBeanProperty[] _propsInOrder;\n\n    public BeanPropertyMap(boolean caseInsensitive, Collection<SettableBeanProperty> props)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.8\n     */\n    protected BeanPropertyMap(BeanPropertyMap base, boolean caseInsensitive)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Mutant factory method that constructs a new instance if desired case-insensitivity\n     * state differs from the state of this instance; if states are the same, returns\n     * <code>this</code>.\n     *\n     * @since 2.8\n     */\n    public BeanPropertyMap withCaseInsensitivity(boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected void init(Collection<SettableBeanProperty> props)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    private final static int findSize(int size)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * @since 2.6\n     */\n    public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Fluent copy method that creates a new instance that is a copy\n     * of this instance except for one additional property that is\n     * passed as the argument.\n     * Note that method does not modify this instance but constructs\n     * and returns a new one.\n     */\n    public BeanPropertyMap withProperty(SettableBeanProperty newProp)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BeanPropertyMap assignIndexes()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Mutant factory method for constructing a map where all entries use given\n     * prefix\n     */\n    public BeanPropertyMap renameAll(NameTransformer transformer)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Mutant factory method that will use this instance as the base, and\n     * construct an instance that is otherwise same except for excluding\n     * properties with specified names.\n     *\n     * @since 2.8\n     */\n    public BeanPropertyMap withoutProperties(Collection<String> toExclude)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Specialized method that can be used to replace an existing entry\n     * (note: entry MUST exist; otherwise exception is thrown) with\n     * specified replacement.\n     */\n    public void replace(SettableBeanProperty newProp)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private List<SettableBeanProperty> properties() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Accessor for traversing over all contained properties.\n     */\n    @Override\n    public Iterator<SettableBeanProperty> iterator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that will re-create initial insertion-ordering of\n     * properties contained in this map. Note that if properties\n     * have been removed, array may contain nulls; otherwise\n     * it should be consecutive.\n     * \n     * @since 2.1\n     */\n    public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // Confining this case insensitivity to this function (and the find method) in case we want to\n    // apply a particular locale to the lower case function.  For now, using the default.\n    protected final String getPropertyName(SettableBeanProperty prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public SettableBeanProperty find(int index)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public SettableBeanProperty find(String key)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private final SettableBeanProperty _find2(String key, int slot, Object match)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public int size() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, String key) throws IOException\n    {\n        final SettableBeanProperty prop = find(key);\n        if (prop == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        try {\n            prop.deserializeAndSet(p, ctxt, bean);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return true;\n    }\n\n    @Override\n    public String toString()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)\n        throws IOException\n    {\n        // inlined 'throwOrReturnThrowable'\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors to be passed as is\n        if (t instanceof Error) {\n         //The specific code has been omitted, but there is no error\n        }\n        // StackOverflowErrors are tricky ones; need to be careful...\n        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n        // Ditto for IOExceptions; except we may want to wrap JSON exceptions\n        if (t instanceof IOException) {\n         //The specific code has been omitted, but there is no error\n        } else if (!wrap) {\n         //The specific code has been omitted, but there is no error\n        }\n        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n    }\n\n    /**\n     * Helper method used to find exact location of a property with name\n     * given exactly, not subject to case changes, within hash area.\n     * Expectation is that such property SHOULD exist, although no\n     * exception is thrown.\n     *\n     * @since 2.7\n     */\n    private final int _findIndexInHash(String key)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    private final int _findFromOrdered(SettableBeanProperty prop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // Offlined version for convenience if we want to change hashing scheme\n    private final int _hashCode(String key) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}