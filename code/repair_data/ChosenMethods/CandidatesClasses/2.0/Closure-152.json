{"FunctionType": "public class FunctionType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n\n  private enum Kind {\n    ORDINARY,\n    CONSTRUCTOR,\n    INTERFACE\n  }\n\n  /**\n   * {@code [[Call]]} property.\n   */\n  private ArrowType call;\n\n  /**\n   * The {@code prototype} property. This field is lazily initialized by\n   * {@code #getPrototype()}. The most important reason for lazily\n   * initializing this field is that there are cycles in the native types\n   * graph, so some prototypes must temporarily be {@code null} during\n   * the construction of the graph.\n   */\n  private FunctionPrototypeType prototype;\n\n  /**\n   * Whether a function is a constructor, an interface, or just an ordinary\n   * function.\n   */\n  private final Kind kind;\n\n  /**\n   * The type of {@code this} in the scope of this function.\n   */\n  private ObjectType typeOfThis;\n\n  /**\n   * The function node which this type represents. It may be {@code null}.\n   */\n  private Node source;\n\n  /**\n   * The interfaces directly implemented by this function.\n   * It is only relevant for constructors. May not be {@code null}.\n   */\n  private List<ObjectType> implementedInterfaces = ImmutableList.of();\n\n  /**\n   * The types which are subtypes of this function. It is only relevant for\n   * constructors and may be {@code null}.\n   */\n  private List<FunctionType> subTypes;\n\n  /**\n   * The template type name. May be {@code null}.\n   */\n  private String templateTypeName;\n\n  /** Creates an instance for a function that might be a constructor. */\n  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Creates an instance for a function that is an interface. */\n  private FunctionType(JSTypeRegistry registry, String name, Node source) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Creates an instance for a function that is an interface. */\n  static FunctionType forInterface(\n      JSTypeRegistry registry, String name, Node source) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isInstanceType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isConstructor() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isInterface() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isOrdinaryFunction() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isFunctionType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean canBeCalled() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public Iterable<Node> getParameters() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets an LP node that contains all params. May be null. */\n  public Node getParametersNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets the minimum number of arguments that this function requires. */\n  public int getMinArguments() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the maximum number of arguments that this function requires,\n   * or Integer.MAX_VALUE if this is a variable argument function.\n   */\n  public int getMaxArguments() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public JSType getReturnType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isReturnTypeInferred() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets the internal arrow type. For use by subclasses only. */\n  ArrowType getInternalArrowType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the {@code prototype} property of this function type. This is\n   * equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}.\n   */\n  public FunctionPrototypeType getPrototype() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n  public void setPrototypeBasedOn(ObjectType baseType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n  public boolean setPrototype(FunctionPrototypeType prototype) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns all interfaces implemented by a class or its superclass and any\n   * superclasses for any of those interfaces. If this is called before all\n   * types are resolved, it may return an incomplete set.\n   */\n  public Iterable<ObjectType> getAllImplementedInterfaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns interfaces implemented directly by a class or its superclass. */\n  public Iterable<ObjectType> getImplementedInterfaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean hasProperty(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean hasOwnProperty(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType getPropertyType(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean isPropertyTypeInferred(String property) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType getLeastSupertype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public JSType getGreatestSubtype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the supremum or infimum of functions with other types.\n   * Because sup() and inf() share a lot of logic for functions, we use\n   * a single helper.\n   * @param leastSuper If true, compute the supremum of {@code this} with\n   *     {@code that}. Otherwise compute the infimum.\n   * @return The least supertype or greatest subtype.\n   */\n  private JSType supAndInfHelper(JSType that, boolean leastSuper) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to get the sup/inf of two functions by looking at the\n   * piecewise components.\n   */\n  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given a constructor or an interface type, get its superclass constructor\n   * or {@code null} if none exists.\n   */\n  public FunctionType getSuperClassConstructor() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given a constructor or an interface type, find out whether the unknown\n   * type is a supertype of the current type.\n   */\n  public boolean hasUnknownSupertype() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given a constructor or an interface type and a property, finds the\n   * top-most superclass that has the property defined (including this\n   * constructor).\n   */\n  public JSType getTopMostDefiningType(String propertyName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Two function types are equal if their signatures match. Since they don't\n   * have signatures, two interfaces are equal if their names match.\n   */\n  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean hasEqualCallType(FunctionType otherType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Informally, a function is represented by\n   * {@code function (params): returnType} where the {@code params} is a comma\n   * separated list of types, the first one being a special\n   * {@code this:T} if the function expects a known type for {@code this}.\n   */\n  @Override\n  public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets the string representation of a var args param. */\n  private void appendVarArgsString(StringBuilder builder, JSType paramType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A function is a subtype of another if their call methods are related via\n   * subtyping and {@code this} is a subtype of {@code that} with regard to\n   * the prototype chain.\n   */\n  @Override\n  public boolean isSubtype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public <T> T visit(Visitor<T> visitor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the type of instance of this function.\n   * @throws IllegalStateException if this function is not a constructor\n   *         (see {@link #isConstructor()}).\n   */\n  public ObjectType getInstanceType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Sets the instance type. This should only be used for special native types. */\n  void setInstanceType(ObjectType instanceType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns whether this function type has an instance type.\n   */\n  public boolean hasInstanceType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the type of {@code this} in this function.\n   */\n  public ObjectType getTypeOfThis() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the source node or null if this is an unknown function.\n   */\n  public Node getSource() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the source node.\n   */\n  public void setSource(Node source) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Adds a type to the list of subtypes for this type. */\n  private void addSubType(FunctionType subType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a list of types that are subtypes of this type. This is only valid\n   * for constructor functions, and may be null. This allows a downward\n   * traversal of the subtype graph.\n   */\n  public List<FunctionType> getSubTypes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean hasCachedValues() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the template type name.\n   */\n  public String getTemplateTypeName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public String toDebugHashCodeString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private String getDebugHashCodeStringOf(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}