{"FromXmlParser": "public class FromXmlParser\n    extends ParserMinimalBase\n{\n    /**\n     * The default name placeholder for XML text segments is empty\n     * String (\"\").\n     */\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n    /**\n     * Enumeration that defines all togglable features for XML parsers.\n     * None defined so far (2.6), so just a placeholder.\n     */\n    public enum Feature implements FormatFeature\n    {\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        private Feature(boolean defaultState) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override public boolean enabledByDefault() {\n         //The specific code has been omitted, but there is no error\n        }\n        @Override public int getMask() {\n         //The specific code has been omitted, but there is no error\n        }\n        @Override public boolean enabledIn(int flags) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * In cases where a start element has both attributes and non-empty textual\n     * value, we have to create a bogus property; we will use this as\n     * the property name.\n     *<p>\n     * Name used for pseudo-property used for returning XML Text value (which does\n     * not have actual element name to use). Defaults to empty String, but\n     * may be changed for interoperability reasons: JAXB, for example, uses\n     * \"value\" as name.\n     * \n     * @since 2.1\n     */\n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link FromXmlParser.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    protected ObjectCodec _objectCodec;\n\n    /*\n    /**********************************************************\n    /* I/O state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected XmlReadContext _parsingContext;\n\n    protected final XmlTokenStream _xmlTokens;\n    /**\n     * \n     * We need special handling to keep track of whether a value\n     * may be exposed as simple leaf value.\n     */\n    protected boolean _mayBeLeaf;\n\n    protected JsonToken _nextToken;\n\n    protected String _currText;\n\n    protected Set<String> _namesToWrap;\n\n    /*\n    /**********************************************************\n    /* Parsing state, parsed values\n    /**********************************************************\n     */\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder = null;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamReader xmlReader)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Version version() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public ObjectCodec getCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public FromXmlParser enable(Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public FromXmlParser disable(Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public final boolean isEnabled(Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*                                                                                       \n    /**********************************************************                              \n    /* FormatFeature support                                                                             \n    /**********************************************************                              \n     */\n\n    @Override\n    public int getFormatFeatures() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamReader getStaxReader() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Internal API\n    /**********************************************************\n     */\n\n    /**\n     * Method that may be called to indicate that specified names\n     * (only local parts retained currently: this may be changed in\n     * future) should be considered \"auto-wrapping\", meaning that\n     * they will be doubled to contain two opening elements, two\n     * matching closing elements. This is needed for supporting\n     * handling of so-called \"unwrapped\" array types, something\n     * XML mappings like JAXB often use.\n     *<p>\n     * NOTE: this method is considered part of internal implementation\n     * interface, and it is <b>NOT</b> guaranteed to remain unchanged\n     * between minor versions (it is however expected not to change in\n     * patch versions). So if you have to use it, be prepared for\n     * possible additional work.\n     * \n     * @since 2.1\n     */\n    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public void close() throws IOException\n    {\n        if (!_closed) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    @Override\n    public boolean isClosed() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Since xml representation can not really distinguish between array\n     * and object starts (both are represented with elements), this method\n     * is overridden and taken to mean that expecation is that the current\n     * start element is to mean 'start array', instead of default of\n     * 'start object'.\n     */\n    @Override\n    public boolean isExpectedStartArrayToken()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // DEBUGGING\n    /*\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        JsonToken t = nextToken0();\n        if (t != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return t;\n    }\n\n//    public JsonToken nextToken0() throws IOException\n */\n\n    \n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of specialized nextXxx() methods\n    /**********************************************************\n     */\n\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (_currToken) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (t) {\n         //The specific code has been omitted, but there is no error\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    /**\n     * XML input actually would offer access to character arrays; but since\n     * we must coalesce things it cannot really be exposed.\n     */\n    @Override\n    public boolean hasTextCharacters()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n         //The specific code has been omitted, but there is no error\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    /*\n    /**********************************************************\n    /* Numeric accessors\n    /**********************************************************\n     */\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract method impls for stuff from JsonParser\n    /**********************************************************\n     */\n\n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException\n    {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * parser.\n     */\n    protected void _releaseBuffers() throws IOException {\n        // anything we can/must release? Underlying parser should do all of it, for now?\n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected boolean _isEmpty(String str)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}