{"ZipArchiveInputStream": "public class ZipArchiveInputStream extends ArchiveInputStream {\n\n    /** The zip encoding to use for filenames and the file comment. */\n    private final ZipEncoding zipEncoding;\n\n    /** Whether to look for and use Unicode extra fields. */\n    private final boolean useUnicodeExtraFields;\n\n    /** Wrapped stream, will always be a PushbackInputStream. */\n    private final InputStream in;\n\n    /** Inflater used for all deflated entries. */\n    private final Inflater inf = new Inflater(true);\n\n    /** Buffer used to read from the wrapped stream. */\n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n\n    /** The entry that is currently being read. */\n    private CurrentEntry current = null;\n\n    /** Whether the stream has been closed. */\n    private boolean closed = false;\n\n    /** Whether the stream has reached the central directory - and thus found all entries. */\n    private boolean hitCentralDirectory = false;\n\n    /**\n     * When reading a stored entry that uses the data descriptor this\n     * stream has to read the full entry and caches it.  This is the\n     * cache.\n     */\n    private ByteArrayInputStream lastStoredEntry = null;\n\n    /** Whether the stream will try to read STORED entries that use a data descriptor. */\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n\n    private static final int LFH_LEN = 30;\n    /*\n      local file header signature     WORD\n      version needed to extract       SHORT\n      general purpose bit flag        SHORT\n      compression method              SHORT\n      last mod file time              SHORT\n      last mod file date              SHORT\n      crc-32                          WORD\n      compressed size                 WORD\n      uncompressed size               WORD\n      file name length                SHORT\n      extra field length              SHORT\n    */\n\n    private static final int CFH_LEN = 46;\n    /*\n        central file header signature   WORD\n        version made by                 SHORT\n        version needed to extract       SHORT\n        general purpose bit flag        SHORT\n        compression method              SHORT\n        last mod file time              SHORT\n        last mod file date              SHORT\n        crc-32                          WORD\n        compressed size                 WORD\n        uncompressed size               WORD\n        file name length                SHORT\n        extra field length              SHORT\n        file comment length             SHORT\n        disk number start               SHORT\n        internal file attributes        SHORT\n        external file attributes        WORD\n        relative offset of local header WORD\n    */\n\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n\n    // cached buffers - must only be used locally in the class (COMPRESS-172 - reduce garbage collection)\n    private final byte[] LFH_BUF = new byte[LFH_LEN];\n    private final byte[] SKIP_BUF = new byte[1024];\n    private final byte[] SHORT_BUF = new byte[SHORT];\n    private final byte[] WORD_BUF = new byte[WORD];\n    private final byte[] TWO_DWORD_BUF = new byte[2 * DWORD];\n\n    private int entriesRead = 0;\n\n    public ZipArchiveInputStream(InputStream inputStream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @since 1.5\n     */\n    public ZipArchiveInputStream(InputStream inputStream, String encoding) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (current != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        try {\n            if (firstEntry) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != -1) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }\n\n    /**\n     * Fills the given array with the first local file header and\n     * deals with splitting/spanning markers that may prefix the first\n     * LFH.\n     */\n    private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\n        readFully(lfh);\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            // The archive is not really split as only one segment was\n            // needed in the end.  Just skip over the marker.\n            byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    /**\n     * Records whether a Zip64 extra is present and sets the size\n     * information from it if sizes are 0xFFFFFFFF and the entry\n     * doesn't use a data descriptor.\n     */\n    private void processZip64Extra(ZipLong size, ZipLong cSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    /**\n     * Whether this class is able to read the given entry.\n     *\n     * <p>May return false if it is set up to use encryption or a\n     * compression method that hasn't been implemented yet.</p>\n     * @since 1.1\n     */\n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int read(byte[] buffer, int offset, int length) throws IOException {\n        if (closed) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (current == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // avoid int overflow, check null buffer\n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n        \n        if (read >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return read;\n    }\n\n    /**\n     * Implementation of read for STORED entries.\n     */\n    private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            int l = in.read(buf.array());\n            if (l == -1) {\n         //The specific code has been omitted, but there is no error\n        }\n            buf.limit(l);\n\n            count(buf.limit());\n            current.bytesReadFromStream += buf.limit();\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    /**\n     * Implementation of read for DEFLATED entries.\n     */\n    private int readDeflated(byte[] buffer, int offset, int length) throws IOException {\n        int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return read;\n    }\n\n    /**\n     * Potentially reads more bytes to fill the inflater's buffer and\n     * reads from it.\n     */\n    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                int l = fill();\n                if (l > 0) {\n         //The specific code has been omitted, but there is no error\n        } else if (l == -1) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (DataFormatException e) {\n         //The specific code has been omitted, but there is no error\n        }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Skips over and discards value bytes of data from this input\n     * stream.\n     *\n     * <p>This implementation may end up skipping over some smaller\n     * number of bytes, possibly 0, if and only if it reaches the end\n     * of the underlying stream.</p>\n     *\n     * <p>The actual number of bytes skipped is returned.</p>\n     *\n     * @param value the number of bytes to be skipped.\n     * @return the actual number of bytes skipped.\n     * @throws IOException - if an I/O error occurs.\n     * @throws IllegalArgumentException - if value is negative.\n     */\n    @Override\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Checks if the signature matches what is expected for a zip file.\n     * Does not currently handle self-extracting zips which may have arbitrary\n     * leading content.\n     *\n     * @param signature the bytes to check\n     * @param length    the number of bytes to check\n     * @return true, if this stream is a zip archive stream, false otherwise\n     */\n    public static boolean matches(byte[] signature, int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static boolean checksig(byte[] signature, byte[] expected) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Closes the current ZIP archive entry and positions the underlying\n     * stream to the beginning of the next entry. All per-entry variables\n     * and data structures are cleared.\n     * <p>\n     * If the compressed size of this entry is included in the entry header,\n     * then any outstanding bytes are simply skipped from the underlying\n     * stream without uncompressing them. This allows an entry to be safely\n     * closed even if the compression method is unsupported.\n     * <p>\n     * In case we don't know the compressed size of this entry or have\n     * already buffered too much data from the underlying stream to support\n     * uncompression, then the uncompression process is completed and the\n     * end position of the stream is adjusted based on the result of that\n     * process.\n     *\n     * @throws IOException if an error occurs\n     */\n    private void closeEntry() throws IOException {\n        if (closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (current == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Ensure all entry bytes are read\n        if (current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor) {\n            drainCurrentEntryData();\n        } else {\n            skip(Long.MAX_VALUE);\n\n            long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            // this is at most a single read() operation and can't\n            // exceed the range of int\n            int diff = (int) (current.bytesReadFromStream - inB);\n\n            // Pushback any required bytes\n            if (diff > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    /**\n     * Read all data of the current entry from the underlying stream\n     * that hasn't been read, yet.\n     */\n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Get the number of bytes Inflater has actually processed.\n     *\n     * <p>for Java &lt; Java7 the getBytes* methods in\n     * Inflater/Deflater seem to return unsigned ints rather than\n     * longs that start over with 0 at 2^32.</p>\n     *\n     * <p>The stream knows how many bytes it has read, but not how\n     * many the Inflater actually consumed - it should be between the\n     * total number of bytes read for the entry and the total number\n     * minus the last read operation.  Here we just try to make the\n     * value close enough to the bytes we've read by assuming the\n     * number of bytes consumed must be smaller than (or equal to) the\n     * number of bytes read but not smaller by more than 2^32.</p>\n     */\n    private long getBytesInflated() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private int fill() throws IOException {\n        if (closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        int length = in.read(buf.array());\n        if (length > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return length;\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = IOUtils.readFully(in, b);\n        count(count);\n        if (count < b.length) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(WORD_BUF);\n        ZipLong val = new ZipLong(WORD_BUF);\n        if (ZipLong.DD_SIG.equals(val)) {\n            // data descriptor with signature, skip sig\n            readFully(WORD_BUF);\n            val = new ZipLong(WORD_BUF);\n        }\n        current.entry.setCrc(val.getValue());\n\n        // if there is a ZIP64 extra field, sizes are eight bytes\n        // each, otherwise four bytes each.  Unfortunately some\n        // implementations - namely Java7 - use eight bytes without\n        // using a ZIP64 extra field -\n        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588\n\n        // just read 16 bytes and check whether bytes nine to twelve\n        // look like one of the signatures of what could follow a data\n        // descriptor (ignoring archive decryption headers for now).\n        // If so, push back eight bytes and assume sizes are four\n        // bytes, otherwise sizes are eight bytes each.\n        readFully(TWO_DWORD_BUF);\n        ZipLong potentialSig = new ZipLong(TWO_DWORD_BUF, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(TWO_DWORD_BUF, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipLong.getValue(TWO_DWORD_BUF, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(TWO_DWORD_BUF, DWORD));\n        }\n    }\n\n    /**\n     * Whether this entry requires a data descriptor this library can work with.\n     *\n     * @return true if allowStoredEntriesWithDataDescriptor is true,\n     * the entry doesn't require any data descriptor or the method is\n     * DEFLATED.\n     */\n    private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Caches a stored entry that uses the data descriptor.\n     *\n     * <ul>\n     *   <li>Reads a stored entry until the signature of a local file\n     *     header, central directory header or data descriptor has been\n     *     found.</li>\n     *   <li>Stores all entry data in lastStoredEntry.</p>\n     *   <li>Rewinds the stream to position at the data\n     *     descriptor.</li>\n     *   <li>reads the data descriptor</li>\n     * </ul>\n     *\n     * <p>After calling this method the entry should know its size,\n     * the entry's data is cached and the stream is positioned at the\n     * next local file or central directory header.</p>\n     */\n    private void readStoredEntry() throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        // length of DD without signature\n        int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\n    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\n    private static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n    /**\n     * Checks whether the current buffer contains the signature of a\n     * &quot;data decsriptor&quot;, &quot;local file header&quot; or\n     * &quot;central directory entry&quot;.\n     *\n     * <p>If it contains such a signature, reads the data descriptor\n     * and positions the stream right after the data descriptor.</p>\n     */\n    private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        return done;\n    }\n\n    /**\n     * If the last read bytes could hold a data descriptor and an\n     * incomplete signature then save the last bytes to the front of\n     * the buffer and cache everything in front of the potential data\n     * descriptor into the given ByteArrayOutputStream.\n     *\n     * <p>Data descriptor plus incomplete signature (3 bytes in the\n     * worst case) can be 20 bytes max.</p>\n     */\n    private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expecteDDLen) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void pushback(byte[] buf, int offset, int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    // End of Central Directory Record\n    //   end of central dir signature    WORD\n    //   number of this disk             SHORT\n    //   number of the disk with the\n    //   start of the central directory  SHORT\n    //   total number of entries in the\n    //   central directory on this disk  SHORT\n    //   total number of entries in\n    //   the central directory           SHORT\n    //   size of the central directory   WORD\n    //   offset of start of central\n    //   directory with respect to\n    //   the starting disk number        WORD\n    //   .ZIP file comment length        SHORT\n    //   .ZIP file comment               up to 64KB\n    //\n\n    /**\n     * Reads the stream until it find the \"End of central directory\n     * record\" and consumes it as well.\n     */\n    private void skipRemainderOfArchive() throws IOException {\n        // skip over central directory. One LFH has been read too much\n        // already.  The calculation discounts file names and extra\n        // data so it will be too short.\n        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip(ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n        readFully(SHORT_BUF);\n        // file comment\n        realSkip(ZipShort.getValue(SHORT_BUF));\n    }\n\n    /**\n     * Reads forward until the signature of the &quot;End of central\n     * directory&quot; record is found.\n     */\n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n         //The specific code has been omitted, but there is no error\n        }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n         //The specific code has been omitted, but there is no error\n        }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n         //The specific code has been omitted, but there is no error\n        }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    /**\n     * Skips bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link\n     * #skip} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private void realSkip(long value) throws IOException {\n        if (value >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /**\n     * Reads bytes by reading from the underlying stream rather than\n     * the (potentially inflating) archive stream - which {@link #read} would do.\n     *\n     * Also updates bytes-read counter.\n     */\n    private int readOneByte() throws IOException {\n        int b = in.read();\n        if (b != -1) {\n         //The specific code has been omitted, but there is no error\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(int b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Structure collecting information for the entry that is\n     * currently being read.\n     */\n    private static final class CurrentEntry {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Bounded input stream adapted from commons-io\n     */\n    private class BoundedInputStream extends InputStream {\n\n        /** the wrapped input stream */\n        private final InputStream in;\n\n        /** the max length to provide */\n        private final long max;\n\n        /** the number of bytes already returned */\n        private long pos = 0;\n    \n        /**\n         * Creates a new <code>BoundedInputStream</code> that wraps the given input\n         * stream and limits it to a certain size.\n         *\n         * @param in The wrapped input stream\n         * @param size The maximum number of bytes to return\n         */\n        public BoundedInputStream(final InputStream in, final long size) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n         //The specific code has been omitted, but there is no error\n        }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n         //The specific code has been omitted, but there is no error\n        }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n    \n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n         //The specific code has been omitted, but there is no error\n        }\n            return in.available();\n        }\n    }\n}", "CurrentEntry": "    private static final class CurrentEntry {\n         //The specific code has been omitted, but there is no error\n        }", "BoundedInputStream": "    private class BoundedInputStream extends InputStream {\n\n        /** the wrapped input stream */\n        private final InputStream in;\n\n        /** the max length to provide */\n        private final long max;\n\n        /** the number of bytes already returned */\n        private long pos = 0;\n    \n        /**\n         * Creates a new <code>BoundedInputStream</code> that wraps the given input\n         * stream and limits it to a certain size.\n         *\n         * @param in The wrapped input stream\n         * @param size The maximum number of bytes to return\n         */\n        public BoundedInputStream(final InputStream in, final long size) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n         //The specific code has been omitted, but there is no error\n        }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n         //The specific code has been omitted, but there is no error\n        }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n    \n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n         //The specific code has been omitted, but there is no error\n        }\n            return in.available();\n        }\n    }"}