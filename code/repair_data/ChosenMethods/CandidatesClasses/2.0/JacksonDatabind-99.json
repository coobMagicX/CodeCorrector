{"ReferenceType": "public class ReferenceType extends SimpleType\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final JavaType _referencedType;\n\n    /**\n     * Essential type used for type ids, for example if type id is needed for\n     * referencing type with polymorphic handling. Typically initialized when\n     * a {@link SimpleType} is upgraded into reference type, but NOT changed\n     * if being sub-classed.\n     *\n     * @since 2.8\n     */\n    protected final JavaType _anchorType;\n\n    protected ReferenceType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType refType,\n            JavaType anchorType,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor used when upgrading into this type (via {@link #upgradeFrom},\n     * the usual way for {@link ReferenceType}s to come into existence.\n     * Sets up what is considered the \"base\" reference type\n     *\n     * @since 2.7\n     */\n    protected ReferenceType(TypeBase base, JavaType refType)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method that can be used to \"upgrade\" a basic type into collection-like\n     * one; usually done via {@link TypeModifier}\n     * \n     * @param baseType Resolved non-reference type (usually {@link SimpleType}) that is being upgraded\n     * @param refdType Referenced type; usually the first and only type parameter, but not necessarily\n     *\n     * @since 2.7\n     */\n    public static ReferenceType upgradeFrom(JavaType baseType, JavaType refdType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.7\n     */\n    public static ReferenceType construct(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, JavaType refType)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Deprecated // since 2.7\n    public static ReferenceType construct(Class<?> cls, JavaType refType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceType withTypeHandler(Object h)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceType withContentTypeHandler(Object h)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceType withValueHandler(Object h) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceType withContentValueHandler(Object h) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Narrow/widen\n    /**********************************************************\n     */\n\n    @Override\n    @Deprecated // since 2.7\n    protected JavaType _narrow(Class<?> subclass)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JavaType getReferencedType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean hasContentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean isReferenceType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public JavaType getAnchorType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience accessor that allows checking whether this is the anchor type\n     * itself; if not, it must be one of supertypes that is also a {@link ReferenceType}\n     */\n    public boolean isAnchorType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean equals(Object o)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}