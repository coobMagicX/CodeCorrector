{"TypeFactory": "public final class TypeFactory\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    private final static JavaType[] NO_TYPES = new JavaType[0];\n\n    /**\n     * Globally shared singleton. Not accessed directly; non-core\n     * code should use per-ObjectMapper instance (via configuration objects).\n     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n     */\n    protected final static TypeFactory instance = new TypeFactory();\n    \n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    // // // Let's assume that a small set of core primitive/basic types\n    // // // will not be modified, and can be freely shared to streamline\n    // // // parts of processing\n    \n    protected final static SimpleType CORE_TYPE_STRING = new SimpleType(String.class);\n    protected final static SimpleType CORE_TYPE_BOOL = new SimpleType(Boolean.TYPE);\n    protected final static SimpleType CORE_TYPE_INT = new SimpleType(Integer.TYPE);\n    protected final static SimpleType CORE_TYPE_LONG = new SimpleType(Long.TYPE);\n\n    /**\n     * Since type resolution can be expensive (specifically when resolving\n     * actual generic types), we will use small cache to avoid repetitive\n     * resolution of core types\n     */\n    protected final LRUMap<ClassKey, JavaType> _typeCache = new LRUMap<ClassKey, JavaType>(16, 100);\n\n    /*\n     * Looks like construction of {@link JavaType} instances can be\n     * a bottleneck, esp. for root-level Maps, so we better do bit\n     * of low-level component caching here...\n     */\n    \n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedHashMapType;\n\n    /**\n     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n     * to its supertypes.\n     */\n    protected transient HierarchicType _cachedArrayListType;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Registered {@link TypeModifier}s: objects that can change details\n     * of {@link JavaType} instances factory constructs.\n     */\n    protected final TypeModifier[] _modifiers;\n    \n    protected final TypeParser _parser;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    private TypeFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public TypeFactory withModifier(TypeModifier mod) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to access the globally shared instance, which has\n     * no custom configuration. Used by <code>ObjectMapper</code> to\n     * get the default factory when constructed.\n     */\n    public static TypeFactory defaultInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that will clear up any cached type definitions that may\n     * be cached by this {@link TypeFactory} instance.\n     * This method should not be commonly used, that is, only use it\n     * if you know there is a problem with retention of type definitions;\n     * the most likely (and currently only known) problem is retention\n     * of {@link Class} instances via {@link JavaType} reference.\n     * \n     * @since 2.4.1\n     */\n    public void clearCache() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Static methods for non-instance-specific functionality\n    /**********************************************************\n     */\n    \n    /**\n     * Method for constructing a marker type that indicates missing generic\n     * type information, which is handled same as simple type for\n     * <code>java.lang.Object</code>.\n     */\n    public static JavaType unknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Static helper method that can be called to figure out type-erased\n     * call for given JDK type. It can be called statically since type resolution\n     * process can never change actual type-erased class; thereby static\n     * default instance is used for determination.\n     */\n    public static Class<?> rawClass(Type t) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Type conversion, parameterization resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for creating a subtype of given base type, as defined\n     * by specified subclass; but retaining generic type information if any.\n     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer>\"\n     * from \"Map&ltString,Integer>\" by giving <code>HashMap.class</code>\n     * as subclass.\n     */\n    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing a {@link JavaType} out of its canonical\n     * representation (see {@link JavaType#toCanonical()}).\n     * \n     * @param canonical Canonical string representation of a type\n     * \n     * @throws IllegalArgumentException If canonical representation is malformed,\n     *   or class that type represents (including its generic parameters) is\n     *   not found\n     */\n    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }\n    \n    /**\n     * Method that is to figure out actual type parameters that given\n     * class binds to generic types defined by given (generic)\n     * interface or class.\n     * This could mean, for example, trying to figure out\n     * key and value types for Map implementations.\n     * \n     * @param type Sub-type (leaf type) that implements <code>expType</code>\n     */\n    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that can be called to figure out more specific of two\n     * types (if they are related; that is, one implements or extends the\n     * other); or if not related, return the primary type.\n     * \n     * @param type1 Primary type to consider\n     * @param type2 Secondary type to consider\n     * \n     * @since 2.2\n     */\n    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Public factory methods\n    /**********************************************************\n     */\n\n    public JavaType constructType(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public JavaType constructType(Type type, TypeBindings bindings) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public JavaType constructType(TypeReference<?> typeRef) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public JavaType constructType(Type type, Class<?> context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public JavaType constructType(Type type, JavaType context) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method that can be used if type information is passed\n     * as Java typing returned from <code>getGenericXxx</code> methods\n     * (usually for a return or argument type).\n     */\n    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Direct factory methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for element type (and other contained types)\n     */\n    public ArrayType constructArrayType(Class<?> elementType) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing an {@link ArrayType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on array type itself; but are called\n     * for contained types.\n     */\n    public ArrayType constructArrayType(JavaType elementType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a {@link CollectionType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n     * for contained types.\n     */\n    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a {@link CollectionLikeType}.\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a {@link MapType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a {@link MapLikeType} instance\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     */\n    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for constructing a type instance with specified parameterization.\n     * \n     * @deprecated Since 2.5, use variant that takes one more argument\n     */\n    @Deprecated\n    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n         //The specific code has been omitted, but there is no error\n        } \n\n    /**\n     * Method that will force construction of a simple type, without trying to\n     * check for more specialized types.\n     *<p> \n     * NOTE: no type modifiers are called on type either, so calling this method\n     * should only be used if caller really knows what it's doing...\n     */\n    public JavaType uncheckedSimpleType(Class<?> cls) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  TypeFactory.parametricType(List.class, Integer.class);\n     *</pre>\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     * \n     * @param parametrized Type-erased type of instance being constructed\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterClasses Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            Class<?>... parameterClasses)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link JavaType} that\n     * represents a parameterized type. For example, to represent\n     * type <code>List&lt;Set&lt;Integer>></code>, you could\n     * call\n     *<pre>\n     *  JavaType inner = TypeFactory.parametricType(Set.class, Integer.class);\n     *  TypeFactory.parametricType(List.class, inner);\n     *</pre>\n     *<p>\n     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n     * for contained types.\n     * \n     * \n     * @param parametrized Actual full type\n     * @param parametersFor class or interface for which type parameters are applied; either\n     *   <code>parametrized</code> or one of its supertypes\n     * @param parameterTypes Type parameters to apply\n     * \n     * @since 2.5\n     */\n    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n     */\n    @Deprecated\n    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Direct factory methods for \"raw\" variants, used when\n    /* parameterization is unknown\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to construct \"raw\" Collection type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that can be used to construct \"raw\" Map type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n     * parameterization is unknown.\n     * This is similar to using <code>Object.class</code> parameterization,\n     * and is equivalent to calling:\n     *<pre>\n     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n     *<pre>\n     *<p>\n     * This method should only be used if parameterization is completely unavailable.\n     */\n    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Actual factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @param context Mapping of formal parameter declarations (for generic\n     *   types) into actual types\n     */\n    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method used by {@link TypeParser} when generics-aware version\n     * is constructed.\n     */\n    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * This method deals with parameterized types, that is,\n     * first class generic classes.\n     */\n    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    \n    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private JavaType _mapType(Class<?> rawClass)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private JavaType _collectionType(Class<?> rawClass)\n    {\n         //The specific code has been omitted, but there is no error\n        }    \n\n    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    protected JavaType _unknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to find inheritance (implements, extends) path\n     * between given types, if one exists (caller generally checks before\n     * calling this method). Returned type represents given <b>subtype</b>,\n     * with supertype linkage extending to <b>supertype</b>.\n     */\n    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}