{"TokenBuffer": "public class TokenBuffer\n/* Won't use JsonGeneratorBase, to minimize overhead for validity\n * checking\n */\n    extends JsonGenerator\n{\n    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object codec to use for stream-based object\n     * conversion through parser/generator interfaces. If null,\n     * such methods can not be used.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     *<p>\n     * NOTE: most features have no effect on this class\n     */\n    protected int _generatorFeatures;\n\n    protected boolean _closed;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeTypeIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _hasNativeObjectIds;\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _mayHaveNativeIds;\n    \n    /*\n    /**********************************************************\n    /* Token buffering state\n    /**********************************************************\n     */\n\n    /**\n     * First segment, for contents this buffer has\n     */\n    protected Segment _first;\n\n    /**\n     * Last segment of this buffer, one that is used\n     * for appending more tokens\n     */\n    protected Segment _last;\n    \n    /**\n     * Offset within last segment, \n     */\n    protected int _appendAt;\n\n    /**\n     * If native type ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _typeId;\n\n    /**\n     * If native object ids supported, this is the id for following\n     * value (or first token of one) to be written.\n     */\n    protected Object _objectId;\n\n    /**\n     * Do we currnetly have a native type or object id buffered?\n     */\n    protected boolean _hasNativeId = false;\n\n    /*\n    /**********************************************************\n    /* Output state\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _writeContext;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     *   \n     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n     */\n    @Deprecated\n    public TokenBuffer(ObjectCodec codec) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n     *   is considered to support native type and object ids\n     */\n    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.3\n     */\n    public TokenBuffer(JsonParser jp)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public Version version() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer. Will use default <code>_objectCodec</code> for\n     * object conversions.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to create a {@link JsonParser} that can read contents\n     * stored in this buffer.\n     *<p>\n     * Note: instances are not synchronized, that is, they are not thread-safe\n     * if there are concurrent appends to the underlying buffer.\n     *\n     * @param codec Object codec to use for stream-based object\n     *   conversion through parser/generator interfaces. If null,\n     *   such methods can not be used.\n     * \n     * @return Parser that can be used for reading contents stored in this buffer\n     */\n    public JsonParser asParser(ObjectCodec codec)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param src Parser to use for accessing source information\n     *    like location, configured codec\n     */\n    public JsonParser asParser(JsonParser src)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Additional accessors\n    /**********************************************************\n     */\n\n    public JsonToken firstToken() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Other custom methods not needed for implementing interfaces\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that will append contents of given buffer into this\n     * buffer.\n     * Not particularly optimized; can be made faster if there is need.\n     * \n     * @return This buffer\n     */\n    @SuppressWarnings(\"resource\")\n    public TokenBuffer append(TokenBuffer other)\n        throws IOException, JsonGenerationException\n    {\n        // Important? If source has native ids, need to store\n        if (!_hasNativeTypeIds) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (!_hasNativeObjectIds) {\n         //The specific code has been omitted, but there is no error\n        }\n        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n        \n        JsonParser jp = other.asParser();\n        while (jp.nextToken() != null) {\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n    \n    /**\n     * Helper method that will write all contents of this buffer\n     * using given {@link JsonGenerator}.\n     *<p>\n     * Note: this method would be enough to implement\n     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n     * but we can not have upwards\n     * references (from core to mapper package); and as such we also\n     * can not take second argument.\n     */\n    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        return this;\n    }\n    \n    @Override\n    @SuppressWarnings(\"resource\")\n    public String toString()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private final void _appendNativeIds(StringBuilder sb)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: configuration\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    //public JsonGenerator configure(SerializationFeature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean isEnabled(Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int getFeatureMask() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonGenerator setFeatureMask(int mask) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public JsonGenerator useDefaultPrettyPrinter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonGenerator setCodec(ObjectCodec oc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ObjectCodec getCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final JsonWriteContext getOutputContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: capability introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Since we can efficiently store <code>byte[]</code>, yes.\n     */\n    @Override\n    public boolean canWriteBinaryNatively() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException { /* NOP */ }\n\n    @Override\n    public void close() throws IOException {\n        _closed = true;\n    }\n\n    @Override\n    public boolean isClosed() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_ARRAY);\n        _writeContext = _writeContext.createChildArrayContext();\n    }\n\n    @Override\n    public final void writeEndArray()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_ARRAY);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    @Override\n    public final void writeStartObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.START_OBJECT);\n        _writeContext = _writeContext.createChildObjectContext();\n    }\n\n    @Override\n    public final void writeEndObject()\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.END_OBJECT);\n        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n        JsonWriteContext c = _writeContext.getParent();\n        if (c != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    @Override\n    public final void writeFieldName(String name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name)\n        throws IOException, JsonGenerationException\n    {\n        _append(JsonToken.FIELD_NAME, name);\n        _writeContext.writeFieldName(name.getValue());\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException,JsonGenerationException {\n        if (text == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        writeString(new String(text, offset, len));\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n        if (text == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _append(JsonToken.VALUE_STRING, text);\n        }\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException, JsonGenerationException\n    {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n    \n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation: write methods, primitive types\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException,JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n        if (dec == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n        if (v == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _append(JsonToken.VALUE_NUMBER_INT, v);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n         *   identity as long as possible\n         */\n        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n    }\n\n    @Override\n    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n    }\n\n    @Override\n    public void writeNull() throws IOException, JsonGenerationException {\n        _append(JsonToken.VALUE_NULL);\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: write methods for POJOs/trees\n    /***********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException\n    {\n        if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        Class<?> raw = value.getClass();\n        if (raw == byte[].class) {\n         //The specific code has been omitted, but there is no error\n        } else if (_objectCodec == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _objectCodec.writeValue(this, value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode node) throws IOException\n    {\n        if (node == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (_objectCodec == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _objectCodec.writeTree(this, node);\n        }\n    }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation; binary\n    /***********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n         *   now, let's try to limit number of conversions.\n         *   The only (?) tricky thing is that of whether to preserve variant,\n         *   seems pointless, so let's not worry about it unless there's some\n         *   compelling reason to.\n         */\n        byte[] copy = new byte[len];\n        System.arraycopy(data, offset, copy, 0, len);\n        writeObject(copy);\n    }\n\n    /**\n     * Although we could support this method, it does not necessarily make\n     * sense: we can not make good use of streaming because buffer must\n     * hold all the data. Because of this, currently this will simply\n     * throw {@link UnsupportedOperationException}\n     */\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /***********************************************************\n    /* JsonGenerator implementation: native ids\n    /***********************************************************\n     */\n\n    @Override\n    public boolean canWriteTypeId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean canWriteObjectId() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public void writeTypeId(Object id) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public void writeObjectId(Object id) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonGenerator implementation; pass-through copy\n    /**********************************************************\n     */\n\n    @Override\n    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if (_mayHaveNativeIds) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (jp.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(jp.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (jp.hasTextCharacters()) {\n                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n            } else {\n                writeString(jp.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (jp.getNumberType()) {\n            case INT:\n                writeNumber(jp.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(jp.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(jp.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n            switch (jp.getNumberType()) {\n            case BIG_DECIMAL:\n                writeNumber(jp.getDecimalValue());\n                break;\n            case FLOAT:\n                writeNumber(jp.getFloatValue());\n                break;\n            default:\n                writeNumber(jp.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(jp.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }\n    \n    @Override\n    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (_mayHaveNativeIds) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        switch (t) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    \n    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        if ((_typeId = jp.getTypeId()) != null) {\n            _hasNativeId = true;\n        }\n        if ((_objectId = jp.getObjectId()) != null) {\n            _hasNativeId = true;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _append(JsonToken type)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected final void _append(JsonToken type, Object value)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected final void _appendRaw(int rawType, Object value)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    protected void _reportUnsupportedOperation() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Supporting classes\n    /**********************************************************\n     */\n\n    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        @Deprecated // since 2.3\n        protected Parser(Segment firstSeg, ObjectCodec codec) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public void setLocation(JsonLocation l) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public ObjectCodec getCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void setCodec(ObjectCodec c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Version version() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        } else if (_currToken == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else if (_currToken == JsonToken.START_ARRAY) {\n         //The specific code has been omitted, but there is no error\n        } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n         //The specific code has been omitted, but there is no error\n        }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonStreamContext getParsingContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public JsonLocation getTokenLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public String getCurrentName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n        \n        @Override\n        public String getText()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int getTextLength() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int getTextOffset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public boolean hasTextCharacters() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n         //The specific code has been omitted, but there is no error\n        }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n         //The specific code has been omitted, but there is no error\n        }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_currToken != JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n            final String str = getText();\n            if (str == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object getTypeId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object getObjectId() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }\n    \n    /**\n     * Individual segment of TokenBuffer that can store up to 16 tokens\n     * (limited by 4 bits per token type marker requirement).\n     * Current implementation uses fixed length array; could alternatively\n     * use 16 distinct fields and switch statement (slightly more efficient\n     * storage, slightly slower access)\n     */\n    protected final static class Segment \n    {\n         //The specific code has been omitted, but there is no error\n        }\n}", "Parser": "    protected final static class Parser\n        extends ParserMinimalBase\n    {\n        /*\n        /**********************************************************\n        /* Configuration\n        /**********************************************************\n         */\n\n        protected ObjectCodec _codec;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeTypeIds;\n\n        /**\n         * @since 2.3\n         */\n        protected final boolean _hasNativeObjectIds;\n\n        protected final boolean _hasNativeIds;\n        \n        /*\n        /**********************************************************\n        /* Parsing state\n        /**********************************************************\n         */\n\n        /**\n         * Currently active segment\n         */\n        protected Segment _segment;\n\n        /**\n         * Pointer to current token within current segment\n         */\n        protected int _segmentPtr;\n\n        /**\n         * Information about parser context, context in which\n         * the next token is to be parsed (root, array, object).\n         */\n        protected JsonReadContext _parsingContext;\n        \n        protected boolean _closed;\n\n        protected transient ByteArrayBuilder _byteBuilder;\n\n        protected JsonLocation _location = null;\n        \n        /*\n        /**********************************************************\n        /* Construction, init\n        /**********************************************************\n         */\n\n        @Deprecated // since 2.3\n        protected Parser(Segment firstSeg, ObjectCodec codec) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * @since 2.3\n         */\n        public Parser(Segment firstSeg, ObjectCodec codec,\n                boolean hasNativeTypeIds,\n                boolean hasNativeObjectIds)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public void setLocation(JsonLocation l) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public ObjectCodec getCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void setCodec(ObjectCodec c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Version version() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /*\n        /**********************************************************\n        /* Extended API beyond JsonParser\n        /**********************************************************\n         */\n        \n        public JsonToken peekNextToken()\n            throws IOException, JsonParseException\n        {\n            // closed? nothing more to peek, either\n            if (_closed) return null;\n            Segment seg = _segment;\n            int ptr = _segmentPtr+1;\n            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n            return (seg == null) ? null : seg.type(ptr);\n        }\n        \n        /*\n        /**********************************************************\n        /* Closeable implementation\n        /**********************************************************\n         */\n\n        @Override\n        public void close() throws IOException {\n            if (!_closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, traversal\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonToken nextToken() throws IOException, JsonParseException\n        {\n            // If we are closed, nothing more to do\n            if (_closed || (_segment == null)) return null;\n\n            // Ok, then: any more tokens?\n            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n            _currToken = _segment.type(_segmentPtr);\n            // Field name? Need to update context\n            if (_currToken == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        } else if (_currToken == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else if (_currToken == JsonToken.START_ARRAY) {\n         //The specific code has been omitted, but there is no error\n        } else if (_currToken == JsonToken.END_OBJECT\n                    || _currToken == JsonToken.END_ARRAY) {\n         //The specific code has been omitted, but there is no error\n        }\n            return _currToken;\n        }\n\n        @Override\n        public boolean isClosed() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, token accessors\n        /**********************************************************\n         */\n        \n        @Override\n        public JsonStreamContext getParsingContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public JsonLocation getTokenLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public JsonLocation getCurrentLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public String getCurrentName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void overrideCurrentName(String name)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, text\n        /**********************************************************\n         */\n        \n        @Override\n        public String getText()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public char[] getTextCharacters() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int getTextLength() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public int getTextOffset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public boolean hasTextCharacters() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */\n\n        @Override\n        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigInteger) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                return ((BigDecimal) n).toBigInteger();\n            }\n            // int/long is simple, but let's also just truncate float/double:\n            return BigInteger.valueOf(n.longValue());\n        }\n\n        @Override\n        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof BigDecimal) {\n         //The specific code has been omitted, but there is no error\n        }\n            switch (getNumberType()) {\n            case INT:\n            case LONG:\n                return BigDecimal.valueOf(n.longValue());\n            case BIG_INTEGER:\n                return new BigDecimal((BigInteger) n);\n            default:\n            }\n            // float or double\n            return BigDecimal.valueOf(n.doubleValue());\n        }\n\n        @Override\n        public double getDoubleValue() throws IOException, JsonParseException {\n            return getNumberValue().doubleValue();\n        }\n\n        @Override\n        public float getFloatValue() throws IOException, JsonParseException {\n            return getNumberValue().floatValue();\n        }\n\n        @Override\n        public int getIntValue() throws IOException, JsonParseException\n        {\n            // optimize common case:\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n         //The specific code has been omitted, but there is no error\n        }\n            return getNumberValue().intValue();\n        }\n\n        @Override\n        public long getLongValue() throws IOException, JsonParseException {\n            return getNumberValue().longValue();\n        }\n\n        @Override\n        public NumberType getNumberType() throws IOException, JsonParseException\n        {\n            Number n = getNumberValue();\n            if (n instanceof Integer) return NumberType.INT;\n            if (n instanceof Long) return NumberType.LONG;\n            if (n instanceof Double) return NumberType.DOUBLE;\n            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n            if (n instanceof Float) return NumberType.FLOAT;\n            if (n instanceof Short) return NumberType.INT;       // should be SHORT\n            return null;\n        }\n\n        @Override\n        public final Number getNumberValue() throws IOException, JsonParseException {\n            _checkIsNumber();\n            Object value = _currentObject();\n            if (value instanceof Number) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Difficult to really support numbers-as-Strings; but let's try.\n            // NOTE: no access to DeserializationConfig, unfortunately, so can not\n            // try to determine Double/BigDecimal preference...\n            if (value instanceof String) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                    +value.getClass().getName());\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, access to token information, other\n        /**********************************************************\n         */\n\n        @Override\n        public Object getEmbeddedObject()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        @SuppressWarnings(\"resource\")\n        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n        {\n            // First: maybe we some special types?\n            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_currToken != JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n            final String str = getText();\n            if (str == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            ByteArrayBuilder builder = _byteBuilder;\n            if (builder == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                _byteBuilder.reset();\n            }\n            _decodeBase64(str, builder, b64variant);\n            return builder.toByteArray();\n        }\n\n        @Override\n        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n            throws IOException, JsonParseException\n        {\n            byte[] data = getBinaryValue(b64variant);\n            if (data != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            return 0;\n        }\n\n        /*\n        /**********************************************************\n        /* Public API, native ids\n        /**********************************************************\n         */\n\n        @Override\n        public boolean canReadObjectId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public boolean canReadTypeId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object getTypeId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object getObjectId() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        /*\n        /**********************************************************\n        /* Internal methods\n        /**********************************************************\n         */\n\n        protected final Object _currentObject() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        protected final void _checkIsNumber() throws JsonParseException\n        {\n            if (_currToken == null || !_currToken.isNumeric()) {\n                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n            }\n        }\n\n        @Override\n        protected void _handleEOF() throws JsonParseException {\n            _throwInternal();\n        }\n    }", "Segment": "    protected final static class Segment \n    {\n         //The specific code has been omitted, but there is no error\n        }"}