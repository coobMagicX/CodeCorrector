{"ZipArchiveEntry": "public class ZipArchiveEntry extends java.util.zip.ZipEntry\n    implements ArchiveEntry {\n\n    public static final int PLATFORM_UNIX = 3;\n    public static final int PLATFORM_FAT  = 0;\n    private static final int SHORT_MASK = 0xFFFF;\n    private static final int SHORT_SHIFT = 16;\n\n    /**\n     * The {@link java.util.zip.ZipEntry} base class only supports\n     * the compression methods STORED and DEFLATED. We override the\n     * field so that any compression methods can be used.\n     * <p>\n     * The default value -1 means that the method has not been specified.\n     *\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-93\"\n     *        >COMPRESS-93</a>\n     */\n    private int method = -1;\n\n    /**\n     * The {@link java.util.zip.ZipEntry#setSize} method in the base\n     * class throws an IllegalArgumentException if the size is bigger\n     * than 2GB for Java versions < 7.  Need to keep our own size\n     * information for Zip64 support.\n     */\n    private long size = SIZE_UNKNOWN;\n\n    private int internalAttributes = 0;\n    private int platform = PLATFORM_FAT;\n    private long externalAttributes = 0;\n    private LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\n    private UnparseableExtraFieldData unparseableExtra = null;\n    private String name = null;\n    private byte[] rawName = null;\n    private GeneralPurposeBit gpb = new GeneralPurposeBit();\n\n    /**\n     * Creates a new zip entry with the specified name.\n     *\n     * <p>Assumes the entry represents a directory if and only if the\n     * name ends with a forward slash \"/\".</p>\n     *\n     * @param name the name of the entry\n     */\n    public ZipArchiveEntry(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new zip entry with fields taken from the specified zip entry.\n     *\n     * <p>Assumes the entry represents a directory if and only if the\n     * name ends with a forward slash \"/\".</p>\n     *\n     * @param entry the entry to get fields from\n     * @throws ZipException on error\n     */\n    public ZipArchiveEntry(java.util.zip.ZipEntry entry) throws ZipException {\n        super(entry);\n        setName(entry.getName());\n        byte[] extra = entry.getExtra();\n        if (extra != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            // initializes extra data to an empty byte array\n            setExtra();\n        }\n        setMethod(entry.getMethod());\n        this.size = entry.getSize();\n    }\n\n    /**\n     * Creates a new zip entry with fields taken from the specified zip entry.\n     *\n     * <p>Assumes the entry represents a directory if and only if the\n     * name ends with a forward slash \"/\".</p>\n     *\n     * @param entry the entry to get fields from\n     * @throws ZipException on error\n     */\n    public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException {\n        this((java.util.zip.ZipEntry) entry);\n        setInternalAttributes(entry.getInternalAttributes());\n        setExternalAttributes(entry.getExternalAttributes());\n        setExtraFields(entry.getExtraFields(true));\n    }\n\n    /**\n     */\n    protected ZipArchiveEntry() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new zip entry taking some information from the given\n     * file and using the provided name.\n     *\n     * <p>The name will be adjusted to end with a forward slash \"/\" if\n     * the file is a directory.  If the file is not a directory a\n     * potential trailing forward slash will be stripped from the\n     * entry name.</p>\n     */\n    public ZipArchiveEntry(File inputFile, String entryName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Overwrite clone.\n     * @return a cloned copy of this ZipArchiveEntry\n     */\n    @Override\n    public Object clone() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the compression method of this entry, or -1 if the\n     * compression method has not been specified.\n     *\n     * @return compression method\n     *\n     * @since 1.1\n     */\n    @Override\n    public int getMethod() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the compression method of this entry.\n     *\n     * @param method compression method\n     *\n     * @since 1.1\n     */\n    @Override\n    public void setMethod(int method) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Retrieves the internal file attributes.\n     *\n     * @return the internal file attributes\n     */\n    public int getInternalAttributes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the internal file attributes.\n     * @param value an <code>int</code> value\n     */\n    public void setInternalAttributes(int value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Retrieves the external file attributes.\n     * @return the external file attributes\n     */\n    public long getExternalAttributes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the external file attributes.\n     * @param value an <code>long</code> value\n     */\n    public void setExternalAttributes(long value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets Unix permissions in a way that is understood by Info-Zip's\n     * unzip command.\n     * @param mode an <code>int</code> value\n     */\n    public void setUnixMode(int mode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Unix permission.\n     * @return the unix permissions\n     */\n    public int getUnixMode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Platform specification to put into the &quot;version made\n     * by&quot; part of the central file header.\n     *\n     * @return PLATFORM_FAT unless {@link #setUnixMode setUnixMode}\n     * has been called, in which case PLATORM_UNIX will be returned.\n     */\n    public int getPlatform() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the platform (UNIX or FAT).\n     * @param platform an <code>int</code> value - 0 is FAT, 3 is UNIX\n     */\n    protected void setPlatform(int platform) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Replaces all currently attached extra fields with the new array.\n     * @param fields an array of extra fields\n     */\n    public void setExtraFields(ZipExtraField[] fields) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Retrieves all extra fields that have been parsed successfully.\n     * @return an array of the extra fields\n     */\n    public ZipExtraField[] getExtraFields() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Retrieves extra fields.\n     * @param includeUnparseable whether to also return unparseable\n     * extra fields as {@link UnparseableExtraFieldData} if such data\n     * exists.\n     * @return an array of the extra fields\n     *\n     * @since 1.1\n     */\n    public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Adds an extra field - replacing an already present extra field\n     * of the same type.\n     *\n     * <p>If no extra field of the same type exists, the field will be\n     * added as last field.</p>\n     * @param ze an extra field\n     */\n    public void addExtraField(ZipExtraField ze) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Adds an extra field - replacing an already present extra field\n     * of the same type.\n     *\n     * <p>The new extra field will be the first one.</p>\n     * @param ze an extra field\n     */\n    public void addAsFirstExtraField(ZipExtraField ze) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Remove an extra field.\n     * @param type the type of extra field to remove\n     */\n    public void removeExtraField(ZipShort type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Removes unparseable extra field data.\n     *\n     * @since 1.1\n     */\n    public void removeUnparseableExtraFieldData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Looks up an extra field by its header id.\n     *\n     * @return null if no such field exists.\n     */\n    public ZipExtraField getExtraField(ZipShort type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Looks up extra field data that couldn't be parsed correctly.\n     *\n     * @return null if no such field exists.\n     *\n     * @since 1.1\n     */\n    public UnparseableExtraFieldData getUnparseableExtraFieldData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parses the given bytes as extra field data and consumes any\n     * unparseable data as an {@link UnparseableExtraFieldData}\n     * instance.\n     * @param extra an array of bytes to be parsed into extra fields\n     * @throws RuntimeException if the bytes cannot be parsed\n     * @throws RuntimeException on error\n     */\n    @Override\n    public void setExtra(byte[] extra) throws RuntimeException {\n        try {\n            ZipExtraField[] local =\n                ExtraFieldUtils.parse(extra, true,\n                                      ExtraFieldUtils.UnparseableExtraField.READ);\n            mergeExtraFields(local, true);\n        } catch (ZipException e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Unfortunately {@link java.util.zip.ZipOutputStream\n     * java.util.zip.ZipOutputStream} seems to access the extra data\n     * directly, so overriding getExtra doesn't help - we need to\n     * modify super's data directly.\n     */\n    protected void setExtra() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the central directory part of extra fields.\n     */\n    public void setCentralDirectoryExtra(byte[] b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Retrieves the extra data for the local file data.\n     * @return the extra data for local file\n     */\n    public byte[] getLocalFileDataExtra() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Retrieves the extra data for the central directory.\n     * @return the central directory extra data\n     */\n    public byte[] getCentralDirectoryExtra() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the name of the entry.\n     * @return the entry name\n     */\n    @Override\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Is this entry a directory?\n     * @return true if the entry is a directory\n     */\n    @Override\n    public boolean isDirectory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the name of the entry.\n     * @param name the name to use\n     */\n    protected void setName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the uncompressed size of the entry data.\n     * @return the entry size\n     */\n    @Override\n    public long getSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the uncompressed size of the entry data.\n     * @param size the uncompressed size in bytes\n     * @exception IllegalArgumentException if the specified size is less\n     *            than 0\n     */\n    @Override\n    public void setSize(long size) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets the name using the raw bytes and the string created from\n     * it by guessing or using the configured encoding.\n     * @param name the name to use created from the raw bytes using\n     * the guessed or configured encoding\n     * @param rawName the bytes originally read as name from the\n     * archive\n     * @since 1.2\n     */\n    protected void setName(String name, byte[] rawName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the raw bytes that made up the name before it has been\n     * converted using the configured or guessed encoding.\n     *\n     * <p>This method will return null if this instance has not been\n     * read from an archive.</p>\n     *\n     * @since 1.2\n     */\n    public byte[] getRawName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the hashCode of the entry.\n     * This uses the name as the hashcode.\n     * @return a hashcode.\n     */\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The \"general purpose bit\" field.\n     * @since 1.1\n     */\n    public GeneralPurposeBit getGeneralPurposeBit() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The \"general purpose bit\" field.\n     * @since 1.1\n     */\n    public void setGeneralPurposeBit(GeneralPurposeBit b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If there are no extra fields, use the given fields as new extra\n     * data - otherwise merge the fields assuming the existing fields\n     * and the new fields stem from different locations inside the\n     * archive.\n     * @param f the extra fields to merge\n     * @param local whether the new fields originate from local data\n     */\n    private void mergeExtraFields(ZipExtraField[] f, boolean local)\n        throws ZipException {\n        if (extraFields == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            for (ZipExtraField element : f) {\n         //The specific code has been omitted, but there is no error\n        }\n            setExtra();\n        }\n    }\n\n    /** {@inheritDoc} */\n    public Date getLastModifiedDate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /* (non-Javadoc)\n     * @see java.lang.Object#equals(java.lang.Object)\n     */\n    @Override\n    public boolean equals(Object obj) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}