{"JsonTreeReader": "public final class JsonTreeReader extends JsonReader {\n  private static final Reader UNREADABLE_READER = new Reader() {\n         //The specific code has been omitted, but there is no error\n        };\n  private static final Object SENTINEL_CLOSED = new Object();\n\n  /*\n   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n   */\n  private Object[] stack = new Object[32];\n  private int stackSize = 0;\n\n  /*\n   * The path members. It corresponds directly to stack: At indices where the\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n   * pathNames contains the name at this scope. Where it contains an array\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n   * that array. Otherwise the value is undefined, and we take advantage of that\n   * by incrementing pathIndices when doing so isn't useful.\n   */\n  private String[] pathNames = new String[32];\n  private int[] pathIndices = new int[32];\n\n  public JsonTreeReader(JsonElement element) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override public void beginArray() throws IOException {\n    expect(JsonToken.BEGIN_ARRAY);\n    JsonArray array = (JsonArray) peekStack();\n    push(array.iterator());\n    pathIndices[stackSize - 1] = 0;\n  }\n\n  @Override public void endArray() throws IOException {\n    expect(JsonToken.END_ARRAY);\n    popStack(); // empty iterator\n    popStack(); // array\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  @Override public void beginObject() throws IOException {\n    expect(JsonToken.BEGIN_OBJECT);\n    JsonObject object = (JsonObject) peekStack();\n    push(object.entrySet().iterator());\n  }\n\n  @Override public void endObject() throws IOException {\n    expect(JsonToken.END_OBJECT);\n    popStack(); // empty iterator\n    popStack(); // object\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  @Override public boolean hasNext() throws IOException {\n    JsonToken token = peek();\n    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n  }\n\n  @Override public JsonToken peek() throws IOException {\n    if (stackSize == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Object o = peekStack();\n    if (o instanceof Iterator) {\n         //The specific code has been omitted, but there is no error\n        } else if (o instanceof JsonObject) {\n         //The specific code has been omitted, but there is no error\n        } else if (o instanceof JsonArray) {\n         //The specific code has been omitted, but there is no error\n        } else if (o instanceof JsonPrimitive) {\n         //The specific code has been omitted, but there is no error\n        } else if (o instanceof JsonNull) {\n         //The specific code has been omitted, but there is no error\n        } else if (o == SENTINEL_CLOSED) {\n         //The specific code has been omitted, but there is no error\n        } else {\n      throw new AssertionError();\n    }\n  }\n\n  private Object peekStack() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Object popStack() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void expect(JsonToken expected) throws IOException {\n    if (peek() != expected) {\n      throw new IllegalStateException(\n          \"Expected \" + expected + \" but was \" + peek() + locationString());\n    }\n  }\n\n  @Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }\n\n  @Override public String nextString() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n         //The specific code has been omitted, but there is no error\n        }\n    String result = ((JsonPrimitive) popStack()).getAsString();\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    return result;\n  }\n\n  @Override public boolean nextBoolean() throws IOException {\n    expect(JsonToken.BOOLEAN);\n    boolean result = ((JsonPrimitive) popStack()).getAsBoolean();\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    return result;\n  }\n\n  @Override public void nextNull() throws IOException {\n    expect(JsonToken.NULL);\n    popStack();\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  @Override public double nextDouble() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    popStack();\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    return result;\n  }\n\n  @Override public long nextLong() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n    long result = ((JsonPrimitive) peekStack()).getAsLong();\n    popStack();\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    return result;\n  }\n\n  @Override public int nextInt() throws IOException {\n    JsonToken token = peek();\n    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n    int result = ((JsonPrimitive) peekStack()).getAsInt();\n    popStack();\n    if (stackSize > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    return result;\n  }\n\n  @Override public void close() throws IOException {\n    stack = new Object[] { SENTINEL_CLOSED };\n    stackSize = 1;\n  }\n\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n    } else {\n      popStack();\n        pathNames[stackSize - 1] = \"null\";\n    }\n      pathIndices[stackSize - 1]++;\n  }\n\n  @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void promoteNameToValue() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    push(entry.getValue());\n    push(new JsonPrimitive((String) entry.getKey()));\n  }\n\n  private void push(Object newTop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override public String getPath() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private String locationString() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}