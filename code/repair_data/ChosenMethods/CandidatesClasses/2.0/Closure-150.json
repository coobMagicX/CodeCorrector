{"TypedScopeCreator": "final class TypedScopeCreator implements ScopeCreator {\n  /**\n   * A suffix for naming delegate proxies differently from their base.\n   */\n  static final String DELEGATE_PROXY_SUFFIX = \"(Proxy)\";\n\n  static final DiagnosticType MALFORMED_TYPEDEF =\n      DiagnosticType.warning(\n          \"JSC_MALFORMED_TYPEDEF\",\n          \"Typedef for {0} does not have any type information\");\n\n  static final DiagnosticType ENUM_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_ENUM_INITIALIZER_NOT_ENUM\",\n          \"enum initializer must be an object literal or an enum\");\n\n  static final DiagnosticType CONSTRUCTOR_EXPECTED =\n      DiagnosticType.warning(\n          \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\",\n          \"Constructor expected as first argument\");\n\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n\n  /**\n   * Defer attachment of types to nodes until all type names\n   * have been resolved. Then, we can resolve the type and attach it.\n   */\n  private class DeferredSetType {\n         //The specific code has been omitted, but there is no error\n        }\n\n  TypedScopeCreator(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Create the outermost scope. This scope contains native binding such as\n   * {@code Object}, {@code Date}, etc.\n   */\n  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void declareNativeType(Scope scope, String name, JSType t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static class DiscoverEnums extends AbstractShallowCallback {\n    private final JSTypeRegistry registry;\n\n    DiscoverEnums(JSTypeRegistry registry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Given a node, determines whether that node names a prototype\n   * property, and if so, returns the qualfied name node representing\n   * the owner of that property. Otherwise, returns null.\n   */\n  private static Node getPrototypePropertyOwner(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void attachLiteralTypes(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private JSType getNativeType(JSTypeNative nativeType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private abstract class AbstractScopeBuilder\n      implements NodeTraversal.Callback {\n\n    /**\n     * The scope that we're builidng.\n     */\n    final Scope scope;\n\n    private final List<DeferredSetType> deferredSetTypes =\n        Lists.newArrayList();\n\n    /**\n     * Functions that we found in the global scope and not in externs.\n     */\n    private final List<Node> nonExternFunctions = Lists.newArrayList();\n\n    /**\n     * Type-less stubs.\n     *\n     * If at the end of traversal, we still don't have types for these\n     * stubs, then we should declare UNKNOWN types.\n     */\n    private final List<StubDeclaration> stubDeclarations =\n        Lists.newArrayList();\n\n    /**\n     * The current source file that we're in.\n     */\n    private String sourceName = null;\n\n    private AbstractScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void setDeferredType(Node node, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void resolveTypes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     */\n    JSType getDeclaredTypeInAnnotation(\n        NodeTraversal t, Node node, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Asserts that it's ok to define this node's name.\n     * The node should have a source name and be of the specified type.\n     */\n    void assertDefinitionNode(Node n, int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a catch parameter.\n     */\n    void defineCatch(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a VAR initialization.\n     */\n    void defineVar(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a declared function.\n     */\n    void defineDeclaredFunction(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a qualified name assign to an enum or constructor.\n     */\n    void defineNamedTypeAssign(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param parent {@code var}'s parent.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     */\n    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the function type from the function node and its attached\n     * {@link JSDocInfo}.\n     * @param name the function's name\n     * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */\n    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the function that's being overridden on this type, if any.\n     */\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets an enum type. If the definition is correct, the object literal used\n     * to define the enum is traversed to gather the elements name, and this\n     * method checks for duplicates. This method also enforces that all\n     * elements' name be syntactic constants according to the\n     * {@link CodingConvention} used.\n     *\n     * @param name the enum's name such as {@code HELLO} or {@code goog.foo.BAR}\n     * @param value the enum's original value. This value may be {@code null}.\n     * @param parent the value's parent\n     * @param elementsType the type of the elements of this enum\n     * @return the enum type\n     */\n    private EnumType getEnumType(String name, Node parent,\n        Node value, JSType elementsType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     */\n    private void defineSlot(Node name, Node parent, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for a type declaration on a GETPROP node.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n        Node n, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     */\n    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Apply special properties that only apply to delegates.\n     */\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     */\n    private ObjectType getObjectSlot(String slotName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Resolve any stub delcarations to unknown types if we could not\n     * find types for them during traversal.\n     */\n    void resolveStubDeclarations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Collects all declared properties in a function, and\n     * resolves them relative to the global scope.\n     */\n    private final class CollectProperties\n        extends AbstractShallowCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n    } // end CollectProperties\n  }\n\n  /**\n   * A stub declaration without any type information.\n   */\n  private static final class StubDeclaration {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A shallow traversal of the global scope to build up all classes,\n   * functions, and methods.\n   */\n  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n\n    private GlobalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     */\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate An ASSIGN or VAR node.\n     */\n    // TODO(nicksantos): Kill this.\n    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n         //The specific code has been omitted, but there is no error\n        }\n  } // end GlobalScopeBuilder\n\n  /**\n   * A shallow traversal of a local scope to find all arguments and\n   * local variables.\n   */\n  private final class LocalScopeBuilder extends AbstractScopeBuilder {\n    /**\n     * @param scope The scope that we're builidng.\n     */\n    private LocalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Traverse the scope root and build it.\n     */\n    void build() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Handle bleeding functions and function parameters. */\n    private void handleFunctionInputs(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n         //The specific code has been omitted, but there is no error\n        } // end declareArguments\n  } // end LocalScopeBuilder\n}", "DeferredSetType": "  private class DeferredSetType {\n         //The specific code has been omitted, but there is no error\n        }", "DiscoverEnums": "  private static class DiscoverEnums extends AbstractShallowCallback {\n    private final JSTypeRegistry registry;\n\n    DiscoverEnums(JSTypeRegistry registry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "AbstractScopeBuilder": "  private abstract class AbstractScopeBuilder\n      implements NodeTraversal.Callback {\n\n    /**\n     * The scope that we're builidng.\n     */\n    final Scope scope;\n\n    private final List<DeferredSetType> deferredSetTypes =\n        Lists.newArrayList();\n\n    /**\n     * Functions that we found in the global scope and not in externs.\n     */\n    private final List<Node> nonExternFunctions = Lists.newArrayList();\n\n    /**\n     * Type-less stubs.\n     *\n     * If at the end of traversal, we still don't have types for these\n     * stubs, then we should declare UNKNOWN types.\n     */\n    private final List<StubDeclaration> stubDeclarations =\n        Lists.newArrayList();\n\n    /**\n     * The current source file that we're in.\n     */\n    private String sourceName = null;\n\n    private AbstractScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void setDeferredType(Node node, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void resolveTypes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     */\n    JSType getDeclaredTypeInAnnotation(\n        NodeTraversal t, Node node, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Asserts that it's ok to define this node's name.\n     * The node should have a source name and be of the specified type.\n     */\n    void assertDefinitionNode(Node n, int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a catch parameter.\n     */\n    void defineCatch(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a VAR initialization.\n     */\n    void defineVar(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a declared function.\n     */\n    void defineDeclaredFunction(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a qualified name assign to an enum or constructor.\n     */\n    void defineNamedTypeAssign(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param parent {@code var}'s parent.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     */\n    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the function type from the function node and its attached\n     * {@link JSDocInfo}.\n     * @param name the function's name\n     * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */\n    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the function that's being overridden on this type, if any.\n     */\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets an enum type. If the definition is correct, the object literal used\n     * to define the enum is traversed to gather the elements name, and this\n     * method checks for duplicates. This method also enforces that all\n     * elements' name be syntactic constants according to the\n     * {@link CodingConvention} used.\n     *\n     * @param name the enum's name such as {@code HELLO} or {@code goog.foo.BAR}\n     * @param value the enum's original value. This value may be {@code null}.\n     * @param parent the value's parent\n     * @param elementsType the type of the elements of this enum\n     * @return the enum type\n     */\n    private EnumType getEnumType(String name, Node parent,\n        Node value, JSType elementsType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     */\n    private void defineSlot(Node name, Node parent, JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for a type declaration on a GETPROP node.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n        Node n, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     */\n    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Apply special properties that only apply to delegates.\n     */\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     */\n    private ObjectType getObjectSlot(String slotName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Resolve any stub delcarations to unknown types if we could not\n     * find types for them during traversal.\n     */\n    void resolveStubDeclarations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Collects all declared properties in a function, and\n     * resolves them relative to the global scope.\n     */\n    private final class CollectProperties\n        extends AbstractShallowCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n    } // end CollectProperties\n  }", "CollectProperties": "    private final class CollectProperties\n        extends AbstractShallowCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n    } // end CollectProperties", "StubDeclaration": "  private static final class StubDeclaration {\n         //The specific code has been omitted, but there is no error\n        }", "GlobalScopeBuilder": "  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n\n    private GlobalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     */\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate An ASSIGN or VAR node.\n     */\n    // TODO(nicksantos): Kill this.\n    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n         //The specific code has been omitted, but there is no error\n        }\n  } // end GlobalScopeBuilder", "LocalScopeBuilder": "  private final class LocalScopeBuilder extends AbstractScopeBuilder {\n    /**\n     * @param scope The scope that we're builidng.\n     */\n    private LocalScopeBuilder(Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Traverse the scope root and build it.\n     */\n    void build() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Handle bleeding functions and function parameters. */\n    private void handleFunctionInputs(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n         //The specific code has been omitted, but there is no error\n        } // end declareArguments\n  } // end LocalScopeBuilder"}