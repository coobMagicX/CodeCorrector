{"ZipArchiveInputStream": "public class ZipArchiveInputStream extends ArchiveInputStream {\n\n    private static final int SHORT = 2;\n    private static final int WORD = 4;\n\n    /**\n     * The zip encoding to use for filenames and the file comment.\n     */\n    private final ZipEncoding zipEncoding;\n\n    /**\n     * Whether to look for and use Unicode extra fields.\n     */\n    private final boolean useUnicodeExtraFields;\n\n    private final InputStream in;\n\n    private final Inflater inf = new Inflater(true);\n    private final CRC32 crc = new CRC32();\n\n    private final byte[] buf = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n\n    private ZipArchiveEntry current = null;\n    private boolean closed = false;\n    private boolean hitCentralDirectory = false;\n    private int readBytesOfEntry = 0, offsetInBuffer = 0;\n    private int bytesReadFromStream = 0;\n    private int lengthOfLastRead = 0;\n    private boolean hasDataDescriptor = false;\n\n    private static final int LFH_LEN = 30;\n    /*\n      local file header signature     4 bytes  (0x04034b50)\n      version needed to extract       2 bytes\n      general purpose bit flag        2 bytes\n      compression method              2 bytes\n      last mod file time              2 bytes\n      last mod file date              2 bytes\n      crc-32                          4 bytes\n      compressed size                 4 bytes\n      uncompressed size               4 bytes\n      file name length                2 bytes\n      extra field length              2 bytes\n    */\n\n    public ZipArchiveInputStream(InputStream inputStream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        if (closed || hitCentralDirectory) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (current != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        byte[] lfh = new byte[LFH_LEN];\n        try {\n            readFully(lfh);\n        } catch (EOFException e) {\n         //The specific code has been omitted, but there is no error\n        }\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.CFH_SIG)) {\n            hitCentralDirectory = true;\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(lfh, off);\n        off += SHORT;\n        current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                            & ZipFile.NIBLET_MASK);\n\n        final int generalPurposeFlag = ZipShort.getValue(lfh, off);\n        final boolean hasEFS = \n            (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n        final ZipEncoding entryEncoding =\n            hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        hasDataDescriptor = (generalPurposeFlag & 8) != 0;\n\n        off += SHORT;\n\n        current.setMethod(ZipShort.getValue(lfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n        current.setTime(time);\n        off += WORD;\n\n        if (!hasDataDescriptor) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(lfh, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(lfh, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.setName(entryEncoding.decode(fileName));\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.setExtra(extraData);\n\n        if (!hasEFS && useUnicodeExtraFields) {\n         //The specific code has been omitted, but there is no error\n        }\n        return current;\n    }\n\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n         //The specific code has been omitted, but there is no error\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n\n    public void close() throws IOException {\n        if (!closed) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    public long skip(long value) throws IOException {\n        if (value >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        throw new IllegalArgumentException();\n    }\n\n    /*\n     *  This test assumes that the zip file does not have any additional leading content,\n     *  which is something that is allowed by the specification (e.g. self-extracting zips)\n     */\n    public static boolean matches(byte[] signature, int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static boolean checksig(byte[] signature, byte[] expected){\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void closeEntry() throws IOException {\n        if (closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (current == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Ensure all entry bytes are read\n        skip(Long.MAX_VALUE);\n        int inB;\n        if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            inB = inf.getTotalIn();\n        } else {\n            inB = readBytesOfEntry;\n        }\n        int diff = 0;\n\n        // Pushback any required bytes\n        if ((diff = bytesReadFromStream - inB) != 0) {\n            ((PushbackInputStream) in).unread(buf,\n                                              lengthOfLastRead - diff, diff);\n        }\n\n        if (hasDataDescriptor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        inf.reset();\n        readBytesOfEntry = offsetInBuffer = bytesReadFromStream =\n            lengthOfLastRead = 0;\n        crc.reset();\n        current = null;\n    }\n\n    private void fill() throws IOException {\n        if (closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        if ((lengthOfLastRead = in.read(buf)) > 0) {\n            inf.setInput(buf, 0, lengthOfLastRead);\n        }\n    }\n\n    private void readFully(byte[] b) throws IOException {\n        int count = 0, x = 0;\n        while (count != b.length) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n}"}