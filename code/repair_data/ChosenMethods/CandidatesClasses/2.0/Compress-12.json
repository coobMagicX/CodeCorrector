{"TarArchiveInputStream": "public class TarArchiveInputStream extends ArchiveInputStream {\n    private static final int SMALL_BUFFER_SIZE = 256;\n    private static final int BUFFER_SIZE = 8 * 1024;\n\n    private boolean hasHitEOF;\n    private long entrySize;\n    private long entryOffset;\n    private byte[] readBuf;\n    protected final TarBuffer buffer;\n    private TarArchiveEntry currEntry;\n\n    /**\n     * Constructor for TarInputStream.\n     * @param is the input stream to use\n     */\n    public TarArchiveInputStream(InputStream is) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param is the input stream to use\n     * @param blockSize the block size to use\n     */\n    public TarArchiveInputStream(InputStream is, int blockSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructor for TarInputStream.\n     * @param is the input stream to use\n     * @param blockSize the block size to use\n     * @param recordSize the record size to use\n     */\n    public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Closes this stream. Calls the TarBuffer's close() method.\n     * @throws IOException on error\n     */\n    @Override\n    public void close() throws IOException {\n        buffer.close();\n    }\n\n    /**\n     * Get the record size being used by this stream's TarBuffer.\n     *\n     * @return The TarBuffer record size.\n     */\n    public int getRecordSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the available data that can be read from the current\n     * entry in the archive. This does not indicate how much data\n     * is left in the entire archive, only in the current entry.\n     * This value is determined from the entry's size header field\n     * and the amount of data already read from the current entry.\n     * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE\n     * bytes are left in the current entry in the archive.\n     *\n     * @return The number of available bytes for the current entry.\n     * @throws IOException for signature\n     */\n    @Override\n    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n         //The specific code has been omitted, but there is no error\n        }\n        return (int) (entrySize - entryOffset);\n    }\n\n    /**\n     * Skip bytes in the input buffer. This skips bytes in the\n     * current entry's data, not the entire archive, and will\n     * stop at the end of the current entry's data if the number\n     * to skip extends beyond that point.\n     *\n     * @param numToSkip The number of bytes to skip.\n     * @return the number actually skipped\n     * @throws IOException on error\n     */\n    @Override\n    public long skip(long numToSkip) throws IOException {\n        // REVIEW\n        // This is horribly inefficient, but it ensures that we\n        // properly skip over bytes via the TarBuffer...\n        //\n        byte[] skipBuf = new byte[BUFFER_SIZE];\n        long skip = numToSkip;\n        while (skip > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return (numToSkip - skip);\n    }\n\n    /**\n     * Since we do not support marking just yet, we do nothing.\n     */\n    @Override\n    public synchronized void reset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (currEntry != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n\n    /**\n     * Get the next record in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next header in the archive, or null.\n     * @throws IOException on error\n     */\n    private byte[] getRecord() throws IOException {\n        if (hasHitEOF) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        byte[] headerBuf = buffer.readRecord();\n\n        if (headerBuf == null) {\n         //The specific code has been omitted, but there is no error\n        } else if (buffer.isEOFRecord(headerBuf)) {\n            hasHitEOF = true;\n        }\n\n        return hasHitEOF ? null : headerBuf;\n    }\n\n    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n         //The specific code has been omitted, but there is no error\n        };\n        Map<String, String> headers = null;\n        try {\n            headers = parsePaxHeaders(br);\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n    Map<String, String> parsePaxHeaders(Reader br) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        while(true){\n         //The specific code has been omitted, but there is no error\n        }\n        return headers;\n    }\n\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Adds the sparse chunks from the current entry to the sparse chunks,\n     * including any additional sparse entries following the current entry.\n     * \n     * @throws IOException on error \n     * \n     * @todo Sparse files get not yet really processed. \n     */\n    private void readGNUSparse() throws IOException {\n        /* we do not really process sparse files yet\n        sparses = new ArrayList();\n        sparses.addAll(currEntry.getSparses());\n        */\n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (hasHitEOF) {\n         //The specific code has been omitted, but there is no error\n        }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                /* we do not really process sparse files yet\n                sparses.addAll(entry.getSparses());\n                */\n            } while (entry.isExtended());\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }\n\n    /**\n     * Reads bytes from the current tar archive entry.\n     *\n     * This method is aware of the boundaries of the current\n     * entry in the archive and will deal with them as if they\n     * were this stream's start and EOF.\n     *\n     * @param buf The buffer into which to place bytes read.\n     * @param offset The offset at which to place bytes read.\n     * @param numToRead The number of bytes to read.\n     * @return The number of bytes read, or -1 at EOF.\n     * @throws IOException on error\n     */\n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n        int totalRead = 0;\n\n        if (entryOffset >= entrySize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if ((numToRead + entryOffset) > entrySize) {\n            numToRead = (int) (entrySize - entryOffset);\n        }\n\n        if (readBuf != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        while (numToRead > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        entryOffset += totalRead;\n\n        return totalRead;\n    }\n\n    /**\n     * Whether this class is able to read the given entry.\n     *\n     * <p>May return false if the current entry is a sparse file.</p>\n     */\n    @Override\n    public boolean canReadEntryData(ArchiveEntry ae) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected final TarArchiveEntry getCurrentEntry() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected final void setCurrentEntry(TarArchiveEntry e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected final boolean isAtEOF() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected final void setAtEOF(boolean b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Checks if the signature matches what is expected for a tar file.\n     * \n     * @param signature\n     *            the bytes to check\n     * @param length\n     *            the number of bytes to check\n     * @return true, if this stream is a tar archive stream, false otherwise\n     */\n    public static boolean matches(byte[] signature, int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n}"}