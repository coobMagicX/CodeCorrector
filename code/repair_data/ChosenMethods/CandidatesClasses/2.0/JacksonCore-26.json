{"NonBlockingJsonParser": "public class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************************\n    /* Input source config\n    /**********************************************************************\n     */\n\n    /**\n     * This buffer is actually provided via {@link NonBlockingInputFeeder}\n     */\n    protected byte[] _inputBuffer = NO_BYTES;\n\n    /**\n     * In addition to current buffer pointer, and end pointer,\n     * we will also need to know number of bytes originally\n     * contained. This is needed to correctly update location\n     * information when the block has been completed.\n     */\n    protected int _origBufferLen;\n\n    // And from ParserBase:\n//  protected int _inputPtr;\n//  protected int _inputEnd;\n\n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public NonBlockingJsonParser(IOContext ctxt, int parserFeatures,\n            ByteQuadsCanonicalizer sym)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************************\n    /* AsyncInputFeeder impl\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public final boolean needMoreInput() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (end < start) {\n         //The specific code has been omitted, but there is no error\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n//    public Boolean nextBooleanValue() throws IOException\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return avail;\n    }\n\n    // Should never be called: can not be implemented quite as expected\n    // due to non-blocking behavior\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    /*\n    /**********************************************************************\n    /* Main-level decoding\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n         //The specific code has been omitted, but there is no error\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method called when decoding of a token has been started, but not yet completed due\n     * to missing input; method is to continue decoding due to at least one more byte\n     * being made available to decode.\n     */\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n         //The specific code has been omitted, but there is no error\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method similar to {@link #_finishToken}, but called when no more input is\n     * available, and end-of-input has been detected. This is usually problem\n     * case, but not always: root-level values may be properly terminated by\n     * this, and similarly trailing white-space may have been skipped.\n     */\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n         //The specific code has been omitted, but there is no error\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, root level\n    /**********************************************************************\n     */\n\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, primary field name decoding\n    /**********************************************************************\n     */\n\n    /**\n     * Method that handles initial token type recognition for token\n     * that has to be either FIELD_NAME or END_OBJECT.\n     */\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (ch != INT_COMMA) {\n         //The specific code has been omitted, but there is no error\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, value decoding\n    /**********************************************************************\n     */\n    \n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value may be preceded by leading white-space, but no separator (comma).\n     */\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (ch) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /**\n     * Helper method called to parse token that is either a value token in array\n     * or end-array marker\n     */\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (ch != INT_COMMA) {\n         //The specific code has been omitted, but there is no error\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (ch) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value MUST be preceded by a semi-colon (which may be surrounded by white-space)\n     */\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (ch != INT_COLON) {\n         //The specific code has been omitted, but there is no error\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (ch) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n         //The specific code has been omitted, but there is no error\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (ch) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n         //The specific code has been omitted, but there is no error\n        }':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, skipping white-space, comments\n    /**********************************************************************\n     */\n    \n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (ch == INT_SLASH) {\n         //The specific code has been omitted, but there is no error\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n         //The specific code has been omitted, but there is no error\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Tertiary decoding, simple tokens\n    /**********************************************************************\n     */\n\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }\n    \n    /*\n    /**********************************************************************\n    /* Second-level decoding, Number decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n         //The specific code has been omitted, but there is no error\n        } else if (ch > INT_9) {\n         //The specific code has been omitted, but there is no error\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n         //The specific code has been omitted, but there is no error\n        } else if (ch > INT_9) {\n         //The specific code has been omitted, but there is no error\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n         //The specific code has been omitted, but there is no error\n        } else if (ch > INT_9) {\n         //The specific code has been omitted, but there is no error\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n         //The specific code has been omitted, but there is no error\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) {\n         //The specific code has been omitted, but there is no error\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n         //The specific code has been omitted, but there is no error\n        }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n         //The specific code has been omitted, but there is no error\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    /*\n    /**********************************************************************\n    /* Name-decoding, tertiary decoding\n    /**********************************************************************\n     */\n\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (q0 == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (i == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Could continue\n        return null;\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hence is offlined to a separate method.\n     */\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (currQuadBytes > 0) {\n         //The specific code has been omitted, but there is no error\n        } else if (qlen == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _fieldComplete(name);\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n         //The specific code has been omitted, but there is no error\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    /**\n     * Parsing of optionally supported non-standard \"unquoted\" names: names without\n     * either double-quotes or apostrophes surrounding them.\n     * Unlike other \n     */\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (currQuadBytes > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (currQuadBytes > 0) {\n         //The specific code has been omitted, but there is no error\n        } else if (qlen == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_quadLength >= _quadBuffer.length) {\n         //The specific code has been omitted, but there is no error\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (currQuadBytes < 4) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) {\n         //The specific code has been omitted, but there is no error\n        }\n        c &= 0xFF;\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, String decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n         //The specific code has been omitted, but there is no error\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n         //The specific code has been omitted, but there is no error\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (prevCount == 2) {\n         //The specific code has been omitted, but there is no error\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n}"}