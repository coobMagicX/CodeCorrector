{"SevenZFile": "public class SevenZFile implements Closeable {\n    static final int SIGNATURE_HEADER_SIZE = 32;\n\n    private final String fileName;\n    private RandomAccessFile file;\n    private final Archive archive;\n    private int currentEntryIndex = -1;\n    private int currentFolderIndex = -1;\n    private InputStream currentFolderInputStream = null;\n    private byte[] password;\n\n    private final ArrayList<InputStream> deferredBlockStreams = new ArrayList<InputStream>();\n\n    static final byte[] sevenZSignature = {\n        (byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n    };\n    \n    /**\n     * Reads a file as 7z archive\n     *\n     * @param filename the file to read\n     * @param password optional password if the archive is encrypted -\n     * the byte array is supposed to be the UTF16-LE encoded\n     * representation of the password.\n     * @throws IOException if reading the archive fails\n     */\n    public SevenZFile(final File filename, final byte[] password) throws IOException {\n        boolean succeeded = false;\n        this.file = new RandomAccessFile(filename, \"r\");\n        this.fileName = filename.getAbsolutePath();\n        try {\n            archive = readHeaders(password);\n            if (password != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                this.password = null;\n            }\n            succeeded = true;\n        } finally {\n            if (!succeeded) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    /**\n     * Reads a file as unencrypted 7z archive\n     *\n     * @param filename the file to read\n     * @throws IOException if reading the archive fails\n     */\n    public SevenZFile(final File filename) throws IOException {\n        this(filename, null);\n    }\n\n    /**\n     * Closes the archive.\n     * @throws IOException if closing the file fails\n     */\n    @Override\n    public void close() throws IOException {\n        if (file != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    /**\n     * Returns the next Archive Entry in this archive.\n     *\n     * @return the next entry,\n     *         or {@code null} if there are no more entries\n     * @throws IOException if the next entry could not be read\n     */\n    public SevenZArchiveEntry getNextEntry() throws IOException {\n        if (currentEntryIndex >= archive.files.length - 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        ++currentEntryIndex;\n        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];\n        buildDecodingStream();\n        return entry;\n    }\n    \n    /**\n     * Returns meta-data of all archive entries.\n     *\n     * <p>This method only provides meta-data, the entries can not be\n     * used to read the contents, you still need to process all\n     * entries in order using {@link #getNextEntry} for that.</p>\n     *\n     * <p>The content methods are only available for entries that have\n     * already been reached via {@link #getNextEntry}.</p>\n     *\n     * @return meta-data of all archive entries.\n     * @since 1.11\n     */\n    public Iterable<SevenZArchiveEntry> getEntries() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    private Archive readHeaders(final byte[] password) throws IOException {\n        final byte[] signature = new byte[6];\n        file.readFully(signature);\n        if (!Arrays.equals(signature, sevenZSignature)) {\n            throw new IOException(\"Bad 7z signature\");\n        }\n        // 7zFormat.txt has it wrong - it's first major then minor\n        final byte archiveVersionMajor = file.readByte();\n        final byte archiveVersionMinor = file.readByte();\n        if (archiveVersionMajor != 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        final long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\n        final StartHeader startHeader = readStartHeader(startHeaderCrc);\n        \n        final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\n        if (nextHeaderSizeInt != startHeader.nextHeaderSize) {\n         //The specific code has been omitted, but there is no error\n        }\n        file.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\n        final byte[] nextHeader = new byte[nextHeaderSizeInt];\n        file.readFully(nextHeader);\n        final CRC32 crc = new CRC32();\n        crc.update(nextHeader);\n        if (startHeader.nextHeaderCrc != crc.getValue()) {\n            throw new IOException(\"NextHeader CRC mismatch\");\n        }\n        \n        final ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\n        DataInputStream nextHeaderInputStream = new DataInputStream(\n                byteStream);\n        Archive archive = new Archive();\n        int nid = nextHeaderInputStream.readUnsignedByte();\n        if (nid == NID.kEncodedHeader) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (nid == NID.kHeader) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            throw new IOException(\"Broken or unsupported archive: no Header\");\n        }\n        return archive;\n    }\n    \n    private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\n        final StartHeader startHeader = new StartHeader();\n        DataInputStream dataInputStream = null;\n        try {\n             dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\n                    new BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\n             startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\n             startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\n             return startHeader;\n        } finally {\n            if (dataInputStream != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    private void readHeader(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kArchiveProperties) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid == NID.kAdditionalStreamsInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid == NID.kMainStreamsInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid == NID.kFilesInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid != NID.kEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    private void readArchiveProperties(final DataInput input) throws IOException {\n        // FIXME: the reference implementation just throws them away?\n        int nid =  input.readUnsignedByte();\n        while (nid != NID.kEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    private DataInputStream readEncodedHeader(final DataInputStream header, final Archive archive,\n                                              final byte[] password) throws IOException {\n        readStreamsInfo(header, archive);\n        \n        // FIXME: merge with buildDecodingStream()/buildDecoderStack() at some stage?\n        final Folder folder = archive.folders[0];\n        final int firstPackStreamIndex = 0;\n        final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                0;\n        \n        file.seek(folderOffset);\n        InputStream inputStreamStack = new BoundedRandomAccessFileInputStream(file,\n                archive.packSizes[firstPackStreamIndex]);\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n         //The specific code has been omitted, but there is no error\n        }\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n        }\n        if (folder.hasCrc) {\n         //The specific code has been omitted, but there is no error\n        }\n        final byte[] nextHeader = new byte[(int)folder.getUnpackSize()];\n        final DataInputStream nextHeaderInputStream = new DataInputStream(inputStreamStack);\n        try {\n            nextHeaderInputStream.readFully(nextHeader);\n        } finally {\n            nextHeaderInputStream.close();\n        }\n        return new DataInputStream(new ByteArrayInputStream(nextHeader));\n    }\n    \n    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kPackInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid == NID.kUnpackInfo) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            // archive without unpack/coders info\n            archive.folders = new Folder[0];\n        }\n        \n        if (nid == NID.kSubStreamsInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid != NID.kEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    private void readPackInfo(final DataInput header, final Archive archive) throws IOException {\n        archive.packPos = readUint64(header);\n        final long numPackStreams = readUint64(header);\n        int nid = header.readUnsignedByte();\n        if (nid == NID.kSize) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid == NID.kCRC) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid != NID.kEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    private void readUnpackInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        if (nid != NID.kFolder) {\n         //The specific code has been omitted, but there is no error\n        }\n        final long numFolders = readUint64(header);\n        final Folder[] folders = new Folder[(int)numFolders];\n        archive.folders = folders;\n        final int external = header.readUnsignedByte();\n        if (external != 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        for (int i = 0; i < (int)numFolders; i++) {\n            folders[i] = readFolder(header);\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid != NID.kCodersUnpackSize) {\n         //The specific code has been omitted, but there is no error\n        }\n        for (final Folder folder : folders) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        nid = header.readUnsignedByte();\n        if (nid == NID.kCRC) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid != NID.kEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        for (final Folder folder : archive.folders) {\n         //The specific code has been omitted, but there is no error\n        }\n        int totalUnpackStreams = archive.folders.length;\n        \n        int nid = header.readUnsignedByte();\n        if (nid == NID.kNumUnpackStream) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n        subStreamsInfo.crcs = new long[totalUnpackStreams];\n        \n        int nextUnpackStream = 0;\n        for (final Folder folder : archive.folders) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (nid == NID.kSize) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        int numDigests = 0;\n        for (final Folder folder : archive.folders) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid == NID.kCRC) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        if (nid != NID.kEnd) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        archive.subStreamsInfo = subStreamsInfo;\n    }\n    \n    private Folder readFolder(final DataInput header) throws IOException {\n        final Folder folder = new Folder();\n        \n        final long numCoders = readUint64(header);\n        final Coder[] coders = new Coder[(int)numCoders];\n        long totalInStreams = 0;\n        long totalOutStreams = 0;\n        for (int i = 0; i < coders.length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        folder.coders = coders;\n        folder.totalInputStreams = totalInStreams;\n        folder.totalOutputStreams = totalOutStreams;\n        \n        if (totalOutStreams == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        final long numBindPairs = totalOutStreams - 1;\n        final BindPair[] bindPairs = new BindPair[(int)numBindPairs];\n        for (int i = 0; i < bindPairs.length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        folder.bindPairs = bindPairs;\n        \n        if (totalInStreams < numBindPairs) {\n         //The specific code has been omitted, but there is no error\n        }\n        final long numPackedStreams = totalInStreams - numBindPairs;\n        final long packedStreams[] = new long[(int)numPackedStreams];\n        if (numPackedStreams == 1) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            for (int i = 0; i < (int)numPackedStreams; i++) {\n                packedStreams[i] = readUint64(header);\n            }\n        }\n        folder.packedStreams = packedStreams;\n        \n        return folder;\n    }\n    \n    private BitSet readAllOrBits(final DataInput header, final int size) throws IOException {\n        final int areAllDefined = header.readUnsignedByte();\n        final BitSet bits;\n        if (areAllDefined != 0) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            bits = readBits(header, size);\n        }\n        return bits;\n    }\n    \n    private BitSet readBits(final DataInput header, final int size) throws IOException {\n        final BitSet bits = new BitSet(size);\n        int mask = 0;\n        int cache = 0;\n        for (int i = 0; i < size; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        return bits;\n    }\n    \n    private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\n        final long numFiles = readUint64(header);\n        final SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\n        for (int i = 0; i < files.length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        BitSet isEmptyStream = null;\n        BitSet isEmptyFile = null; \n        BitSet isAnti = null;\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        int nonEmptyFileCounter = 0;\n        int emptyFileCounter = 0;\n        for (int i = 0; i < files.length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        archive.files = files;\n        calculateStreamMap(archive);\n    }\n    \n    private void calculateStreamMap(final Archive archive) throws IOException {\n        final StreamMap streamMap = new StreamMap();\n        \n        int nextFolderPackStreamIndex = 0;\n        final int numFolders = archive.folders != null ? archive.folders.length : 0;\n        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n        for (int i = 0; i < numFolders; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        long nextPackStreamOffset = 0;\n        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n        streamMap.packStreamOffsets = new long[numPackSizes];\n        for (int i = 0; i < numPackSizes; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        streamMap.folderFirstFileIndex = new int[numFolders];\n        streamMap.fileFolderIndex = new int[archive.files.length];\n        int nextFolderIndex = 0;\n        int nextFolderUnpackStreamIndex = 0;\n        for (int i = 0; i < archive.files.length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        archive.streamMap = streamMap;\n    }\n    \n    private void buildDecodingStream() throws IOException {\n        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n        if (folderIndex < 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n        if (currentFolderIndex == folderIndex) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            // We're opening a new folder. Discard any queued streams/ folder stream.\n            currentFolderIndex = folderIndex;\n            deferredBlockStreams.clear();\n            if (currentFolderInputStream != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            \n            final Folder folder = archive.folders[folderIndex];\n            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n        }\n\n        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\n        if (file.getHasCrc()) {\n            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n        }\n        \n        deferredBlockStreams.add(fileStream);\n    }\n\n    private InputStream buildDecoderStack(final Folder folder, final long folderOffset,\n                final int firstPackStreamIndex, final SevenZArchiveEntry entry) throws IOException {\n        file.seek(folderOffset);\n        InputStream inputStreamStack =\n            new BufferedInputStream(\n              new BoundedRandomAccessFileInputStream(file,\n                  archive.packSizes[firstPackStreamIndex]));\n        final LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();\n        for (final Coder coder : folder.getOrderedCoders()) {\n            if (coder.numInStreams != 1 || coder.numOutStreams != 1) {\n         //The specific code has been omitted, but there is no error\n        }\n            final SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);\n            inputStreamStack = Coders.addDecoder(fileName, inputStreamStack,\n                    folder.getUnpackSizeForCoder(coder), coder, password);\n            methods.addFirst(new SevenZMethodConfiguration(method,\n                     Coders.findByMethod(method).getOptionsFromCoder(coder, inputStreamStack)));\n        }\n        entry.setContentMethods(methods);\n        if (folder.hasCrc) {\n         //The specific code has been omitted, but there is no error\n        }\n        return inputStreamStack;\n    }\n    \n    /**\n     * Reads a byte of data.\n     * \n     * @return the byte read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read() throws IOException {\n        return getCurrentStream().read();\n    }\n    \n    private InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }\n\n    /**\n     * Reads data into an array of bytes.\n     * \n     * @param b the array to write data to\n     * @return the number of bytes read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read(final byte[] b) throws IOException {\n        return read(b, 0, b.length);\n    }\n    \n    /**\n     * Reads data into an array of bytes.\n     * \n     * @param b the array to write data to\n     * @param off offset into the buffer to start filling at\n     * @param len of bytes to read\n     * @return the number of bytes read, or -1 if end of input is reached\n     * @throws IOException\n     *             if an I/O error has occurred\n     */\n    public int read(final byte[] b, final int off, final int len) throws IOException {\n        return getCurrentStream().read(b, off, len);\n    }\n    \n    private static long readUint64(final DataInput in) throws IOException {\n        // long rather than int as it might get shifted beyond the range of an int\n        final long firstByte = in.readUnsignedByte();\n        int mask = 0x80;\n        long value = 0;\n        for (int i = 0; i < 8; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        return value;\n    }\n\n    /**\n     * Checks if the signature matches what is expected for a 7z file.\n     *\n     * @param signature\n     *            the bytes to check\n     * @param length\n     *            the number of bytes to check\n     * @return true, if this is the signature of a 7z archive.\n     * @since 1.8\n     */\n    public static boolean matches(final byte[] signature, final int length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n        if (bytesToSkip < 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        long skipped = 0;\n        while (bytesToSkip > Integer.MAX_VALUE) {\n         //The specific code has been omitted, but there is no error\n        }\n        while (bytesToSkip > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return skipped;\n    }\n    \n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}