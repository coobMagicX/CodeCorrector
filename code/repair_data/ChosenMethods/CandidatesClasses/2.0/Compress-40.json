{"BitInputStream": "public class BitInputStream implements Closeable {\n    private static final int MAXIMUM_CACHE_SIZE = 63; // bits in long minus sign bit\n    private static final long[] MASKS = new long[MAXIMUM_CACHE_SIZE + 1];\n\n    static {\n        for (int i = 1; i <= MAXIMUM_CACHE_SIZE; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private final InputStream in;\n    private final ByteOrder byteOrder;\n    private long bitsCached = 0;\n    private int bitsCachedSize = 0;\n\n    /**\n     * Constructor taking an InputStream and its bit arrangement. \n     * @param in the InputStream\n     * @param byteOrder the bit arrangement across byte boundaries,\n     *      either BIG_ENDIAN (aaaaabbb bb000000) or LITTLE_ENDIAN (bbbaaaaa 000000bb)\n     */\n    public BitInputStream(final InputStream in, final ByteOrder byteOrder) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n    \n    /**\n     * Clears the cache of bits that have been read from the\n     * underlying stream but not yet provided via {@link #readBits}.\n     */\n    public void clearBitCache() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n         //The specific code has been omitted, but there is no error\n        }\n        while (bitsCachedSize < count) {\n         //The specific code has been omitted, but there is no error\n        }\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        \n        final long bitsOut;\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        return bitsOut;\n    }\n}"}