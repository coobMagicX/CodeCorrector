{"InlineFunctions": "class InlineFunctions implements SpecializationAwareCompilerPass {\n\n  // TODO(nicksantos): This needs to be completely rewritten to use scopes\n  // to do variable lookups. Right now, it assumes that all functions are\n  // uniquely named variables. There's currently a stopgap scope-check\n  // to ensure that this doesn't produce invalid code. But in the long run,\n  // this needs a major refactor.\n  private final Map<String, FunctionState> fns = Maps.newHashMap();\n  private final Map<Node, String> anonFns = Maps.newHashMap();\n\n  private final AbstractCompiler compiler;\n\n  private final FunctionInjector injector;\n\n  private final boolean blockFunctionInliningEnabled;\n  private final boolean inlineGlobalFunctions;\n  private final boolean inlineLocalFunctions;\n\n  private SpecializeModule.SpecializationState specializationState;\n\n  InlineFunctions(AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean inlineGlobalFunctions,\n      boolean inlineLocalFunctions,\n      boolean blockFunctionInliningEnabled) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  FunctionState getOrCreateFunctionState(String fnName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void enableSpecialization(SpecializeModule.SpecializationState\n      specializationState) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Find functions that might be inlined.\n   */\n  private class FindCandidateFunctions implements Callback {\n    private int callsSeen = 0;\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find function expressions that are called directly in the form of\n     *   (function(a,b,...){\n         //The specific code has been omitted, but there is no error\n        })(a,b,...)\n     * or\n     *   (function(a,b,...){\n         //The specific code has been omitted, but there is no error\n        }).call(this,a,b, ...)\n     */\n    public void findFunctionExpressions(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Updates the FunctionState object for the given function. Checks if the\n   * given function matches the criteria for an inlinable function.\n   */\n  private void maybeAddFunction(Function fn, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param fnNode The function to inspect.\n   * @return Whether the function has parameters, var, or function declarations.\n   */\n  private boolean hasLocalNames(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the function the traversal is currently traversing, or null\n   * if in the global scope.\n   */\n  private static Node getContainingFunction(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks if the given function matches the criteria for an inlinable\n   * function.\n   */\n  private boolean isCandidateFunction(Function fn) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see CallVisitor\n   */\n  private interface CallVisitorCallback {\n    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs);\n  }\n\n  /**\n   * Visit call sites for functions in functionMap.\n   */\n  private static class CallVisitor extends AbstractPostOrderCallback {\n\n    protected CallVisitorCallback callback;\n    private Map<String, FunctionState> functionMap;\n    private Map<Node, String> anonFunctionMap;\n\n    CallVisitor(Map<String, FunctionState> fns,\n                Map<Node, String> anonFns,\n                CallVisitorCallback callback) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * @return Whether the name is used in a way that might be a candidate\n   *   for inlining.\n   */\n  static boolean isCandidateUsage(Node name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Find references to functions that are inlinable.\n   */\n  private class FindCandidatesReferences\n      extends CallVisitor\n      implements CallVisitorCallback {\n    FindCandidatesReferences(\n        Map<String, FunctionState> fns,\n        Map<Node, String> anonFns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void maybeAddReference(NodeTraversal t, FunctionState fs,\n        Node callNode, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean maybeAddReferenceUsingMode(\n        NodeTraversal t, FunctionState fs, Node callNode,\n        JSModule module, InliningMode mode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find functions that can be inlined.\n     */\n    private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Inline functions at the call sites.\n   */\n  private static class Inline implements CallVisitorCallback {\n    private final FunctionInjector injector;\n    private final SpecializeModule.SpecializationState specializationState;\n\n    Inline(FunctionInjector injector,\n        SpecializeModule.SpecializationState specializationState) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Inline a function into the call site.\n     */\n    private void inlineFunction(\n        NodeTraversal t, Node callNode, FunctionState fs, InliningMode mode) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Remove entries that aren't a valid inline candidates, from the list of\n   * encountered names.\n   */\n  private void trimCanidatesNotMeetingMinimumRequirements() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Remove entries from the list of candidates that can't be inlined.\n   */\n  void trimCanidatesUsingOnCost() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines if the function is worth inlining and potentially\n   * trims references that increase the cost.\n   * @return Whether inlining the references lowers the overall cost.\n   */\n  private boolean mimimizeCost(FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether inlining the function reduces code size.\n   */\n  private boolean inliningLowersCost(FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Size base inlining calculations are thrown off when a function that is\n   * being inlined also contains calls to functions that are slated for\n   * inlining.\n   *\n   * Specifically, a clone of the FUNCTION node tree is used when the function\n   * is inlined. Calls in this new tree are not included in the list of function\n   * references so they won't be inlined (which is what we want). Here we mark\n   * those functions as non-removable (as they will have new references in the\n   * cloned node trees).\n   *\n   * This prevents a function that would only be inlined because it is\n   * referenced once from being inlined into multiple call sites because\n   * the calling function has been inlined in multiple locations or the\n   * function being removed while there are still references.\n   */\n  private void resolveInlineConflicts() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see #resolveInlineConflicts\n   */\n  private void resolveInlineConflictsForFunction(FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This functions that may be called directly.\n   */\n  private Set<String> findCalledFunctions(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * For any call-site that needs it, prepare the call-site for inlining\n   * by rewriting the containing expression.\n   */\n  private void decomposeExpressions(Set<String> fnNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removed inlined functions that no longer have any references.\n   */\n  void removeInlinedFunctions() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sanity check to verify, that expression rewriting didn't\n   * make a call inaccessible.\n   */\n  void verifyAllReferencesInlined(FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Use to track the decisions that have been make about a function.\n   */\n  private static class FunctionState {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Interface for dealing with function declarations and function\n   * expressions equally\n   */\n  private static interface Function {\n    /** Gets the name of the function */\n    public String getName();\n\n    /** Gets the function node */\n    public Node getFunctionNode();\n\n    /** Removes itself from the javascript */\n    public void remove();\n\n    public Node getDeclaringBlock();\n  }\n\n  /** NamedFunction implementation of the Function interface */\n  private static class NamedFunction implements Function {\n    private final Node fn;\n\n    public NamedFunction(Node fn) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getDeclaringBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /** FunctionVar implementation of the Function interface */\n  private static class FunctionVar implements Function {\n    private final Node var;\n\n    public FunctionVar(Node var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getDeclaringBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /** FunctionExpression implementation of the Function interface */\n  private static class FunctionExpression implements Function {\n    private final Node fn;\n    private final String fakeName;\n\n    public FunctionExpression(Node fn, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getDeclaringBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  }\n\n  class Reference extends FunctionInjector.Reference {\n    final boolean requiresDecomposition;\n    boolean inlined = false;\n    Reference(\n        Node callNode, JSModule module, InliningMode mode, boolean decompose) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "FindCandidateFunctions": "  private class FindCandidateFunctions implements Callback {\n    private int callsSeen = 0;\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find function expressions that are called directly in the form of\n     *   (function(a,b,...){\n         //The specific code has been omitted, but there is no error\n        })(a,b,...)\n     * or\n     *   (function(a,b,...){\n         //The specific code has been omitted, but there is no error\n        }).call(this,a,b, ...)\n     */\n    public void findFunctionExpressions(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "CallVisitor": "  private static class CallVisitor extends AbstractPostOrderCallback {\n\n    protected CallVisitorCallback callback;\n    private Map<String, FunctionState> functionMap;\n    private Map<Node, String> anonFunctionMap;\n\n    CallVisitor(Map<String, FunctionState> fns,\n                Map<Node, String> anonFns,\n                CallVisitorCallback callback) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FindCandidatesReferences": "  private class FindCandidatesReferences\n      extends CallVisitor\n      implements CallVisitorCallback {\n    FindCandidatesReferences(\n        Map<String, FunctionState> fns,\n        Map<Node, String> anonFns) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void maybeAddReference(NodeTraversal t, FunctionState fs,\n        Node callNode, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean maybeAddReferenceUsingMode(\n        NodeTraversal t, FunctionState fs, Node callNode,\n        JSModule module, InliningMode mode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find functions that can be inlined.\n     */\n    private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Inline": "  private static class Inline implements CallVisitorCallback {\n    private final FunctionInjector injector;\n    private final SpecializeModule.SpecializationState specializationState;\n\n    Inline(FunctionInjector injector,\n        SpecializeModule.SpecializationState specializationState) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Inline a function into the call site.\n     */\n    private void inlineFunction(\n        NodeTraversal t, Node callNode, FunctionState fs, InliningMode mode) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FunctionState": "  private static class FunctionState {\n         //The specific code has been omitted, but there is no error\n        }", "NamedFunction": "  private static class NamedFunction implements Function {\n    private final Node fn;\n\n    public NamedFunction(Node fn) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getDeclaringBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FunctionVar": "  private static class FunctionVar implements Function {\n    private final Node var;\n\n    public FunctionVar(Node var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getDeclaringBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "FunctionExpression": "  private static class FunctionExpression implements Function {\n    private final Node fn;\n    private final String fakeName;\n\n    public FunctionExpression(Node fn, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getDeclaringBlock() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  }", "Reference": "  class Reference extends FunctionInjector.Reference {\n    final boolean requiresDecomposition;\n    boolean inlined = false;\n    Reference(\n        Node callNode, JSModule module, InliningMode mode, boolean decompose) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}