{"BasicDeserializerFactory": "public abstract class BasicDeserializerFactory\n    extends DeserializerFactory\n    implements java.io.Serializable\n{\n    private final static Class<?> CLASS_OBJECT = Object.class;\n    private final static Class<?> CLASS_STRING = String.class;\n    private final static Class<?> CLASS_CHAR_SEQUENCE = CharSequence.class;\n    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n\n    /**\n     * We need a placeholder for creator properties that don't have name\n     * but are marked with `@JsonWrapped` annotation.\n     */\n    protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\");\n    \n    /* We do some defaulting for abstract Map classes and\n     * interfaces, to avoid having to use exact types or annotations in\n     * cases where the most common concrete Maps will do.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Map>> _mapFallbacks =\n        new HashMap<String, Class<? extends Map>>();\n    static {\n        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n\n        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n                java.util.concurrent.ConcurrentSkipListMap.class);\n    }\n\n    /* We do some defaulting for abstract Collection classes and\n     * interfaces, to avoid having to use exact types or annotations in\n     * cases where the most common concrete Collection will do.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks =\n        new HashMap<String, Class<? extends Collection>>();\n    static {\n        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n\n        // then JDK 1.6 types:\n        /* 17-May-2013, tatu: [databind#216] Should be fine to use straight Class references EXCEPT\n         *   that some god-forsaken platforms (... looking at you, Android) do not\n         *   include these. So, use \"soft\" references...\n         */\n        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n    }\n\n    /*\n    /**********************************************************\n    /* Config\n    /**********************************************************\n     */\n    \n    /**\n     * Configuration settings for this factory; immutable instance (just like this\n     * factory), new version created via copy-constructor (fluent-style)\n     */\n    protected final DeserializerFactoryConfig _factoryConfig;\n\n    /*\n    /**********************************************************\n    /* Life cycle\n    /**********************************************************\n     */\n\n    protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for getting current {@link DeserializerFactoryConfig}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializerFactoryConfig getFactoryConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config);\n    \n    /*\n    /********************************************************\n    /* Configuration handling: fluent factories\n    /********************************************************\n     */\n\n    /**\n     * Convenience method for creating a new factory instance with additional deserializer\n     * provider.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link KeyDeserializers}.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link BeanDeserializerModifier}.\n     */\n    @Override\n    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link AbstractTypeResolver}.\n     */\n    @Override\n    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method for creating a new factory instance with additional\n     * {@link ValueInstantiators}.\n     */\n    @Override\n    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* DeserializerFactory impl (partial): type mappings\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException\n    {\n        // first, general mappings\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Method that will find abstract type mapping for specified type, doing a single\n     * lookup through registered abstract type resolvers; will not do recursive lookups.\n     */\n    private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n        throws JsonMappingException\n    {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if ((concrete != null) && !concrete.hasRawClass(currClass)) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): ValueInstantiators\n    /**********************************************************\n     */\n\n    /**\n     * Value instantiator is created both based on creator annotations,\n     * and on optional externally provided instantiators (registered through\n     * module interface).\n     */\n    @Override\n    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        // Check @JsonValueInstantiator before anything else\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (instantiator == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // finally: anyone want to modify ValueInstantiator?\n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                // let's do sanity check; easier to spot buggy handlers\n                if (instantiator == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            }\n        }\n\n        // Sanity check: does the chosen ValueInstantiator have incomplete creators?\n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }\n\n    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> raw = beanDesc.getBeanClass();\n        if (raw == JsonLocation.class) {\n         //The specific code has been omitted, but there is no error\n        }\n        // [databind#1868]: empty List/Set/Map\n        if (Collection.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_SET.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_SET);\n            }\n            if (Collections.EMPTY_LIST.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_LIST);\n            }\n        } else if (Map.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_MAP.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_MAP);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Method that will construct standard default {@link ValueInstantiator}\n     * using annotations (like @JsonCreator) and visibility rules\n     */\n    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        CreatorCollector creators = new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        // need to construct suitable visibility checker:\n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(beanDesc.getBeanClass(),\n                beanDesc.getClassInfo());\n\n        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n         *  (which has creator parameters sprinkled around) with actual creator\n         *  declarations (which are needed to access creator annotation, amongst other things).\n         *  Easiest to combine that info first, then pass it to remaining processing.\n         */\n        /* 15-Mar-2015, tatu: Alas, this won't help with constructors that only have implicit\n         *   names. Those will need to be resolved later on.\n         */\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n        // Important: first add factory methods; then constructors, so\n        // latter can override former!\n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        // constructors only usable on concrete types:\n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(ctxt);\n    }\n\n    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    if (defs[index] != null) {\n         //The specific code has been omitted, but there is no error\n        }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }\n    \n    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n            Annotated annotated, Object instDef)\n        throws JsonMappingException\n    {\n        if (instDef == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }\n\n    /*\n    /**********************************************************\n    /* Creator introspection\n    /**********************************************************\n     */\n\n    protected void _addDeserializerConstructors(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n                 throws JsonMappingException\n    {\n        // 25-Jan-2017, tatu: As per [databind#1501], [databind#1502], [databind#1503], best\n        //     for now to skip attempts at using anything but no-args constructor (see\n        //     `InnerClassProperty` construction for that)\n        final boolean isNonStaticInnerClass = beanDesc.isNonStaticInnerClass();\n        if (isNonStaticInnerClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // First things first: the \"default constructor\" (zero-arg\n        // constructor; whether implicit or explicit) is NOT included\n        // in list of constructors, so needs to be handled separately.\n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // 21-Sep-2017, tatu: First let's handle explicitly annotated ones\n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);\n            if (Mode.DISABLED == creatorMode) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (creatorMode == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            switch (creatorMode) {\n         //The specific code has been omitted, but there is no error\n        }\n            ++explCount;\n        }\n        // And only if and when those handled, consider potentially visible ones\n        if (explCount > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        List<AnnotatedWithParams> implicitCtors = null;\n        for (CreatorCandidate candidate : nonAnnotated) {\n         //The specific code has been omitted, but there is no error\n        }\n        // last option, as per [#725]: consider implicit-names-only, visible constructor,\n        // if just one found\n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }\n\n    /**\n     * Helper method called when there is the explicit \"is-creator\" with mode of \"delegating\"\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Somewhat simple: find injectable values, if any, ensure there is one\n        // and just one delegated argument; report violations if any\n\n        int ix = -1;\n        final int argCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n        for (int i = 0; i < argCount; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Also, let's require that one Delegating argument does eixt\n        if (ix < 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        // 17-Jan-2018, tatu: as per [databind#1853] need to ensure we will distinguish\n        //   \"well-known\" single-arg variants (String, int/long, boolean) from \"generic\" delegating...\n        if (argCount == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n    }\n\n    /**\n     * Helper method called when there is the explicit \"is-creator\" with mode of \"properties-based\"\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitPropertyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        final int paramCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n\n        for (int i = 0; i < paramCount; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n    }\n\n    /**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n         //The specific code has been omitted, but there is no error\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void _checkImplicitlyNamedConstructors(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            List<AnnotatedWithParams> implicitCtors) throws JsonMappingException\n    {\n        AnnotatedWithParams found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        // Further checks: (a) must have names for all parameters, (b) only one visible\n        // Also, since earlier matching of properties and creators relied on existence of\n        // `@JsonCreator` (or equivalent) annotation, we need to do bit more re-inspection...\n\n        main_loop:\n        for (AnnotatedWithParams ctor : implicitCtors) {\n         //The specific code has been omitted, but there is no error\n        }\n        // found one and only one visible? Ship it!\n        if (found != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    protected void _addDeserializerFactoryMethods\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        List<CreatorCandidate> nonAnnotated = new LinkedList<>();\n        int explCount = 0;\n\n        // 21-Sep-2017, tatu: First let's handle explicitly annotated ones\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), factory);\n            final int argCount = factory.getParameterCount();\n            if (creatorMode == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (creatorMode == Mode.DISABLED) {\n         //The specific code has been omitted, but there is no error\n        }\n            \n            // zero-arg method factory methods fine, as long as explicit\n            if (argCount == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            switch (creatorMode) {\n         //The specific code has been omitted, but there is no error\n        }\n            ++explCount;\n        }\n        // And only if and when those handled, consider potentially visible ones\n        if (explCount > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        // And then implicitly found\n        for (CreatorCandidate candidate : nonAnnotated) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    protected boolean _handleSingleArgumentCreator(CreatorCollector creators,\n            AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // 01-Dec-2016, tatu: As per [databind#265] we cannot yet support passing\n    //   of unwrapped values through creator properties, so fail fast\n    protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, AnnotatedParameter param)\n        throws JsonMappingException\n    {\n        ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                \"Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported\",\n                param.getIndex()));\n    }\n\n    /**\n     * Method that will construct a property object that represents\n     * a logical property passed via Creator (constructor or static\n     * factory method)\n     */\n    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, PropertyName name, int index,\n            AnnotatedParameter param,\n            JacksonInject.Value injectable)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(b, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param), param, metadata);\n        // Type deserializer: either comes from property (and already resolved)\n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        // or if not, based on type being referenced:\n        if (typeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Note: contextualization of typeDeser _should_ occur in constructor of CreatorProperty\n        // so it is not called directly here\n\n        Object injectableValueId = (injectable == null) ? null : injectable.getId();\n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return prop;\n    }\n\n    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: array deserializers\n    /**********************************************************\n     */\n        \n    @Override\n    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n            ArrayType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (elemTypeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // 23-Nov-2010, tatu: Custom array deserializer?\n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Collection(-like) deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n            CollectionType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /* One twist: if we are being asked to instantiate an interface or\n         * abstract Collection, we need to either find something that implements\n         * the thing, or give up.\n         *\n         * Note that we do NOT try to guess based on secondary interfaces\n         * here; that would probably not work correctly since casts would\n         * fail later on (as the primary type is not the interface we'd\n         * be implementing)\n         */\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // allow post-processing it too\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n    @Override\n    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n            CollectionLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: Map(-like) deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n            MapType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        // Then optional type info; either attached to type, or resolved separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n    @Override\n    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n            MapLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        /* !!! 24-Jan-2012, tatu: NOTE: impls MUST use resolve() to find key deserializer!\n        if (keyDes == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        */\n        // Then optional type info (1.5); either attached to type, or resolve separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl: other types\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method for constructing serializers of {@link Enum} types.\n     */\n    @Override\n    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // and then post-process it too\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }\n\n    @Override\n    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n            JavaType nodeType, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }\n\n    @Override\n    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt,\n            ReferenceType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): type deserializers\n    /**********************************************************\n     */\n\n    @Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        // Ok: if there is no explicit type info handler, we may want to\n        // use a default. If so, config object knows what to use.\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n        //    map to better type here\n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Overridable method called after checking all other types.\n     * \n     * @since 2.2\n     */\n    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializerFactory impl (partial): key deserializers\n    /**********************************************************\n     */\n    \n    @Override\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // and then post-processing\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());\n        // May have @JsonCreator for static factory method:\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (_hasCreatorAnnotation(ctxt, factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n         //The specific code has been omitted, but there is no error\n        }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method called to create a type information deserializer for values of\n     * given non-container property, if one is needed.\n     * If not needed (no polymorphic handling configured for property), should return null.\n     *<p>\n     * Note that this method is only called for non-container bean properties,\n     * and not for values in container types or root values (or container properties)\n     *\n     * @param baseType Declared base type of the value to deserializer (actual\n     *    deserializer type will be this type or its subtype)\n     * \n     * @return Type deserializer to use for given base type, if one is needed; null if not.\n     */\n    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, AnnotatedMember annotated)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }\n    \n    /**\n     * Method called to find and create a type information deserializer for values of\n     * given container (list, array, map) property, if one is needed.\n     * If not needed (no polymorphic handling configured for property), should return null.\n     *<p>\n     * Note that this method is only called for container bean properties,\n     * and not for values in container types or root values (or non-container properties)\n     * \n     * @param containerType Type of property; must be a container type\n     * @param propertyEntity Field or method that contains container property\n     */    \n    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config,\n            JavaType containerType, AnnotatedMember propertyEntity)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        // Defaulting: if no annotations on member, check class\n        if (b == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }\n\n    /**\n     * Helper method called to find one of default serializers for \"well-known\"\n     * platform types: JDK-provided types, and small number of public Jackson\n     * API types.\n     * \n     * @since 2.2\n     */\n    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        // Object (\"untyped\"), String equivalents:\n        if (rawType == CLASS_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_SEQUENCE) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (rawType == CLASS_ITERABLE) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n         //The specific code has been omitted, but there is no error\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        // and a few Jackson types as well:\n        if (rawType == TokenBuffer.class) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }\n\n    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, finding custom deserializers\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n    \n    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n\n    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, value/content/key type introspection\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization; and if\n     * so, to instantiate, that deserializer to use.\n     * Note that deserializer will NOT yet be contextualized so caller needs to\n     * take care to call contextualization appropriately.\n     * Returns null if no such annotation found.\n     */\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization.\n     * Returns null if no such annotation found.\n     */\n    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n            throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    /**\n     * @since 2.9\n     */\n    protected JsonDeserializer<Object> findContentDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n    \n    /**\n     * Helper method used to resolve additional type-related annotation information\n     * like type overrides, or handler (serializer, deserializer) overrides,\n     * so that from declared field, property or constructor parameter type\n     * is used as the base and modified based on annotations, if any.\n     * \n     * @since 2.8 Combines functionality of <code>modifyTypeByAnnotation</code>\n     *     and <code>resolveType</code>\n     */\n    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt,\n            AnnotatedMember member, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // First things first: see if we can find annotations on declared\n        // type\n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        if (type.hasContentType()) { // that is, is either container- or reference-type\n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Second part: find actual type-override annotations on member, if any\n\n        // 18-Jun-2016, tatu: Should we re-do checks for annotations on refined\n        //   subtypes as well? Code pre-2.8 did not do this, but if we get bug\n        //   reports may need to consider\n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }\n\n    protected EnumResolver constructEnumResolver(Class<?> enumClass,\n            DeserializationConfig config, AnnotatedMember jsonValueAccessor)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.9\n     */\n    protected boolean _hasCreatorAnnotation(DeserializationContext ctxt,\n            Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Deprecated helper methods\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     *\n     * @deprecated Since 2.8; call {@link #resolveMemberAndTypeAnnotations} instead\n     */\n    @Deprecated\n    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }\n\n    /**\n     * @deprecated since 2.8 call {@link #resolveMemberAndTypeAnnotations} instead.\n     */\n    @Deprecated // since 2.8\n    protected JavaType resolveType(DeserializationContext ctxt,\n            BeanDescription beanDesc, JavaType type, AnnotatedMember member)\n        throws JsonMappingException\n    {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }\n\n    /**\n     * @deprecated since 2.8 call <code>findJsonValueMethod</code> on {@link BeanDescription} instead\n     */\n    @Deprecated // not used, possibly remove as early as 2.9\n    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}