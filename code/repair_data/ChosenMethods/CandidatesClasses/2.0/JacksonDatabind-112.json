{"StringCollectionDeserializer": "public final class StringCollectionDeserializer\n    extends ContainerDeserializerBase<Collection<String>>\n    implements ContextualDeserializer\n{\n    private static final long serialVersionUID = 1L;\n\n    // // Configuration\n\n    /**\n     * Value deserializer to use, if NOT the standard one\n     * (if it is, will be null).\n     */\n    protected final JsonDeserializer<String> _valueDeserializer;\n\n    // // Instance construction settings:\n    \n    /**\n     * Instantiator used in case custom handling is needed for creation.\n     */\n    protected final ValueInstantiator _valueInstantiator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected final JsonDeserializer<Object> _delegateDeserializer;\n\n    // NOTE: no PropertyBasedCreator, as JSON Arrays have no properties\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n    \n    public StringCollectionDeserializer(JavaType collectionType,\n            JsonDeserializer<?> valueDeser, ValueInstantiator valueInstantiator)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @SuppressWarnings(\"unchecked\")\n    protected StringCollectionDeserializer(JavaType collectionType,\n            ValueInstantiator valueInstantiator, JsonDeserializer<?> delegateDeser,\n            JsonDeserializer<?> valueDeser,\n            NullValueProvider nuller, Boolean unwrapSingle)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected StringCollectionDeserializer withResolved(JsonDeserializer<?> delegateDeser,\n            JsonDeserializer<?> valueDeser,\n            NullValueProvider nuller, Boolean unwrapSingle)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override // since 2.5\n    public boolean isCachable() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        if (_valueInstantiator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }\n    \n    /*\n    /**********************************************************\n    /* ContainerDeserializerBase API\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ValueInstantiator getValueInstantiator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer API\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_delegateDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        final Collection<String> result = (Collection<String>) _valueInstantiator.createUsingDefault(ctxt);\n        return deserialize(p, ctxt, result);\n    }\n\n    @Override\n    public Collection<String> deserialize(JsonParser p, DeserializationContext ctxt,\n            Collection<String> result)\n        throws IOException\n    {\n        // Ok: must point to START_ARRAY\n        if (!p.isExpectedStartArrayToken()) {\n            return handleNonArray(p, ctxt, result);\n        }\n\n        if (_valueDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        try {\n            while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return result;\n    }\n    \n    private Collection<String> deserializeUsingCustom(JsonParser p, DeserializationContext ctxt,\n            Collection<String> result, final JsonDeserializer<String> deser) throws IOException\n    {\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        return result;\n    }\n    \n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer) throws IOException {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromArray(p, ctxt);\n    }\n\n    /**\n     * Helper method called when current token is not START_ARRAY. Will either\n     * throw an exception, or try to handle value as if member of implicit\n     * array, depending on configuration.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private final Collection<String> handleNonArray(JsonParser p, DeserializationContext ctxt,\n            Collection<String> result) throws IOException\n    {\n        // implicit arrays from single values?\n        boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||\n                ((_unwrapSingle == null) &&\n                        ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));\n        if (!canWrap) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Strings are one of \"native\" (intrinsic) types, so there's never type deserializer involved\n        JsonDeserializer<String> valueDes = _valueDeserializer;\n        JsonToken t = p.getCurrentToken();\n\n        String value;\n        \n        if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            value = (valueDes == null) ? _parseString(p, ctxt) : valueDes.deserialize(p, ctxt);\n        }\n        result.add(value);\n        return result;\n    }\n}"}