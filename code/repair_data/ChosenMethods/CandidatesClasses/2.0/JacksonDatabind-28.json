{"JsonNodeDeserializer": "public class JsonNodeDeserializer\n    extends BaseNodeDeserializer<JsonNode>\n{\n    /**\n     * Singleton instance of generic deserializer for {@link JsonNode}.\n     * Only used for types other than JSON Object and Array.\n     */\n    private final static JsonNodeDeserializer instance = new JsonNodeDeserializer();\n\n    protected JsonNodeDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for accessing deserializer for specific node type\n     */\n    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Actual deserializer implementations\n    /**********************************************************\n     */\n\n    @Override\n    public JsonNode getNullValue(DeserializationContext ctxt) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    @Deprecated // since 2.6, remove from 2.7\n    public JsonNode getNullValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Implementation that will produce types of any JSON nodes; not just one\n     * deserializer is registered to handle (in case of more specialized handler).\n     * Overridden by typed sub-classes for more thorough checking\n     */\n    @Override\n    public JsonNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n        default:\n            return deserializeAny(p, ctxt, ctxt.getNodeFactory());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Specific instances for more accurate types\n    /**********************************************************\n     */\n\n    final static class ObjectDeserializer\n        extends BaseNodeDeserializer<ObjectNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ObjectDeserializer _instance = new ObjectDeserializer();\n\n        protected ObjectDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static ObjectDeserializer getInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static ArrayDeserializer getInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n    }\n}", "ObjectDeserializer": "    final static class ObjectDeserializer\n        extends BaseNodeDeserializer<ObjectNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ObjectDeserializer _instance = new ObjectDeserializer();\n\n        protected ObjectDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static ObjectDeserializer getInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }", "ArrayDeserializer": "    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static ArrayDeserializer getInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n    }", "BaseNodeDeserializer": "abstract class BaseNodeDeserializer<T extends JsonNode>\n    extends StdDeserializer<T>\n{\n    public BaseNodeDeserializer(Class<T> vc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        /* Output can be as JSON Object, Array or scalar: no way to know\n         * a priori. So:\n         */\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }\n\n    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n     *   sense to also mark this is cachable, since lookup not exactly free, and\n     *   since it's not uncommon to \"read anything\"\n     */\n    @Override\n    public boolean isCachable() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Overridable methods\n    /**********************************************************\n     */\n\n    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }\n\n    /**\n     * Method called when there is a duplicate value for a field.\n     * By default we don't care, and the last value is used.\n     * Can be overridden to provide alternate handling, such as throwing\n     * an exception, or choosing different strategy for combining values\n     * or choosing which one to keep.\n     *\n     * @param fieldName Name of the field for which duplicate value was found\n     * @param objectNode Object node that contains values\n     * @param oldValue Value that existed for the object node before newValue\n     *   was added\n     * @param newValue Newly added value just added to the object node\n     */\n    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory,\n            String fieldName, ObjectNode objectNode,\n            JsonNode oldValue, JsonNode newValue)\n        throws JsonProcessingException\n    {\n        // [Issue#237]: Report an error if asked to do so:\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (t != JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return node;\n    }\n\n    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: // for empty JSON Objects we may point to this\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            // These states can not be mapped; input stream is\n            // off by an event or two\n\n        //case END_OBJECT:\n        //case END_ARRAY:\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }\n\n    protected final JsonNode _fromInt(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt;\n        int feats = ctxt.getDeserializationFeatures();\n        if ((feats & F_MASK_INT_COERCIONS) != 0) {\n            if (DeserializationFeature.USE_BIG_INTEGER_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.BIG_INTEGER;\n            } else if (DeserializationFeature.USE_LONG_FOR_INTS.enabledIn(feats)) {\n                nt = JsonParser.NumberType.LONG;\n            } else {\n                nt = p.getNumberType();\n            }\n        } else {\n            nt = p.getNumberType();\n        }\n        if (nt == JsonParser.NumberType.INT) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (nt == JsonParser.NumberType.LONG) {\n         //The specific code has been omitted, but there is no error\n        }\n        return nodeFactory.numberNode(p.getBigIntegerValue());\n    }\n\n    protected final JsonNode _fromFloat(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        JsonParser.NumberType nt = p.getNumberType();\n        if (nt == JsonParser.NumberType.BIG_DECIMAL\n            || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return nodeFactory.numberNode(p.getDecimalValue());\n        }\n        return nodeFactory.numberNode(p.getDoubleValue());\n    }\n\n    protected final JsonNode _fromEmbedded(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory) throws IOException\n    {\n        // [JACKSON-796]\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        Class<?> type = ob.getClass();\n        if (type == byte[].class) {\n         //The specific code has been omitted, but there is no error\n        }\n        // [databind#743]: Don't forget RawValue\n        if (ob instanceof RawValue) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (ob instanceof JsonNode) {\n         //The specific code has been omitted, but there is no error\n        }\n        // any other special handling needed?\n        return nodeFactory.pojoNode(ob);\n    }\n}"}