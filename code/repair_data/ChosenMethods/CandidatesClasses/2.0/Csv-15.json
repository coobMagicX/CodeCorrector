{"CSVFormat": "public final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withEscape('\\\\')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private final boolean allowMissingColumnNames;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    private final boolean autoFlush;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter, final boolean autoFlush) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean equals(final Object obj) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (object == null) {\n         //The specific code has been omitted, but there is no error\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // write last segment\n        if (pos > start) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        switch (quoteModePolicy) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (!quote) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private String[] toStringArray(final Object[] values) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private CharSequence trim(final CharSequence charSequence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // validate header\n        if (header != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}