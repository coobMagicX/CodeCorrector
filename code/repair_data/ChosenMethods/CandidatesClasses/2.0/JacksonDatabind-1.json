{"BeanPropertyWriter": "public class BeanPropertyWriter\n    implements BeanProperty\n{\n    /**\n     * Marker object used to indicate \"do not serialize if empty\"\n     */\n    public final static Object MARKER_FOR_EMPTY = new Object();\n    \n    /*\n    /**********************************************************\n    /* Settings for accessing property value to serialize\n    /**********************************************************\n     */\n\n    /**\n     * Member (field, method) that represents property and allows access\n     * to associated annotations.\n     */\n    protected final AnnotatedMember _member;\n\n    /**\n     * Annotations from context (most often, class that declares property,\n     * or in case of sub-class serializer, from that sub-class)\n     */\n    protected final Annotations _contextAnnotations;\n    \n    /**\n     * Type property is declared to have, either in class definition \n     * or associated annotations.\n     */\n    protected final JavaType _declaredType;\n    \n    /**\n     * Accessor method used to get property value, for\n     * method-accessible properties.\n     * Null if and only if {@link #_field} is null.\n     */\n    protected final Method _accessorMethod;\n    \n    /**\n     * Field that contains the property value for field-accessible\n     * properties.\n     * Null if and only if {@link #_accessorMethod} is null.\n     */\n    protected final Field _field;\n    \n    /*\n    /**********************************************************\n    /* Opaque internal data that bean serializer factory and\n    /* bean serializers can add.\n    /**********************************************************\n     */\n\n    protected HashMap<Object,Object> _internalSettings;\n    \n    /*\n    /**********************************************************\n    /* Serialization settings\n    /**********************************************************\n     */\n    \n    /**\n     * Logical name of the property; will be used as the field name\n     * under which value for the property is written.\n     */\n    protected final SerializedString _name;\n\n    /**\n     * Wrapper name to use for this element, if any\n     * \n     * @since 2.2\n     */\n    protected final PropertyName _wrapperName;\n    \n    /**\n     * Type to use for locating serializer; normally same as return\n     * type of the accessor method, but may be overridden by annotations.\n     */\n    protected final JavaType _cfgSerializationType;\n\n    /**\n     * Serializer to use for writing out the value: null if it can not\n     * be known statically; non-null if it can.\n     */\n    protected JsonSerializer<Object> _serializer;\n\n    /**\n     * Serializer used for writing out null values, if any: if null,\n     * null values are to be suppressed.\n     */\n    protected JsonSerializer<Object> _nullSerializer;\n    \n    /**\n     * In case serializer is not known statically (i.e. <code>_serializer</code>\n     * is null), we will use a lookup structure for storing dynamically\n     * resolved mapping from type(s) to serializer(s).\n     */\n    protected PropertySerializerMap _dynamicSerializers;\n\n    /**\n     * Whether null values are to be suppressed (nothing written out if\n     * value is null) or not.\n     */\n    protected final boolean _suppressNulls;\n    \n    /**\n     * Value that is considered default value of the property; used for\n     * default-value-suppression if enabled.\n     */\n    protected final Object _suppressableValue;\n\n    /**\n     * Alternate set of property writers used when view-based filtering\n     * is available for the Bean.\n     */\n    protected final Class<?>[] _includeInViews;\n\n    /**\n     * If property being serialized needs type information to be\n     * included this is the type serializer to use.\n     * Declared type (possibly augmented with annotations) of property\n     * is used for determining exact mechanism to use (compared to\n     * actual runtime type used for serializing actual state).\n     */\n    protected TypeSerializer _typeSerializer;\n    \n    /**\n     * Base type of the property, if the declared type is \"non-trivial\";\n     * meaning it is either a structured type (collection, map, array),\n     * or parameterized. Used to retain type information about contained\n     * type, which is mostly necessary if type meta-data is to be\n     * included.\n     */\n    protected JavaType _nonTrivialBaseType;\n\n    /**\n     * Whether value of this property has been marked as required.\n     * Retained since it will be needed when traversing type hierarchy\n     * for producing schemas (and other similar tasks); currently not\n     * used for serialization.\n     * \n     * @since 2.2\n     */\n    protected final boolean _isRequired;\n    \n    /*\n    /**********************************************************\n    /* Construction, configuration\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    public BeanPropertyWriter(BeanPropertyDefinition propDef,\n            AnnotatedMember member, Annotations contextAnnotations,\n            JavaType declaredType,\n            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n            boolean suppressNulls, Object suppressableValue)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * \"Copy constructor\" to be used by filtering sub-classes\n     */\n    protected BeanPropertyWriter(BeanPropertyWriter base) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BeanPropertyWriter rename(NameTransformer transformer) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method called to assign value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignSerializer(JsonSerializer<Object> ser)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to assign null value serializer for property\n     * \n     * @since 2.0\n     */\n    public void assignNullSerializer(JsonSerializer<Object> nullSer)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method called create an instance that handles details of unwrapping\n     * contained value.\n     */\n    public BeanPropertyWriter unwrappingWriter(NameTransformer unwrapper) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to define type to consider as \"non-trivial\" basetype,\n     * needed for dynamic serialization resolution for complex (usually container)\n     * types\n     */\n    public void setNonTrivialBaseType(JavaType t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* BeanProperty impl\n    /**********************************************************\n     */\n    \n    @Override\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JavaType getType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public PropertyName getWrapperName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean isRequired() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public AnnotatedMember getMember() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n    @Override\n    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n        throws JsonMappingException\n    {\n        if (objectVisitor != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Managing and accessing of opaque internal settings\n    /* (used by extensions)\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing value of specified internal setting.\n     * \n     * @return Value of the setting, if any; null if none.\n     */\n    public Object getInternalSetting(Object key)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for setting specific internal setting to given value\n     * \n     * @return Old value of the setting, if any (null if none)\n     */\n    public Object setInternalSetting(Object key, Object value)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for removing entry for specified internal setting.\n     * \n     * @return Existing value of the setting, if any (null if none)\n     */\n    public Object removeInternalSetting(Object key)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Accessors\n    /**********************************************************\n     */\n\n    public SerializedString getSerializedName() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public boolean hasSerializer() {\n         //The specific code has been omitted, but there is no error\n        }\n    public boolean hasNullSerializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean willSuppressNulls() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    // Needed by BeanSerializer#getSchema\n    public JsonSerializer<Object> getSerializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public JavaType getSerializationType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Class<?> getRawSerializationType() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public Class<?> getPropertyType() \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the generic property type of this property writer.\n     *\n     * @return The property type, or null if not found.\n     */\n    public Type getGenericPropertyType()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Class<?>[] getViews() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     *<p>\n     * NOTE: due to introspection, this is a <b>slow</b> method to call\n     * and should never be called during actual serialization or filtering\n     * of the property. Rather it is needed for traversal needed for things\n     * like constructing JSON Schema instances.\n     * \n     * @since 2.1\n     * \n     * @deprecated since 2.2, use {@link #isRequired()} instead.\n     */\n    @Deprecated\n    protected boolean isRequired(AnnotationIntrospector intr) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Legacy support for JsonFormatVisitable\n    /**********************************************************\n     */\n\n    /**\n     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n     * \n     * @param propertiesNode Node which the given property would exist within\n     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n     *  processing\n     *  \n     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n     * \n     * @since 2.1\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n        throws JsonMappingException\n    {\n        JavaType propType = getSerializationType();\n        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n        JsonNode schemaNode;\n        // Maybe it already has annotated/statically configured serializer?\n        JsonSerializer<Object> ser = getSerializer();\n        if (ser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        boolean isOptional = !isRequired();\n        if (ser instanceof SchemaAware) {\n         //The specific code has been omitted, but there is no error\n        } else {  \n            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n        }\n        propertiesNode.put(getName(), schemaNode);\n    }\n    \n    /*\n    /**********************************************************\n    /* Serialization functionality\n    /**********************************************************\n     */\n\n    /**\n     * Method called to access property that this bean stands for, from\n     * within given bean, and to serialize it as a JSON Object field\n     * using appropriate serializer.\n     */\n    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        // Null handling is bit different, check that first\n        if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // then find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n         //The specific code has been omitted, but there is no error\n        }\n        jgen.writeFieldName(_name);\n        if (_typeSerializer == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_typeSerializer == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Method called to serialize a placeholder used in tabular output when\n     * real value is not to be included (is filtered out), but when we need\n     * an entry so that field indexes will not be off. Typically this should\n     * output null or empty String, depending on datatype.\n     * \n     * @since 2.1\n     */\n    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        if (_nullSerializer != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            jgen.writeNull();\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n    \n    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n            Class<?> type, SerializerProvider provider) throws JsonMappingException\n    {\n        PropertySerializerMap.SerializerAndMapResult result;\n        if (_nonTrivialBaseType != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            result = map.findAndAddSerializer(type, provider, this);\n        }\n        // did we get a new map of serializers? If so, start using it\n        if (map != result.map) {\n         //The specific code has been omitted, but there is no error\n        }\n        return result.serializer;\n    }\n    \n    /**\n     * Method that can be used to access value of the property this\n     * Object describes, from given bean instance.\n     *<p>\n     * Note: method is final as it should not need to be overridden -- rather,\n     * calling method(s) ({@link #serializeAsField}) should be overridden\n     * to change the behavior\n     */\n    public final Object get(Object bean) throws Exception\n    {\n        if (_accessorMethod != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _field.get(bean);\n    }\n\n    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n        throws JsonMappingException\n    {\n        /* 05-Feb-2012, tatu: Usually a problem, but NOT if we are handling\n         *    object id; this may be the case for BeanSerializers at least.\n         */\n        if (ser.usesObjectId()) {\n            return;\n        }\n        throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n    }\n\n    @Override\n    public String toString()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}