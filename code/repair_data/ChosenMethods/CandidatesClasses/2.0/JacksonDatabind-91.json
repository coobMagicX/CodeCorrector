{"DeserializerCache": "public final class DeserializerCache\n    implements java.io.Serializable // since 2.1 -- needs to be careful tho\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /**\n     * We will also cache some dynamically constructed deserializers;\n     * specifically, ones that are expensive to construct.\n     * This currently means bean and Enum deserializers; starting with\n     * 2.5, container deserializers will also be cached.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * define a relatively low concurrency setting.\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n\n    /**\n     * During deserializer construction process we may need to keep track of partially\n     * completed deserializers, to resolve cyclic dependencies. This is the\n     * map used for storing deserializers before they are fully complete.\n     */\n    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public DeserializerCache() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JDK serialization handling\n    /**********************************************************\n     */\n\n    Object writeReplace() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Access to caching aspects\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to determine how many deserializers this\n     * provider is caching currently \n     * (if it does caching: default implementation does)\n     * Exact count depends on what kind of deserializers get cached;\n     * default implementation caches only dynamically constructed deserializers,\n     * but not eagerly constructed standard deserializers (which is different\n     * from how serializer provider works).\n     *<p>\n     * The main use case for this method is to allow conditional flushing of\n     * deserializer cache, if certain number of entries is reached.\n     */\n    public int cachedDeserializersCount() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that will drop all dynamically constructed deserializers (ones that\n     * are counted as result value for {@link #cachedDeserializersCount}).\n     * This can be used to remove memory usage (in case some deserializers are\n     * only used once or so), or to force re-construction of deserializers after\n     * configuration changes for mapper than owns the provider.\n     */\n    public void flushCachedDeserializers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* General deserializer locating method\n    /**********************************************************\n     */\n\n    /**\n     * Method called to get hold of a deserializer for a value of given type;\n     * or if no such deserializer can be found, a default handler (which\n     * may do a best-effort generic serialization or just simply\n     * throw an exception when invoked).\n     *<p>\n     * Note: this method is only called for value types; not for keys.\n     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n     *<p>\n     * Note also that deserializer returned is guaranteed to be resolved\n     * (if it is of type {@link ResolvableDeserializer}), but\n     * not contextualized (wrt {@link ContextualDeserializer}): caller\n     * has to handle latter if necessary.\n     *\n     * @param ctxt Deserialization context\n     * @param propertyType Declared type of the value to deserializer (obtained using\n     *   'setter' method signature and/or type annotations\n     *\n     * @throws JsonMappingException if there are fatal problems with\n     *   accessing suitable deserializer; including that of not\n     *   finding any serializer\n     */\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    /**\n     * Method called to get hold of a deserializer to use for deserializing\n     * keys for {@link java.util.Map}.\n     *\n     * @throws JsonMappingException if there are fatal problems with\n     *   accessing suitable key deserializer; including that of not\n     *   finding any serializer\n     */\n    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n        if (kd == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // First: need to resolve?\n        if (kd instanceof ResolvableDeserializer) {\n         //The specific code has been omitted, but there is no error\n        }\n        return kd;\n    }\n\n    /**\n     * Method called to find out whether provider would be able to find\n     * a deserializer for given type, using a root reference (i.e. not\n     * through fields or membership in an array or collection)\n     */\n    public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Note: mostly copied from findValueDeserializer, except for\n         * handling of unknown types\n         */\n        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return (deser != null);\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods that handle cache lookups\n    /**********************************************************\n     */\n\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that will try to create a deserializer for given type,\n     * and resolve and cache it if necessary\n     * \n     * @param ctxt Currently active deserialization context\n     * @param type Type of property to deserialize\n     */\n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Method that handles actual construction (via factory) and caching (both\n     * intermediate and eventual)\n     */\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (addToCache) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deser;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for actual construction of deserializers\n    /**********************************************************\n     */\n    \n    /**\n     * Method that does the heavy lifting of checking for per-type annotations,\n     * find out full type, and figure out which actual factory method\n     * to call.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [databind#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n    protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // If not, let's see which factory method to use:\n        if (type.isEnumType()) {\n            return factory.createEnumDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isContainerType()) {\n            if (type.isArrayType()) {\n                return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc);\n            }\n            if (type.isMapLikeType()) {\n                MapLikeType mlt = (MapLikeType) type;\n                if (mlt.isTrueMapType()) {\n                    return factory.createMapDeserializer(ctxt,(MapType) mlt, beanDesc);\n                }\n                return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc);\n            }\n            if (type.isCollectionLikeType()) {\n                /* 03-Aug-2012, tatu: As per [databind#40], one exception is if shape\n                 *   is to be Shape.OBJECT. Ideally we'd determine it bit later on\n                 *   (to allow custom handler checks), but that won't work for other\n                 *   reasons. So do it here.\n                 */\n                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n                if ((format == null) || format.getShape() != JsonFormat.Shape.OBJECT) {\n                    CollectionLikeType clt = (CollectionLikeType) type;\n                    if (clt.isTrueCollectionType()) {\n                        return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc);\n                    }\n                    return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc);\n                }\n            }\n        }\n        if (type.isReferenceType()) {\n            return factory.createReferenceDeserializer(ctxt, (ReferenceType) type, beanDesc);\n        }\n        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n            return factory.createTreeDeserializer(config, type, beanDesc);\n        }\n        return factory.createBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n    /**\n     * Helper method called to check if a class or method\n     * has annotation that tells which class to use for deserialization.\n     * Returns null if no such annotation found.\n     */\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        // One more thing however: may need to also apply a converter:\n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n    /**\n     * Helper method that will check whether given annotated entity (usually class,\n     * but may also be a property accessor) indicates that a {@link Converter} is to\n     * be used; and if so, to construct and return suitable serializer for it.\n     * If not, will simply return given serializer as is.\n     */\n    protected JsonDeserializer<Object> findConvertingDeserializer(DeserializationContext ctxt,\n            Annotated a, JsonDeserializer<Object> deser)\n        throws JsonMappingException\n    {\n        Converter<Object,Object> conv = findConverter(ctxt, a);\n        if (conv == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        return (JsonDeserializer<Object>) new StdDelegatingDeserializer<Object>(conv, delegateType, deser);\n    }\n\n    protected Converter<Object,Object> findConverter(DeserializationContext ctxt,\n            Annotated a)\n        throws JsonMappingException\n    {\n        Object convDef = ctxt.getAnnotationIntrospector().findDeserializationConverter(a);\n        if (convDef == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return ctxt.converterInstance(a, convDef);\n    }    \n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type derived from the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // First things first: find explicitly annotated deserializer(s)\n\n        // then key/value handlers  (annotated deserializers)?\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n            //   (not 100% why or how, but this does seem to get called more than once, which\n            //   is not good: for now, let's just avoid errors)\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            }            \n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // And after handlers, possible type refinements\n        // (note: could possibly avoid this if explicit deserializer was invoked?)\n        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);\n        \n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Overridable error reporting methods\n    /**********************************************************\n     */\n\n    // NOTE: changed 2.6 -> 2.7 to pass context; no way to make backwards compatible\n    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(DeserializationContext ctxt, JavaType type)\n        throws JsonMappingException\n    {\n        // Let's try to figure out the reason, to give better error messages\n        Class<?> rawClass = type.getRawClass();\n        if (!ClassUtil.isConcrete(rawClass)) {\n            ctxt.reportMappingException(\"Can not find a Value deserializer for abstract type %s\", type);\n        }\n        ctxt.reportMappingException(\"Can not find a Value deserializer for type %s\", type);\n        return null;\n    }\n\n    protected KeyDeserializer _handleUnknownKeyDeserializer(DeserializationContext ctxt, JavaType type)\n        throws JsonMappingException\n    {\n        ctxt.reportMappingException(\"Can not find a (Map) Key deserializer for type %s\", type);\n        return null;\n    }\n}"}