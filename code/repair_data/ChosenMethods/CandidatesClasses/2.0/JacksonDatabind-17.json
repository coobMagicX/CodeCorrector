{"ObjectMapper": "public class ObjectMapper\n    extends ObjectCodec\n    implements Versioned,\n        java.io.Serializable // as of 2.1\n{\n    private static final long serialVersionUID = 1L;\n\n    /*\n    /**********************************************************\n    /* Helper classes, enums\n    /**********************************************************\n     */\n\n    /**\n     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n     * to specify what kind of types (classes) default typing should\n     * be used for. It will only be used if no explicit type information\n     * is found, but this enumeration further limits subset of those types.\n     *<p>\n     * Since 2.4 there are special exceptions for JSON Tree model\n     * types (sub-types of {@link TreeNode}: default typing is never\n     * applied to them\n     * (see <a href=\"https://github.com/FasterXML/jackson-databind/issues/88\">Issue#88</a> for details)\n     */\n    public enum DefaultTyping {\n        /**\n         * This value means that only properties that have\n         * {@link java.lang.Object} as declared type (including\n         * generic types without explicit type) will use default\n         * typing.\n         */\n        JAVA_LANG_OBJECT,\n        \n        /**\n         * Value that means that default typing will be used for\n         * properties with declared type of {@link java.lang.Object}\n         * or an abstract type (abstract class or interface).\n         * Note that this does <b>not</b> include array types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        OBJECT_AND_NON_CONCRETE,\n\n        /**\n         * Value that means that default typing will be used for\n         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n         * plus all array types for them.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_CONCRETE_AND_ARRAYS,\n        \n        /**\n         * Value that means that default typing will be used for\n         * all non-final types, with exception of small number of\n         * \"natural\" types (String, Boolean, Integer, Double), which\n         * can be correctly inferred from JSON; as well as for\n         * all arrays of non-final types.\n         *<p>\n         * Since 2.4, this does NOT apply to {@link TreeNode} and its subtypes.\n         */\n        NON_FINAL\n    }\n\n    /**\n     * Customized {@link TypeResolverBuilder} that provides type resolver builders\n     * used with so-called \"default typing\"\n     * (see {@link ObjectMapper#enableDefaultTyping()} for details).\n     *<p>\n     * Type resolver construction is based on configuration: implementation takes care\n     * of only providing builders in cases where type information should be applied.\n     * This is important since build calls may be sent for any and all types, and\n     * type information should NOT be applied to all of them.\n     */\n    public static class DefaultTypeResolverBuilder\n        extends StdTypeResolverBuilder\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Definition of what types is this default typer valid for.\n         */\n        protected final DefaultTyping _appliesFor;\n\n        public DefaultTypeResolverBuilder(DefaultTyping t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n     *   sure what'd be simple and elegant way. So until then:\n     */\n    protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n\n    // 16-May-2009, tatu: Ditto ^^^\n    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n\n    protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n\n    protected final static PrettyPrinter _defaultPrettyPrinter = new DefaultPrettyPrinter();\n    \n    /**\n     * Base settings contain defaults used for all {@link ObjectMapper}\n     * instances.\n     */\n    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n            DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n            null, StdDateFormat.instance, null,\n            Locale.getDefault(),\n//            TimeZone.getDefault()\n            TimeZone.getTimeZone(\"GMT\"),\n            Base64Variants.getDefaultVariant() // 2.1\n    );\n\n    /*\n    /**********************************************************\n    /* Configuration settings, shared\n    /**********************************************************\n     */\n\n    /**\n     * Factory used to create {@link JsonParser} and {@link JsonGenerator}\n     * instances as necessary.\n     */\n    protected final JsonFactory _jsonFactory;\n\n    /**\n     * Specific factory used for creating {@link JavaType} instances;\n     * needed to allow modules to add more custom type handling\n     * (mostly to support types of non-Java JVM languages)\n     */\n    protected TypeFactory _typeFactory;\n\n    /**\n     * Provider for values to inject in deserialized POJOs.\n     */\n    protected InjectableValues _injectableValues;\n\n    /**\n     * Thing used for registering sub-types, resolving them to\n     * super/sub-types as needed.\n     */\n    protected SubtypeResolver _subtypeResolver;\n\n    /**\n     * Cache for root names used when root-wrapping is enabled.\n     */\n    protected final RootNameLookup _rootNames;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Mapping that defines how to apply mix-in annotations: key is\n     * the type to received additional annotations, and value is the\n     * type that has annotations to \"mix in\".\n     *<p>\n     * Annotations associated with the value classes will be used to\n     * override annotations of the key class, associated with the\n     * same field or method. They can be further masked by sub-classes:\n     * you can think of it as injecting annotations between the target\n     * class and its sub-classes (or interfaces)\n     */\n    protected final HashMap<ClassKey,Class<?>> _mixInAnnotations;\n    \n    /*\n    /**********************************************************\n    /* Configuration settings, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected SerializationConfig _serializationConfig;\n\n    /**\n     * Object that manages access to serializers used for serialization,\n     * including caching.\n     * It is configured with {@link #_serializerFactory} to allow\n     * for constructing custom serializers.\n     *<p>\n     * Note: while serializers are only exposed {@link SerializerProvider},\n     * mappers and readers need to access additional API defined by\n     * {@link DefaultSerializerProvider}\n     */\n    protected DefaultSerializerProvider _serializerProvider;\n\n    /**\n     * Serializer factory used for constructing serializers.\n     */\n    protected SerializerFactory _serializerFactory;\n\n    /*\n    /**********************************************************\n    /* Configuration settings, deserialization\n    /**********************************************************\n     */\n\n    /**\n     * Configuration object that defines basic global\n     * settings for the serialization process\n     */\n    protected DeserializationConfig _deserializationConfig;\n\n    /**\n     * Blueprint context object; stored here to allow custom\n     * sub-classes. Contains references to objects needed for\n     * deserialization construction (cache, factory).\n     */\n    protected DefaultDeserializationContext _deserializationContext;\n\n    /*\n    /**********************************************************\n    /* Caching\n    /**********************************************************\n     */\n\n    /* Note: handling of serializers and deserializers is not symmetric;\n     * and as a result, only root-level deserializers can be cached here.\n     * This is mostly because typing and resolution for deserializers is\n     * fully static; whereas it is quite dynamic for serialization.\n     */\n\n    /**\n     * We will use a separate main-level Map for keeping track\n     * of root-level deserializers. This is where most succesful\n     * cache lookups get resolved.\n     * Map will contain resolvers for all kinds of types, including\n     * container types: this is different from the component cache\n     * which will only cache bean deserializers.\n     *<p>\n     * Given that we don't expect much concurrency for additions\n     * (should very quickly converge to zero after startup), let's\n     * explicitly define a low concurrency setting.\n     *<p>\n     * Since version 1.5, these may are either \"raw\" deserializers (when\n     * no type information is needed for base type), or type-wrapped\n     * deserializers (if it is needed)\n     */\n    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers\n        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2);\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructing instance\n    /**********************************************************\n     */\n\n    /**\n     * Default constructor, which will construct the default\n     * {@link JsonFactory} as necessary, use\n     * {@link SerializerProvider} as its\n     * {@link SerializerProvider}, and\n     * {@link BeanSerializerFactory} as its\n     * {@link SerializerFactory}.\n     * This means that it\n     * can serialize all standard JDK types, as well as regular\n     * Java Beans (based on method names and Jackson-specific annotations),\n     * but does not support JAXB annotations.\n     */\n    public ObjectMapper()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s.\n     */\n    public ObjectMapper(JsonFactory jf)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy-constructor, mostly used to support {@link #copy}.\n     * \n     * @since 2.1\n     */\n    protected ObjectMapper(ObjectMapper src)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Constructs instance that uses specified {@link JsonFactory}\n     * for constructing necessary {@link JsonParser}s and/or\n     * {@link JsonGenerator}s, and uses given providers for accessing\n     * serializers and deserializers.\n     * \n     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n     * @param dc Blueprint deserialization context instance to use for creating\n     *    actual context objects; if null, will construct standard\n     *    {@link DeserializationContext}\n     */\n    public ObjectMapper(JsonFactory jf,\n            DefaultSerializerProvider sp, DefaultDeserializationContext dc)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for creating a new {@link ObjectMapper} instance that\n     * has same initial configuration as this instance. Note that this\n     * also requires making a copy of the underlying {@link JsonFactory}\n     * instance.\n     *<p>\n     * Method is typically\n     * used when multiple, differently configured mappers are needed.\n     * Although configuration is shared, cached serializers and deserializers\n     * are NOT shared, which means that the new instance may be re-configured\n     * before use; meaning that it behaves the same way as if an instance\n     * was constructed from scratch.\n     * \n     * @since 2.1\n     */\n    public ObjectMapper copy()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.1\n     * @param exp\n     */\n    protected void _checkInvalidCopy(Class<?> exp)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Versioned impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will return version information stored in and read from jar\n     * that contains this class.\n     */\n    @Override\n    public Version version() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Module registration, discovery\n    /**********************************************************\n     */\n\n    /**\n     * Method for registering a module that can extend functionality\n     * provided by this mapper; for example, by adding providers for\n     * custom serializers and deserializers.\n     * \n     * @param module Module to register\n     */\n    public ObjectMapper registerModule(Module module)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n         //The specific code has been omitted, but there is no error\n        }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Module... modules)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method for registering specified modules in order;\n     * functionally equivalent to:\n     *<pre>\n     *   for (Module module : modules) {\n         //The specific code has been omitted, but there is no error\n        }\n     *</pre>\n     * \n     * @since 2.2\n     */\n    public ObjectMapper registerModules(Iterable<Module> modules)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<Module> findModules() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for locating available methods, using JDK {@link ServiceLoader}\n     * facility, along with module-provided SPI.\n     *<p>\n     * Note that method does not do any caching, so calls should be considered\n     * potentially expensive.\n     * \n     * @since 2.2\n     */\n    public static List<Module> findModules(ClassLoader classLoader)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method that is functionally equivalent to:\n     *<code>\n     *   mapper.registerModules(mapper.findModules());\n     *<code>\n     *<p>\n     * As with {@link #findModules()}, no caching is done for modules, so care\n     * needs to be taken to either create and share a single mapper instance;\n     * or to cache introspected set of modules.\n     *\n     * @since 2.2\n     */\n    public ObjectMapper findAndRegisterModules() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration: main config object access\n    /**********************************************************\n     */\n\n    /**\n     * Method that returns the shared default {@link SerializationConfig}\n     * object that defines configuration settings for serialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public SerializationConfig getSerializationConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that returns\n     * the shared default {@link DeserializationConfig} object\n     * that defines configuration settings for deserialization.\n     *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of config object.\n     */\n    public DeserializationConfig getDeserializationConfig() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for getting current {@link DeserializationContext}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of context object.\n    */\n    public DeserializationContext getDeserializationContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Configuration: ser/deser factory, provider access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for setting specific {@link SerializerFactory} to use\n     * for constructing (bean) serializers.\n     */\n    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting current {@link SerializerFactory}.\n      *<p>\n     * Note that since instances are immutable, you can NOT change settings\n     * by accessing an instance and calling methods: this will simply create\n     * new instance of factory object.\n     */\n    public SerializerFactory getSerializerFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for setting specific {@link SerializerProvider} to use\n     * for handling caching of {@link JsonSerializer} instances.\n     */\n    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public SerializerProvider getSerializerProvider() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration: mix-in annotations\n    /**********************************************************\n     */\n    \n    /**\n     * Method to use for defining mix-in annotations to use for augmenting\n     * annotations that processable (serializable / deserializable)\n     * classes have.\n     * Mixing in is done when introspecting class annotations and properties.\n     * Map passed contains keys that are target classes (ones to augment\n     * with new annotation overrides), and values that are source classes\n     * (have annotations to use for augmentation).\n     * Annotations from source classes (and their supertypes)\n     * will <b>override</b>\n     * annotations that target classes (and their super-types) have.\n     */\n    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     */\n    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method to use for adding mix-in annotations to use for augmenting\n     * specified class or interface. All annotations from\n     * <code>mixinSource</code> are taken to override annotations\n     * that <code>target</code> (or its supertypes) has.\n     *\n     * @param target Class (or interface) whose annotations to effectively override\n     * @param mixinSource Class (or interface) whose annotations are to\n     *   be \"added\" to target's annotations, overriding as necessary\n     */\n    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public final Class<?> findMixInClassFor(Class<?> cls) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public final int mixInCount() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration, introspection\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     */\n    public VisibilityChecker<?> getVisibilityChecker() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for setting currently configured visibility checker;\n     * object used for determining whether given property element\n     * (method, field, constructor) can be auto-detected or not.\n     * This default checker is used if no per-class overrides\n     * are defined.\n     */    \n    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method that allows changing configuration for\n     * underlying {@link VisibilityChecker}s, to change details of what kinds of\n     * properties are auto-detected.\n     * Basically short cut for doing:\n     *<pre>\n     *  mapper.setVisibilityChecker(\n     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)\n     *  );\n     *</pre>\n     * one common use case would be to do:\n     *<pre>\n     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);\n     *</pre>\n     * which would make all member fields serializable without further annotations,\n     * instead of just public fields (default setting).\n     * \n     * @param forMethod Type of property descriptor affected (field, getter/isGetter,\n     *     setter, creator)\n     * @param visibility Minimum visibility to require for the property descriptors of type\n     * \n     * @return Modified mapper instance (that is, \"this\"), to allow chaining\n     *    of configuration calls\n     */\n    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for accessing subtype resolver in use.\n     */\n    public SubtypeResolver getSubtypeResolver() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for setting custom subtype resolver to use.\n     */\n    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} used by this\n     * mapper instance for both serialization and deserialization\n     */\n    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for changing {@link AnnotationIntrospector} instances used\n     * by this mapper instance for serialization and deserialization,\n     * specifying them separately so that different introspection can be\n     * used for different aspects\n     * \n     * @since 2.1\n     * \n     * @param serializerAI {@link AnnotationIntrospector} to use for configuring\n     *    serialization\n     * @param deserializerAI {@link AnnotationIntrospector} to use for configuring\n     *    deserialization\n     */\n    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for setting custom property naming strategy to use.\n     */\n    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for setting defalt POJO property inclusion strategy for serialization.\n     */\n    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Type information configuration (1.5+)\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method that is equivalent to calling\n     *<pre>\n     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n     *</pre>\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling automatic inclusion of type information, needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n     * \n     * @param applicability Defines kinds of types for which additional type information\n     *    is added; see {@link DefaultTyping} for more information.\n     */\n    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling automatic inclusion of type information -- needed\n     * for proper deserialization of polymorphic types (unless types\n     * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) --\n     * using \"As.PROPERTY\" inclusion mechanism and specified property name\n     * to use for inclusion (default being \"@class\" since default type information\n     * always uses class name as type identifier)\n     */\n    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for disabling automatic inclusion of type information; if so, only\n     * explicitly annotated types (ones with\n     * {@link com.fasterxml.jackson.annotation.JsonTypeInfo}) will have\n     * additional embedded type information.\n     */\n    public ObjectMapper disableDefaultTyping() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling automatic inclusion of type information, using\n     * specified handler object for determining which types this affects,\n     * as well as details of how information is embedded.\n     * \n     * @param typer Type information inclusion handler\n     */\n    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Type for given class is determined from appropriate annotation;\n     * or if missing, default name (unqualified class name)\n     */\n    public void registerSubtypes(Class<?>... classes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for registering specified class as a subtype, so that\n     * typename-based resolution can link supertypes to subtypes\n     * (as an alternative to using annotations).\n     * Name may be provided as part of argument, but if not will\n     * be based on annotations or use default name (unqualified\n     * class name).\n     */\n    public void registerSubtypes(NamedType... types) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Configuration, basic type handling\n    /**********************************************************\n     */\n\n    /**\n     * Accessor for getting currently configured {@link TypeFactory} instance.\n     */\n    public TypeFactory getTypeFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that can be used to override {@link TypeFactory} instance\n     * used by this mapper.\n     *<p>\n     * Note: will also set {@link TypeFactory} that deserialization and\n     * serialization config objects use.\n     */\n    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Convenience method for constructing {@link JavaType} out of given\n     * type (typically <code>java.lang.Class</code>), but without explicit\n     * context.\n     */\n    public JavaType constructType(Type t) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration, deserialization\n    /**********************************************************\n     */\n    \n    /**\n     * Method for specifying {@link JsonNodeFactory} to use for\n     * constructing root level tree nodes (via method\n     * {@link #createObjectNode}\n     */\n    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for adding specified {@link DeserializationProblemHandler}\n     * to be used for handling specific problems during deserialization.\n     */\n    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for removing all registered {@link DeserializationProblemHandler}s\n     * instances from this mapper.\n     */\n    public ObjectMapper clearProblemHandlers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that allows overriding of the underlying {@link DeserializationConfig}\n     * object.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any deserialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(DeserializationConfig config) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration, serialization\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method that is equivalent to:\n     *<pre>\n     *  mapper.setFilters(mapper.getSerializationConfig().withFilters(filterProvider));\n     *</pre>\n     *<p>\n     * Note that usually it is better to use method {@link #writer(FilterProvider)};\n     * however, sometimes\n     * this method is more convenient. For example, some frameworks only allow configuring\n     * of ObjectMapper instances and not ObjectWriters.\n     */\n    public void setFilters(FilterProvider filterProvider) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that will configure default {@link Base64Variant} that\n     * <code>byte[]</code> serializers and deserializers will use.\n     * \n     * @param v Base64 variant to use\n     * \n     * @return This mapper, for convenience to allow chaining\n     * \n     * @since 2.1\n     */\n    public ObjectMapper setBase64Variant(Base64Variant v) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that allows overriding of the underlying {@link SerializationConfig}\n     * object, which contains serialization-specific configuration settings.\n     * It is added as a fallback method that may be used if no other configuration\n     * modifier method works: it should not be used if there are alternatives,\n     * and its use is generally discouraged.\n     *<p>\n     * <b>NOTE</b>: only use this method if you know what you are doing -- it allows\n     * by-passing some of checks applied to other configuration methods.\n     * Also keep in mind that as with all configuration of {@link ObjectMapper},\n     * this is only thread-safe if done before calling any serialization methods.\n     * \n     * @since 2.4\n     */\n    public ObjectMapper setConfig(SerializationConfig config) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to get hold of {@link JsonFactory} that this\n     * mapper uses if it needs to construct {@link JsonParser}s\n     * and/or {@link JsonGenerator}s.\n     *\n     * @return {@link JsonFactory} that this mapper uses when it needs to\n     *   construct Json parser and generators\n     */\n    @Override\n    public JsonFactory getFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * @deprecated Since 2.1: Use {@link #getFactory} instead\n     */\n    @Deprecated\n    @Override\n    public JsonFactory getJsonFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for configuring the default {@link DateFormat} to use when serializing time\n     * values as Strings, and deserializing from JSON Strings.\n     * This is preferably to directly modifying {@link SerializationConfig} and\n     * {@link DeserializationConfig} instances.\n     * If you need per-request configuration, use {@link #writer(DateFormat)} to\n     * create properly configured {@link ObjectWriter} and use that; this because\n     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n     * thread-safe when configuring methods (such as this one) are NOT called.\n     */\n    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for configuring {@link HandlerInstantiator} to use for creating\n     * instances of handlers (such as serializers, deserializers, type and type\n     * id resolvers), given a class.\n     *\n     * @param hi Instantiator to use; if null, use the default implementation\n     */\n    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for configuring {@link InjectableValues} which used to find\n     * values to inject.\n     */\n    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for overriding default locale to use for formatting.\n     * Default value used is {@link Locale#getDefault()}.\n     */\n    public ObjectMapper setLocale(Locale l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for overriding default TimeZone to use for formatting.\n     * Default value used is UTC (NOT local timezone).\n     */\n    public ObjectMapper setTimeZone(TimeZone tz) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Configuration, simple features\n    /**********************************************************\n     */\n\n    /**\n     * Method for changing state of an on/off mapper feature for\n     * this mapper instance.\n     */\n    public ObjectMapper configure(MapperFeature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for changing state of an on/off serialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(SerializationFeature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for changing state of an on/off deserialization feature for\n     * this object mapper.\n     */\n    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for changing state of an on/off {@link JsonParser} feature for\n     * {@link JsonFactory} instance this object mapper uses.\n     *<p>\n     * This is method is basically a shortcut method for calling\n     * {@link JsonFactory#enable} on the shared\n     * {@link JsonFactory} this mapper uses (which is accessible\n     * using {@link #getJsonFactory}).\n     */\n    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for changing state of an on/off {@link JsonGenerator} feature for\n     * {@link JsonFactory} instance this object mapper uses.\n     *<p>\n     * This is method is basically a shortcut method for calling\n     * {@link JsonFactory#enable} on the shared\n     * {@link JsonFactory} this mapper uses (which is accessible\n     * using {@link #getJsonFactory}).\n     */\n    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling specified {@link MapperConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(MapperFeature... f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(MapperFeature... f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(DeserializationFeature first,\n            DeserializationFeature... f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(DeserializationFeature first,\n            DeserializationFeature... f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} feature.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for enabling specified {@link DeserializationConfig} features.\n     * Modifies and returns this instance; no new object is created.\n     */\n    public ObjectMapper disable(SerializationFeature first,\n            SerializationFeature... f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether given Mapper\n     * feature is enabled.\n     */\n    public boolean isEnabled(MapperFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether given serialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(SerializationFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for checking whether given deserialization-specific\n     * feature is enabled.\n     */\n    public boolean isEnabled(DeserializationFeature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonFactory.Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonParser.Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Convenience method, equivalent to:\n     *<pre>\n     *  getJsonFactory().isEnabled(f);\n     *</pre>\n     */\n    public boolean isEnabled(JsonGenerator.Feature f) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method that can be used to get hold of {@link JsonNodeFactory}\n     * that this mapper will use when directly constructing\n     * root {@link JsonNode} instances for Trees.\n     *<p>\n     * Note: this is just a shortcut for calling\n     *<pre>\n     *   getDeserializationConfig().getNodeFactory()\n     *</pre>\n     */\n    public JsonNodeFactory getNodeFactory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): deserialization\n    /* (mapping from JSON to Java types);\n    /* main methods\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content into a non-container\n     * type (it can be an array type, however): typically a bean, array\n     * or a wrapper type (like {@link java.lang.Boolean}).\n     *<p>\n     * Note: this method should NOT be used if the result type is a\n     * container ({@link java.util.Collection} or {@link java.util.Map}.\n     * The reason is that due to type erasure, key and value types\n     * can not be introspected when using this method.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n    } \n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using so-called\n     * \"super type token\" (see )\n     * and specifically needs to be used if the root type is a \n     * parameterized (generic) container type.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n    }\n\n    /**\n     * Method to deserialize JSON content into a Java type, reference\n     * to which is passed as argument. Type is passed using \n     * Jackson specific type; instance of which can be constructed using\n     * {@link TypeFactory}.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances. Returns\n     * root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     */\n    @Override\n    public <T extends TreeNode> T readTree(JsonParser jp)\n        throws IOException, JsonProcessingException\n    {\n        /* 02-Mar-2009, tatu: One twist; deserialization provider\n         *   will map JSON null straight into Java null. But what\n         *   we want to return is the \"null node\" instead.\n         */\n        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n         *   calling readValue(), since that'll choke on it otherwise\n         */\n        DeserializationConfig cfg = getDeserializationConfig();\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n        if (n == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        @SuppressWarnings(\"unchecked\")\n        T result = (T) n;\n        return result;\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     * Sequence can be either root-level \"unwrapped\" sequence (without surrounding\n     * JSON array), or a sequence contained in a JSON Array.\n     * In either case {@link JsonParser} must point to the first token of\n     * the first element, OR not point to any token (in which case it is advanced\n     * to the next token). This means, specifically, that for wrapped sequences,\n     * parser MUST NOT point to the surrounding <code>START_ARRAY</code> but rather\n     * to the token following it.\n     *<p>\n     * Note that {@link ObjectReader} has more complete set of variants.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, ResolvedType valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, (JavaType) valueType);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n            throws IOException, JsonProcessingException\n    {\n        DeserializationConfig config = getDeserializationConfig();\n        DeserializationContext ctxt = createDeserializationContext(jp, config);\n        JsonDeserializer<?> deser = _findRootDeserializer(ctxt, valueType);\n        // false -> do NOT close JsonParser (since caller passed it)\n        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n                false, null);\n    }\n\n    /**\n     * Type-safe overloaded method, basically alias for {@link #readValues(JsonParser, ResolvedType)}.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueType));\n    }\n\n    /**\n     * Method for reading sequence of Objects from parser stream.\n     */\n    @Override\n    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n        throws IOException, JsonProcessingException\n    {\n        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API not included in ObjectCodec: deserialization\n    /* (mapping from JSON to Java types)\n    /**********************************************************\n     */\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param in Input stream used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(InputStream in)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(in), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed\n     * using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist\n     * of just a single node if the current event is a\n     * value event, not container).\n     *\n     * @param r Reader used to read JSON content\n     *   for building the JSON tree.\n     */\n    public JsonNode readTree(Reader r)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(String content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param content JSON content to parse to build the JSON tree.\n     */\n    public JsonNode readTree(byte[] content)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n    \n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param file File of which contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(File file)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(file), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /**\n     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n     * Returns root of the resulting tree (where root can consist of just a single node if the current\n     * event is a value event, not container).\n     *\n     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n     */\n    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from ObjectCodec): serialization\n    /* (mapping from Java types to Json)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using provided {@link JsonGenerator}.\n     */\n    @Override\n    public void writeValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        // 10-Aug-2012, tatu: as per [Issue#12], must handle indentation:\n        if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _writeCloseableValue(jgen, value, config);\n        } else {\n            _serializerProvider(config).serializeValue(jgen, value);\n            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API (from TreeCodec via ObjectCodec): Tree Model support\n    /**********************************************************\n     */\n\n    @Override\n    public void writeTree(JsonGenerator jgen, TreeNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     * Method to serialize given JSON Tree, using generator\n     * provided.\n     */\n    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }\n    \n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override    \n    public ObjectNode createObjectNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     *<p>\n     * Note: return type is co-variant, as basic ObjectCodec\n     * abstraction can not refer to concrete node types (as it's\n     * part of core package, whereas impls are part of mapper\n     * package)\n     */\n    @Override\n    public ArrayNode createArrayNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for constructing a {@link JsonParser} out of JSON tree\n     * representation.\n     * \n     * @param n Root node of the tree that resulting parser will read from\n     */\n    @Override\n    public JsonParser treeAsTokens(TreeNode n)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience conversion method that will bind data given JSON tree\n     * contains into specific value (usually bean) type.\n     *<p>\n     * Functionally equivalent to:\n     *<pre>\n     *   objectMapper.convertValue(n, valueClass);\n     *</pre>\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n         //The specific code has been omitted, but there is no error\n        } catch (IOException e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n     * construct equivalent JSON Tree representation. Functionally similar\n     * to serializing value into JSON and parsing JSON as tree, but\n     * more efficient.\n     *<p>\n     * NOTE: one known difference from actual serialization is that so-called\n     * \"raw values\" are not supported -- since they are opaque sequence of\n     * bytes to include (which may or may not be supported by the backend)\n     * they can not be converted using this method. It may be possible to\n     * support conversions using full serialization, if raw values must be\n     * preserved.\n     * \n     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}\n     * @param fromValue Bean value to convert\n     * @return Root node of the resulting JSON tree\n     */\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return (T) result;\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could serialize an instance of given Class.\n     * Check is done\n     * by checking whether a serializer can be found for the type.\n     *<p>\n     * NOTE: since this method does NOT throw exceptions, but internal\n     * processing may, caller usually has little information as to why\n     * serialization would fail.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canSerialize(Class<?> type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method similar to {@link #canSerialize(Class)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method that can be called to check whether mapper thinks\n     * it could deserialize an Object of given type.\n     * Check is done\n     * by checking whether a deserializer can be found for the type.\n     *\n     * @return True if mapper can find a serializer for instances of\n     *  given class (potentially serializable), false otherwise (not\n     *  serializable)\n     */\n    public boolean canDeserialize(JavaType type)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method similar to {@link #canDeserialize(JavaType)} but that can return\n     * actual {@link Throwable} that was thrown when trying to construct\n     * serializer: this may be useful in figuring out what the actual problem is.\n     * \n     * @since 2.3\n     */\n    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API, deserialization,\n    /* convenience methods\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(File src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(File src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(URL src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(URL src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(String content, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(String content, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(content), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(Reader src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(InputStream src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//      _setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n    } \n    \n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len, \n                               Class<T> valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n     // !!! TODO\n//    \t_setupClassLoaderForDeserialization(valueType);\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueType));\n    } \n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n    } \n    \n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public <T> T readValue(byte[] src, int offset, int len,\n                           TypeReference valueTypeRef)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T readValue(byte[] src, int offset, int len,\n                           JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType);\n    } \n    \n    /*\n    /**********************************************************\n    /* Extended Public API: serialization\n    /* (mapping from Java types to JSON)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, written to File provided.\n     */\n    public void writeValue(File resultFile, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(resultFile, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using output stream provided (using encoding\n     * {@link JsonEncoding#UTF8}).\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(OutputStream out, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(out, JsonEncoding.UTF8), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * JSON output, using Writer provided.\n     *<p>\n     * Note: method does not close the underlying stream explicitly\n     * here; however, {@link JsonFactory} this mapper uses may choose\n     * to close the stream depending on its settings (by default,\n     * it will try to close it when {@link JsonGenerator} we construct\n     * is closed).\n     */\n    public void writeValue(Writer w, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }\n\n    /**\n     * Method that can be used to serialize any Java value as\n     * a String. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n     * and constructing String, but more efficient.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) {\n         //The specific code has been omitted, but there is no error\n        } catch (IOException e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return sw.getAndClear();\n    }\n    \n    /**\n     * Method that can be used to serialize any Java value as\n     * a byte array. Functionally equivalent to calling\n     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n     * and getting bytes, but more efficient.\n     * Encoding used will be UTF-8.\n     *<p>\n     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.\n     */\n    @SuppressWarnings(\"resource\")\n    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) {\n         //The specific code has been omitted, but there is no error\n        } catch (IOException e) {\n         //The specific code has been omitted, but there is no error\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectWriters\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for constructing {@link ObjectWriter}\n     * with default settings.\n     */\n    public ObjectWriter writer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     */\n    public ObjectWriter writer(SerializationFeature first,\n            SerializationFeature... other) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified {@link DateFormat}; or, if\n     * null passed, using timestamp (64-bit number.\n     */\n    public ObjectWriter writer(DateFormat df) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified JSON View (filter).\n     */\n    public ObjectWriter writerWithView(Class<?> serializationView) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime\n     * type.\n     */\n    public ObjectWriter writerWithType(Class<?> rootType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     */\n    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified root type, instead of actual\n     * runtime type of value. Type must be a super-type of runtime type.\n     */\n    public ObjectWriter writerWithType(JavaType rootType) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified pretty printer for indentation\n     * (or if null, no pretty printer)\n     */\n    public ObjectWriter writer(PrettyPrinter pp) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using the default pretty printer for indentation\n     */\n    public ObjectWriter writerWithDefaultPrettyPrinter() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * serialize objects using specified filter provider.\n     */\n    public ObjectWriter writer(FilterProvider filterProvider) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * pass specific schema object to {@link JsonGenerator} used for\n     * writing content.\n     * \n     * @param schema Schema to pass to generator\n     */\n    public ObjectWriter writer(FormatSchema schema) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectWriter writer(Base64Variant defaultBase64) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified character escaping details for output.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(CharacterEscapes escapes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectWriter} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectWriter writer(ContextAttributes attrs) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: constructing ObjectReaders\n    /* for more advanced configuration\n    /**********************************************************\n     */\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * default settings. Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified feature enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature feature) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} with\n     * specified features enabled (compared to settings that this\n     * mapper instance has).\n     * Note that the resulting instance is NOT usable as is,\n     * without defining expected value type.\n     */\n    public ObjectReader reader(DeserializationFeature first,\n            DeserializationFeature... other) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * update given Object (usually Bean, but can be a Collection or Map\n     * as well, but NOT an array) with JSON data. Deserialization occurs\n     * normally except that the root-level value in JSON is not used for\n     * instantiating a new object; instead give updateable object is used\n     * as root.\n     * Runtime type of value object is used for locating deserializer,\n     * unless overridden by other factory methods of {@link ObjectReader}\n     */\n    public ObjectReader readerForUpdating(Object valueToUpdate)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(JavaType type)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(Class<?> type)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * read or update instances of specified type\n     */\n    public ObjectReader reader(TypeReference<?> type)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified {@link JsonNodeFactory} for constructing JSON trees.\n     */\n    public ObjectReader reader(JsonNodeFactory f)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * pass specific schema object to {@link JsonParser} used for\n     * reading content.\n     * \n     * @param schema Schema to pass to parser\n     */\n    public ObjectReader reader(FormatSchema schema) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified injectable values.\n     * \n     * @param injectableValues Injectable values to use\n     */\n    public ObjectReader reader(InjectableValues injectableValues) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * deserialize objects using specified JSON View (filter).\n     */\n    public ObjectReader readerWithView(Class<?> view) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified Base64 encoding variant for Base64-encoded binary data.\n     * \n     * @since 2.1\n     */\n    public ObjectReader reader(Base64Variant defaultBase64) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for constructing {@link ObjectReader} that will\n     * use specified default attributes.\n     * \n     * @since 2.3\n     */\n    public ObjectReader reader(ContextAttributes attrs) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Extended Public API: convenience type conversion\n    /**********************************************************\n     */\n   \n    /**\n     * Convenience method for doing two-step conversion from given value, into\n     * instance of given value type. This is functionality equivalent to first\n     * serializing given value into JSON, then binding JSON data into value\n     * of given type, but may be executed without fully serializing into\n     * JSON. Same converters (serializers, deserializers) will be used as for\n     * data binding, meaning same object mapper configuration works.\n     *      \n     * @throws IllegalArgumentException If conversion fails due to incompatible type;\n     *    if so, root cause will contain underlying checked exception data binding\n     *    functionality threw\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n        throws IllegalArgumentException\n    {\n        return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n    } \n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T convertValue(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } \n\n    /**\n     * Actual conversion implementation: instead of using existing read\n     * and write methods, much of code is inlined. Reason for this is\n     * that we must avoid root value wrapping/unwrapping both for efficiency and\n     * for correctness. If root value wrapping/unwrapping is actually desired,\n     * caller must use explicit <code>writeValue</code> and\n     * <code>readValue</code> methods.\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        /* Then use TokenBuffer, which is a JsonGenerator:\n         * (see [JACKSON-175])\n         */\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended Public API: JSON Schema generation\n    /**********************************************************\n     */\n\n    /**\n     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n     * instance for specified class.\n     *\n     * @param t The class to generate schema for\n     * @return Constructed JSON schema.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }\n\n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n    }\n    \n    /**\n     * Method for visiting type hierarchy for given type, using specified visitor.\n     * Visitation uses <code>Serializer</code> hierarchy and related properties\n     *<p>\n     * This method can be used for things like\n     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n     * instance for specified type.\n     *\n     * @param type Type to generate schema for (possibly with generic signature)\n     * \n     * @since 2.1\n     */\n    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        if (type == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for serialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used for constructing\n     * {@link SerializerProvider} to use for serialization.\n     */\n    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Helper method that should return default pretty-printer to\n     * use for generators constructed by this mapper, when instructed\n     * to use default pretty printer.\n     */\n    protected PrettyPrinter _defaultPrettyPrinter() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method called to configure the generator as necessary and then\n     * call write functionality\n     */\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig();\n        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            /* won't try to close twice; also, must catch exception (so it \n             * will not mask exception that is pending)\n             */\n            if (!closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n\n    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            if (!closed) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n\n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (jgen != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (toClose != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    /**\n     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n     * method is to be called right after serialization has been called\n     */\n    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods for deserialization, overridable\n    /**********************************************************\n     */\n\n    /**\n     * Internal helper method called to create an instance of {@link DeserializationContext}\n     * for deserializing a single root value.\n     * Can be overridden if a custom context is needed.\n     */\n    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Actual implementation of value reading+binding operation.\n     */\n    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: may need to read the next token, to initialize\n         * state (either before first read from parser, or after\n         * previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(jp);\n        if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n            // ok, let's get the value\n            if (cfg.useRootWrapping()) {\n                result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n            } else {\n                result = deser.deserialize(jp, ctxt);\n            }\n        }\n        // Need to consume the token too\n        jp.clearCurrentToken();\n        return result;\n    }\n    \n    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        try {\n            Object result;\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                DeserializationConfig cfg = getDeserializationConfig();\n                DeserializationContext ctxt = createDeserializationContext(jp, cfg);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n                if (cfg.useRootWrapping()) {\n                    result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser);\n                } else {\n                    result = deser.deserialize(jp, ctxt);\n                }\n                ctxt.checkUnresolvedObjectId();\n            }\n            // Need to consume the token too\n            jp.clearCurrentToken();\n            return result;\n        } finally {\n            try {\n                jp.close();\n            } catch (IOException ioe) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    /**\n     * Method called to ensure that given parser is ready for reading\n     * content for data binding.\n     *\n     * @return First token to be used for data binding after this call:\n     *  can never be null as exception will be thrown if parser can not\n     *  provide more tokens.\n     *\n     * @throws IOException if the underlying input source has problems during\n     *   parsing\n     * @throws JsonParseException if parser has problems parsing content\n     * @throws JsonMappingException if the parser does not have any more\n     *   content to map (note: Json \"null\" value is considered content;\n     *   enf-of-stream not)\n     */\n    protected JsonToken _initForReading(JsonParser jp)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return t;\n    }\n\n    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n            DeserializationConfig config,\n            JavaType rootType, JsonDeserializer<Object> deser)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        String expName = config.getRootName();\n        if (expName == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        String actualName = jp.getCurrentName();\n        if (!expName.equals(actualName)) {\n            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n                    +expName+\"') for type \"+rootType);\n        }\n        // ok, then move to value itself....\n        jp.nextToken();\n        Object result = deser.deserialize(jp, ctxt);\n        // and last, verify that we now get matching END_OBJECT\n        if (jp.nextToken() != JsonToken.END_OBJECT) {\n            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n                    +expName+\"'), but \"+jp.getCurrentToken());\n        }\n        return result;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to locate deserializer for the passed root-level value.\n     */\n    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }\n\n    /**\n     * @since 2.2\n     */\n    protected void _verifySchemaType(FormatSchema schema)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}", "DefaultTypeResolverBuilder": "    public static class DefaultTypeResolverBuilder\n        extends StdTypeResolverBuilder\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Definition of what types is this default typer valid for.\n         */\n        protected final DefaultTyping _appliesFor;\n\n        public DefaultTypeResolverBuilder(DefaultTyping t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n    }"}