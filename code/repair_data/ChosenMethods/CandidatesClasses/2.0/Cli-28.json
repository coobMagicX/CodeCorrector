{"Parser": "public abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected Options getOptions()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected List getRequiredOptions()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specifed {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n         //The specific code has been omitted, but there is no error\n        }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n         //The specific code has been omitted, but there is no error\n        }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by <code>arg</code> using the values\n     * retrieved from the specfied iterator <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter) throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // get the option represented by arg\n        Option opt = (Option) getOptions().getOption(arg).clone();\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}"}