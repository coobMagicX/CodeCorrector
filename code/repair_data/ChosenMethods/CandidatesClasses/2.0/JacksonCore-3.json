{"UTF8StreamJsonParser": "public class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected BytesToNameCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public ObjectCodec getCodec() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n         //The specific code has been omitted, but there is no error\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore()\n        throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable)\n        throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n         //The specific code has been omitted, but there is no error\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n         //The specific code has been omitted, but there is no error\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n         //The specific code has been omitted, but there is no error\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer)\n        throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        return outputCount;\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_tokenIncomplete) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n         //The specific code has been omitted, but there is no error\n        }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n         //The specific code has been omitted, but there is no error\n        }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        Name n = _parseName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        // Let's do a quickie check:\n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n         //The specific code has been omitted, but there is no error\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n         //The specific code has been omitted, but there is no error\n        }        \n        JsonToken t;\n\n        switch (i) {\n         //The specific code has been omitted, but there is no error\n        }\n        _nextToken = t;\n        return _currToken;\n    }"}