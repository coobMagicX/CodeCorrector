{"TypeInference": "class TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n\n  // TODO(johnlenz): We no longer make this check, but we should.\n  static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS =\n    DiagnosticType.warning(\n        \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\",\n        \"Function literal argument refers to undefined this argument\");\n\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n\n  // For convenience\n  private final ObjectType unknownType;\n\n  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Infers all of a function's arguments if their types aren't declared.\n   */\n  private void inferArguments(Scope functionScope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  FlowScope createInitialEstimateLattice() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  FlowScope createEntryLattice() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  @SuppressWarnings({\"fallthrough\", \"incomplete-switch\"})\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverse(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Traverse a return value.\n   */\n  private FlowScope traverseReturn(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Any value can be thrown, so it's really impossible to determine the type\n   * of a CATCH param. Treat it as the UNKNOWN type.\n   */\n  private FlowScope traverseCatch(Node catchNode, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseAssign(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Defines a property if the property has not been defined yet.\n   */\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Defines a declared property if it has not been defined yet.\n   *\n   * This handles the case where a property is declared on an object where\n   * the object type is inferred, and so the object type will not\n   * be known in {@code TypedScopeCreator}.\n   */\n  private void ensurePropertyDeclared(Node getprop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Declares a property on its owner, if necessary.\n   * @return True if a property was declared.\n   */\n  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseName(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Traverse each element of the array. */\n  private FlowScope traverseArrayLiteral(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseAdd(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean isAddedAsNumber(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseHook(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseCall(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope tightenTypesAfterAssertions(FlowScope scope,\n      Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * We only do forward type inference. We do not do full backwards\n   * type inference.\n   *\n   * In other words, if we have,\n   * <code>\n   * var x = f();\n   * g(x);\n   * </code>\n   * a forward type-inference engine would try to figure out the type\n   * of \"x\" from the return type of \"f\". A backwards type-inference engine\n   * would try to figure out the type of \"x\" from the parameter type of \"g\".\n   *\n   * However, there are a few special syntactic forms where we do some\n   * some half-assed backwards type-inference, because programmers\n   * expect it in this day and age. To take an example from Java,\n   * <code>\n   * List<String> x = Lists.newArrayList();\n   * </code>\n   * The Java compiler will be able to infer the generic type of the List\n   * returned by newArrayList().\n   *\n   * In much the same way, we do some special-case backwards inference for\n   * JS. Those cases are enumerated here.\n   */\n  private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * When \"bind\" is called on a function, we infer the type of the returned\n   * \"bound\" function by looking at the number of parameters in the call site.\n   */\n  private void updateBind(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * For functions with function parameters, type inference will set the type of\n   * a function literal argument from the function parameter type.\n   */\n  private void updateTypeOfParameters(Node n, FunctionType fnType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n      FunctionType fnType, Node call) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void maybeResolveTemplatedType(\n      JSType paramType,\n      JSType argType,\n      Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void maybeResolveTemplateTypeFromNodes(\n      Iterable<Node> declParams,\n      Iterable<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes, Set<JSType> seenTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void maybeResolveTemplateTypeFromNodes(\n      Iterator<Node> declParams,\n      Iterator<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes,\n      Set<JSType> seenTypes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static void resolvedTemplateType(\n      Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static class TemplateTypeReplacer extends ModificationVisitor {\n    private final Map<TemplateType, JSType> replacements;\n    private final JSTypeRegistry registry;\n    boolean madeChanges = false;\n\n    TemplateTypeReplacer(\n        JSTypeRegistry registry, Map<TemplateType, JSType> replacements) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseTemplateType(TemplateType type) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseNew(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseChildren(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseGetElem(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {\n         //The specific code has been omitted, but there is no error\n        }\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private static void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   */\n  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private BooleanOutcomePair traverseOr(Node n, FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private BooleanOutcomePair traverseShortCircuitingBinOp(\n      Node n, FlowScope scope, boolean condition) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n,\n      FlowScope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Infers the boolean outcome pair that can be taken by a\n   * short-circuiting binary operation ({@code &&} or {@code ||}).\n   * @see #getBooleanOutcomes(BooleanLiteralSet, BooleanLiteralSet, boolean)\n   */\n  BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left,\n      BooleanOutcomePair right, boolean condition) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Infers the boolean literal set that can be taken by a\n   * short-circuiting binary operation ({@code &&} or {@code ||}).\n   * @param left the set of possible {@code ToBoolean} predicate results for\n   *    the expression on the left side of the operator\n   * @param right the set of possible {@code ToBoolean} predicate results for\n   *    the expression on the right side of the operator\n   * @param condition the left side {@code ToBoolean} predicate result that\n   *    causes the right side to get evaluated (i.e. not short-circuited)\n   * @return a set of possible {@code ToBoolean} predicate results for the\n   *    entire expression\n   */\n  static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left,\n      BooleanLiteralSet right, boolean condition) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * When traversing short-circuiting binary operations, we need to keep track\n   * of two sets of boolean literals:\n   * 1. {@code toBooleanOutcomes}: boolean literals as converted from any types,\n   * 2. {@code booleanValues}: boolean literals from just boolean types.\n   */\n  private final class BooleanOutcomePair {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private BooleanOutcomePair newBooleanOutcomePair(\n      JSType jsType, FlowScope flowScope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void redeclareSimpleVar(\n      FlowScope scope, Node nameNode, JSType varType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean isUnflowable(Var v) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "TemplateTypeReplacer": "  private static class TemplateTypeReplacer extends ModificationVisitor {\n    private final Map<TemplateType, JSType> replacements;\n    private final JSTypeRegistry registry;\n    boolean madeChanges = false;\n\n    TemplateTypeReplacer(\n        JSTypeRegistry registry, Map<TemplateType, JSType> replacements) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSType caseTemplateType(TemplateType type) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "BooleanOutcomePair": "  private final class BooleanOutcomePair {\n         //The specific code has been omitted, but there is no error\n        }"}