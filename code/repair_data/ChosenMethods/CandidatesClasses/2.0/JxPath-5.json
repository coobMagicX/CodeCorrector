{"NodePointer": "public abstract class NodePointer implements Pointer {\n\n    public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n    protected int index = WHOLE_COLLECTION;\n    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n    private boolean attribute = false;\n    private transient Object rootNode;\n    private NamespaceResolver namespaceResolver;\n    \n    /**\n     * Allocates an entirely new NodePointer by iterating through all installed\n     * NodePointerFactories until it finds one that can create a pointer.\n     */\n    public static NodePointer newNodePointer(\n        QName name,\n        Object bean,\n        Locale locale) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Allocates an new child NodePointer by iterating through all installed\n     * NodePointerFactories until it finds one that can create a pointer.\n     */\n    public static NodePointer newChildNodePointer(\n        NodePointer parent,\n        QName name,\n        Object bean) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected NodePointer parent;\n    protected Locale locale;\n//    private NamespaceManager namespaceManager;\n\n    protected NodePointer(NodePointer parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected NodePointer(NodePointer parent, Locale locale) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public NamespaceResolver getNamespaceResolver() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public NodePointer getParent() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public NodePointer getImmediateParentPointer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set to true if the pointer represents the \"attribute::\" axis.\n     */\n    public void setAttribute(boolean attribute) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if the pointer represents the \"attribute::\" axis.\n     */\n    public boolean isAttribute() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if this Pointer has no parent.\n     */\n    public boolean isRoot() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If true, this node does not have children\n     */\n    public abstract boolean isLeaf();\n\n    /**\n     * @deprecated Please use !isContainer()\n     */\n    public boolean isNode() {\n         //The specific code has been omitted, but there is no error\n        }\n     \n    /**\n     * If true, this node is axiliary and can only be used as an intermediate in\n     * the chain of pointers.\n     */\n    public boolean isContainer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If the pointer represents a collection, the index identifies\n     * an element of that collection.  The default value of <code>index</code>\n     * is <code>WHOLE_COLLECTION</code>, which just means that the pointer\n     * is not indexed at all.\n     * Note: the index on NodePointer starts with 0, not 1.\n     */\n    public int getIndex() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void setIndex(int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns <code>true</code> if the value of the pointer is an array or\n     * a Collection.\n     */\n    public abstract boolean isCollection();\n\n    /**\n     * If the pointer represents a collection (or collection element),\n     * returns the length of the collection.\n     * Otherwise returns 1 (even if the value is null).\n     */\n    public abstract int getLength();\n\n    /**\n     * By default, returns <code>getNode()</code>, can be overridden to\n     * return a \"canonical\" value, like for instance a DOM element should\n     * return its string value.\n     */\n    public Object getValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If this pointer manages a transparent container, like a variable,\n     * this method returns the pointer to the contents.\n     * Only an auxiliary (non-node) pointer can (and should) return a\n     * value pointer other than itself.\n     * Note that you probably don't want to override \n     * <code>getValuePointer()</code> directly.  Override the\n     * <code>getImmediateValuePointer()</code> method instead.  The\n     * <code>getValuePointer()</code> method is calls\n     * <code>getImmediateValuePointer()</code> and, if the result is not\n     * <code>this</code>, invokes <code>getValuePointer()</code> recursively.\n     * The idea here is to open all nested containers. Let's say we have a\n     * container within a container within a container. The\n     * <code>getValuePointer()</code> method should then open all those\n     * containers and return the pointer to the ultimate contents. It does so\n     * with the above recursion.\n     */\n    public NodePointer getValuePointer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @see #getValuePointer()\n     * \n     * @return NodePointer is either <code>this</code> or a pointer\n     *   for the immediately contained value.\n     */\n    public NodePointer getImmediateValuePointer() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * An actual pointer points to an existing part of an object graph, even\n     * if it is null. A non-actual pointer represents a part that does not exist\n     * at all.\n     * For instance consider the pointer \"/address/street\".\n     * If both <em>address</em> and <em>street</em> are not null,\n     * the pointer is actual.\n     * If <em>address</em> is not null, but <em>street</em> is null,\n     * the pointer is still actual.\n     * If <em>address</em> is null, the pointer is not actual.\n     * (In JavaBeans) if <em>address</em> is not a property of the root bean,\n     * a Pointer for this path cannot be obtained at all - actual or otherwise.\n     */\n    public boolean isActual() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the name of this node. Can be null.\n     */\n    public abstract QName getName();\n\n    /**\n     * Returns the value represented by the pointer before indexing.\n     * So, if the node represents an element of a collection, this\n     * method returns the collection itself.\n     */\n    public abstract Object getBaseValue();\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     *\n     * @deprecated 1.1 Please use getNode()\n     */\n    public Object getNodeValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type. Opens containers, properties etc and returns\n     * the ultimate contents.\n     */\n    public Object getNode() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public Object getRootNode() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Returns the object the pointer points to; does not convert it\n     * to a \"canonical\" type.\n     */\n    public abstract Object getImmediateNode();\n\n    /**\n     * Converts the value to the required type and changes the corresponding\n     * object to that value.\n     */\n    public abstract void setValue(Object value);\n\n    /**\n     * Compares two child NodePointers and returns a positive number,\n     * zero or a positive number according to the order of the pointers.\n     */\n    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static boolean equalStrings(String s1, String s2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     *  Called directly by JXPathContext. Must create path and\n     *  set value.\n     */\n    public NodePointer createPath(JXPathContext context, Object value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Remove the node of the object graph this pointer points to.\n     */\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Called by a child pointer when it needs to create a parent object.\n     * Must create an object described by this pointer and return\n     * a new pointer that properly describes the new object.\n     */\n    public NodePointer createPath(JXPathContext context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Called by a child pointer if that child needs to assign the value\n     * supplied in the createPath(context, value) call to a non-existent\n     * node. This method may have to expand the collection in order to assign\n     * the element.\n     */\n    public NodePointer createChild(\n        JXPathContext context,\n        QName name,\n        int index,\n        Object value) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Called by a child pointer when it needs to create a parent object for a\n     * non-existent collection element. It may have to expand the collection,\n     * then create an element object and return a new pointer describing the\n     * newly created element.\n     */\n    public NodePointer createChild(JXPathContext context, QName name, int index)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Called to create a non-existing attribute\n     */\n    public NodePointer createAttribute(JXPathContext context, QName name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If the Pointer has a parent, returns the parent's locale; otherwise\n     * returns the locale specified when this Pointer was created.\n     */\n    public Locale getLocale() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if the selected locale name starts\n     * with the specified prefix <i>lang</i>, case-insensitive.\n     */\n    public boolean isLanguage(String lang) {\n         //The specific code has been omitted, but there is no error\n        }\n\n//    /**\n//     * Installs the supplied manager as the namespace manager for this node\n//     * pointer. The {@link #getNamespaceURI(String) getNamespaceURI(prefix)}\n//     * uses this manager to resolve namespace prefixes.\n//     * \n//     * @param namespaceManager\n//     */\n//    public void setNamespaceManager(NamespaceManager namespaceManager) {\n         //The specific code has been omitted, but there is no error\n        }\n//    \n//    public NamespaceManager getNamespaceManager() {\n         //The specific code has been omitted, but there is no error\n        }\n//    \n    /**\n     * Returns a NodeIterator that iterates over all children or all children\n     * that match the given NodeTest, starting with the specified one.\n     */\n    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a NodeIterator that iterates over all attributes of the current\n     * node matching the supplied node name (could have a wildcard).\n     * May return null if the object does not support the attributes.\n     */\n    public NodeIterator attributeIterator(QName qname) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a NodeIterator that iterates over all namespaces of the value\n     * currently pointed at.\n     * May return null if the object does not support the namespaces.\n     */\n    public NodeIterator namespaceIterator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a NodePointer for the specified namespace. Will return null\n     * if namespaces are not supported.\n     * Will return UNKNOWN_NAMESPACE if there is no such namespace.\n     */\n    public NodePointer namespacePointer(String namespace) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Decodes a namespace prefix to the corresponding URI.\n     */\n    public String getNamespaceURI(String prefix) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the namespace URI associated with this Pointer.\n     */\n    public String getNamespaceURI() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns true if the supplied prefix represents the\n     * default namespace in the context of the current node.\n     */\n    protected boolean isDefaultNamespace(String prefix) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected String getDefaultNamespaceURI() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Locates a node by ID.\n     */\n    public Pointer getPointerByID(JXPathContext context, String id) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Locates a node by key and value.\n     */\n    public Pointer getPointerByKey(\n        JXPathContext context,\n        String key,\n        String value) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns an XPath that maps to this Pointer.\n     */\n    public String asPath() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Object clone() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public int compareTo(Object object) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Print internal structure of a pointer for debugging\n     */\n    public void printPointerChain() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static void printDeep(NodePointer pointer, String indent) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}