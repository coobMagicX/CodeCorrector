{"JsonWriter": "public class JsonWriter implements Closeable, Flushable {\n\n  /*\n   * From RFC 7159, \"All Unicode characters may be placed within the\n   * quotation marks except for the characters that must be escaped:\n   * quotation mark, reverse solidus, and the control characters\n   * (U+0000 through U+001F).\"\n   *\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n   * newline characters. This prevents eval() from failing with a syntax\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n   */\n  private static final String[] REPLACEMENT_CHARS;\n  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n  static {\n    REPLACEMENT_CHARS = new String[128];\n    for (int i = 0; i <= 0x1f; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n  }\n\n  /** The output data, containing at most one top-level array or object. */\n  private final Writer out;\n\n  private int[] stack = new int[32];\n  private int stackSize = 0;\n  {\n    push(EMPTY_DOCUMENT);\n  }\n\n  /**\n   * A string containing a full set of spaces for a single level of\n   * indentation, or null for no pretty printing.\n   */\n  private String indent;\n\n  /**\n   * The name/value separator; either \":\" or \": \".\n   */\n  private String separator = \":\";\n\n  private boolean lenient;\n\n  private boolean htmlSafe;\n\n  private String deferredName;\n\n  private boolean serializeNulls = true;\n\n  /**\n   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n   * For best performance, ensure {@link Writer} is buffered; wrapping in\n   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n   */\n  public JsonWriter(Writer out) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Top-level values of any type. With strict writing, the top-level\n   *       value must be an object or an array.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if this writer has relaxed syntax rules.\n   */\n  public boolean isLenient() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences.\n   */\n  public final void setHtmlSafe(boolean htmlSafe) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents.\n   */\n  public final boolean isHtmlSafe() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final void setSerializeNulls(boolean serializeNulls) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */\n  public final boolean getSerializeNulls() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginArray() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_ARRAY, \"[\");\n  }\n\n  /**\n   * Ends encoding the current array.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endArray() throws IOException {\n    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, \"]\");\n  }\n\n  /**\n   * Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter beginObject() throws IOException {\n    writeDeferredName();\n    return open(EMPTY_OBJECT, \"{\");\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */\n  public JsonWriter endObject() throws IOException {\n    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, \"}\");\n  }\n\n  /**\n   * Enters a new scope by appending any necessary whitespace and the given\n   * bracket.\n   */\n  private JsonWriter open(int empty, String openBracket) throws IOException {\n    beforeValue();\n    push(empty);\n    out.write(openBracket);\n    return this;\n  }\n\n  /**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */\n  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n         //The specific code has been omitted, but there is no error\n        }\n    if (deferredName != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    stackSize--;\n    if (context == nonempty) {\n         //The specific code has been omitted, but there is no error\n        }\n    out.write(closeBracket);\n    return this;\n  }\n\n  private void push(int newTop) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the value on the top of the stack.\n   */\n  private int peek() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(int topOfStack) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer.\n   */\n  public JsonWriter name(String name) throws IOException {\n    if (name == null) {\n         //The specific code has been omitted, but there is no error\n        }\n    if (deferredName != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    if (stackSize == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    deferredName = name;\n    return this;\n  }\n\n  private void writeDeferredName() throws IOException {\n    if (deferredName != null) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }\n\n  /**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */\n  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n    writeDeferredName();\n    beforeValue();\n    out.append(value);\n    return this;\n  }\n\n  /**\n   * Encodes {@code null}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter nullValue() throws IOException {\n    if (deferredName != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    beforeValue();\n    out.write(\"null\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    writeDeferredName();\n    String string = value.toString();\n    if (!lenient\n        && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(string);\n    return this;\n  }\n\n  /**\n   * Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer.\n   */\n  public void flush() throws IOException {\n    if (stackSize == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    out.flush();\n  }\n\n  /**\n   * Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete.\n   */\n  public void close() throws IOException {\n    out.close();\n\n    int size = stackSize;\n    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {\n         //The specific code has been omitted, but there is no error\n        }\n    stackSize = 0;\n  }\n\n  private void string(String value) throws IOException {\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n    out.write(\"\\\"\");\n    int last = 0;\n    int length = value.length();\n    for (int i = 0; i < length; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n    if (last < length) {\n         //The specific code has been omitted, but there is no error\n        }\n    out.write(\"\\\"\");\n  }\n\n  private void newline() throws IOException {\n    if (indent == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    out.write(\"\\n\");\n    for (int i = 1, size = stackSize; i < size; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value.\n   */\n  private void beforeName() throws IOException {\n    int context = peek();\n    if (context == NONEMPTY_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else if (context != EMPTY_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n    newline();\n    replaceTop(DANGLING_NAME);\n  }\n\n  /**\n   * Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void beforeValue() throws IOException {\n    switch (peek()) {\n    case NONEMPTY_DOCUMENT:\n      if (!lenient) {\n         //The specific code has been omitted, but there is no error\n        }\n      // fall-through\n    case EMPTY_DOCUMENT: // first in document\n      replaceTop(NONEMPTY_DOCUMENT);\n      break;\n\n    case EMPTY_ARRAY: // first in array\n      replaceTop(NONEMPTY_ARRAY);\n      newline();\n      break;\n\n    case NONEMPTY_ARRAY: // another in array\n      out.append(',');\n      newline();\n      break;\n\n    case DANGLING_NAME: // value for name\n      out.append(separator);\n      replaceTop(NONEMPTY_OBJECT);\n      break;\n\n    default:\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n  }\n}"}