{"MapDeserializer": "public class MapDeserializer\n    extends ContainerDeserializerBase<Map<Object,Object>>\n    implements ContextualDeserializer, ResolvableDeserializer\n{\n    private static final long serialVersionUID = -3378654289961736240L;\n\n    // // Configuration: typing, deserializers\n\n    protected final JavaType _mapType;\n\n    /**\n     * Key deserializer to use; either passed via constructor\n     * (when indicated by annotations), or resolved when\n     * {@link #resolve} is called;\n     */\n    protected final KeyDeserializer _keyDeserializer;\n\n    /**\n     * Flag set to indicate that the key type is\n     * {@link java.lang.String} (or {@link java.lang.Object}, for\n     * which String is acceptable), <b>and</b> that the\n     * default Jackson key deserializer would be used.\n     * If both are true, can optimize handling.\n     */\n    protected boolean _standardStringKey;\n\n    /**\n     * Value deserializer.\n     */\n    protected final JsonDeserializer<Object> _valueDeserializer;\n\n    /**\n     * If value instances have polymorphic type information, this\n     * is the type deserializer that can handle it\n     */\n    protected final TypeDeserializer _valueTypeDeserializer;\n    \n    // // Instance construction settings:\n\n    protected final ValueInstantiator _valueInstantiator;\n\n    protected final boolean _hasDefaultCreator;\n\n    /**\n     * Deserializer that is used iff delegate-based creator is\n     * to be used for deserializing from JSON Object.\n     */\n    protected JsonDeserializer<Object> _delegateDeserializer;\n\n    /**\n     * If the Map is to be instantiated using non-default constructor\n     * or factory method\n     * that takes one or more named properties as argument(s),\n     * this creator is used for instantiation.\n     */\n    protected PropertyBasedCreator _propertyBasedCreator;    \n\n    // // Any properties to ignore if seen?\n    \n    protected HashSet<String> _ignorableProperties;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator,\n            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write styling copying of settings of an existing instance.\n     */\n    protected MapDeserializer(MapDeserializer src)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected MapDeserializer(MapDeserializer src,\n            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n            TypeDeserializer valueTypeDeser,\n            HashSet<String> ignorable)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Fluent factory method used to create a copy with slightly\n     * different settings. When sub-classing, MUST be overridden.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected MapDeserializer withResolved(KeyDeserializer keyDeser,\n            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser,\n            HashSet<String> ignorable)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Helper method used to check whether we can just use the default key\n     * deserialization, where JSON String becomes Java String.\n     */\n    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void setIgnorableProperties(String[] ignorable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Validation, post-processing (ResolvableDeserializer)\n    /**********************************************************\n     */\n\n    @Override\n    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n    {\n        // May need to resolve types for delegate- and/or property-based creators:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            /* Theoretically should be able to get CreatorProperty for delegate\n             * parameter to pass; but things get tricky because DelegateCreator\n             * may contain injectable values. So, for now, let's pass nothing.\n             */\n            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n        }\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n    }\n\n    /**\n     * Method called to finalize setup of this deserializer,\n     * when it is known for which property deserializer is needed for.\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            if (kd instanceof ContextualKeyDeserializer) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        // #125: May have a content converter\n        vd = findConvertingContentDeserializer(ctxt, property, vd);\n        if (vd == null) {\n         //The specific code has been omitted, but there is no error\n        } else { // if directly assigned, probably not yet contextual, so:\n            vd = ctxt.handleSecondaryContextualization(vd, property);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        HashSet<String> ignored = _ignorableProperties;\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null && property != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return withResolved(kd, vtd, vd, ignored);\n    }\n    \n    /*\n    /**********************************************************\n    /* ContainerDeserializerBase API\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonDeserializer<Object> getContentDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* JsonDeserializer API\n    /**********************************************************\n     */\n\n    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_propertyBasedCreator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_delegateDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (!_hasDefaultCreator) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n         //The specific code has been omitted, but there is no error\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        // Ok: must point to START_OBJECT or FIELD_NAME\n        JsonToken t = jp.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_standardStringKey) {\n         //The specific code has been omitted, but there is no error\n        }\n        _readAndBind(jp, ctxt, result);\n        return result;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException, JsonProcessingException\n    {\n        // In future could check current token... for now this should be enough:\n        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n    }\n    \n    /*\n    /**********************************************************\n    /* Other public accessors\n    /**********************************************************\n     */\n\n    @SuppressWarnings(\"unchecked\")\n    public final Class<?> getMapClass() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JavaType getValueType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n         //The specific code has been omitted, but there is no error\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            Object key = keyDes.deserializeKey(fieldName, ctxt);\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try{\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (typeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                /* !!! 23-Dec-2008, tatu: should there be an option to verify\n                 *   that there are no duplicate field names? (and/or what\n                 *   to do, keep-first or keep-last)\n                 */\n                if (useObjectId) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    result.put(key, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n         //The specific code has been omitted, but there is no error\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n\n    /**\n     * Optimized method used when keys can be deserialized as plain old\n     * {@link java.lang.String}s, and there is no custom deserialized\n     * specified.\n     */\n    protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt,\n            Map<Object,Object> result)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        MapReferringAccumulator referringAccumulator = null;\n        boolean useObjectId = valueDes.getObjectIdReader() != null;\n        if (useObjectId) {\n         //The specific code has been omitted, but there is no error\n        }\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            // Must point to field name\n            String fieldName = jp.getCurrentName();\n            // And then the value...\n            t = jp.nextToken();\n            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n                jp.skipChildren();\n                continue;\n            }\n            try {\n                // Note: must handle null explicitly here; value deserializers won't\n                Object value;\n                if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (typeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n                if (useObjectId) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    result.put(fieldName, value);\n                }\n            } catch (UnresolvedForwardReference reference) {\n         //The specific code has been omitted, but there is no error\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n    \n    @SuppressWarnings(\"unchecked\") \n    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        // null -> no ObjectIdReader for Maps (yet?)\n        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null);\n\n        JsonToken t = jp.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            t = jp.nextToken(); // to get to value\n            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n                jp.skipChildren(); // and skip it (in case of array/object)\n                continue;\n            }\n            // creator property?\n            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // other property? needs buffering\n            String fieldName = jp.getCurrentName();\n            Object key = _keyDeserializer.deserializeKey(fieldName, ctxt);\n            Object value; \n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n         //The specific code has been omitted, but there is no error\n        } else if (typeDeser == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n            buffer.bufferMapProperty(key, value);\n        }\n        // end of JSON object?\n        // if so, can just construct and leave...\n        try {\n            return (Map<Object,Object>)creator.build(ctxt, buffer);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    @Deprecated // since 2.5\n    protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n        wrapAndThrow(t, ref, null);\n    }\n    \n    // note: copied from BeanDeserializer; should try to share somehow...\n    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n    {\n        // to handle StackOverflow:\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors and \"plain\" IOExceptions to be passed as is\n        if (t instanceof Error) {\n         //The specific code has been omitted, but there is no error\n        }\n        // ... except for mapping exceptions\n        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n            throw (IOException) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, ref, key);\n    }\n\n    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n            Object key, UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        if (accumulator == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        Referring referring = accumulator.handleUnresolvedReference(reference, key);\n        reference.getRoid().appendReferring(referring);\n    }\n\n    private final static class MapReferringAccumulator {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Helper class to maintain processing order of value. The resolved\n     * object associated with {@link #_id} comes before the values in\n     * {@link _next}.\n     */\n    private final static class MapReferring extends Referring {\n        private final MapReferringAccumulator _parent;\n\n        public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n        public final Object key;\n        \n        protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                Class<?> valueType, Object key)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }\n}", "MapReferringAccumulator": "    private final static class MapReferringAccumulator {\n         //The specific code has been omitted, but there is no error\n        }", "MapReferring": "    private final static class MapReferring extends Referring {\n        private final MapReferringAccumulator _parent;\n\n        public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n        public final Object key;\n        \n        protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                Class<?> valueType, Object key)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n            _parent.resolveForwardReference(id, value);\n        }\n    }"}