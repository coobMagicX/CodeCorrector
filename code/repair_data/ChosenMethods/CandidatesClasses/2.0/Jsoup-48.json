{"HttpConnection": "public class HttpConnection implements Connection {\n    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n    private static final String CONTENT_TYPE = \"Content-Type\";\n    private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n    private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n\n    public static Connection connect(String url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public static Connection connect(URL url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\tprivate static String encodeUrl(String url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static String encodeMimeName(String val) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Connection.Request req;\n    private Connection.Response res;\n\n\tprivate HttpConnection() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection url(URL url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection url(String url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection userAgent(String userAgent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection timeout(int millis) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection maxBodySize(int bytes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection followRedirects(boolean followRedirects) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection referrer(String referrer) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection method(Method method) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection ignoreContentType(boolean ignoreContentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection validateTLSCertificates(boolean value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection data(String key, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection data(String key, String filename, InputStream inputStream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection data(Map<String, String> data) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection data(String... keyvals) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection data(Collection<Connection.KeyVal> data) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection header(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection cookie(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection cookies(Map<String, String> cookies) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection parser(Parser parser) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }\n\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }\n\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    public Connection.Request request() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection request(Connection.Request request) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection.Response response() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection response(Connection.Response response) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Connection postDataCharset(String charset) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @SuppressWarnings({\"unchecked\"})\n    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> {\n        URL url;\n        Method method;\n        Map<String, String> headers;\n        Map<String, String> cookies;\n\n        private Base() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public URL url() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T url(URL url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Method method() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T method(Method method) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String header(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T header(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean hasHeader(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Test if the request has a header with this value (case insensitive).\n         */\n        public boolean hasHeaderWithValue(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T removeHeader(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Map<String, String> headers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private String getHeaderCaseInsensitive(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Map.Entry<String, String> scanHeaders(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String cookie(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T cookie(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean hasCookie(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T removeCookie(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Map<String, String> cookies() {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n        private int timeoutMilliseconds;\n        private int maxBodySizeBytes;\n        private boolean followRedirects;\n        private Collection<Connection.KeyVal> data;\n        private boolean ignoreHttpErrors = false;\n        private boolean ignoreContentType = false;\n        private Parser parser;\n        private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n        private boolean validateTSLCertificates = true;\n        private String postDataCharset = DataUtil.defaultCharset;\n\n        private Request() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public int timeout() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Request timeout(int millis) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public int maxBodySize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request maxBodySize(int bytes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean followRedirects() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request followRedirects(boolean followRedirects) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean ignoreHttpErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean validateTLSCertificates() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public void validateTLSCertificates(boolean value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean ignoreContentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Request data(Connection.KeyVal keyval) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Collection<Connection.KeyVal> data() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Request parser(Parser parser) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Parser parser() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request postDataCharset(String charset) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String postDataCharset() {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n        private static final int MAX_REDIRECTS = 20;\n        private static SSLSocketFactory sslSocketFactory;\n        private static final String LOCATION = \"Location\";\n        private int statusCode;\n        private String statusMessage;\n        private ByteBuffer byteData;\n        private String charset;\n        private String contentType;\n        private boolean executed = false;\n        private int numRedirects = 0;\n        private Connection.Request req;\n\n        /*\n         * Matches XML content types (like text/xml, application/xhtml+xml;charset=UTF8, etc)\n         */\n        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\");\n\n        Response() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (!req.method().hasBody() && req.data().size() > 0) {\n                serialiseRequestUrl(req); // appends query string\n            } else if (req.method().hasBody()) {\n                mimeBoundary = setOutputContentType(req);\n            }\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream bodyStream = null;\n                    InputStream dataStream = null;\n                    try {\n                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                                new BufferedInputStream(dataStream);\n\n                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    } finally {\n                        if (bodyStream != null) bodyStream.close();\n                        if (dataStream != null) dataStream.close();\n                    }\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }\n\n        public int statusCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String statusMessage() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String charset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String contentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n            byteData.rewind();\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            return doc;\n        }\n\n        public String body() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public byte[] bodyAsBytes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // set up connection defaults, and details from request\n        private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout());\n\n            if (conn instanceof HttpsURLConnection) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            if (req.cookies().size() > 0)\n                conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n            for (Map.Entry<String, String> header : req.headers().entrySet()) {\n                conn.addRequestProperty(header.getKey(), header.getValue());\n            }\n            return conn;\n        }\n\n        /**\n         * Instantiate Hostname Verifier that does nothing.\n         * This is used for connections with disabled SSL certificates validation.\n         *\n         *\n         * @return Hostname Verifier that does nothing and accepts all hostnames\n         */\n        private static HostnameVerifier getInsecureVerifier() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Initialise Trust manager that does not validate certificate chains and\n         * add it to current SSLContext.\n         * <p/>\n         * please not that this method will only perform action if sslSocketFactory is not yet\n         * instantiated.\n         *\n         * @throws IOException\n         */\n        private static synchronized void initUnSecureTSL() throws IOException {\n            if (sslSocketFactory == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        }\n\n        // set up url, method, header, cookies\n        private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            // if from a redirect, map previous response cookies into this response\n            if (previousResponse != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private static String setOutputContentType(final Connection.Request req) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n\n            if (bound != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                // regular form data (application/x-www-form-urlencoded)\n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n         //The specific code has been omitted, but there is no error\n        }\n            }\n            w.close();\n        }\n\n        private static String getRequestCookieString(Connection.Request req) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // for get url reqs, serialise the data map into the url\n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = new StringBuilder();\n            boolean first = true;\n            // reconstitute the query, ready for appends\n            url\n                .append(in.getProtocol())\n                .append(\"://\")\n                .append(in.getAuthority()) // includes host, port\n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(url.toString()));\n            req.data().clear(); // moved into url as get params\n        }\n    }\n\n    public static class KeyVal implements Connection.KeyVal {\n        private String key;\n        private String value;\n        private InputStream stream;\n\n        public static KeyVal create(String key, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private KeyVal() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public KeyVal key(String key) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String key() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public KeyVal value(String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String value() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public InputStream inputStream() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean hasInputStream() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n}", "Base": "    private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> {\n        URL url;\n        Method method;\n        Map<String, String> headers;\n        Map<String, String> cookies;\n\n        private Base() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public URL url() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T url(URL url) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Method method() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T method(Method method) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String header(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T header(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean hasHeader(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Test if the request has a header with this value (case insensitive).\n         */\n        public boolean hasHeaderWithValue(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T removeHeader(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Map<String, String> headers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private String getHeaderCaseInsensitive(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Map.Entry<String, String> scanHeaders(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String cookie(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T cookie(String name, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean hasCookie(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public T removeCookie(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Map<String, String> cookies() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "Request": "    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n        private int timeoutMilliseconds;\n        private int maxBodySizeBytes;\n        private boolean followRedirects;\n        private Collection<Connection.KeyVal> data;\n        private boolean ignoreHttpErrors = false;\n        private boolean ignoreContentType = false;\n        private Parser parser;\n        private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n        private boolean validateTSLCertificates = true;\n        private String postDataCharset = DataUtil.defaultCharset;\n\n        private Request() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public int timeout() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Request timeout(int millis) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public int maxBodySize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request maxBodySize(int bytes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean followRedirects() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request followRedirects(boolean followRedirects) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean ignoreHttpErrors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean validateTLSCertificates() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public void validateTLSCertificates(boolean value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean ignoreContentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Request data(Connection.KeyVal keyval) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Collection<Connection.KeyVal> data() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Request parser(Parser parser) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Parser parser() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Connection.Request postDataCharset(String charset) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String postDataCharset() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "Response": "    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n        private static final int MAX_REDIRECTS = 20;\n        private static SSLSocketFactory sslSocketFactory;\n        private static final String LOCATION = \"Location\";\n        private int statusCode;\n        private String statusMessage;\n        private ByteBuffer byteData;\n        private String charset;\n        private String contentType;\n        private boolean executed = false;\n        private int numRedirects = 0;\n        private Connection.Request req;\n\n        /*\n         * Matches XML content types (like text/xml, application/xhtml+xml;charset=UTF8, etc)\n         */\n        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\");\n\n        Response() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private Response(Response previousResponse) throws IOException {\n            super();\n            if (previousResponse != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        static Response execute(Connection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (!req.method().hasBody() && req.data().size() > 0) {\n                serialiseRequestUrl(req); // appends query string\n            } else if (req.method().hasBody()) {\n                mimeBoundary = setOutputContentType(req);\n            }\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream bodyStream = null;\n                    InputStream dataStream = null;\n                    try {\n                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                                new BufferedInputStream(dataStream);\n\n                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    } finally {\n                        if (bodyStream != null) bodyStream.close();\n                        if (dataStream != null) dataStream.close();\n                    }\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }\n\n        public int statusCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String statusMessage() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String charset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String contentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n            byteData.rewind();\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            return doc;\n        }\n\n        public String body() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public byte[] bodyAsBytes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // set up connection defaults, and details from request\n        private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout());\n\n            if (conn instanceof HttpsURLConnection) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            if (req.cookies().size() > 0)\n                conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n            for (Map.Entry<String, String> header : req.headers().entrySet()) {\n                conn.addRequestProperty(header.getKey(), header.getValue());\n            }\n            return conn;\n        }\n\n        /**\n         * Instantiate Hostname Verifier that does nothing.\n         * This is used for connections with disabled SSL certificates validation.\n         *\n         *\n         * @return Hostname Verifier that does nothing and accepts all hostnames\n         */\n        private static HostnameVerifier getInsecureVerifier() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /**\n         * Initialise Trust manager that does not validate certificate chains and\n         * add it to current SSLContext.\n         * <p/>\n         * please not that this method will only perform action if sslSocketFactory is not yet\n         * instantiated.\n         *\n         * @throws IOException\n         */\n        private static synchronized void initUnSecureTSL() throws IOException {\n            if (sslSocketFactory == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        }\n\n        // set up url, method, header, cookies\n        private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            // if from a redirect, map previous response cookies into this response\n            if (previousResponse != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private static String setOutputContentType(final Connection.Request req) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n\n            if (bound != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                // regular form data (application/x-www-form-urlencoded)\n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n         //The specific code has been omitted, but there is no error\n        }\n            }\n            w.close();\n        }\n\n        private static String getRequestCookieString(Connection.Request req) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // for get url reqs, serialise the data map into the url\n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = new StringBuilder();\n            boolean first = true;\n            // reconstitute the query, ready for appends\n            url\n                .append(in.getProtocol())\n                .append(\"://\")\n                .append(in.getAuthority()) // includes host, port\n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(url.toString()));\n            req.data().clear(); // moved into url as get params\n        }\n    }", "KeyVal": "    public static class KeyVal implements Connection.KeyVal {\n        private String key;\n        private String value;\n        private InputStream stream;\n\n        public static KeyVal create(String key, String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        private KeyVal() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public KeyVal key(String key) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String key() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public KeyVal value(String value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public String value() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public InputStream inputStream() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public boolean hasInputStream() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n    }"}