{"AnnotatedClass": "public final class AnnotatedClass\n    extends Annotated\n{\n    private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0];\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Class for which annotations apply, and that owns other\n     * components (constructors, methods)\n     */\n    final protected Class<?> _class;\n\n    /**\n     * Ordered set of super classes and interfaces of the\n     * class itself: included in order of precedence\n     */\n    final protected List<Class<?>> _superTypes;\n\n    /**\n     * Filter used to determine which annotations to gather; used\n     * to optimize things so that unnecessary annotations are\n     * ignored.\n     */\n    final protected AnnotationIntrospector _annotationIntrospector;\n\n    /**\n     * Object that knows mapping of mix-in classes (ones that contain\n     * annotations to add) with their target classes (ones that\n     * get these additional annotations \"mixed in\").\n     */\n    final protected MixInResolver _mixInResolver;\n\n    /**\n     * Primary mix-in class; one to use for the annotated class\n     * itself. Can be null.\n     */\n    final protected Class<?> _primaryMixIn;\n\n    /*\n    /**********************************************************\n    /* Gathered information\n    /**********************************************************\n     */\n\n    /**\n     * Combined list of Jackson annotations that the class has,\n     * including inheritable ones from super classes and interfaces\n     */\n    protected AnnotationMap _classAnnotations;\n\n    /**\n     * Flag to indicate whether creator information has been resolved\n     * or not.\n     */\n    protected boolean _creatorsResolved = false;\n    \n    /**\n     * Default constructor of the annotated class, if it has one.\n     */\n    protected AnnotatedConstructor _defaultConstructor;\n\n    /**\n     * Single argument constructors the class has, if any.\n     */\n    protected List<AnnotatedConstructor> _constructors;\n\n    /**\n     * Single argument static methods that might be usable\n     * as factory methods\n     */\n    protected List<AnnotatedMethod> _creatorMethods;\n\n    /**\n     * Member methods of interest; for now ones with 0 or 1 arguments\n     * (just optimization, since others won't be used now)\n     */\n    protected AnnotatedMethodMap  _memberMethods;\n\n    /**\n     * Member fields of interest: ones that are either public,\n     * or have at least one annotation.\n     */\n    protected List<AnnotatedField> _fields;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor will not do any initializations, to allow for\n     * configuring instances differently depending on use cases\n     */\n    private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes,\n            AnnotationIntrospector aintr, MixInResolver mir,\n            AnnotationMap classAnnotations)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Factory method that instantiates an instance. Returned instance\n     * will only be initialized with class annotations, but not with\n     * any method information.\n     */\n    public static AnnotatedClass construct(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method similar to {@link #construct}, but that will NOT include\n     * information from supertypes; only class itself and any direct\n     * mix-ins it may have.\n     */\n    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Annotated impl \n    /**********************************************************\n     */\n\n    @Override\n    public Class<?> getAnnotated() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int getModifiers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> acls)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Type getGenericType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Class<?> getRawType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Iterable<Annotation> annotations() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    protected AnnotationMap getAllAnnotations() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Public API, generic accessors\n    /**********************************************************\n     */\n\n    public Annotations getAnnotations() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public boolean hasAnnotations() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public AnnotatedConstructor getDefaultConstructor()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public List<AnnotatedConstructor> getConstructors()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public List<AnnotatedMethod> getStaticMethods()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Iterable<AnnotatedMethod> memberMethods()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public int getMemberMethodCount()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public int getFieldCount() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Iterable<AnnotatedField> fields()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API, main-level resolution methods\n    /**********************************************************\n     */\n\n    /**\n     * Initialization method that will recursively collect Jackson\n     * annotations for this class and all super classes and\n     * interfaces.\n     */\n    private void resolveClassAnnotations()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Initialization method that will find out all constructors\n     * and potential static factory methods the class has.\n     */\n    private void resolveCreators()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for resolving member method information: aggregating all non-static methods\n     * and combining annotations (to implement method-annotation inheritance)\n     * \n     * @param methodFilter Filter used to determine which methods to include\n     */\n    private void resolveMemberMethods()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method that will collect all member (non-static) fields\n     * that are either public, or have at least a single annotation\n     * associated with them.\n     */\n    private void resolveFields()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Helper methods for resolving class annotations\n    /* (resolution consisting of inheritance, overrides,\n    /* and injection of mix-ins as necessary)\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method for adding any mix-in annotations specified\n     * class might have.\n     */\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,\n                                   Class<?> mixin)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating creator (ctor, factory) information\n    /**********************************************************\n     */\n\n    protected void _addConstructorMixIns(Class<?> mixin)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected void _addFactoryMixIns(Class<?> mixin)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating method information\n    /**********************************************************\n     */\n\n    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Helper methods for populating field information\n    /**********************************************************\n     */\n\n    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to add field mix-ins from given mix-in class (and its fields)\n     * into already collected actual fields (from introspected classes and their\n     * super-classes)\n     */\n    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n            Map<String,AnnotatedField> fields)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Helper methods, constructing value types\n    /**********************************************************\n     */\n\n    protected AnnotatedMethod _constructMethod(Method m)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected AnnotatedMethod _constructCreatorMethod(Method m)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected AnnotatedField _constructField(Field f)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n \n    private AnnotationMap _emptyAnnotationMap() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Helper methods, inclusion filtering\n    /**********************************************************\n     */\n\n    protected boolean _isIncludableMemberMethod(Method m)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean _isIncludableField(Field f)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Helper methods, attaching annotations\n    /**********************************************************\n     */\n\n    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /* Helper method used to add all applicable annotations from given set.\n     * Takes into account possible \"annotation bundles\" (meta-annotations to\n     * include instead of main-level annotation)\n     */\n    private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * @param addParamAnnotations Whether parameter annotations are to be\n     *   added as well\n     */\n    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target,\n            boolean addParamAnnotations)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @param addParamAnnotations Whether parameter annotations are to be\n     *   added as well\n     */\n    protected void _addMixOvers(Method mixin, AnnotatedMethod target,\n            boolean addParamAnnotations)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that will add annotations from specified source method to target method,\n     * but only if target does not yet have them.\n     */\n    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n         //The specific code has been omitted, but there is no error\n        }\n\n   private final boolean _isAnnotationBundle(Annotation ann)\n   {\n         //The specific code has been omitted, but there is no error\n        }\n   \n    /*\n    /**********************************************************\n    /* Other methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}