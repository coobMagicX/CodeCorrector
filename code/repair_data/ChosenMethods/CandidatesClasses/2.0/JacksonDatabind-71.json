{"StdKeyDeserializer": "public class StdKeyDeserializer extends KeyDeserializer\n    implements java.io.Serializable\n{\n    private static final long serialVersionUID = 1L;\n\n    public final static int TYPE_BOOLEAN = 1;\n    public final static int TYPE_BYTE = 2;\n    public final static int TYPE_SHORT = 3;\n    public final static int TYPE_CHAR = 4;\n    public final static int TYPE_INT = 5;\n    public final static int TYPE_LONG = 6;\n    public final static int TYPE_FLOAT = 7;\n    public final static int TYPE_DOUBLE = 8;\n    public final static int TYPE_LOCALE = 9;\n    public final static int TYPE_DATE = 10;\n    public final static int TYPE_CALENDAR = 11;\n    public final static int TYPE_UUID = 12;\n    public final static int TYPE_URI = 13;\n    public final static int TYPE_URL = 14;\n    public final static int TYPE_CLASS = 15;\n    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        } catch (Exception re) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n    }\n\n    public Class<?> getKeyClass() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected Object _parse(String key, DeserializationContext ctxt) throws Exception\n    {\n        switch (_kind) {\n         //The specific code has been omitted, but there is no error\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    protected int _parseInt(String key) throws IllegalArgumentException {\n        return Integer.parseInt(key);\n    }\n\n    protected long _parseLong(String key) throws IllegalArgumentException {\n        return Long.parseLong(key);\n    }\n\n    protected double _parseDouble(String key) throws IllegalArgumentException {\n        return NumberInput.parseDouble(key);\n    }\n\n    /*\n    /**********************************************************\n    /* First: the standard \"String as String\" deserializer\n    /**********************************************************\n     */\n\n    @JacksonStdImpl\n    final static class StringKD extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n        private final static StringKD sString = new StringKD(String.class);\n        private final static StringKD sObject = new StringKD(Object.class);\n        \n        private StringKD(Class<?> nominalType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static StringKD forType(Class<?> nominalType)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            return key;\n        }\n    }    \n\n    /*\n    /**********************************************************\n    /* Key deserializer implementations; other\n    /**********************************************************\n     */\n\n    /**\n     * Key deserializer that wraps a \"regular\" deserializer (but one\n     * that must recognize FIELD_NAMEs as text!) to reuse existing\n     * handlers as key handlers.\n     */\n    final static class DelegatingKD\n        extends KeyDeserializer // note: NOT the std one\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        final protected Class<?> _keyClass;\n\n        protected final JsonDeserializer<?> _delegate;\n        \n        protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            if (key == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            try {\n                // Ugh... should not have to give parser which may or may not be correct one...\n                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n                if (result != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            } catch (Exception re) {\n         //The specific code has been omitted, but there is no error\n        }\n            throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n        }\n\n        public Class<?> getKeyClass() {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n     \n    @JacksonStdImpl\n    final static class EnumKD extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final EnumResolver _byNameResolver;\n\n        protected final AnnotatedMethod _factory;\n\n        /**\n         * Lazily constructed alternative in case there is need to\n         * use 'toString()' method as the source.\n         *\n         * @since 2.7.3\n         */\n        protected EnumResolver _byToStringResolver;\n        \n        protected EnumKD(EnumResolver er, AnnotatedMethod factory) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n        {\n            if (_factory != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n                    ? _getToStringResolver() : _byNameResolver;\n            Enum<?> e = res.findEnum(key);\n            if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                throw ctxt.weirdKeyException(_keyClass, key, \"not one of values excepted for Enum class: \"\n                        +res.getEnumIds());\n            }\n            return e;\n        }\n\n        private EnumResolver _getToStringResolver()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    /**\n     * Key deserializer that calls a single-string-arg constructor\n     * to instantiate desired key type.\n     */\n    final static class StringCtorKeyDeserializer extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final Constructor<?> _ctor;\n\n        public StringCtorKeyDeserializer(Constructor<?> ctor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception\n        {\n            return _ctor.newInstance(key);\n        }\n    }\n\n    /**\n     * Key deserializer that calls a static no-args factory method\n     * to instantiate desired key type.\n     */\n    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n\n        final Method _factoryMethod;\n\n        public StringFactoryKeyDeserializer(Method fm) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception\n        {\n            return _factoryMethod.invoke(null, key);\n        }\n    }\n}", "StringKD": "    final static class StringKD extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n        private final static StringKD sString = new StringKD(String.class);\n        private final static StringKD sObject = new StringKD(Object.class);\n        \n        private StringKD(Class<?> nominalType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        public static StringKD forType(Class<?> nominalType)\n        {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            return key;\n        }\n    }    ", "DelegatingKD": "    final static class DelegatingKD\n        extends KeyDeserializer // note: NOT the std one\n        implements java.io.Serializable\n    {\n        private static final long serialVersionUID = 1L;\n\n        final protected Class<?> _keyClass;\n\n        protected final JsonDeserializer<?> _delegate;\n        \n        protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public final Object deserializeKey(String key, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            if (key == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            try {\n                // Ugh... should not have to give parser which may or may not be correct one...\n                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n                if (result != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            } catch (Exception re) {\n         //The specific code has been omitted, but there is no error\n        }\n            throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n        }\n\n        public Class<?> getKeyClass() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "EnumKD": "    final static class EnumKD extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final EnumResolver _byNameResolver;\n\n        protected final AnnotatedMethod _factory;\n\n        /**\n         * Lazily constructed alternative in case there is need to\n         * use 'toString()' method as the source.\n         *\n         * @since 2.7.3\n         */\n        protected EnumResolver _byToStringResolver;\n        \n        protected EnumKD(EnumResolver er, AnnotatedMethod factory) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n        {\n            if (_factory != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            EnumResolver res = ctxt.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)\n                    ? _getToStringResolver() : _byNameResolver;\n            Enum<?> e = res.findEnum(key);\n            if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                throw ctxt.weirdKeyException(_keyClass, key, \"not one of values excepted for Enum class: \"\n                        +res.getEnumIds());\n            }\n            return e;\n        }\n\n        private EnumResolver _getToStringResolver()\n        {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "StringCtorKeyDeserializer": "    final static class StringCtorKeyDeserializer extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final Constructor<?> _ctor;\n\n        public StringCtorKeyDeserializer(Constructor<?> ctor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception\n        {\n            return _ctor.newInstance(key);\n        }\n    }", "StringFactoryKeyDeserializer": "    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer\n    {\n        private static final long serialVersionUID = 1L;\n\n        final Method _factoryMethod;\n\n        public StringFactoryKeyDeserializer(Method fm) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        public Object _parse(String key, DeserializationContext ctxt) throws Exception\n        {\n            return _factoryMethod.invoke(null, key);\n        }\n    }"}