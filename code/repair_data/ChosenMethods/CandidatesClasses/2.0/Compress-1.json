{"CpioArchiveOutputStream": "public class CpioArchiveOutputStream extends ArchiveOutputStream implements\n        CpioConstants {\n\n    private CpioArchiveEntry cpioEntry;\n\n    private boolean closed = false;\n\n    private boolean finished;\n\n    private short entryFormat = FORMAT_NEW;\n\n    private final HashMap names = new HashMap();\n\n    private long crc = 0;\n\n    private long written;\n\n    private final OutputStream out;\n\n    /**\n     * Construct the cpio output stream with a specified format\n     * \n     * @param out\n     *            The cpio stream\n     * @param format\n     *            The format of the stream\n     */\n    public CpioArchiveOutputStream(final OutputStream out, final short format) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct the cpio output stream. The format for this CPIO stream is the\n     * \"new\" format\n     * \n     * @param out\n     *            The cpio stream\n     */\n    public CpioArchiveOutputStream(final OutputStream out) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check to make sure that this stream has not been closed\n     * \n     * @throws IOException\n     *             if the stream is already closed\n     */\n    private void ensureOpen() throws IOException {\n        if (this.closed) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Set a default header format. This will be used if no format is defined in\n     * the cpioEntry given to putNextEntry().\n     * \n     * @param format\n     *            A CPIO format\n     */\n    private void setFormat(final short format) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Begins writing a new CPIO file entry and positions the stream to the\n     * start of the entry data. Closes the current entry if still active. The\n     * current time will be used if the entry has no set modification time and\n     * the default header format will be used if no other format is specified in\n     * the entry.\n     * \n     * @param e\n     *            the CPIO cpioEntry to be written\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void putNextEntry(final CpioArchiveEntry e) throws IOException {\n        ensureOpen();\n        if (this.cpioEntry != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (e.getTime() == -1) {\n            e.setTime(System.currentTimeMillis());\n        }\n\n        // TODO what happens if an entry has an other format than the\n        // outputstream?\n        if (e.getFormat() == -1) {\n            e.setFormat(this.entryFormat);\n        }\n\n        if (this.names.put(e.getName(), e) != null) {\n            throw new IOException(\"duplicate entry: \" + e.getName());\n        }\n\n        writeHeader(e);\n        this.cpioEntry = e;\n        this.written = 0;\n    }\n\n    private void writeHeader(final CpioArchiveEntry e) throws IOException {\n        switch (e.getFormat()) {\n        case FORMAT_NEW:\n            out.write(MAGIC_NEW.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_NEW_CRC:\n            out.write(MAGIC_NEW_CRC.getBytes());\n            writeNewEntry(e);\n            break;\n        case FORMAT_OLD_ASCII:\n            out.write(MAGIC_OLD_ASCII.getBytes());\n            writeOldAsciiEntry(e);\n            break;\n        case FORMAT_OLD_BINARY:\n            boolean swapHalfWord = true;\n            writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord);\n            writeOldBinaryEntry(e, swapHalfWord);\n            break;\n        }\n    }\n\n    private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {\n        writeAsciiLong(entry.getInode(), 8, 16);\n        writeAsciiLong(entry.getMode(), 8, 16);\n        writeAsciiLong(entry.getUID(), 8, 16);\n        writeAsciiLong(entry.getGID(), 8, 16);\n        writeAsciiLong(entry.getNumberOfLinks(), 8, 16);\n        writeAsciiLong(entry.getTime(), 8, 16);\n        writeAsciiLong(entry.getSize(), 8, 16);\n        writeAsciiLong(entry.getDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);\n        writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);\n        writeAsciiLong(entry.getName().length() + 1, 8, 16);\n        writeAsciiLong(entry.getChksum(), 8, 16);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 4);\n    }\n\n    private void writeOldAsciiEntry(final CpioArchiveEntry entry)\n            throws IOException {\n        writeAsciiLong(entry.getDevice(), 6, 8);\n        writeAsciiLong(entry.getInode(), 6, 8);\n        writeAsciiLong(entry.getMode(), 6, 8);\n        writeAsciiLong(entry.getUID(), 6, 8);\n        writeAsciiLong(entry.getGID(), 6, 8);\n        writeAsciiLong(entry.getNumberOfLinks(), 6, 8);\n        writeAsciiLong(entry.getRemoteDevice(), 6, 8);\n        writeAsciiLong(entry.getTime(), 11, 8);\n        writeAsciiLong(entry.getName().length() + 1, 6, 8);\n        writeAsciiLong(entry.getSize(), 11, 8);\n        writeCString(entry.getName());\n    }\n\n    private void writeOldBinaryEntry(final CpioArchiveEntry entry,\n            final boolean swapHalfWord) throws IOException {\n        writeBinaryLong(entry.getDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getInode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getMode(), 2, swapHalfWord);\n        writeBinaryLong(entry.getUID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getGID(), 2, swapHalfWord);\n        writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);\n        writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);\n        writeBinaryLong(entry.getTime(), 4, swapHalfWord);\n        writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord);\n        writeBinaryLong(entry.getSize(), 4, swapHalfWord);\n        writeCString(entry.getName());\n        pad(entry.getHeaderSize() + entry.getName().length() + 1, 2);\n    }\n\n    /*(non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#closeArchiveEntry\n     * ()\n     */\n    public void closeArchiveEntry() throws IOException {\n        ensureOpen();\n\n        if (this.cpioEntry.getSize() != this.written) {\n            throw new IOException(\"invalid entry size (expected \"\n                    + this.cpioEntry.getSize() + \" but got \" + this.written\n                    + \" bytes)\");\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) {\n            pad(this.cpioEntry.getSize(), 4);\n        } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) {\n            pad(this.cpioEntry.getSize(), 2);\n        }\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            if (this.crc != this.cpioEntry.getChksum()) {\n                throw new IOException(\"CRC Error\");\n            }\n        }\n        this.cpioEntry = null;\n        this.crc = 0;\n        this.written = 0;\n    }\n\n    /**\n     * Writes an array of bytes to the current CPIO entry data. This method will\n     * block until all the bytes are written.\n     * \n     * @param b\n     *            the data to be written\n     * @param off\n     *            the start offset in the data\n     * @param len\n     *            the number of bytes that are written\n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n        ensureOpen();\n        if (off < 0 || len < 0 || off > b.length - len) {\n         //The specific code has been omitted, but there is no error\n        } else if (len == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (this.cpioEntry == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (this.written + len > this.cpioEntry.getSize()) {\n            throw new IOException(\"attempt to write past end of STORED entry\");\n        }\n        out.write(b, off, len);\n        this.written += len;\n        if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) {\n            for (int pos = 0; pos < len; pos++) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n    }\n\n    /**\n     * Finishes writing the contents of the CPIO output stream without closing\n     * the underlying stream. Use this method when applying multiple filters in\n     * succession to the same output stream.\n     * \n     * @throws IOException\n     *             if an I/O exception has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (this.cpioEntry != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private void pad(final long count, final int border) throws IOException {\n        long skip = count % border;\n        if (skip > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n         //The specific code has been omitted, but there is no error\n        } else if (radix == 8) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            tmp.append(Long.toString(number));\n        }\n\n        if (tmp.length() <= length) {\n            long insertLength = length - tmp.length();\n            for (int pos = 0; pos < insertLength; pos++) {\n         //The specific code has been omitted, but there is no error\n        }\n            tmpStr = tmp.toString();\n        } else {\n            tmpStr = tmp.substring(tmp.length() - length);\n        }\n        out.write(tmpStr.getBytes());\n    }\n\n    private void writeCString(final String str) throws IOException {\n        out.write(str.getBytes());\n        out.write('\\0');\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see\n     * org.apache.commons.compress.archivers.ArchiveOutputStream#putArchiveEntry\n     * (org.apache.commons.compress.archivers.ArchiveEntry)\n     */\n    public void putArchiveEntry(ArchiveEntry entry) throws IOException {\n        this.putNextEntry((CpioArchiveEntry) entry);\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see java.io.OutputStream#write(int)\n     */\n    public void write(int b) throws IOException {\n        out.write(b);\n    }\n}"}