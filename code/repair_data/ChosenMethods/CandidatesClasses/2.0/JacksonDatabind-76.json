{"BuilderBasedDeserializer": "public class BuilderBasedDeserializer\n    extends BeanDeserializerBase\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final AnnotatedMethod _buildMethod;\n\n    /*\n    /**********************************************************\n    /* Life-cycle, construction, initialization\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used by {@link BeanDeserializerBuilder}.\n     */\n    public BuilderBasedDeserializer(BeanDeserializerBuilder builder,\n            BeanDescription beanDesc,\n            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n            Set<String> ignorableProps, boolean ignoreAllUnknown,\n            boolean hasViews)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy-constructor that can be used by sub-classes to allow\n     * copy-on-write styling copying of settings of an existing instance.\n     */\n    protected BuilderBasedDeserializer(BuilderBasedDeserializer src)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected BuilderBasedDeserializer(BuilderBasedDeserializer src, boolean ignoreAllUnknown)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected BuilderBasedDeserializer(BuilderBasedDeserializer src, NameTransformer unwrapper) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BuilderBasedDeserializer(BuilderBasedDeserializer src, ObjectIdReader oir) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BuilderBasedDeserializer(BuilderBasedDeserializer src, Set<String> ignorableProps) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public BuilderBasedDeserializer(BuilderBasedDeserializer src, BeanPropertyMap props) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public BeanDeserializerBase withObjectIdReader(ObjectIdReader oir) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public BeanDeserializerBase withIgnorableProperties(Set<String> ignorableProps) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    protected BeanDeserializerBase asArrayDeserializer() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* JsonDeserializer implementation\n    /**********************************************************\n     */\n\n    protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n            throws IOException\n    {\n        // As per [databind#777], allow returning builder itself\n        if (null == _buildMethod) {\n         //The specific code has been omitted, but there is no error\n        }\n        try {\n            return _buildMethod.getMember().invoke(builder);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Main deserialization method for bean-based objects (POJOs).\n     */\n    @Override\n    public final Object deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n\n        // common case first:\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }\n\n    /**\n     * Secondary deserialization method, called in cases where POJO\n     * instance is created as part of deserialization, potentially\n     * after collecting some or all of the properties to set.\n     */\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt,\n    \t\tObject builder)\n        throws IOException\n    {\n        /* Important: we call separate method which does NOT call\n         * 'finishBuild()', to avoid problems with recursion\n         */\n        return finishBuild(ctxt, _deserialize(p, ctxt, builder));\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */\n\n    protected final Object _deserialize(JsonParser p,\n            DeserializationContext ctxt, Object builder)\n        throws IOException, JsonProcessingException\n    {\n        if (_injectables != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_unwrappedPropertyHandler != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_externalTypeIdHandler != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_needViewProcesing) {\n         //The specific code has been omitted, but there is no error\n        }\n        JsonToken t = p.getCurrentToken();\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n        return builder;\n    }\n\n    /**\n     * Streamlined version that is only used when no \"special\"\n     * features are enabled.\n     */\n    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException, JsonProcessingException\n    {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            }\n        }\n        return bean;\n    }\n\n    /**\n     * General version used when handling needs more advanced\n     * features.\n     */\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_nonStandardCreation) {\n         //The specific code has been omitted, but there is no error\n        }\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        if (_injectables != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_needViewProcesing) {\n         //The specific code has been omitted, but there is no error\n        }\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }\n\n    /**\n     * Method called to deserialize bean using \"property-based creator\":\n     * this means that a non-default constructor or factory method is\n     * called, and then possibly other setters. The trick is that\n     * values for creator method need to be buffered, first; and\n     * due to non-guaranteed ordering possibly some other properties\n     * as well.\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n            final DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // As per [JACKSON-313], things marked as ignorable should not be\n            // passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (unknown != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserializing when we have to consider an active View\n    /**********************************************************\n     */\n\n    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have \"unwrapped\" values\n    /**********************************************************\n     */\n\n    /**\n     * Method called when there are declared \"unwrapped\" properties\n     * which need special handling\n     */\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_delegateDeserializer != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (_propertyBasedCreator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n\n        if (_injectables != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt, Object bean)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }\n\n    /*\n    /**********************************************************\n    /* Handling for cases where we have property/-ies with\n    /* external type id\n    /**********************************************************\n     */\n\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_propertyBasedCreator != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n    protected Object deserializeWithExternalTypeId(JsonParser p,\n    \t\tDeserializationContext ctxt, Object bean)\n        throws IOException, JsonProcessingException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n                // Unknown: let's call handler method\n                handleUnknownProperty(p, ctxt, bean, propName);\n            }\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }\n\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // !!! 04-Mar-2012, TODO: Need to fix -- will not work as is...\n        throw new IllegalStateException(\"Deserialization with Builder, External type id, @JsonCreator not yet implemented\");\n    }\n}"}