{"GroupImpl": "public class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Set getPrefixes() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Set getTriggers() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n         //The specific code has been omitted, but there is no error\n        }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (commandLine.looksLikeOption(arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n         //The specific code has been omitted, but there is no error\n        }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n         //The specific code has been omitted, but there is no error\n        }\n\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // too few option\n        if (present < minimum) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public String getDescription() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Option findOption(final String trigger) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public int getMinimum() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public int getMaximum() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean isRequired() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ReverseStringComparator": "class ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}