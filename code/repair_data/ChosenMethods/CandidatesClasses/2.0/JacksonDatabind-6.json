{"StdDateFormat": "public class StdDateFormat\n    extends DateFormat\n{\n    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n     * permissive. The two don't mix, need to write a better one.\n     */\n    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n    //   not really robust\n\n    /**\n     * Defines a commonly used date format that conforms\n     * to ISO-8601 date formatting standard, when it includes basic undecorated\n     * timezone definition\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n\n    /**\n     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n     * (or \"GMT\")\n     */\n    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    /**\n     * ISO-8601 with just the Date part, no time\n     */\n    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n\n    /**\n     * This constant defines the date format specified by\n     * RFC 1123 / RFC 822.\n     */\n    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n\n    /**\n     * For error messages we'll also need a list of all formats.\n     */\n    protected final static String[] ALL_FORMATS = new String[] {\n        DATE_FORMAT_STR_ISO8601,\n        DATE_FORMAT_STR_ISO8601_Z,\n        DATE_FORMAT_STR_RFC1123,\n        DATE_FORMAT_STR_PLAIN\n    };\n\n    /**\n     * By default we use GMT for everything.\n     */\n    private final static TimeZone DEFAULT_TIMEZONE;\n    static {\n        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n    }\n\n    private final static Locale DEFAULT_LOCALE = Locale.US;\n    \n    protected final static DateFormat DATE_FORMAT_RFC1123;\n\n    protected final static DateFormat DATE_FORMAT_ISO8601;\n    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n\n    protected final static DateFormat DATE_FORMAT_PLAIN;\n\n    /* Let's construct \"blueprint\" date format instances: can not be used\n     * as is, due to thread-safety issues, but can be used for constructing\n     * actual instances more cheaply (avoids re-parsing).\n     */\n    static {\n        /* Another important thing: let's force use of GMT for\n         * baseline DataFormat objects\n         */\n\n        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n    }\n    \n    /**\n     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n     */\n    public final static StdDateFormat instance = new StdDateFormat();\n    \n    /**\n     * Caller may want to explicitly override timezone to use; if so,\n     * we will have non-null value here.\n     */\n    protected transient TimeZone _timezone;\n\n    protected final Locale _locale;\n    \n    protected transient DateFormat _formatRFC1123;\n    protected transient DateFormat _formatISO8601;\n    protected transient DateFormat _formatISO8601_z;\n    protected transient DateFormat _formatPlain;\n\n    /*\n    /**********************************************************\n    /* Life cycle, accessing singleton \"standard\" formats\n    /**********************************************************\n     */\n\n    public StdDateFormat() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.4, use variant that also takes Locale\n     */\n    @Deprecated // since 2.4\n    public StdDateFormat(TimeZone tz) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    public StdDateFormat(TimeZone tz, Locale loc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public static TimeZone getDefaultTimeZone() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method used for creating a new instance with specified timezone;\n     * if no timezone specified, defaults to the default timezone (UTC).\n     */\n    public StdDateFormat withTimeZone(TimeZone tz) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public StdDateFormat withLocale(Locale loc) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public StdDateFormat clone() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintISO8601Format() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getISO8601Format(TimeZone tz) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specified timezone and can handle simple ISO-8601\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for getting the globally shared DateFormat instance\n     * that uses GMT timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @deprecated Since 2.4 not to be used.\n     */\n    @Deprecated\n    public static DateFormat getBlueprintRFC1123Format() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a non-shared DateFormat instance\n     * that uses specific timezone and can handle RFC-1123\n     * compliant date format.\n     * \n     * @since 2.4\n     */\n    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.4; use variant that takes Locale\n     */\n    @Deprecated\n    public static DateFormat getRFC1123Format(TimeZone tz) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    @Override\n    public void setTimeZone(TimeZone tz)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public Date parse(String dateStr) throws ParseException\n    {\n        dateStr = dateStr.trim();\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(dateStr, pos);\n        if (result != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (String f : ALL_FORMATS) {\n         //The specific code has been omitted, but there is no error\n        }\n        sb.append('\"');\n        throw new ParseException\n            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n                           dateStr, sb.toString()), pos.getErrorIndex());\n    }\n\n    @Override\n    public Date parse(String dateStr, ParsePosition pos)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Std overrides\n    /**********************************************************\n     */\n    \n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Overridable helper method used to figure out which of supported\n     * formats is the likeliest match.\n     */\n    protected boolean looksLikeISO8601(String dateStr)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private final static boolean hasTimeZone(String str)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n}"}