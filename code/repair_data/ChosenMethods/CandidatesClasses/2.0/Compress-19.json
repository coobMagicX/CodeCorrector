{"Zip64ExtendedInformationExtraField": "public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n\n    static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\n    private static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n        \"Zip64 extended information must contain\"\n        + \" both size values in the local file header.\";\n    private static final byte[] EMPTY = new byte[0];\n\n    private ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\n    private ZipLong diskStart;\n\n    /**\n     * Stored in {@link #parseFromCentralDirectoryData\n     * parseFromCentralDirectoryData} so it can be reused when ZipFile\n     * calls {@link #reparseCentralDirectoryData\n     * reparseCentralDirectoryData}.\n     *\n     * <p>Not used for anything else</p>\n     *\n     * @since 1.3\n     */\n    private byte[] rawCentralDirectoryData;\n\n    /**\n     * This constructor should only be used by the code that reads\n     * archives inside of Commons Compress.\n     */\n    public Zip64ExtendedInformationExtraField() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates an extra field based on the original and compressed size.\n     *\n     * @param size the entry's original size\n     * @param compressedSize the entry's compressed size\n     *\n     * @throws IllegalArgumentException if size or compressedSize is null\n     */\n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n                                              ZipEightByteInteger compressedSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Creates an extra field based on all four possible values.\n     *\n     * @param size the entry's original size\n     * @param compressedSize the entry's compressed size\n     *\n     * @throws IllegalArgumentException if size or compressedSize is null\n     */\n    public Zip64ExtendedInformationExtraField(ZipEightByteInteger size,\n                                              ZipEightByteInteger compressedSize,\n                                              ZipEightByteInteger relativeHeaderOffset,\n                                              ZipLong diskStart) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public ZipShort getHeaderId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public ZipShort getLocalFileDataLength() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public ZipShort getCentralDirectoryLength() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public byte[] getLocalFileDataData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public byte[] getCentralDirectoryData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public void parseFromLocalFileData(byte[] buffer, int offset, int length)\n        throws ZipException {\n        if (length == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (length < 2 * DWORD) {\n         //The specific code has been omitted, but there is no error\n        }\n        size = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        compressedSize = new ZipEightByteInteger(buffer, offset);\n        offset += DWORD;\n        int remaining = length - 2 * DWORD;\n        if (remaining >= DWORD) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (remaining >= WORD) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void parseFromCentralDirectoryData(byte[] buffer, int offset,\n                                              int length)\n        throws ZipException {\n        // store for processing in reparseCentralDirectoryData\n        rawCentralDirectoryData = new byte[length];\n        System.arraycopy(buffer, offset, rawCentralDirectoryData, 0, length);\n\n        // if there is no size information in here, we are screwed and\n        // can only hope things will get resolved by LFH data later\n        // But there are some cases that can be detected\n        // * all data is there\n        // * length == 24 -> both sizes and offset\n        // * length % 8 == 4 -> at least we can identify the diskStart field\n        if (length >= 3 * DWORD + WORD) {\n         //The specific code has been omitted, but there is no error\n        } else if (length == 3 * DWORD) {\n         //The specific code has been omitted, but there is no error\n        } else if (length % DWORD == WORD) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public ZipEightByteInteger getSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public void setSize(ZipEightByteInteger size) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The compressed size stored in this extra field.\n     */\n    public ZipEightByteInteger getCompressedSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The uncompressed size stored in this extra field.\n     */\n    public void setCompressedSize(ZipEightByteInteger compressedSize) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The relative header offset stored in this extra field.\n     */\n    public ZipEightByteInteger getRelativeHeaderOffset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The relative header offset stored in this extra field.\n     */\n    public void setRelativeHeaderOffset(ZipEightByteInteger rho) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The disk start number stored in this extra field.\n     */\n    public ZipLong getDiskStartNumber() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The disk start number stored in this extra field.\n     */\n    public void setDiskStartNumber(ZipLong ds) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private int addSizes(byte[] data) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}