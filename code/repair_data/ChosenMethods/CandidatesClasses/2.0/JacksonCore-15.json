{"FilteringParserDelegate": "public class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public final int getCurrentTokenId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean hasCurrentToken() {\n         //The specific code has been omitted, but there is no error\n        }\n    @Override public boolean hasTokenId(int id) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public final boolean hasToken(JsonToken t) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override public boolean isExpectedStartArrayToken() {\n         //The specific code has been omitted, but there is no error\n        }\n    @Override public boolean isExpectedStartObjectToken() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public JsonLocation getCurrentLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n         //The specific code has been omitted, but there is no error\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonToken getLastClearedToken() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void overrideCurrentName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \t\t//if not scalar and ended successfully, then return null\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() {\n         //The specific code has been omitted, but there is no error\n        }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n         //The specific code has been omitted, but there is no error\n        }\n  \n}"}