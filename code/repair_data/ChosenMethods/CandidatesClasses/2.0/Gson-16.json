{"$Gson$Types": "public final class $Gson$Types {\n  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n\n  private $Gson$Types() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type.\n   */\n  public static ParameterizedType newParameterizedTypeWithOwner(\n      Type ownerType, Type rawType, Type... typeArguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type.\n   */\n  public static GenericArrayType arrayOf(Type componentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n   */\n  public static WildcardType subtypeOf(Type bound) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}.\n   */\n  public static WildcardType supertypeOf(Type bound) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}.\n   */\n  public static Type canonicalize(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static Class<?> getRawType(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean equal(Object a, Object b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if {@code a} and {@code b} are equal.\n   */\n  public static boolean equals(Type a, Type b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static int hashCodeOrZero(Object o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static String typeToString(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n   */\n  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this.\n   */\n  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array.\n   */\n  public static Type getArrayComponentType(Type array) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection.\n   */\n  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively.\n   */\n  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static int indexOf(Object[] array, Object toFind) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns the declaring class of {\n         //The specific code has been omitted, but there is no error\n        }, or {@code null} if it was not declared by\n   * a class.\n   */\n  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static void checkNotPrimitive(Type type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type[] getActualTypeArguments() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type getRawType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type getOwnerType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type getGenericComponentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean equals(Object o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static final long serialVersionUID = 0;\n  }\n\n  /**\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the Java 6 language needs - at most one\n   * bound. If a lower bound is set, the upper bound must be Object.class.\n   */\n  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type[] getUpperBounds() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type[] getLowerBounds() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static final long serialVersionUID = 0;\n  }\n}", "ParameterizedTypeImpl": "  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n    private final Type ownerType;\n    private final Type rawType;\n    private final Type[] typeArguments;\n\n    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type[] getActualTypeArguments() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type getRawType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type getOwnerType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static final long serialVersionUID = 0;\n  }", "GenericArrayTypeImpl": "  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n    private final Type componentType;\n\n    public GenericArrayTypeImpl(Type componentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type getGenericComponentType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean equals(Object o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static final long serialVersionUID = 0;\n  }", "WildcardTypeImpl": "  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n    private final Type upperBound;\n    private final Type lowerBound;\n\n    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type[] getUpperBounds() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Type[] getLowerBounds() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static final long serialVersionUID = 0;\n  }"}