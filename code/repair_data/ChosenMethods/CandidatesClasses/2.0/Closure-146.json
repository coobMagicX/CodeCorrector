{"JSType": "public abstract class JSType implements Serializable {\n  private static final long serialVersionUID = 1L;\n\n  private boolean resolved = false;\n  private JSType resolveResult = null;\n\n  public static final String UNKNOWN_NAME =\n      \"Unknown class name\";\n\n  public static final String NOT_A_CLASS =\n      \"Not declared as a constructor\";\n\n  public static final String NOT_A_TYPE =\n      \"Not declared as a type name\";\n\n  public static final String EMPTY_TYPE_COMPONENT =\n      \"Named type with empty name component\";\n\n  /**\n   * Total ordering on types based on their textual representation.\n   * This is used to have a deterministic output of the toString\n   * method of the union type since this output is used in tests.\n   */\n  static final Comparator<JSType> ALPHA = new Comparator<JSType>() {\n    public int compare(JSType t1, JSType t2) {\n         //The specific code has been omitted, but there is no error\n        }\n  };\n\n  // A flag set on enum definition tree nodes\n  public static final int ENUMDECL = 1;\n  public static final int NOT_ENUMDECL = 0;\n\n  final JSTypeRegistry registry;\n\n  JSType(JSTypeRegistry registry) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Utility method for less verbose code.\n   */\n  JSType getNativeType(JSTypeNative typeId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the docInfo for this type. By default, documentation cannot be\n   * attached to arbitrary types. This must be overridden for\n   * programmer-defined types.\n   */\n  public JSDocInfo getJSDocInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If we see a type name without braces, it might be legacy jsdoc.\n   * So we shouldn't emit warnings about it. This method is how we skip\n   * those warnings.\n   */\n  void forgiveUnknownNames() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isNoType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isNoObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public final boolean isEmptyType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isNumberObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isNumberValueType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Whether this is the prototype of a function. */\n  public boolean isFunctionPrototypeType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isStringObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean isTheObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isStringValueType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether the type is a string (value or Object).\n   * @return {@code this &lt;: (String, string)}\n   */\n  public final boolean isString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether the type is a number (value or Object).\n   * @return {@code this &lt;: (Number, number)}\n   */\n  public final boolean isNumber() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isArrayType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isBooleanObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isBooleanValueType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isRegexpType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isDateType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isNullType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isVoidType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isAllType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isCheckedUnknownType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isUnionType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isFunctionType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isEnumElementType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isEnumType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean isNamedType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isRecordType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public boolean isTemplateType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether this type is an {@code Object}, or any subtype thereof.\n   * @return {@code this &lt;: Object}\n   */\n  public boolean isObject() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether this type is a {@link FunctionType} that is a constructor or a\n   * named type that points to such a type.\n   */\n  public boolean isConstructor() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether this type is a nominal type (a named instance object or\n   * a named enum).\n   */\n  public boolean isNominalType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether this type is an Instance object of some constructor.\n   */\n  public boolean isInstanceType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether this type is a {@link FunctionType} that is an interface or a named\n   * type that points to such a type.\n   */\n  public boolean isInterface() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether this type is a {@link FunctionType} that is an ordinary function or\n   * a named type that points to such a type.\n   */\n  public boolean isOrdinaryFunction() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks if two types are equivalent.\n   */\n  public boolean isEquivalentTo(JSType jsType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static boolean isEquivalent(JSType typeA, JSType typeB) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public boolean equals(Object jsType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in a\n   * 'Int32' context.  This context includes, for example, the operands of a\n   * bitwise or operator.  Since we do not currently support integer types,\n   * this is a synonym for {@code Number}.\n   */\n  public final boolean matchesInt32Context() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in a\n   * 'Uint32' context.  This context includes the right-hand operand of a shift\n   * operator.\n   */\n  public final boolean matchesUint32Context() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in a\n   * numeric context, such as an operand of a multiply operator.\n   */\n  public boolean matchesNumberContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in a\n   * {@code String} context, such as an operand of a string concat (+) operator.\n   *\n   * All types have at least the potential for converting to {@code String}.\n   * When we add externally defined types, such as a browser OM, we may choose\n   * to add types that do not automatically convert to {@code String}.\n   */\n  public boolean matchesStringContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can appear in an\n   * {@code Object} context, such as the expression in a with statement.\n   *\n   * Most types we will encounter, except notably {@code null}, have at least\n   * the potential for converting to {@code Object}.  Host defined objects can\n   * get peculiar.\n   */\n  public boolean matchesObjectContext() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Coerces this type to an Object type, then gets the type of the property\n   * whose name is given.\n   *\n   * Unlike {@link ObjectType#getPropertyType}, returns null if the property\n   * is not found.\n   *\n   * @return The property's type. {@code null} if the current type cannot\n   *     have properties, or if the type is not found.\n   */\n  public JSType findPropertyType(String propertyName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This predicate is used to test whether a given type can be used as the\n   * 'function' in a function call.\n   *\n   * @return {@code true} if this type might be callable.\n   */\n  public boolean canBeCalled() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether values of {@code this} type can be safely assigned\n   * to values of {@code that} type.<p>\n   *\n   * The default implementation verifies that {@code this} is a subtype\n   * of {@code that}.<p>\n   */\n  public boolean canAssignTo(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the type to which this type auto-boxes.\n   *\n   * @return the auto-boxed type or {@code null} if this type does not auto-box\n   */\n  public JSType autoboxesTo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the type to which this type unboxes.\n   *\n   * @return the unboxed type or {@code null} if this type does not unbox.\n   */\n  public JSType unboxesTo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Casts this to an ObjectType, or returns null if this is not an ObjectType.\n   *\n   * Does not change the underlying JS type. If you want to simulate JS\n   * autoboxing or dereferencing, you should use autoboxesTo() or dereference().\n   * Those methods may change the underlying JS type.\n   */\n  public ObjectType toObjectType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Dereference a type for property access.\n   *\n   * Autoboxes the type, filters null/undefined, and returns the result\n   * iff it's an object.\n   */\n  public final ObjectType dereference() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether {@code this} and {@code that} are meaningfully\n   * comparable. By meaningfully, we mean compatible types that do not lead\n   * to step 22 of the definition of the Abstract Equality Comparison\n   * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>\n   */\n  public final boolean canTestForEqualityWith(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Compares {@code this} and {@code that}.\n   * @return <ul>\n   * <li>{@link TernaryValue#TRUE} if the comparison of values of\n   *   {@code this} type and {@code that} always succeed (such as\n   *   {@code undefined} compared to {@code null})</li>\n   * <li>{@link TernaryValue#FALSE} if the comparison of values of\n   *   {@code this} type and {@code that} always fails (such as\n   *   {@code undefined} compared to {@code number})</li>\n   * <li>{@link TernaryValue#UNKNOWN} if the comparison can succeed or\n   *   fail depending on the concrete values</li>\n   * </ul>\n   */\n  public TernaryValue testForEquality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether {@code this} and {@code that} are meaningfully\n   * comparable using shallow comparison. By meaningfully, we mean compatible\n   * types that are not rejected by step 1 of the definition of the Strict\n   * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the\n   * ECMA-262 specification.<p>\n   */\n  public final boolean canTestForShallowEqualityWith(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Tests whether this type is nullable.\n   */\n  public boolean isNullable() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the least supertype of {@code this} and {@code that}.\n   * The least supertype is the join (&#8744;) or supremum of both types in the\n   * type lattice.<p>\n   * Examples:\n   * <ul>\n   * <li>{@code number &#8744; *} = {@code *}</li>\n   * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>\n   * <li>{@code Number &#8744; Object} = {@code Object}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   */\n  public JSType getLeastSupertype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A generic implementation meant to be used as a helper for common\n   * getLeastSupertype implementations.\n   */\n  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the greatest subtype of {@code this} and {@code that}.\n   * The greatest subtype is the meet (&#8743;) or infimum of both types in the\n   * type lattice.<p>\n   * Examples\n   * <ul>\n   * <li>{@code Number &#8743; Any} = {@code Any}</li>\n   * <li>{@code number &#8743; Object} = {@code Any}</li>\n   * <li>{@code Number &#8743; Object} = {@code Number}</li>\n   * </ul>\n   * @return {@code this &#8744; that}\n   */\n  public JSType getGreatestSubtype(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A generic implementation meant to be used as a helper for common\n   * getGreatestSubtype implementations.\n   */\n  static JSType getGreatestSubtype(JSType thisType, JSType thatType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.\n   */\n  public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the set of possible outcomes of the {@code ToBoolean} predicate\n   * for this type. The {@code ToBoolean} predicate is defined by the ECMA-262\n   * standard, 3<sup>rd</sup> edition. Its behavior for simple types can be\n   * summarized by the following table:\n   * <table>\n   * <tr><th>type</th><th>result</th></tr>\n   * <tr><td>{@code undefined}</td><td>{false}</td></tr>\n   * <tr><td>{@code null}</td><td>{false}</td></tr>\n   * <tr><td>{@code boolean}</td><td>{true, false}</td></tr>\n   * <tr><td>{@code number}</td><td>{true, false}</td></tr>\n   * <tr><td>{@code string}</td><td>{true, false}</td></tr>\n   * <tr><td>{@code Object}</td><td>{true}</td></tr>\n   * </table>\n   * @return the set of boolean literals for this type\n   */\n  public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types if equality\n   * is observed. If a value {@code v1} of type {@code null} is equal to a value\n   * {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code null} and the type of {@code v2} is\n   * {@code undefined}.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderEquality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types under shallow\n   * equality.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}.\n   */\n  public TypePair getTypesUnderShallowEquality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types under\n   * shallow inequality.\n   *\n   * @return A pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderShallowInequality(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If this is a union type, returns a union type that does not include\n   * the null or undefined type.\n   */\n  public JSType restrictByNotNullOrUndefined() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Checks whether {@code this} is a subtype of {@code that}.<p>\n   *\n   * Subtyping rules:\n   * <ul>\n   * <li>(unknown) &mdash; every type is a subtype of the Unknown type.</li>\n   * <li>(no) &mdash; the No type is a subtype of every type.</li>\n   * <li>(no-object) &mdash; the NoObject type is a subtype of every object\n   * type (i.e. subtypes of the Object type).</li>\n   * <li>(ref) &mdash; a type is a subtype of itself.</li>\n   * <li>(union-l) &mdash; A union type is a subtype of a type U if all the\n   * union type's constituents are a subtype of U. Formally<br>\n   * {@code (T<sub>1</sub>, &hellip;, T<sub>n</sub>) &lt;: U} if and only\n   * {@code T<sub>k</sub> &lt;: U} for all {@code k &isin; 1..n}.</li>\n   * <li>(union-r) &mdash; A type U is a subtype of a union type if it is a\n   * subtype of one of the union type's constituents. Formally<br>\n   * {@code U &lt;: (T<sub>1</sub>, &hellip;, T<sub>n</sub>)} if and only\n   * if {@code U &lt;: T<sub>k</sub>} for some index {@code k}.</li>\n   * <li>(objects) &mdash; an Object {@code O<sub>1</sub>} is a subtype\n   * of an object {@code O<sub>2</sub>} if it has more properties\n   * than {@code O<sub>2</sub>} and all common properties are\n   * pairwise subtypes.</li>\n   * </ul>\n   *\n   * @return {@code this &lt;: that}\n   */\n  public abstract boolean isSubtype(JSType that);\n\n  /**\n   * Whether this type is meaningfully different from {@code that} type.\n   * This is a trickier check than pure equality, because it has to properly\n   * handle unknown types.\n   *\n   * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown\n   *     unknowns</a>\n   */\n  public boolean differsFrom(JSType that) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A generic implementation meant to be used as a helper for common subtyping\n   * cases.\n   */\n  static boolean isSubtype(JSType thisType, JSType thatType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Visit this type with the given visitor.\n   * @see com.google.javascript.rhino.jstype.Visitor\n   * @return the value returned by the visitor\n   */\n  public abstract <T> T visit(Visitor<T> visitor);\n\n  /**\n   * Force this type to resolve, even if the registry is in a lazy\n   * resolving mode.\n   * @see #resolve\n   */\n  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see #resolve\n   */\n  abstract JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope);\n\n  void setResolvedTypeInternal(JSType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Whether the type has been resolved. */\n  public final boolean isResolved() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Clears the resolved field. */\n  public final void clearResolved() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A null-safe resolve.\n   * @see #resolve\n   */\n  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static class TypePair {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A hash code function for diagnosing complicated issues\n   * around type-identity.\n   */\n  public String toDebugHashCodeString() {\n         //The specific code has been omitted, but there is no error\n        }\n}", "TypePair": "  public static class TypePair {\n         //The specific code has been omitted, but there is no error\n        }"}