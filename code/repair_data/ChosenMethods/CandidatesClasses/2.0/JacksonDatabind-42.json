{"FromStringDeserializer": "public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n{\n    public static Class<?>[] types() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Deserializer implementations\n    /**********************************************************\n     */\n    \n    protected FromStringDeserializer(Class<?> vc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Factory method for trying to find a deserializer for one of supported\n     * types that have simple from-String serialization.\n     */\n    public static Std findDeserializer(Class<?> rawType)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Deserializer implementations\n    /**********************************************************\n     */\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // Issue#381\n        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n            jp.nextToken();\n            final T value = deserialize(jp, ctxt);\n            if (jp.nextToken() != JsonToken.END_ARRAY) {\n                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                                \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n            }\n            return value;\n        }\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = jp.getValueAsString();\n        if (text != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = jp.getEmbeddedObject();\n            if (ob == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        throw ctxt.mappingException(_valueClass);\n    }\n        \n    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n\n    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n        // default impl: error out\n        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type %s into %s\",\n                ob.getClass().getName(), _valueClass.getName());\n    }\n\n    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* A general-purpose implementation\n    /**********************************************************\n     */\n\n    /**\n     * \"Chameleon\" deserializer that works on simple types that are deserialized\n     * from a simple String.\n     * \n     * @since 2.4\n     */\n    public static class Std extends FromStringDeserializer<Object>\n    {\n        private static final long serialVersionUID = 1;\n\n        public final static int STD_FILE = 1;\n        public final static int STD_URL = 2;\n        public final static int STD_URI = 3;\n        public final static int STD_CLASS = 4;\n        public final static int STD_JAVA_TYPE = 5;\n        public final static int STD_CURRENCY = 6;\n        public final static int STD_PATTERN = 7;\n        public final static int STD_LOCALE = 8;\n        public final static int STD_CHARSET = 9;\n        public final static int STD_TIME_ZONE = 10;\n        public final static int STD_INET_ADDRESS = 11;\n        public final static int STD_INET_SOCKET_ADDRESS = 12;\n\n        protected final int _kind;\n        \n        protected Std(Class<?> valueType, int kind) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n         //The specific code has been omitted, but there is no error\n        }\n            throw new IllegalArgumentException();\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            // As per [databind#398], URI requires special handling\n            if (_kind == STD_URI) {\n         //The specific code has been omitted, but there is no error\n        }\n            // As per [databind#1123], Locale too\n            return super._deserializeFromEmptyString();\n        }\n    }\n}", "Std": "    public static class Std extends FromStringDeserializer<Object>\n    {\n        private static final long serialVersionUID = 1;\n\n        public final static int STD_FILE = 1;\n        public final static int STD_URL = 2;\n        public final static int STD_URI = 3;\n        public final static int STD_CLASS = 4;\n        public final static int STD_JAVA_TYPE = 5;\n        public final static int STD_CURRENCY = 6;\n        public final static int STD_PATTERN = 7;\n        public final static int STD_LOCALE = 8;\n        public final static int STD_CHARSET = 9;\n        public final static int STD_TIME_ZONE = 10;\n        public final static int STD_INET_ADDRESS = 11;\n        public final static int STD_INET_SOCKET_ADDRESS = 12;\n\n        protected final int _kind;\n        \n        protected Std(Class<?> valueType, int kind) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        @Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n         //The specific code has been omitted, but there is no error\n        }\n            throw new IllegalArgumentException();\n        }\n\n        @Override\n        protected Object _deserializeFromEmptyString() throws IOException {\n            // As per [databind#398], URI requires special handling\n            if (_kind == STD_URI) {\n         //The specific code has been omitted, but there is no error\n        }\n            // As per [databind#1123], Locale too\n            return super._deserializeFromEmptyString();\n        }\n    }"}