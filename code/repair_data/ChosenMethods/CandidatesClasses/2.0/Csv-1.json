{"ExtendedBufferedReader": "class ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n         //The specific code has been omitted, but there is no error\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n         //The specific code has been omitted, but there is no error\n        } else if (len == -1) {\n         //The specific code has been omitted, but there is no error\n        }\n        \n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).\n     * This method should only be called when processing a comment, otherwise\n     * information can be lost.\n     * <p>\n     * Increments  {@link #lineCounter}\n     * <p>\n     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, \n     * otherwise to last character on the line (won't be CR or LF) \n     * \n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        String line = super.readLine();\n\n        if (line != null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So\n     * the next call to {@link #read()} will still return this value.\n     * \n     * @return the next character\n     * \n     * @throws IOException if there is an error in reading\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    /**\n     * Returns the nof line read\n     *\n     * @return the current-line-number (or -1)\n     */\n    int getLineNumber() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}