{"TarArchiveEntry": "public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n    private static final TarArchiveEntry[] EMPTY_TAR_ARCHIVE_ENTRIES = new TarArchiveEntry[0];\n\n    /** The entry's name. */\n    private String name = \"\";\n\n    /** Whether to enforce leading slashes on the name */\n    private boolean preserveLeadingSlashes;\n\n    /** The entry's permission mode. */\n    private int mode;\n\n    /** The entry's user id. */\n    private long userId = 0;\n\n    /** The entry's group id. */\n    private long groupId = 0;\n\n    /** The entry's size. */\n    private long size = 0;\n\n    /** The entry's modification time. */\n    private long modTime;\n\n    /** If the header checksum is reasonably correct. */\n    private boolean checkSumOK;\n\n    /** The entry's link flag. */\n    private byte linkFlag;\n\n    /** The entry's link name. */\n    private String linkName = \"\";\n\n    /** The entry's magic tag. */\n    private String magic = MAGIC_POSIX;\n    /** The version of the format */\n    private String version = VERSION_POSIX;\n\n    /** The entry's user name. */\n    private String userName;\n\n    /** The entry's group name. */\n    private String groupName = \"\";\n\n    /** The entry's major device number. */\n    private int devMajor = 0;\n\n    /** The entry's minor device number. */\n    private int devMinor = 0;\n\n    /** If an extension sparse header follows. */\n    private boolean isExtended;\n\n    /** The entry's real size in case of a sparse file. */\n    private long realSize;\n\n    /** is this entry a GNU sparse entry using one of the PAX formats? */\n    private boolean paxGNUSparse;\n\n    /** is this entry a star sparse entry using the PAX header? */\n    private boolean starSparse;\n\n    /** The entry's file reference */\n    private final File file;\n\n    /** Maximum length of a user's name in the tar file */\n    public static final int MAX_NAMELEN = 31;\n\n    /** Default permissions bits for directories */\n    public static final int DEFAULT_DIR_MODE = 040755;\n\n    /** Default permissions bits for files */\n    public static final int DEFAULT_FILE_MODE = 0100644;\n\n    /** Convert millis to seconds */\n    public static final int MILLIS_PER_SECOND = 1000;\n\n    /**\n     * Construct an empty entry and prepares the header values.\n     */\n    private TarArchiveEntry() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry with only a name. This allows the programmer\n     * to construct the entry's header \"by hand\". File is set to null.\n     *\n     * @param name the entry name\n     */\n    public TarArchiveEntry(final String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry with only a name. This allows the programmer\n     * to construct the entry's header \"by hand\". File is set to null.\n     *\n     * @param name the entry name\n     * @param preserveLeadingSlashes whether to allow leading slashes\n     * in the name.\n     *\n     * @since 1.1\n     */\n    public TarArchiveEntry(String name, final boolean preserveLeadingSlashes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry with a name and a link flag.\n     *\n     * @param name the entry name\n     * @param linkFlag the entry link flag.\n     */\n    public TarArchiveEntry(final String name, final byte linkFlag) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry with a name and a link flag.\n     *\n     * @param name the entry name\n     * @param linkFlag the entry link flag.\n     * @param preserveLeadingSlashes whether to allow leading slashes\n     * in the name.\n     *\n     * @since 1.5\n     */\n    public TarArchiveEntry(final String name, final byte linkFlag, final boolean preserveLeadingSlashes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry for a file. File is set to file, and the\n     * header is constructed from information from the file.\n     * The name is set from the normalized file path.\n     *\n     * @param file The file that the entry represents.\n     */\n    public TarArchiveEntry(final File file) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry for a file. File is set to file, and the\n     * header is constructed from information from the file.\n     *\n     * @param file The file that the entry represents.\n     * @param fileName the name to be used for the entry.\n     */\n    public TarArchiveEntry(final File file, final String fileName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry from an archive's header bytes. File is set\n     * to null.\n     *\n     * @param headerBuf The header bytes from a tar archive entry.\n     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n     */\n    public TarArchiveEntry(final byte[] headerBuf) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Construct an entry from an archive's header bytes. File is set\n     * to null.\n     *\n     * @param headerBuf The header bytes from a tar archive entry.\n     * @param encoding encoding to use for file names\n     * @since 1.4\n     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n     * @throws IOException on error\n     */\n    public TarArchiveEntry(final byte[] headerBuf, final ZipEncoding encoding)\n        throws IOException {\n        this();\n        parseTarHeader(headerBuf, encoding);\n    }\n\n    /**\n     * Determine if the two entries are equal. Equality is determined\n     * by the header names being equal.\n     *\n     * @param it Entry to be checked for equality.\n     * @return True if the entries are equal.\n     */\n    public boolean equals(final TarArchiveEntry it) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determine if the two entries are equal. Equality is determined\n     * by the header names being equal.\n     *\n     * @param it Entry to be checked for equality.\n     * @return True if the entries are equal.\n     */\n    @Override\n    public boolean equals(final Object it) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Hashcodes are based on entry names.\n     *\n     * @return the entry hashcode\n     */\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determine if the given entry is a descendant of this entry.\n     * Descendancy is determined by the name of the descendant\n     * starting with this entry's name.\n     *\n     * @param desc Entry to be checked as a descendent of this.\n     * @return True if entry is a descendant of this.\n     */\n    public boolean isDescendent(final TarArchiveEntry desc) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's name.\n     *\n     * @return This entry's name.\n     */\n    @Override\n    public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's name.\n     *\n     * @param name This entry's new name.\n     */\n    public void setName(final String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set the mode for this entry\n     *\n     * @param mode the mode for this entry\n     */\n    public void setMode(final int mode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's link name.\n     *\n     * @return This entry's link name.\n     */\n    public String getLinkName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's link name.\n     *\n     * @param link the link name to use.\n     *\n     * @since 1.1\n     */\n    public void setLinkName(final String link) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's user id.\n     *\n     * @return This entry's user id.\n     * @deprecated use #getLongUserId instead as user ids can be\n     * bigger than {@link Integer#MAX_VALUE}\n     */\n    @Deprecated\n    public int getUserId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's user id.\n     *\n     * @param userId This entry's new user id.\n     */\n    public void setUserId(final int userId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's user id.\n     *\n     * @return This entry's user id.\n     * @since 1.10\n     */\n    public long getLongUserId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's user id.\n     *\n     * @param userId This entry's new user id.\n     * @since 1.10\n     */\n    public void setUserId(final long userId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's group id.\n     *\n     * @return This entry's group id.\n     * @deprecated use #getLongGroupId instead as group ids can be\n     * bigger than {@link Integer#MAX_VALUE}\n     */\n    @Deprecated\n    public int getGroupId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's group id.\n     *\n     * @param groupId This entry's new group id.\n     */\n    public void setGroupId(final int groupId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's group id.\n     *\n     * @since 1.10\n     * @return This entry's group id.\n     */\n    public long getLongGroupId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's group id.\n     *\n     * @since 1.10\n     * @param groupId This entry's new group id.\n     */\n    public void setGroupId(final long groupId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's user name.\n     *\n     * @return This entry's user name.\n     */\n    public String getUserName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's user name.\n     *\n     * @param userName This entry's new user name.\n     */\n    public void setUserName(final String userName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's group name.\n     *\n     * @return This entry's group name.\n     */\n    public String getGroupName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's group name.\n     *\n     * @param groupName This entry's new group name.\n     */\n    public void setGroupName(final String groupName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method to set this entry's group and user ids.\n     *\n     * @param userId This entry's new user id.\n     * @param groupId This entry's new group id.\n     */\n    public void setIds(final int userId, final int groupId) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Convenience method to set this entry's group and user names.\n     *\n     * @param userName This entry's new user name.\n     * @param groupName This entry's new group name.\n     */\n    public void setNames(final String userName, final String groupName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's modification time. The parameter passed\n     * to this method is in \"Java time\".\n     *\n     * @param time This entry's new modification time.\n     */\n    public void setModTime(final long time) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's modification time.\n     *\n     * @param time This entry's new modification time.\n     */\n    public void setModTime(final Date time) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's modification time.\n     *\n     * @return time This entry's new modification time.\n     */\n    public Date getModTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Date getLastModifiedDate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's checksum status.\n     *\n     * @return if the header checksum is reasonably correct\n     * @see TarUtils#verifyCheckSum(byte[])\n     * @since 1.5\n     */\n    public boolean isCheckSumOK() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's file.\n     *\n     * @return This entry's file.\n     */\n    public File getFile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's mode.\n     *\n     * @return This entry's mode.\n     */\n    public int getMode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's file size.\n     *\n     * @return This entry's file size.\n     */\n    @Override\n    public long getSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's file size.\n     *\n     * @param size This entry's new file size.\n     * @throws IllegalArgumentException if the size is &lt; 0.\n     */\n    public void setSize(final long size) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's major device number.\n     *\n     * @return This entry's major device number.\n     * @since 1.4\n     */\n    public int getDevMajor() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's major device number.\n     *\n     * @param devNo This entry's major device number.\n     * @throws IllegalArgumentException if the devNo is &lt; 0.\n     * @since 1.4\n     */\n    public void setDevMajor(final int devNo) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's minor device number.\n     *\n     * @return This entry's minor device number.\n     * @since 1.4\n     */\n    public int getDevMinor() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Set this entry's minor device number.\n     *\n     * @param devNo This entry's minor device number.\n     * @throws IllegalArgumentException if the devNo is &lt; 0.\n     * @since 1.4\n     */\n    public void setDevMinor(final int devNo) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicates in case of an oldgnu sparse file if an extension\n     * sparse header follows.\n     *\n     * @return true if an extension oldgnu sparse header follows.\n     */\n    public boolean isExtended() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get this entry's real file size in case of a sparse file.\n     *\n     * @return This entry's real file size.\n     */\n    public long getRealSize() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicate if this entry is a GNU sparse block.\n     *\n     * @return true if this is a sparse extension provided by GNU tar\n     */\n    public boolean isGNUSparse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicate if this entry is a GNU or star sparse block using the\n     * oldgnu format.\n     *\n     * @return true if this is a sparse extension provided by GNU tar or star\n     * @since 1.11\n     */\n    public boolean isOldGNUSparse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicate if this entry is a GNU sparse block using one of the\n     * PAX formats.\n     *\n     * @return true if this is a sparse extension provided by GNU tar\n     * @since 1.11\n     */\n    public boolean isPaxGNUSparse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicate if this entry is a star sparse block using PAX headers.\n     *\n     * @return true if this is a sparse extension provided by star\n     * @since 1.11\n     */\n    public boolean isStarSparse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicate if this entry is a GNU long linkname block\n     *\n     * @return true if this is a long name extension provided by GNU tar\n     */\n    public boolean isGNULongLinkEntry() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Indicate if this entry is a GNU long name block\n     *\n     * @return true if this is a long name extension provided by GNU tar\n     */\n    public boolean isGNULongNameEntry() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a link entry.\n     *\n     * @since 1.2\n     * @return whether this is a link entry\n     */\n    public boolean isLink() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a character device entry.\n     *\n     * @since 1.2\n     * @return whether this is a character device\n     */\n    public boolean isCharacterDevice() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a block device entry.\n     *\n     * @since 1.2\n     * @return whether this is a block device\n     */\n    public boolean isBlockDevice() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check if this is a FIFO (pipe) entry.\n     *\n     * @since 1.2\n     * @return whether this is a FIFO entry\n     */\n    public boolean isFIFO() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Check whether this is a sparse entry.\n     *\n     * @return whether this is a sparse entry\n     * @since 1.11\n     */\n    public boolean isSparse() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If this entry represents a file, and the file is a directory, return\n     * an array of TarEntries for this entry's children.\n     *\n     * @return An array of TarEntry's for this entry's children.\n     */\n    public TarArchiveEntry[] getDirectoryEntries() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Write an entry's header information to a header buffer.\n     *\n     * <p>This method does not use the star/GNU tar/BSD tar extensions.</p>\n     *\n     * @param outbuf The tar entry header buffer to fill in.\n     */\n    public void writeEntryHeader(final byte[] outbuf) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Write an entry's header information to a header buffer.\n     *\n     * @param outbuf The tar entry header buffer to fill in.\n     * @param encoding encoding to use when writing the file name.\n     * @param starMode whether to use the star/GNU tar/BSD tar\n     * extension for numeric fields if their value doesn't fit in the\n     * maximum size of standard tar archives\n     * @since 1.4\n     * @throws IOException on error\n     */\n    public void writeEntryHeader(final byte[] outbuf, final ZipEncoding encoding,\n                                 final boolean starMode) throws IOException {\n        int offset = 0;\n\n        offset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN,\n                                          encoding);\n        offset = writeEntryHeaderField(mode, outbuf, offset, MODELEN, starMode);\n        offset = writeEntryHeaderField(userId, outbuf, offset, UIDLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(groupId, outbuf, offset, GIDLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(size, outbuf, offset, SIZELEN, starMode);\n        offset = writeEntryHeaderField(modTime, outbuf, offset, MODTIMELEN,\n                                       starMode);\n\n        final int csOffset = offset;\n\n        for (int c = 0; c < CHKSUMLEN; ++c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        outbuf[offset++] = linkFlag;\n        offset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN,\n                                          encoding);\n        offset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\n        offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\n        offset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN,\n                                          encoding);\n        offset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN,\n                                          encoding);\n        offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,\n                                       starMode);\n        offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,\n                                       starMode);\n\n        while (offset < outbuf.length) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        final long chk = TarUtils.computeCheckSum(outbuf);\n\n        TarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n    }\n\n    private int writeEntryHeaderField(final long value, final byte[] outbuf, final int offset,\n                                      final int length, final boolean starMode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     * @throws IllegalArgumentException if any of the numeric fields have an invalid format\n     */\n    public void parseTarHeader(final byte[] header) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Parse an entry's header information from a header buffer.\n     *\n     * @param header The tar entry header buffer to get information from.\n     * @param encoding encoding to use for file names\n     * @since 1.4\n     * @throws IllegalArgumentException if any of the numeric fields\n     * have an invalid format\n     * @throws IOException on error\n     */\n    public void parseTarHeader(final byte[] header, final ZipEncoding encoding)\n        throws IOException {\n        parseTarHeader(header, encoding, false);\n    }\n\n    private void parseTarHeader(final byte[] header, final ZipEncoding encoding,\n                                final boolean oldStyle)\n        throws IOException {\n        int offset = 0;\n\n        name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n        offset += NAMELEN;\n        mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN);\n        offset += MODELEN;\n        userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN);\n        offset += UIDLEN;\n        groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n        offset += GIDLEN;\n        size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\n        offset += SIZELEN;\n        modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN);\n        offset += MODTIMELEN;\n        checkSumOK = TarUtils.verifyCheckSum(header);\n        offset += CHKSUMLEN;\n        linkFlag = header[offset++];\n        linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN)\n            : TarUtils.parseName(header, offset, NAMELEN, encoding);\n        offset += NAMELEN;\n        magic = TarUtils.parseName(header, offset, MAGICLEN);\n        offset += MAGICLEN;\n        version = TarUtils.parseName(header, offset, VERSIONLEN);\n        offset += VERSIONLEN;\n        userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN)\n            : TarUtils.parseName(header, offset, UNAMELEN, encoding);\n        offset += UNAMELEN;\n        groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN)\n            : TarUtils.parseName(header, offset, GNAMELEN, encoding);\n        offset += GNAMELEN;\n        devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n        offset += DEVLEN;\n        devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN);\n        offset += DEVLEN;\n\n        final int type = evaluateType(header);\n        switch (type) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Strips Windows' drive letter as well as any leading slashes,\n     * turns path separators into forward slahes.\n     */\n    private static String normalizeFileName(String fileName,\n                                            final boolean preserveLeadingSlashes) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Evaluate an entry's header format from a header buffer.\n     *\n     * @param header The tar entry header buffer to evaluate the format for.\n     * @return format type\n     */\n    private int evaluateType(final byte[] header) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void fillGNUSparse0xData(final Map<String, String> headers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void fillGNUSparse1xData(final Map<String, String> headers) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    void fillStarSparseData(final Map<String, String> headers) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}