{"ClassNameIdResolver": "public class ClassNameIdResolver\n    extends TypeIdResolverBase\n{\n    public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JsonTypeInfo.Id getMechanism() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void registerSubtype(Class<?> type, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public String idFromValue(Object value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public String idFromValueAndType(Object value, Class<?> type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n        return _typeFromId(id, context);\n    }\n\n    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n         //The specific code has been omitted, but there is no error\n        } catch (Exception e) {\n         //The specific code has been omitted, but there is no error\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n    \n    protected final String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public String getDescForKnownTypeIds() {\n         //The specific code has been omitted, but there is no error\n        }\n}"}