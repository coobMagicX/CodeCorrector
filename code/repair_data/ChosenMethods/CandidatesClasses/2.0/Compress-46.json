{"X5455_ExtendedTimestamp": "public class X5455_ExtendedTimestamp implements ZipExtraField, Cloneable, Serializable {\n    private static final ZipShort HEADER_ID = new ZipShort(0x5455);\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The bit set inside the flags by when the last modification time\n     * is present in this extra field.\n     */\n    public static final byte MODIFY_TIME_BIT = 1;\n    /**\n     * The bit set inside the flags by when the lasr access time is\n     * present in this extra field.\n     */\n    public static final byte ACCESS_TIME_BIT = 2;\n    /**\n     * The bit set inside the flags by when the original creation time\n     * is present in this extra field.\n     */\n    public static final byte CREATE_TIME_BIT = 4;\n\n    // The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n    // are ignored according to the current version of the spec (December 2012).\n    private byte flags;\n\n    // Note: even if bit1 and bit2 are set, the Central data will still not contain\n    // access/create fields:  only local data ever holds those!  This causes\n    // some of our implementation to look a little odd, with seemingly spurious\n    // != null and length checks.\n    private boolean bit0_modifyTimePresent;\n    private boolean bit1_accessTimePresent;\n    private boolean bit2_createTimePresent;\n\n    private ZipLong modifyTime;\n    private ZipLong accessTime;\n    private ZipLong createTime;\n\n    /**\n     * Constructor for X5455_ExtendedTimestamp.\n     */\n    public X5455_ExtendedTimestamp() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The Header-ID.\n     *\n     * @return the value for the header id for this extrafield\n     */\n    @Override\n    public ZipShort getHeaderId() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    @Override\n    public ZipShort getLocalFileDataLength() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Length of the extra field in the local file data - without\n     * Header-ID or length specifier.\n     *\n     * <p>For X5455 the central length is often smaller than the\n     * local length, because central cannot contain access or create\n     * timestamps.</p>\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */\n    @Override\n    public ZipShort getCentralDirectoryLength() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The actual data to put into local file data - without Header-ID\n     * or length specifier.\n     *\n     * @return get the data\n     */\n    @Override\n    public byte[] getLocalFileDataData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * The actual data to put into central directory data - without Header-ID\n     * or length specifier.\n     *\n     * @return the central directory data\n     */\n    @Override\n    public byte[] getCentralDirectoryData() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Populate data from this array as if it was in local file data.\n     *\n     * @param data   an array of bytes\n     * @param offset the start offset\n     * @param length the number of bytes in the array from offset\n     * @throws java.util.zip.ZipException on error\n     */\n    @Override\n    public void parseFromLocalFileData(\n            final byte[] data, int offset, final int length\n    ) throws ZipException {\n        reset();\n        final int len = offset + length;\n        setFlags(data[offset++]);\n        if (bit0_modifyTimePresent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // Notice the extra length check in case we are parsing the shorter\n        // central data field (for both access and create timestamps).\n        if (bit1_accessTimePresent && offset + 4 <= len) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (bit2_createTimePresent && offset + 4 <= len) {\n         //The specific code has been omitted, but there is no error\n        }\n    }\n\n    /**\n     * Doesn't do anything special since this class always uses the\n     * same parsing logic for both central directory and local file data.\n     */\n    @Override\n    public void parseFromCentralDirectoryData(\n            final byte[] buffer, final int offset, final int length\n    ) throws ZipException {\n        reset();\n        parseFromLocalFileData(buffer, offset, length);\n    }\n\n    /**\n     * Reset state back to newly constructed state.  Helps us make sure\n     * parse() calls always generate clean results.\n     */\n    private void reset() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Sets flags byte.  The flags byte tells us which of the\n     * three datestamp fields are present in the data:\n     * <pre>\n     * bit0 - modify time\n     * bit1 - access time\n     * bit2 - create time\n     * </pre>\n     * Only first 3 bits of flags are used according to the\n     * latest version of the spec (December 2012).\n     *\n     * @param flags flags byte indicating which of the\n     *              three datestamp fields are present.\n     */\n    public void setFlags(final byte flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets flags byte.  The flags byte tells us which of the\n     * three datestamp fields are present in the data:\n     * <pre>\n     * bit0 - modify time\n     * bit1 - access time\n     * bit2 - create time\n     * </pre>\n     * Only first 3 bits of flags are used according to the\n     * latest version of the spec (December 2012).\n     *\n     * @return flags byte indicating which of the\n     *         three datestamp fields are present.\n     */\n    public byte getFlags() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether bit0 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a modify timestamp in this particular zip entry.\n     *\n     * @return true if bit0 of the flags byte is set.\n     */\n    public boolean isBit0_modifyTimePresent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether bit1 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a \"last access\" timestamp in this particular zip entry.\n     *\n     * @return true if bit1 of the flags byte is set.\n     */\n    public boolean isBit1_accessTimePresent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns whether bit2 of the flags byte is set or not,\n     * which should correspond to the presence or absence of\n     * a create timestamp in this particular zip entry.\n     *\n     * @return true if bit2 of the flags byte is set.\n     */\n    public boolean isBit2_createTimePresent() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the modify time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     *\n     * @return modify time (seconds since epoch) or null.\n     */\n    public ZipLong getModifyTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the access time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     *\n     * @return access time (seconds since epoch) or null.\n     */\n    public ZipLong getAccessTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Returns the create time (seconds since epoch) of this zip entry\n     * as a ZipLong object, or null if no such timestamp exists in the\n     * zip entry.\n     * </p><p>\n     * Note: modern linux file systems (e.g., ext2)\n     * do not appear to store a \"create time\" value, and so\n     * it's usually omitted altogether in the zip extra\n     * field.  Perhaps other unix systems track this.\n     *\n     * @return create time (seconds since epoch) or null.\n     */\n    public ZipLong getCreateTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the modify time as a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     *\n     * @return modify time as java.util.Date or null.\n     */\n    public Date getModifyJavaTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns the access time as a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     *\n     * @return access time as java.util.Date or null.\n     */\n    public Date getAccessJavaTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static Date zipLongToDate(ZipLong unixTime) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Returns the create time as a a java.util.Date\n     * of this zip entry, or null if no such timestamp exists in the zip entry.\n     * The milliseconds are always zeroed out, since the underlying data\n     * offers only per-second precision.\n     * </p><p>\n     * Note: modern linux file systems (e.g., ext2)\n     * do not appear to store a \"create time\" value, and so\n     * it's usually omitted altogether in the zip extra\n     * field.  Perhaps other unix systems track this.\n     *\n     * @return create time as java.util.Date or null.\n     */\n    public Date getCreateJavaTime() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Sets the modify time (seconds since epoch) of this zip entry\n     * using a ZipLong object.\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the modify time (seconds per epoch)\n     */\n    public void setModifyTime(final ZipLong l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Sets the access time (seconds since epoch) of this zip entry\n     * using a ZipLong object\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the access time (seconds per epoch)\n     */\n    public void setAccessTime(final ZipLong l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Sets the create time (seconds since epoch) of this zip entry\n     * using a ZipLong object\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param l ZipLong of the create time (seconds per epoch)\n     */\n    public void setCreateTime(final ZipLong l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Sets the modify time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d modify time as java.util.Date\n     */\n    public void setModifyJavaTime(final Date d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Sets the access time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d access time as java.util.Date\n     */\n    public void setAccessJavaTime(final Date d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * <p>\n     * Sets the create time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d create time as java.util.Date\n     */\n    public void setCreateJavaTime(final Date d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Utility method converts java.util.Date (milliseconds since epoch)\n     * into a ZipLong (seconds since epoch).\n     * <p/>\n     * Also makes sure the converted ZipLong is not too big to fit\n     * in 32 unsigned bits.\n     *\n     * @param d java.util.Date to convert to ZipLong\n     * @return ZipLong\n     */\n    private static ZipLong dateToZipLong(final Date d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private static ZipLong unixTimeToZipLong(long l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Returns a String representation of this class useful for\n     * debugging purposes.\n     *\n     * @return A String representation of this class useful for\n     *         debugging purposes.\n     */\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n}"}