{"AsPropertyTypeDeserializer": "public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n{\n    private static final long serialVersionUID = 1L;\n\n    protected final As _inclusion;\n\n    /**\n     * @since 2.8\n     */\n    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, JavaType defaultImpl)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * @since 2.8\n     */\n    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n            String typePropertyName, boolean typeIdVisible, JavaType defaultImpl,\n            As inclusion)\n    {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public TypeDeserializer forProperty(BeanProperty prop) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    @Override\n    public As getTypeInclusion() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * This is the trickiest thing to handle, since property we are looking\n     * for may be anywhere...\n     */\n    @Override\n    @SuppressWarnings(\"resource\")\n    public Object deserializeTypedFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        \n        // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n         //The specific code has been omitted, but there is no error\n        } else if (/*t == JsonToken.START_ARRAY ||*/ t != JsonToken.FIELD_NAME) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Ok, let's try to find the property. But first, need token buffer...\n        TokenBuffer tb = null;\n\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String name = p.getCurrentName();\n            p.nextToken(); // to point to the value\n            if (name.equals(_typePropertyName)) { // gotcha!\n                return _deserializeTypedForId(p, ctxt, tb);\n            }\n            if (tb == null) {\n         //The specific code has been omitted, but there is no error\n        }\n            tb.writeFieldName(name);\n            tb.copyCurrentStructure(p);\n        }\n        return _deserializeTypedUsingDefaultImpl(p, ctxt, tb);\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedForId(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException\n    {\n        String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        if (_typeIdVisible) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (tb != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:\n        p.nextToken(); // to skip past String value\n        // deserializer should take care of closing END_OBJECT as well\n        return deser.deserialize(p, ctxt);\n    }\n    \n    // off-lined to keep main method lean and mean...\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        }\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null;\n    }\n\n    /* Also need to re-route \"unknown\" version. Need to think\n     * this through bit more in future, but for now this does address issue and has\n     * no negative side effects (at least within existing unit test suite).\n     */\n    @Override\n    public Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException {\n        /* Sometimes, however, we get an array wrapper; specifically\n         * when an array or list has been serialized with type information.\n         */\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromArray(p, ctxt);\n        }\n        return deserializeTypedFromObject(p, ctxt);\n    }    \n    \n    // These are fine from base class:\n    //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n    //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    \n}"}