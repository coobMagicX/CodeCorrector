{"AnnotationIntrospector": "public abstract class AnnotationIntrospector\n    implements Versioned, java.io.Serializable\n{\n    /*\n    /**********************************************************\n    /* Helper types\n    /**********************************************************\n     */\n\n    /**\n     * Value type used with managed and back references; contains type and\n     * logic name, used to link related references\n     */\n    public static class ReferenceProperty\n    {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method for accessing \"no operation\" implementation\n     * of introspector: instance that will never find any annotation-based\n     * configuration.\n     */\n    public static AnnotationIntrospector nopInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Access to possibly chained introspectors\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation returns a Singleton list with this introspector\n     * as contents.\n     * This usually works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     */\n    public Collection<AnnotationIntrospector> allIntrospectors() {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method that can be used to collect all \"real\" introspectors that\n     * this introspector contains, if any; or this introspector\n     * if it is not a container. Used to get access to all container\n     * introspectors in their priority order.\n     *<p>\n     * Default implementation adds this introspector in result; this usually\n     * works for sub-classes, except for proxy or delegating \"container\n     * introspectors\" which need to override implementation.\n     */\n    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Default Versioned impl\n    /**********************************************************\n     */\n\n    @Override\n    public abstract Version version();\n    \n    /*\n    /**********************************************************\n    /* Meta-annotations (annotations for annotation types)\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given annotation is considered an\n     * annotation bundle: if so, all meta-annotations it has will\n     * be used instead of annotation (\"bundle\") itself.\n     * \n     * @since 2.0\n     */\n    public boolean isAnnotationBundle(Annotation ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Annotations for Object Id handling\n    /**********************************************************\n     */\n    \n    /**\n     * Method for checking whether given annotated thing\n     * (type, or accessor) indicates that values\n     * referenced (values of type of annotated class, or\n     * values referenced by annotated property; latter\n     * having precedence) should include Object Identifier,\n     * and if so, specify details of Object Identity used.\n     * \n     * @since 2.0\n     */\n    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for figuring out additional properties of an Object Identity reference\n     * \n     * @since 2.1\n     */\n    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* General class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for locating name used as \"root name\" (for use by\n     * some serializers when outputting root-level object -- mostly\n     * for XML compatibility purposes) for given class, if one\n     * is defined. Returns null if no declaration found; can return\n     * explicit empty String, which is usually ignored as well as null.\n     *<p> \n     * NOTE: method signature changed in 2.1, to return {@link PropertyName}\n     * instead of String.\n     */\n    public PropertyName findRootName(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding list of properties to ignore for given class\n     * (null is returned if not specified).\n     * List of property names is applied\n     * after other detection mechanisms, to filter out these specific\n     * properties from being serialized and deserialized.\n     * \n     * @param forSerialization True if requesting properties to ignore for serialization;\n     *   false if for deserialization\n     */\n    public String[] findPropertiesToIgnore(Annotated ac, boolean forSerialization) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @deprecated Since 2.6, use variant that takes second argument.\n     */\n    @Deprecated\n    public String[] findPropertiesToIgnore(Annotated ac) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for checking whether an annotation indicates that all unknown properties\n     */\n    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether properties that have specified type\n     * (class, not generics aware) should be completely ignored for\n     * serialization and deserialization purposes.\n     * \n     * @param ac Type to check\n     * \n     * @return Boolean.TRUE if properties of type should be ignored;\n     *   Boolean.FALSE if they are not to be ignored, null for default\n     *   handling (which is 'do not ignore')\n     */\n    public Boolean isIgnorableType(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding if annotated class has associated filter; and if so,\n     * to return id that is used to locate filter.\n     * \n     * @return Id of the filter to use for filtering properties of annotated\n     *    class, if any; or null if none found.\n     */\n    public Object findFilterId(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding {@link PropertyNamingStrategy} for given\n     * class, if any specified by annotations; and if so, either return\n     * a {@link PropertyNamingStrategy} instance, or Class to use for\n     * creating instance\n     * \n     * @return Sub-class or instance of {@link PropertyNamingStrategy}, if one\n     *   is specified for given class; null if not.\n     * \n     * @since 2.1\n     */\n    public Object findNamingStrategy(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to check whether specified class defines a human-readable\n     * description to use for documentation.\n     * There are no further definitions for contents; for example, whether\n     * these may be marked up using HTML (or something like wiki format like Markup)\n     * is not defined.\n     * \n     * @return Human-readable description, if any.\n     * \n     * @since 2.7\n     */\n    public String findClassDescription(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Property auto-detection\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking if annotations indicate changes to minimum visibility levels\n     * needed for auto-detecting property elements (fields, methods, constructors).\n     * A baseline checker is given, and introspector is to either return it as is\n     * (if no annotations are found), or build and return a derived instance (using\n     * checker's build methods).\n     */\n    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Annotations for Polymorphic type handling\n    /**********************************************************\n    */\n    \n    /**\n     * Method for checking if given class has annotations that indicate\n     * that specific type resolver is to be used for handling instances.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param ac Annotated class to check for annotations\n     * @param baseType Base java type of value for which resolver is to be found\n     * \n     * @return Type resolver builder for given type, if one found; null if none\n     */\n    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking if given property entity (field or method) has annotations\n     * that indicate that specific type resolver is to be used for handling instances.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param am Annotated member (field or method) to check for annotations\n     * @param baseType Base java type of property for which resolver is to be found\n     * \n     * @return Type resolver builder for properties of given entity, if one found;\n     *    null if none\n     */\n    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking if given structured property entity (field or method that\n     * has nominal value of Map, Collection or array type) has annotations\n     * that indicate that specific type resolver is to be used for handling type\n     * information of contained values.\n     * This includes not only\n     * instantiating resolver builder, but also configuring it based on\n     * relevant annotations (not including ones checked with a call to\n     * {@link #findSubtypes}\n     * \n     * @param config Configuration settings in effect (for serialization or deserialization)\n     * @param am Annotated member (field or method) to check for annotations\n     * @param containerType Type of property for which resolver is to be found (must be a container type)\n     * \n     * @return Type resolver builder for values contained in properties of given entity,\n     *    if one found; null if none\n     */    \n    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for locating annotation-specified subtypes related to annotated\n     * entity (class, method, field). Note that this is only guaranteed to be\n     * a list of directly\n     * declared subtypes, no recursive processing is guarantees (i.e. caller\n     * has to do it if/as necessary)\n     * \n     * @param a Annotated entity (class, field/method) to check for annotations\n     */\n    public List<NamedType> findSubtypes(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking if specified type has explicit name.\n     * \n     * @param ac Class to check for type name annotations\n     */\n    public String findTypeName(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether given accessor claims to represent\n     * type id: if so, its value may be used as an override,\n     * instead of generated type id.\n     */\n    public Boolean isTypeId(AnnotatedMember member) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* General member (field, method/constructor) annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking if given member indicates that it is part\n     * of a reference (parent/child).\n     */\n    public ReferenceProperty findReferenceType(AnnotatedMember member) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to check whether given property is marked to be \"unwrapped\"\n     * when being serialized (and appropriately handled in reverse direction,\n     * i.e. expect unwrapped representation during deserialization).\n     * Return value is the name transformation to use, if wrapping/unwrapping\n     * should  be done, or null if not -- note that transformation may simply\n     * be identity transformation (no changes).\n     */\n    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to check whether given property is marked to\n     * be ignored. This is used to determine whether to ignore\n     * properties, on per-property basis, usually combining\n     * annotations from multiple accessors (getters, setters, fields,\n     * constructor parameters).\n     */\n    public boolean hasIgnoreMarker(AnnotatedMember m) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to find out whether given member expectes a value\n     * to be injected, and if so, what is the identifier of the value\n     * to use during injection.\n     * Type if identifier needs to be compatible with provider of\n     * values (of type {@link InjectableValues}); often a simple String\n     * id is used.\n     * \n     * @param m Member to check\n     * \n     * @return Identifier of value to inject, if any; null if no injection\n     *   indicator is found\n     */\n    public Object findInjectableValueId(AnnotatedMember m) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that can be called to check whether this member has\n     * an annotation that suggests whether value for matching property\n     * is required or not.\n     * \n     * @since 2.0\n     */\n    public Boolean hasRequiredMarker(AnnotatedMember m) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for checking if annotated property (represented by a field or\n     * getter/setter method) has definitions for views it is to be included in.\n     * If null is returned, no view definitions exist and property is always\n     * included (or always excluded as per default view inclusion configuration);\n     * otherwise it will only be included for views included in returned\n     * array. View matches are checked using class inheritance rules (sub-classes\n     * inherit inclusions of super-classes)\n     * \n     * @param a Annotated property (represented by a method, field or ctor parameter)\n     * @return Array of views (represented by classes) that the property is included in;\n     *    if null, always included (same as returning array containing <code>Object.class</code>)\n     */\n    public Class<?>[] findViews(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding format annotations for property or class.\n     * Return value is typically used by serializers and/or\n     * deserializers to customize presentation aspects of the\n     * serialized value.\n     * \n     * @since 2.1\n     */\n    public JsonFormat.Value findFormat(Annotated memberOrClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to check if specified property has annotation that indicates\n     * that it should be wrapped in an element; and if so, name to use.\n     * Note that not all serializers and deserializers support use this method:\n     * currently (2.1) it is only used by XML-backed handlers.\n     * \n     * @return Wrapper name to use, if any, or {@link PropertyName#USE_DEFAULT}\n     *   to indicate that no wrapper element should be used.\n     * \n     * @since 2.1\n     */\n    public PropertyName findWrapperName(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding suggested default value (as simple textual serialization)\n     * for the property. While core databind does not make any use of it, it is exposed\n     * for extension modules to use: an expected use is generation of schema representations\n     * and documentation.\n     *\n     * @since 2.5\n     */\n    public String findPropertyDefaultValue(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to check whether specified property member (accessor\n     * or mutator) defines human-readable description to use for documentation.\n     * There are no further definitions for contents; for example, whether\n     * these may be marked up using HTML is not defined.\n     * \n     * @return Human-readable description, if any.\n     * \n     * @since 2.3\n     */\n    public String findPropertyDescription(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method used to check whether specified property member (accessor\n     * or mutator) defines numeric index, and if so, what is the index value.\n     * Possible use cases for index values included use by underlying data format\n     * (some binary formats mandate use of index instead of name) and ordering\n     * of properties (for documentation, or during serialization).\n     * \n     * @since 2.4\n     * \n     * @return Explicitly specified index for the property, if any\n     */\n    public Integer findPropertyIndex(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding implicit name for a property that given annotated\n     * member (field, method, creator parameter) may represent.\n     * This is different from explicit, annotation-based property name, in that\n     * it is \"weak\" and does not either proof that a property exists (for example,\n     * if visibility is not high enough), or override explicit names.\n     * In practice this method is used to introspect optional names for creator\n     * parameters (which may or may not be available and can not be detected\n     * by standard databind); or to provide alternate name mangling for\n     * fields, getters and/or setters.\n     * \n     * @since 2.4\n     */\n    public String findImplicitPropertyName(AnnotatedMember member) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding optional access definition for a property, annotated\n     * on one of its accessors. If a definition for read-only, write-only\n     * or read-write cases, visibility rules may be modified. Note, however,\n     * that even more specific annotations (like one for ignoring specific accessor)\n     * may further override behavior of the access definition.\n     *\n     * @since 2.6\n     */\n    public JsonProperty.Access findPropertyAccess(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called in cases where a class has two methods eligible to be used\n     * for the same logical property, and default logic is not enough to figure\n     * out clear precedence. Introspector may try to choose one to use; or, if\n     * unable, return `null` to indicate it can not resolve the problem.\n     *\n     * @since 2.7\n     */\n    public AnnotatedMethod resolveSetterConflict(MapperConfig<?> config,\n            AnnotatedMethod setter1, AnnotatedMethod setter2) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Serialization: general annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting a serializer definition on specified method\n     * or field. Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findSerializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a serializer definition for keys of associated <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findKeySerializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a serializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonSerializer}) or Class (of type\n     * <code>Class&lt;JsonSerializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findContentSerializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a serializer definition for serializer to use\n     * for nulls (null values) of associated property or type.\n     * \n     * @since 2.3\n     */\n    public Object findNullSerializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for accessing declared typing mode annotated (if any).\n     * This is used for type detection, unless more granular settings\n     * (such as actual exact type; or serializer to use which means\n     * no type information is needed) take precedence.\n     *\n     * @return Typing mode to use, if annotation is found; null otherwise\n     */\n    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * serialization. If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * This feature is typically used to convert internal values into types\n     * that Jackson can convert.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit serializer is usually better way to handle serialization.\n     * \n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *   \n     * @since 2.2\n     */\n    public Object findSerializationConverter(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used first to convert property\n     * value to converter target type, and then serializer for that\n     * type is used for actual serialization.\n     *<p>\n     * Other notes are same as those for {@link #findSerializationConverter}\n     * \n     * @param a Annotated property (field, method) to check.\n     *   \n     * @since 2.2\n     */\n    public Object findSerializationContentConverter(AnnotatedMember a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether given annotated entity (class, method,\n     * field) defines which Bean/Map properties are to be included in\n     * serialization.\n     * If no annotation is found, method should return given second\n     * argument; otherwise value indicated by the annotation.\n     *<p>\n     * Note that meaning of inclusion value depends on whether it is for\n     * a Class or property (field/method/constructor): in former case,\n     * it is the default for all properties; in latter case it is specific\n     * override for annotated property.\n     *\n     * @return Enumerated value indicating which properties to include\n     *   in serialization\n     * \n     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead\n     */\n    @Deprecated // since 2.7\n    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether content (entries) of a {@link java.util.Map} property\n     * are to be included during serialization or not.\n     * NOTE: this is NOT called for POJO properties, or array/Collection elements.\n     * \n     * @since 2.5\n     * \n     * @deprecated Since 2.7 Use {@link #findPropertyInclusion} instead\n     */\n    @Deprecated // since 2.7\n    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking inclusion criteria for a type (Class) or property (yes, method\n     * name is bit unfortunate -- not just for properties!).\n     * In case of class, acts as the default for properties POJO contains; for properties\n     * acts as override for class defaults and possible global defaults.\n     *\n     * @since 2.6\n     */\n    public JsonInclude.Value findPropertyInclusion(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Serialization: type refinements\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing annotated type definition that a\n     * method/field can have, to be used as the type for serialization\n     * instead of the runtime type.\n     * Type returned (if any) needs to be widening conversion (super-type).\n     * Declared return type of the method is also considered acceptable.\n     *\n     * @return Class to use instead of runtime type\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationType(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding possible widening type definition that a property\n     * value can have, to define less specific key type to use for serialization.\n     * It should be only be used with {@link java.util.Map} types.\n     * \n     * @return Class specifying more general type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding possible widening type definition that a property\n     * value can have, to define less specific key type to use for serialization.\n     * It should be only used with structured types (arrays, collections, maps).\n     * \n     * @return Class specifying more general type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineSerializationType} instead\n     */\n    @Deprecated // since 2.7\n    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Serialization: class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing defined property serialization order (which may be\n     * partial). May return null if no ordering is defined.\n     */\n    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether an annotation indicates that serialized properties\n     * for which no explicit is defined should be alphabetically (lexicograpically)\n     * ordered\n     */\n    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for adding possible virtual properties to be serialized along\n     * with regular properties.\n     * \n     * @since 2.5\n     */\n    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Serialization: property annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for serialization.\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     * \n     * @param a Property accessor to check\n     * \n     * @return Name to use if found; null if not.\n     * \n     * @since 2.1\n     */\n    public PropertyName findNameForSerialization(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the return value of annotated method\n     * should be used as \"the value\" of the object instance; usually\n     * serialized as a primitive value such as String or number.\n     *\n     * @return True if such annotation is found (and is not disabled);\n     *   false if no enabled annotation is found\n     */\n    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // TODO: Deprecate in 2.8?\n    /**\n     * Method for determining the String value to use for serializing\n     * given enumeration entry; used when serializing enumerations\n     * as Strings (the standard method).\n     *\n     * @return Serialized enum value.\n     */\n    public String findEnumValue(Enum<?> value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for efficiently figuring out which if given set of <code>Enum</code> values\n     * have explicitly defined name. Method will overwrite entries in incoming <code>names</code>\n     * array with explicit names found, if any, leaving other entries unmodified.\n     *<p>\n     * Default implementation will simply delegate to {@link #findEnumValue}, which is close\n     * enough, although unfortunately NOT 100% equivalent (as it will also consider <code>name()</code>\n     * to give explicit value).\n     *\n     * @since 2.7\n     */\n    public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Deserialization: general annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for getting a deserializer definition on specified method\n     * or field.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findDeserializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a deserializer definition for keys of\n     * associated <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findKeyDeserializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for getting a deserializer definition for content (values) of\n     * associated <code>Collection</code>, <code>array</code> or\n     * <code>Map</code> property.\n     * Type of definition is either instance (of type\n     * {@link JsonDeserializer}) or Class (of type\n     * <code>Class&lt;JsonDeserializer></code>); if value of different\n     * type is returned, a runtime exception may be thrown by caller.\n     */\n    public Object findContentDeserializer(Annotated am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding {@link Converter} that annotated entity\n     * (property or class) has indicated to be used as part of\n     * deserialization.\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * This feature is typically used to convert intermediate Jackson types\n     * (that default deserializers can produce) into custom type instances.\n     *<p>\n     * Note also that this feature does not necessarily work well with polymorphic\n     * type handling, or object identity handling; if such features are needed\n     * an explicit deserializer is usually better way to handle deserialization.\n     * \n     * @param a Annotated property (field, method) or class to check for\n     *   annotations\n     *   \n     * @since 2.2\n     */\n    public Object findDeserializationConverter(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding {@link Converter} that annotated property\n     * has indicated needs to be used for values of container type\n     * (this also means that method should only be called for properties\n     * of container types, List/Map/array properties).\n     *<p>\n     * If not null, either has to be actual\n     * {@link Converter} instance, or class for such converter;\n     * and resulting converter will be used after Jackson has deserializer\n     * data into intermediate type (Converter input type), and Converter\n     * needs to convert this into its target type to be set as property value.\n     *<p>\n     * Other notes are same as those for {@link #findDeserializationConverter}\n     * \n     * @param a Annotated property (field, method) to check.\n     *   \n     * @since 2.2\n     */\n    public Object findDeserializationContentConverter(AnnotatedMember a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Deserialization: type refinements\n    /**********************************************************\n     */\n\n    /**\n     * Method called to find out possible type refinements to use\n     * for deserialization.\n     *\n     * @since 2.7\n     */\n    public JavaType refineDeserializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> valueClass = findDeserializationType(a, type);\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return type;\n    }\n    \n    /**\n     * Method for accessing annotated type definition that a\n     * property can have, to be used as the type for deserialization\n     * instead of the static (declared) type.\n     * Type is usually narrowing conversion (i.e.subtype of declared type).\n     * Declared return type of the method is also considered acceptable.\n     *\n     * @param baseType Assumed type before considering annotations\n     *\n     * @return Class to use for deserialization instead of declared type\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for accessing additional narrowing type definition that a\n     * method can have, to define more specific key type to use.\n     * It should be only be used with {@link java.util.Map} types.\n     * \n     * @param baseKeyType Assumed key type before considering annotations\n     *\n     * @return Class specifying more specific type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for accessing additional narrowing type definition that a\n     * method can have, to define more specific content type to use;\n     * content refers to Map values and Collection/array elements.\n     * It should be only be used with Map, Collection and array types.\n     * \n     * @param baseContentType Assumed content (value) type before considering annotations\n     *\n     * @return Class specifying more specific type to use instead of\n     *   declared type, if annotation found; null if not\n     *\n     * @deprecated Since 2.7 call {@link #refineDeserializationType} instead\n     */\n    @Deprecated\n    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /*\n    /**********************************************************\n    /* Deserialization: class annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method getting {@link ValueInstantiator} to use for given\n     * type (class): return value can either be an instance of\n     * instantiator, or class of instantiator to create.\n     */\n    public Object findValueInstantiator(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding Builder object to use for constructing\n     * value instance and binding data (sort of combining value\n     * instantiators that can construct, and deserializers\n     * that can bind data).\n     *<p>\n     * Note that unlike accessors for some helper Objects, this\n     * method does not allow returning instances: the reason is\n     * that builders have state, and a separate instance needs\n     * to be created for each deserialization call.\n     * \n     * @since 2.0\n     */\n    public Class<?> findPOJOBuilder(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @since 2.0\n     */\n    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Deserialization: property annotations\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given property accessors (method,\n     * field) has an annotation that suggests property name to use\n     * for deserialization (reading JSON into POJOs).\n     * Should return null if no annotation\n     * is found; otherwise a non-null name (possibly\n     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n     * \n     * @param a Property accessor to check\n     * \n     * @return Name to use if found; null if not.\n     * \n     * @since 2.1\n     */\n    public PropertyName findNameForDeserialization(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for setting values of any properties for\n     * which no dedicated setter method is found.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for checking whether given method has an annotation\n     * that suggests that the method is to serve as \"any setter\";\n     * method to be used for accessing set of miscellaneous \"extra\"\n     * properties, often bound with matching \"any setter\" method.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /**\n     * Method for checking whether given annotated item (method, constructor)\n     * has an annotation\n     * that suggests that the method is a \"creator\" (aka factory)\n     * method to be used for construct new instances of deserialized\n     * values.\n     *\n     * @return True if such annotation is found (and is not disabled),\n     *   false otherwise\n     */\n    public boolean hasCreatorAnnotation(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method for finding indication of creator binding mode for\n     * a creator (something for which {@link #hasCreatorAnnotation} returns\n     * true), for cases where there may be ambiguity (currently: single-argument\n     * creator with implicit but no explicit name for the argument).\n     * \n     * @since 2.5\n     */\n    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n         //The specific code has been omitted, but there is no error\n        }\n    \n    /*\n    /**********************************************************\n    /* Overridable methods: may be used as low-level extension\n    /* points.\n    /**********************************************************\n     */\n\n    /**\n     * Method that should be used by sub-classes for ALL\n     * annotation access;\n     * overridable so \n     * that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change it.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.getAnnotation(annoClass);\n     *</code>\n     * \n     * @since 2.5\n     */\n    protected <A extends Annotation> A _findAnnotation(Annotated annotated,\n            Class<A> annoClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Method that should be used by sub-classes for ALL\n     * annotation existence access;\n     * overridable so  that sub-classes may, if they choose to, mangle actual access to\n     * block access (\"hide\" annotations) or perhaps change value seen.\n     *<p>\n     * Default implementation is simply:\n     *<code>\n     *  return annotated.hasAnnotation(annoClass);\n     *</code>\n     * \n     * @since 2.5\n     */\n    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Alternative lookup method that is used to see if annotation has at least one of\n     * annotations of types listed in second argument.\n     *\n     * @since 2.7\n     */\n    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ReferenceProperty": "    public static class ReferenceProperty\n    {\n         //The specific code has been omitted, but there is no error\n        }"}