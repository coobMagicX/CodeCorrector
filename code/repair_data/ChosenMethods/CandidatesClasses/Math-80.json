{"EigenDecompositionImpl": "public class EigenDecompositionImpl implements EigenDecomposition {\n\n    /** Tolerance. */\n    private static final double TOLERANCE = 100 * MathUtils.EPSILON;\n\n    /** Squared tolerance. */\n    private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE;\n\n    /** Split tolerance. */\n    private double splitTolerance;\n\n    /** Main diagonal of the tridiagonal matrix. */\n    private double[] main;\n\n    /** Secondary diagonal of the tridiagonal matrix. */\n    private double[] secondary;\n\n    /** Squared secondary diagonal of the tridiagonal matrix. */\n    private double[] squaredSecondary;\n\n    /** Transformer to tridiagonal (may be null if matrix is already tridiagonal). */\n    private TriDiagonalTransformer transformer;\n\n    /** Lower bound of spectra. */\n    private double lowerSpectra;\n\n    /** Upper bound of spectra. */\n    private double upperSpectra;\n\n    /** Minimum pivot in the Sturm sequence. */\n    private double minPivot;\n\n    /** Current shift. */\n    private double sigma;\n\n    /** Low part of the current shift. */\n    private double sigmaLow;\n\n    /** Shift increment to apply. */\n    private double tau;\n\n    /** Work array for all decomposition algorithms. */\n    private double[] work;\n\n    /** Shift within qd array for ping-pong implementation. */\n    private int pingPong;\n\n    /** Max value of diagonal elements in current segment. */\n    private double qMax;\n\n    /** Min value of off-diagonal elements in current segment. */\n    private double eMin;\n\n    /** Type of the last dqds shift. */\n    private int    tType;\n\n    /** Minimal value on current state of the diagonal. */\n    private double dMin;\n\n    /** Minimal value on current state of the diagonal, excluding last element. */\n    private double dMin1;\n\n    /** Minimal value on current state of the diagonal, excluding last two elements. */\n    private double dMin2;\n\n    /** Last value on current state of the diagonal. */\n    private double dN;\n\n    /** Last but one value on current state of the diagonal. */\n    private double dN1;\n\n    /** Last but two on current state of the diagonal. */\n    private double dN2;\n\n    /** Shift ratio with respect to dMin used when tType == 6. */\n    private double g;\n\n    /** Real part of the realEigenvalues. */\n    private double[] realEigenvalues;\n\n    /** Imaginary part of the realEigenvalues. */\n    private double[] imagEigenvalues;\n\n    /** Eigenvectors. */\n    private ArrayRealVector[] eigenvectors;\n\n    /** Cached value of V. */\n    private RealMatrix cachedV;\n\n    /** Cached value of D. */\n    private RealMatrix cachedD;\n\n    /** Cached value of Vt. */\n    private RealMatrix cachedVt;\n\n    /**\n     * Calculates the eigen decomposition of the given symmetric matrix.\n     * @param matrix The <strong>symmetric</strong> matrix to decompose.\n     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     * geometric mean to split the tridiagonal matrix (a suggested value is\n     * {@link MathUtils#SAFE_MIN})\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public EigenDecompositionImpl(final RealMatrix matrix,\n                                  final double splitTolerance)\n        throws InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported\n            // see issue https://issues.apache.org/jira/browse/MATH-235\n            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    /**\n     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.\n     * @param main the main diagonal of the matrix (will be copied)\n     * @param secondary the secondary diagonal of the matrix (will be copied)\n     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     * geometric mean to split the tridiagonal matrix (a suggested value is\n     * {@link MathUtils#SAFE_MIN})\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }\n\n    /**\n     * Check if a matrix is symmetric.\n     * @param matrix matrix to check\n     * @return true if matrix is symmetric\n     */\n    private boolean isSymmetric(final RealMatrix matrix) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Decompose a tridiagonal symmetric matrix.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    private void decompose() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getD()\n        throws InvalidMatrixException {\n        if (cachedD == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return cachedD;\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getVT()\n        throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // return the cached matrix\n        return cachedVt;\n\n    }\n\n    /** {@inheritDoc} */\n    public double[] getRealEigenvalues()\n        throws InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    /** {@inheritDoc} */\n    public double getRealEigenvalue(final int i)\n        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        return realEigenvalues[i];\n    }\n\n    /** {@inheritDoc} */\n    public double[] getImagEigenvalues()\n        throws InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    /** {@inheritDoc} */\n    public double getImagEigenvalue(final int i)\n        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        return imagEigenvalues[i];\n    }\n\n    /** {@inheritDoc} */\n    public RealVector getEigenvector(final int i)\n        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        if (eigenvectors == null) {\n         //The specific code has been omitted, but there is no error\n        }\n        return eigenvectors[i].copy();\n    }\n\n    /**\n     * Return the determinant of the matrix\n     * @return determinant of the matrix\n     */\n    public double getDeterminant() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public DecompositionSolver getSolver() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Specialized solver. */\n    private static class Solver implements DecompositionSolver {\n\n        /** Real part of the realEigenvalues. */\n        private double[] realEigenvalues;\n\n        /** Imaginary part of the realEigenvalues. */\n        private double[] imagEigenvalues;\n\n        /** Eigenvectors. */\n        private final ArrayRealVector[] eigenvectors;\n\n        /**\n         * Build a solver from decomposed matrix.\n         * @param realEigenvalues real parts of the eigenvalues\n         * @param imagEigenvalues imaginary parts of the eigenvalues\n         * @param eigenvectors eigenvectors\n         */\n        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues,\n                       final ArrayRealVector[] eigenvectors) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n         * <p>This method only find exact linear solutions, i.e. solutions for\n         * which ||A &times; X - B|| is exactly 0.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public double[] solve(final double[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return bp;\n\n        }\n\n        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n         * <p>This method only find exact linear solutions, i.e. solutions for\n         * which ||A &times; X - B|| is exactly 0.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealVector solve(final RealVector b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.getDimension(), m);\n            }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return new ArrayRealVector(bp, false);\n\n        }\n\n        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n         * <p>This method only find exact linear solutions, i.e. solutions for\n         * which ||A &times; X - B|| is exactly 0.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a matrix X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealMatrix solve(final RealMatrix b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return MatrixUtils.createRealMatrix(bp);\n\n        }\n\n        /**\n         * Check if the decomposed matrix is non-singular.\n         * @return true if the decomposed matrix is non-singular\n         */\n        public boolean isNonSingular() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Get the inverse of the decomposed matrix.\n         * @return inverse matrix\n         * @throws InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealMatrix getInverse()\n            throws InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n\n            for (int i = 0; i < m; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n            return MatrixUtils.createRealMatrix(invData);\n\n        }\n\n    }\n\n    /**\n     * Transform matrix to tridiagonal.\n     * @param matrix matrix to transform\n     */\n    private void transformToTridiagonal(final RealMatrix matrix) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the Gershgorin circles for all rows.\n     */\n    private void computeGershgorinCircles() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find the realEigenvalues.\n     * @exception InvalidMatrixException if a block cannot be diagonalized\n     */\n    private void findEigenvalues()\n        throws InvalidMatrixException {\n\n        // compute splitting points\n        List<Integer> splitIndices = computeSplits();\n\n        // find realEigenvalues in each block\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // sort the realEigenvalues in decreasing order\n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n    /**\n     * Compute splitting points.\n     * @return list of indices after matrix can be split\n     */\n    private List<Integer> computeSplits() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find eigenvalue in a block with 1 row.\n     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n     * @param index index of the first row of the block\n     */\n    private void process1RowBlock(final int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find realEigenvalues in a block with 2 rows.\n     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n     * @param index index of the first row of the block\n     * @exception InvalidMatrixException if characteristic polynomial cannot be solved\n     */\n    private void process2RowsBlock(final int index)\n        throws InvalidMatrixException {\n\n        // the characteristic polynomial is\n        // X^2 - (q0 + q1) X + q0 q1 - e1^2\n        final double q0   = main[index];\n        final double q1   = main[index + 1];\n        final double e12  = squaredSecondary[index];\n\n        final double s     = q0 + q1;\n        final double p     = q0 * q1 - e12;\n        final double delta = s * s - 4 * p;\n        if (delta < 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n        realEigenvalues[index]     = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n\n    }\n\n    /**\n     * Find realEigenvalues in a block with 3 rows.\n     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n     * @param index index of the first row of the block\n     * @exception InvalidMatrixException if diagonal elements are not positive\n     */\n    private void process3RowsBlock(final int index)\n        throws InvalidMatrixException {\n\n        // the characteristic polynomial is\n        // X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2\n        final double q0       = main[index];\n        final double q1       = main[index + 1];\n        final double q2       = main[index + 2];\n        final double e12      = squaredSecondary[index];\n        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n\n        // compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0\n        final double b        = -(q0 + q1 + q2);\n        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n        final double d        = q2 * e12 - q0 * q1q2Me22;\n\n        // solve cubic equation\n        final double b2       = b * b;\n        final double q        = (3 * c - b2) / 9;\n        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n        final double delta    = q * q * q + r * r;\n        if (delta >= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n        final double sqrtMq = Math.sqrt(-q);\n        final double theta  = Math.acos(r / (-q * sqrtMq));\n        final double alpha  = 2 * sqrtMq;\n        final double beta   = b / 3;\n\n        double z0 = alpha * Math.cos(theta / 3) - beta;\n        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n        if (z0 < z1) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (z1 < z2) {\n         //The specific code has been omitted, but there is no error\n        }\n        if (z0 < z1) {\n         //The specific code has been omitted, but there is no error\n        }\n        realEigenvalues[index]     = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n\n    }\n\n    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (sumOffDiag == 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n    /**\n     * Perform two iterations with Li's tests for initial splits.\n     * @param n number of rows of the matrix to process\n     */\n    private void initialSplits(final int n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Perform one \"good\" dqd/dqds step.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLAZQ3.</p>\n     * @param start start index\n     * @param end end index\n     * @return new end (maybe deflated)\n     */\n    private int goodStep(final int start, final int end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Flip qd array if warranted.\n     * @param n number of rows in the block\n     * @param step within the array (1 for flipping all elements, 2 for flipping\n     * only every other element)\n     * @return true if qd array was flipped\n     */\n    private boolean flipIfWarranted(final int n, final int step) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute an interval containing all realEigenvalues of a block.\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return an interval containing the realEigenvalues\n     */\n    private double[] eigenvaluesRange(final int index, final int n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Count the number of realEigenvalues below a point.\n     * @param t value below which we must count the number of realEigenvalues\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     * @return number of realEigenvalues smaller than t\n     */\n    private int countEigenValues(final double t, final int index, final int n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>.\n     * <p>A shifted symmetric tridiagonal matrix T can be decomposed as\n     * LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal\n     * and D is a diagonal matrix. This method is an implementation of\n     * algorithm 4.4.7 from Dhillon's thesis.</p>\n     * @param lambda shift to add to the matrix before decomposing it\n     * to ensure it is positive definite\n     * @param index index of the first row of the block\n     * @param n number of rows of the block\n     */\n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Perform a dqds step, using current shift increment.\n     * <p>This implementation is a translation of the LAPACK routine DLASQ5.</p>\n     * @param start start index\n     * @param end end index\n     */\n    private void dqds(final int start, final int end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n    /**\n     * Perform a dqd step.\n     * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>\n     * @param start start index\n     * @param end end index\n     */\n    private void dqd(final int start, final int end) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Update sigma.\n     * @param shift shift to apply to sigma\n     */\n    private void updateSigma(final double shift) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find eigenvectors.\n     */\n    private void findEigenVectors() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Find an eigenvector corresponding to an eigenvalue, using bidiagonals.\n     * <p>This method corresponds to algorithm X from Dhillon's thesis.</p>\n     *\n     * @param eigenvalue eigenvalue for which eigenvector is desired\n     * @param d diagonal elements of the initial non-shifted D matrix\n     * @param l off-diagonal elements of the initial non-shifted L matrix\n     * @return an eigenvector\n     */\n    private ArrayRealVector findEigenvector(final double eigenvalue,\n                                           final double[] d, final double[] l) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n     * L<sub>+</sub>D<sub>+</sub>L<sub>+</sub><sup>T</sup>.\n     * <p>This method corresponds to algorithm 4.4.3 (dstqds) from Dhillon's thesis.</p>\n     * @param d diagonal elements of D,\n     * @param l off-diagonal elements of L\n     * @param lambda shift to apply\n     */\n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\n                                                       final double lambda) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n     * U<sub>-</sub>D<sub>-</sub>U<sub>-</sub><sup>T</sup>.\n     * <p>This method corresponds to algorithm 4.4.5 (dqds) from Dhillon's thesis.</p>\n     * @param d diagonal elements of D\n     * @param l off-diagonal elements of L\n     * @param lambda shift to apply\n     */\n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\n                                                        final double lambda) {\n         //The specific code has been omitted, but there is no error\n        }\n\n}", "Solver": "    private static class Solver implements DecompositionSolver {\n\n        /** Real part of the realEigenvalues. */\n        private double[] realEigenvalues;\n\n        /** Imaginary part of the realEigenvalues. */\n        private double[] imagEigenvalues;\n\n        /** Eigenvectors. */\n        private final ArrayRealVector[] eigenvectors;\n\n        /**\n         * Build a solver from decomposed matrix.\n         * @param realEigenvalues real parts of the eigenvalues\n         * @param imagEigenvalues imaginary parts of the eigenvalues\n         * @param eigenvectors eigenvectors\n         */\n        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues,\n                       final ArrayRealVector[] eigenvectors) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n         * <p>This method only find exact linear solutions, i.e. solutions for\n         * which ||A &times; X - B|| is exactly 0.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public double[] solve(final double[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return bp;\n\n        }\n\n        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n         * <p>This method only find exact linear solutions, i.e. solutions for\n         * which ||A &times; X - B|| is exactly 0.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealVector solve(final RealVector b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.getDimension(), m);\n            }\n\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return new ArrayRealVector(bp, false);\n\n        }\n\n        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n         * <p>This method only find exact linear solutions, i.e. solutions for\n         * which ||A &times; X - B|| is exactly 0.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a matrix X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealMatrix solve(final RealMatrix b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return MatrixUtils.createRealMatrix(bp);\n\n        }\n\n        /**\n         * Check if the decomposed matrix is non-singular.\n         * @return true if the decomposed matrix is non-singular\n         */\n        public boolean isNonSingular() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** Get the inverse of the decomposed matrix.\n         * @return inverse matrix\n         * @throws InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealMatrix getInverse()\n            throws InvalidMatrixException {\n\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n\n            for (int i = 0; i < m; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n            return MatrixUtils.createRealMatrix(invData);\n\n        }\n\n    }"}