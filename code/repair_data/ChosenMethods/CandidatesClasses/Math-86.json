{"CholeskyDecompositionImpl": "public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n\n    /** Default threshold above which off-diagonal elements are considered too different\n     * and matrix not symmetric. */\n    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n\n    /** Default threshold below which diagonal elements are considered null\n     * and matrix not positive definite. */\n    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n\n    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n    private double[][] lTData;\n\n    /** Cached value of L. */\n    private RealMatrix cachedL;\n\n    /** Cached value of LT. */\n    private RealMatrix cachedLT;\n\n    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * <p>\n     * Calling this constructor is equivalent to call {@link\n     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n     * thresholds set to the default values {@link\n     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n     * </p>\n     * @param matrix the matrix to decompose\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n    }\n\n    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getL() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public RealMatrix getLT() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public double getDeterminant() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public DecompositionSolver getSolver() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Specialized solver. */\n    private static class Solver implements DecompositionSolver {\n    \n        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n        private final double[][] lTData;\n\n        /**\n         * Build a solver from decomposed matrix.\n         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n         */\n        private Solver(final double[][] lTData) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public boolean isNonSingular() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public double[] solve(double[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.length != m) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            final double[] x = b.clone();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return x;\n\n        }\n\n        /** {@inheritDoc} */\n        public RealVector solve(RealVector b)\n            throws IllegalArgumentException, InvalidMatrixException {\n            try {\n                return solve((RealVectorImpl) b);\n            } catch (ClassCastException cce) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        /** Solve the linear equation A &times; X = B.\n         * <p>The A matrix is implicit here. It is </p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X such that A &times; X = B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealVectorImpl solve(RealVectorImpl b)\n            throws IllegalArgumentException, InvalidMatrixException {\n            return new RealVectorImpl(solve(b.getDataRef()), false);\n        }\n\n        /** {@inheritDoc} */\n        public RealMatrix solve(RealMatrix b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            double[][] x = b.getData();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return new RealMatrixImpl(x, false);\n\n        }\n\n        /** {@inheritDoc} */\n        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n        }\n\n    }\n\n}", "Solver": "    private static class Solver implements DecompositionSolver {\n    \n        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n        private final double[][] lTData;\n\n        /**\n         * Build a solver from decomposed matrix.\n         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n         */\n        private Solver(final double[][] lTData) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public boolean isNonSingular() {\n         //The specific code has been omitted, but there is no error\n        }\n\n        /** {@inheritDoc} */\n        public double[] solve(double[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.length != m) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            final double[] x = b.clone();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return x;\n\n        }\n\n        /** {@inheritDoc} */\n        public RealVector solve(RealVector b)\n            throws IllegalArgumentException, InvalidMatrixException {\n            try {\n                return solve((RealVectorImpl) b);\n            } catch (ClassCastException cce) {\n         //The specific code has been omitted, but there is no error\n        }\n        }\n\n        /** Solve the linear equation A &times; X = B.\n         * <p>The A matrix is implicit here. It is </p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X such that A &times; X = B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealVectorImpl solve(RealVectorImpl b)\n            throws IllegalArgumentException, InvalidMatrixException {\n            return new RealVectorImpl(solve(b.getDataRef()), false);\n        }\n\n        /** {@inheritDoc} */\n        public RealMatrix solve(RealMatrix b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            double[][] x = b.getData();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n         //The specific code has been omitted, but there is no error\n        }\n\n            return new RealMatrixImpl(x, false);\n\n        }\n\n        /** {@inheritDoc} */\n        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n        }\n\n    }"}