{"PeepholeSubstituteAlternateSyntax": "public class PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n\n  static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n    DiagnosticType.error(\n        \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n        \"Invalid flags to RegExp constructor: {0}\");\n\n  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n      = new Predicate<Node>() {\n    @Override\n    public boolean apply(Node input) {\n         //The specific code has been omitted, but there is no error\n        }\n  };\n\n  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n   *\n   * Returns the replacement for n, or the original if no change was made.\n   */\n  private Node tryReduceReturn(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to minimize NOT nodes such as !(x==y).\n   *\n   * Returns the replacement for n or the original if no change was made\n   */\n  private Node tryMinimizeNot(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to remove duplicate statements from IF blocks. For example:\n   *\n   * if (a) {\n         //The specific code has been omitted, but there is no error\n        } else {\n   *   x = 2;\n   *   return true;\n   * }\n   *\n   * becomes:\n   *\n   * if (a) {\n         //The specific code has been omitted, but there is no error\n        } else {\n   *   x = 2;\n   * }\n   * return true;\n   *\n   * @param n The IF node to examine.\n   */\n  private void tryRemoveRepeatedStatements(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The expression node.\n   */\n  private Node getBlockExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an return.\n   */\n  private boolean isReturnExpressBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The expression that is part of the return.\n   */\n  private Node getBlockReturnExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     a VAR declaration of a single variable.\n   */\n  private boolean isVarBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The var node.\n   */\n  private Node getBlockVar(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does a statement consume a 'dangling else'? A statement consumes\n   * a 'dangling else' if an 'else' token following the statement\n   * would be considered by the parser to be part of the statement.\n   */\n  private boolean consumesDanglingElse(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does the expression contain an operator with lower precedence than\n   * the argument?\n   */\n  private boolean isLowerPrecedenceInExpression(Node n,\n      final int precedence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does the expression contain a property assignment?\n   */\n  private boolean isPropertyAssignmentInExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to minimize conditions expressions, as there are additional\n   * assumptions that can be made when it is known that the final result\n   * is a boolean.\n   *\n   * The following transformations are done recursively:\n   *   !(x||y) --> !x&&!y\n   *   !(x&&y) --> !x||!y\n   *   !!x     --> x\n   * Thus:\n   *   !(x&&!y) --> !x||!!y --> !x||y\n   *\n   *   Returns the replacement for n, or the original if no change was made\n   */\n  private Node tryMinimizeCondition(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replaces a node with a number node if the new number node is not equivalent\n   * to the current node.\n   *\n   * Returns the replacement for n if it was replaced, otherwise returns n.\n   */\n  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n    // String, Number, and Boolean functions return non-object types, whereas\n    // new String, new Number, and new Boolean return object types, so don't\n    // include them here.\n    ImmutableSet.of(\n      \"Object\",\n      \"Array\",\n      \"RegExp\",\n      \"Error\"\n      );\n\n  /**\n   * Fold \"new Object()\" to \"Object()\".\n   */\n  private Node tryFoldStandardConstructors(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replaces a new Array or Object node with an object literal, unless the\n   * call to Array or Object is to a local function with the same name.\n   */\n  private Node tryFoldLiteralConstructor(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static enum FoldArrayAction {\n    NOT_SAFE_TO_FOLD, SAFE_TO_FOLD_WITH_ARGS, SAFE_TO_FOLD_WITHOUT_ARGS}\n\n  /**\n   * Checks if it is safe to fold Array() constructor into []. It can be\n   * obviously done, if the initial constructor has either no arguments or\n   * at least two. The remaining case may be unsafe since Array(number)\n   * actually reserves memory for an empty array which contains number elements.\n   */\n  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Node tryFoldRegularExpressionConstructor(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n\n  /**\n   * are the given flags valid regular expression flags?\n   * Javascript recognizes several suffix flags for regular expressions,\n   * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n   * They are case insensitive, and javascript does not recognize the extended\n   * syntax mode, single-line mode, or expression replacement mode from perl5.\n   */\n  private static boolean areValidRegexpFlags(String flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * are the given flags safe to fold?\n   * We don't fold the regular expression if global ('g') flag is on,\n   * because in this case it isn't really a constant: its 'lastIndex'\n   * property contains the state of last execution, so replacing\n   * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n   * the program if the RegExp is used inside a loop, for example.\n   */\n  private static boolean areSafeFlagsToFold(String flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * returns a string node that can safely be rendered inside /brackets/.\n   */\n  private static Node makeForwardSlashBracketSafe(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * true if the javascript string would contain a unicode escape when written\n   * out as the body of a regular expression literal.\n   */\n  static boolean containsUnicodeEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}