{"DiscreteDistribution": "public class DiscreteDistribution<T> {\n\n    /**\n     * RNG instance used to generate samples from the distribution.\n     */\n    protected final RandomGenerator random;\n    /**\n     * List of random variable values.\n     */\n    private final List<T> singletons;\n    /**\n     * Normalized array of probabilities of respective random variable values.\n     */\n    private final double[] probabilities;\n\n    /**\n     * Create a discrete distribution using the given probability mass function\n     * definition.\n     *\n     * @param samples definition of probability mass function in the format of\n     * list of pairs.\n     * @throws NotPositiveException if probability of at least one value is\n     * negative.\n     * @throws MathArithmeticException if the probabilities sum to zero.\n     * @throws MathIllegalArgumentException if probability of at least one value\n     * is infinite.\n     */\n    public DiscreteDistribution(final List<Pair<T, Double>> samples)\n        throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n        this(new Well19937c(), samples);\n    }\n\n    /**\n     * Create a discrete distribution using the given random number generator\n     * and probability mass function definition.\n     *\n     * @param rng random number generator.\n     * @param samples definition of probability mass function in the format of\n     * list of pairs.\n     * @throws NotPositiveException if probability of at least one value is\n     * negative.\n     * @throws MathArithmeticException if the probabilities sum to zero.\n     * @throws MathIllegalArgumentException if probability of at least one value\n     * is infinite.\n     */\n    public DiscreteDistribution(final RandomGenerator rng, final List<Pair<T, Double>> samples)\n        throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n        random = rng;\n\n        singletons = new ArrayList<T>(samples.size());\n        final double[] probs = new double[samples.size()];\n\n        for (int i = 0; i < samples.size(); i++) {\n            final Pair<T, Double> sample = samples.get(i);\n            singletons.add(sample.getKey());\n            if (sample.getValue() < 0) {\n                throw new NotPositiveException(sample.getValue());\n            }\n            probs[i] = sample.getValue();\n        }\n\n        probabilities = MathArrays.normalizeArray(probs, 1.0);\n    }\n\n    /**\n     * Reseed the random generator used to generate samples.\n     *\n     * @param seed the new seed\n     */\n    public void reseedRandomGenerator(long seed) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * For a random variable {@code X} whose values are distributed according to\n     * this distribution, this method returns {@code P(X = x)}. In other words,\n     * this method represents the probability mass function (PMF) for the\n     * distribution.\n     *\n     * @param x the point at which the PMF is evaluated\n     * @return the value of the probability mass function at {@code x}\n     */\n    double probability(final T x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Return the definition of probability mass function in the format of list\n     * of pairs.\n     *\n     * @return definition of probability mass function.\n     */\n    public List<Pair<T, Double>> getSamples() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Generate a random value sampled from this distribution.\n     *\n     * @return a random value.\n     */\n    public T sample() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n        for (int i = 0; i < sampleSize; i++) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        return out;\n\n    }\n\n}"}