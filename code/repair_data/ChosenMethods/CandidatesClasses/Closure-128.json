{"CodeGenerator": "class CodeGenerator {class CodeGenerator {\n  private static final String LT_ESCAPED = \"\\\\x3c\";\n  private static final String GT_ESCAPED = \"\\\\x3e\";\n\n  // A memoizer for formatting strings as JS strings.\n  private final Map<String, String> ESCAPED_JS_STRINGS = Maps.newHashMap();\n\n  private static final char[] HEX_CHARS\n      = { '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n  private final CodeConsumer cc;\n\n  private final CharsetEncoder outputCharsetEncoder;\n\n  private final boolean preferSingleQuotes;\n  private final boolean trustedStrings;\n\n  private CodeGenerator(CodeConsumer consumer) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static CodeGenerator forCostEstimation(CodeConsumer consumer) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  CodeGenerator(\n      CodeConsumer consumer,\n      CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Insert a ECMASCRIPT 5 strict annotation.\n   */\n  public void tagAsStrict() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void add(String str) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addIdentifier(String identifier) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void add(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void add(Node n, Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isSimpleNumber(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static double getSimpleNumber(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the name is an indirect eval.\n   */\n  private boolean isIndirectEval(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Adds a block or expression, substituting a VOID with an empty statement.\n   * This is used for \"for (...);\" and \"if (...);\" type statements.\n   *\n   * @param n The node to print.\n   * @param context The context to determine how the node should be printed.\n   */\n  private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the Node is a DO or FUNCTION (with or without\n   * labels).\n   */\n  private boolean isOneExactlyFunctionOrDo(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void addExpr(Node n, int minPrecedence, Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addList(Node firstInList) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addList(Node firstInList, boolean isArrayOrFunctionArgument) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * This function adds a comma-separated list as is specified by an ARRAYLIT\n   * node with the associated skipIndexes array.  This is a space optimization\n   * since we avoid creating a whole Node object for each empty array literal\n   * slot.\n   * @param firstInList The first in the node list (chained through the next\n   * property).\n   */\n  void addArrayList(Node firstInList) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addCaseBody(Node caseBody) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  void addAllSiblings(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Outputs a JS string, using the optimal (single/double) quote character */\n  private void addJsString(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private String jsString(String s, boolean useSlashV) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Escapes regular expression */\n  String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Escapes the given string to a double quoted (\") JavaScript/JSON string\n   */\n  String escapeToDoubleQuotedJsString(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /* If the user doesn't want to specify an output charset encoder, assume\n     they want Latin/ASCII characters only.\n   */\n  String regexpEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Helper to escape JavaScript string as well as regular expression */\n  private String strEscape(\n      String s,\n      char quote,\n      String doublequoteEscape,\n      String singlequoteEscape,\n      String backslashEscape,\n      CharsetEncoder outputCharsetEncoder,\n      boolean useSlashV,\n      boolean isRegexp) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static String identifierEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n  /**\n   * @param maxCount The maximum number of children to look for.\n   * @return The number of children of this node that are non empty up to\n   * maxCount.\n   */\n  private static int getNonEmptyChildCount(Node n, int maxCount) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Gets the first non-empty child of the given node. */\n  private static Node getFirstNonEmptyChild(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // Information on the current context. Used for disambiguating special cases.\n  // For example, a \"{\" could indicate the start of an object literal or a\n  // block, depending on the current context.\n  enum Context {\n    STATEMENT,\n    BEFORE_DANGLING_ELSE, // a hack to resolve the else-clause ambiguity\n    START_OF_EXPR,\n    PRESERVE_BLOCK,\n    // Are we inside the init clause of a for loop?  If so, the containing\n    // expression can't contain an in operator.  Pass this context flag down\n    // until we reach expressions which no longer have the limitation.\n    IN_FOR_INIT_CLAUSE,\n    OTHER\n  }\n\n  private Context getContextForNonEmptyExpression(Context currentContext) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * If we're in a IN_FOR_INIT_CLAUSE, we can't permit in operators in the\n   * expression.  Pass on the IN_FOR_INIT_CLAUSE flag through subexpressions.\n   */\n  private  Context getContextForNoInOperator(Context context) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @see #appendHexJavaScriptRepresentation(int, Appendable)\n   */\n  private static void appendHexJavaScriptRepresentation(\n      StringBuilder sb, char c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns a JavaScript representation of the character in a hex escaped\n   * format.\n   *\n   * @param codePoint The code point to append.\n   * @param out The buffer to which the hex representation should be appended.\n   */\n  private static void appendHexJavaScriptRepresentation(\n      int codePoint, Appendable out)\n      throws IOException {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n      // Handle supplementary Unicode values which are not representable in\n      // JavaScript.  We deal with these by escaping them as two 4B sequences\n      // so that they will round-trip properly when sent from Java to JavaScript\n      // and back.\n      char[] surrogates = Character.toChars(codePoint);\n      appendHexJavaScriptRepresentation(surrogates[0], out);\n      appendHexJavaScriptRepresentation(surrogates[1], out);\n      return;\n    }\n    out.append(\"\\\\u\")\n        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n        .append(HEX_CHARS[codePoint & 0xf]);\n  }\n}"}