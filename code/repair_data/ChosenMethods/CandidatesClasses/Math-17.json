{"Dfp": "public class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the {@link org.apache.commons.math3.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math3.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is less than or equal to 0.\n     * @return true if instance is not NaN and less than or equal to 0, false otherwise\n     */\n    public boolean negativeOrNull() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is strictly less than 0.\n     * @return true if instance is not NaN and less than or equal to 0, false otherwise\n     */\n    public boolean strictlyNegative() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is greater than or equal to 0.\n     * @return true if instance is not NaN and greater than or equal to 0, false otherwise\n     */\n    public boolean positiveOrNull() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is strictly greater than 0.\n     * @return true if instance is not NaN and greater than or equal to 0, false otherwise\n     */\n    public boolean strictlyPositive() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the absolute value of instance.\n     * @return absolute value of instance\n     */\n    public Dfp abs() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is equal to zero.\n     * @return true if instance is equal to zero\n     */\n    public boolean isZero() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    private Dfp multiplyFast(final int x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** {@inheritDoc} */\n    public Dfp reciprocal() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n         //The specific code has been omitted, but there is no error\n        }\n\n}"}