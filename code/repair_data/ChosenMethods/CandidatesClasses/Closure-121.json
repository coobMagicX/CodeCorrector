{"InlineVariables": "class InlineVariables implements CompilerPass {\n\n  private final AbstractCompiler compiler;\n\n  enum Mode {\n    // Only inline things explicitly marked as constant.\n    CONSTANTS_ONLY,\n    // Locals only\n    LOCALS_ONLY,\n    ALL\n  }\n\n  private final Mode mode;\n\n  // Inlines all strings, even if they increase the size of the gzipped binary.\n  private final boolean inlineAllStrings;\n\n  private final IdentifyConstants identifyConstants = new IdentifyConstants();\n\n  InlineVariables(\n      AbstractCompiler compiler,\n      Mode mode,\n      boolean inlineAllStrings) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private Predicate<Var> getFilterForMode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Filters variables declared as \"constant\", and declares them in the outer\n   * declaredConstants map.\n   *\n   * In Google coding conventions, this means anything declared with @const\n   * or named in all caps, and initialized to an immutable value.\n   * CheckConsts has already verified that these are truly constants.\n   */\n  private class IdentifyConstants implements Predicate<Var> {\n    @Override\n    public boolean apply(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Filters non-global variables.\n   */\n  private class IdentifyLocals implements Predicate<Var> {\n    @Override\n    public boolean apply(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private static class AliasCandidate {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Builds up information about nodes in each scope. When exiting the\n   * scope, inspects all variables in that scope, and inlines any\n   * that we can.\n   */\n  private class InliningBehavior implements Behavior {\n\n    /**\n     * A list of variables that should not be inlined, because their\n     * reference information is out of sync with the state of the AST.\n     */\n    private final Set<Var> staleVars = Sets.newHashSet();\n\n    /**\n     * Stored possible aliases of variables that never change, with\n     * all the reference info about those variables. Hashed by the NAME\n     * node of the variable being aliased.\n     */\n    final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap();\n\n    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If any of the variables are well-defined and alias other variables,\n     * mark them as aliasing candidates.\n     */\n    private void collectAliasCandidates(NodeTraversal t,\n        ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * For all variables in this scope, see if they are only used once.\n     * If it looks safe to do so, inline them.\n     */\n    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean maybeEscapedOrModifiedArguments(\n        Scope scope, ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isLValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If there are any variable references in the given node tree, blacklist\n     * them to prevent the pass from trying to inline the variable.\n     */\n    private void blacklistVarReferencesInTree(Node root, Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Whether the given variable is forbidden from being inlined.\n     */\n    private boolean isVarInlineForbidden(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Do the actual work of inlining a single declaration into a single\n     * reference.\n     */\n    private void inline(Var v, Reference decl, Reference init, Reference ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Inline an immutable variable into all of its references.\n     */\n    private void inlineWellDefinedVariable(Var v, Node value,\n        List<Reference> refSet) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Inline a declared constant.\n     */\n    private void inlineDeclaredConstant(Var v, Node value,\n        List<Reference> refSet) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Remove the given VAR declaration.\n     */\n    private void removeDeclaration(Reference decl) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Replace the given reference with the given value node.\n     *\n     * @param v The variable that's referenced.\n     * @param ref The reference to replace.\n     * @param value The node tree to replace it with. This tree should be safe\n     *     to re-parent.\n     */\n    private void inlineValue(Var v, Reference ref, Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the given variable is declared as a constant\n     * and may be inlined.\n     */\n    private boolean isInlineableDeclaredConstant(Var var,\n        ReferenceCollection refInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute whether the given string is worth inlining.\n     */\n    private boolean isStringWorthInlining(Var var, List<Reference> refs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If the value is a literal, we can cross more boundaries to inline it.\n     */\n    private boolean canMoveAggressively(Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If the value of a variable is not constant, then it may read or modify\n     * state. Therefore it cannot be moved past anything else that may modify\n     * the value being read or read values that are modified.\n     */\n    private boolean canMoveModerately(\n        Reference initialization,\n        Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return true if the reference is a normal VAR or FUNCTION declaration.\n     */\n    private boolean isValidDeclaration(Reference declaration) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether there is a initial value.\n     */\n    private boolean isValidInitialization(Reference initialization) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return true if the reference is a candidate for inlining\n     */\n    private boolean isValidReference(Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the reference collection describes a variable that\n     * is initialized to an immutable value, never modified, and defined before\n     * every reference.\n     */\n    private boolean isImmutableAndWellDefinedVariable(Var v,\n        ReferenceCollection refInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "IdentifyConstants": "  private class IdentifyConstants implements Predicate<Var> {\n    @Override\n    public boolean apply(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "IdentifyLocals": "  private class IdentifyLocals implements Predicate<Var> {\n    @Override\n    public boolean apply(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "AliasCandidate": "  private static class AliasCandidate {\n         //The specific code has been omitted, but there is no error\n        }", "InliningBehavior": "  private class InliningBehavior implements Behavior {\n\n    /**\n     * A list of variables that should not be inlined, because their\n     * reference information is out of sync with the state of the AST.\n     */\n    private final Set<Var> staleVars = Sets.newHashSet();\n\n    /**\n     * Stored possible aliases of variables that never change, with\n     * all the reference info about those variables. Hashed by the NAME\n     * node of the variable being aliased.\n     */\n    final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap();\n\n    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If any of the variables are well-defined and alias other variables,\n     * mark them as aliasing candidates.\n     */\n    private void collectAliasCandidates(NodeTraversal t,\n        ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * For all variables in this scope, see if they are only used once.\n     * If it looks safe to do so, inline them.\n     */\n    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean maybeEscapedOrModifiedArguments(\n        Scope scope, ReferenceMap referenceMap) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isLValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If there are any variable references in the given node tree, blacklist\n     * them to prevent the pass from trying to inline the variable.\n     */\n    private void blacklistVarReferencesInTree(Node root, Scope scope) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Whether the given variable is forbidden from being inlined.\n     */\n    private boolean isVarInlineForbidden(Var var) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Do the actual work of inlining a single declaration into a single\n     * reference.\n     */\n    private void inline(Var v, Reference decl, Reference init, Reference ref) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Inline an immutable variable into all of its references.\n     */\n    private void inlineWellDefinedVariable(Var v, Node value,\n        List<Reference> refSet) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Inline a declared constant.\n     */\n    private void inlineDeclaredConstant(Var v, Node value,\n        List<Reference> refSet) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Remove the given VAR declaration.\n     */\n    private void removeDeclaration(Reference decl) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Replace the given reference with the given value node.\n     *\n     * @param v The variable that's referenced.\n     * @param ref The reference to replace.\n     * @param value The node tree to replace it with. This tree should be safe\n     *     to re-parent.\n     */\n    private void inlineValue(Var v, Reference ref, Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the given variable is declared as a constant\n     * and may be inlined.\n     */\n    private boolean isInlineableDeclaredConstant(Var var,\n        ReferenceCollection refInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Compute whether the given string is worth inlining.\n     */\n    private boolean isStringWorthInlining(Var var, List<Reference> refs) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If the value is a literal, we can cross more boundaries to inline it.\n     */\n    private boolean canMoveAggressively(Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * If the value of a variable is not constant, then it may read or modify\n     * state. Therefore it cannot be moved past anything else that may modify\n     * the value being read or read values that are modified.\n     */\n    private boolean canMoveModerately(\n        Reference initialization,\n        Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return true if the reference is a normal VAR or FUNCTION declaration.\n     */\n    private boolean isValidDeclaration(Reference declaration) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return Whether there is a initial value.\n     */\n    private boolean isValidInitialization(Reference initialization) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * @return true if the reference is a candidate for inlining\n     */\n    private boolean isValidReference(Reference reference) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether the reference collection describes a variable that\n     * is initialized to an immutable value, never modified, and defined before\n     * every reference.\n     */\n    private boolean isImmutableAndWellDefinedVariable(Var v,\n        ReferenceCollection refInfo) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}