{"FoldConstants": "class FoldConstants extends AbstractPostOrderCallback\n    implements CompilerPass {\n\n  static final DiagnosticType DIVIDE_BY_0_ERROR = DiagnosticType.error(\n      \"JSC_DIVIDE_BY_0_ERROR\",\n      \"Divide by 0\");\n\n  static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n      DiagnosticType.error(\n          \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n          \"Array index not integer: {0}\");\n\n  static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n      DiagnosticType.error(\n          \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n          \"Array index out of bounds: {0}\");\n\n  static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n      DiagnosticType.error(\n          \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n          \"Can't negate non-numeric value: {0}\");\n\n  static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n      DiagnosticType.error(\n          \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n          \"Invalid flags to RegExp constructor: {0}\");\n\n  static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n      DiagnosticType.error(\n          \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n          \"Operand out of range, bitwise operation will lose information: {0}\");\n\n  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n      \"Shift amount out of bounds: {0}\");\n\n  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n      \"Fractional bitwise operand: {0}\");\n\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n\n  private final AbstractCompiler compiler;\n\n  FoldConstants(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void process(Node externs, Node jsRoot) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does a statement consume a 'dangling else'? A statement consumes\n   * a 'dangling else' if an 'else' token following the statement\n   * would be considered by the parser to be part of the statement.\n   */\n  private boolean consumesDanglingElse(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try removing unneeded block nodes and their useless children\n   */\n  void tryFoldBlock(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try folding :? (hook) and IF nodes by removing dead branches.\n   * @return were any changes performed?\n   */\n  boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to minimize NOT nodes such as !(x==y).\n   */\n  private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   */\n  void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to remove duplicate statements from IF blocks. For example:\n   *\n   * if (a) {\n         //The specific code has been omitted, but there is no error\n        } else {\n   *   x = 2;\n   *   return true;\n   * }\n   *\n   * becomes:\n   *\n   * if (a) {\n         //The specific code has been omitted, but there is no error\n        } else {\n   *   x = 2;\n   * }\n   * return true;\n   *\n   * @param n The IF node to examine.\n   */\n  private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n   */\n  private void tryReduceReturn(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does the expression contain a property assignment?\n   */\n  private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Does the expression contain an operator with lower precedence than\n   * the argument?\n   */\n  private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n,\n      final int precedence) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold a AND/OR node.\n   */\n  void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right,\n                    Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n   * where no node has two const children ((foo() + 'a') + 'b'), so\n   * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n   * Specifically it folds Add exprssions where:\n   *  - The left child is also and add expression\n   *  - The right child is a constant value\n   *  - The left child's right child is a STRING constant.\n   *\n   * WARNING: If javascript ever adds operator overloading, this will\n   * probably stop being correct.\n   */\n  void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right,\n                           Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold a ADD node\n   */\n  void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right,\n                  Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold arithmetic binary operators\n   */\n  void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right,\n                       Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold shift operations\n   */\n  void tryFoldShift(NodeTraversal t, Node n, Node left, Node right,\n                    Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold comparison nodes, e.g ==\n   */\n  @SuppressWarnings(\"fallthrough\")\n  void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to evaluate String.indexOf/lastIndexOf:\n   *     \"abcdef\".indexOf(\"bc\") -> 1\n   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n   */\n  void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,\n                            Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-element. e.g [1, 2, 3][10];\n   */\n  void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right,\n                      Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n   */\n  void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,\n                      Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to fold a RegExp constructor to a regular expression literal.\n   */\n  void tryFoldRegularExpressionConstructor(\n      NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n\n  /**\n   * are the given flags valid regular expression flags?\n   * Javascript recognizes several suffix flags for regular expressions,\n   * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n   * They are case insensitive, and javascript does not recognize the extended\n   * syntax mode, single-line mode, or expression replacement mode from perl5.\n   */\n  private static boolean areValidRegexpFlags(String flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * are the given flags safe to fold?\n   * We don't fold the regular expression if global ('g') flag is on,\n   * because in this case it isn't really a constant: its 'lastIndex'\n   * property contains the state of last execution, so replacing\n   * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n   * the program if the RegExp is used inside a loop, for example.\n   */\n  private static boolean areSafeFlagsToFold(String flags) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * returns a string node that can safely be rendered inside /brackets/.\n   */\n  private static Node makeForwardSlashBracketSafe(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Replaces a new Array or Object node with an object literal, unless the\n   * call to Array or Object is to a local function with the same name.\n   *\n   * @param t\n   * @param n new call node (assumed to be of type TokenStream.NEW)\n   * @param parent\n   * @param type type of object literal to replace the new call node with\n   */\n  void tryFoldLiteralConstructor(\n      NodeTraversal t, Node n, Node parent, String className, int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * true if the javascript string would contain a unicode escape when written\n   * out as the body of a regular expression literal.\n   */\n  static boolean containsUnicodeEscape(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes WHILEs that always evaluate to false.\n   */\n  void tryFoldWhile(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes FORs that always evaluate to false.\n   */\n  void tryFoldFor(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes DOs that always evaluate to false. This leaves the\n   * statements that were in the loop in a BLOCK node.\n   * The block will be removed in a later pass, if possible.\n   */\n  void tryFoldDo(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   *\n   */\n  boolean hasBreakOrContinue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Try to minimize conditions expressions, as there are additional\n   * assumptions that can be made when it is known that the final result\n   * is a boolean.\n   *\n   * The following transformations are done recursively:\n   *   !(x||y) --> !x&&!y\n   *   !(x&&y) --> !x||!y\n   *   !!x     --> x\n   * Thus:\n   *   !(x&&!y) --> !x||!!y --> !x||y\n   */\n  void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Remove always true loop conditions.\n   */\n  private void tryFoldForCondition(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  \n  /**\n   * Replaces a node with a number node if the new number node is not equivalent\n   * to the current node.\n   */\n  private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent,\n      int num) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isExpressBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The expression node.\n   */\n  private Node getBlockExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an return.\n   */\n  private boolean isReturnExpressBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The expression that is part of the return.\n   */\n  private Node getBlockReturnExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     a VAR declaration of a single variable.\n   */\n  private boolean isVarBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The var node.\n   */\n  private Node getBlockVar(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n}"}