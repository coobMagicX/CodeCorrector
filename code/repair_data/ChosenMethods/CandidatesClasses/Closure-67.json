{"AnalyzePrototypeProperties": "class AnalyzePrototypeProperties implements CompilerPass {\n\n  // Constants for symbol types, for easier readability.\n  private final SymbolType PROPERTY = SymbolType.PROPERTY;\n  private final SymbolType VAR = SymbolType.VAR;\n\n  private final AbstractCompiler compiler;\n  private final boolean canModifyExterns;\n  private final boolean anchorUnusedVars;\n  private final JSModuleGraph moduleGraph;\n  private final JSModule firstModule;\n\n  // Properties that are implicitly used as part of the JS language.\n  private static final Set<String> IMPLICITLY_USED_PROPERTIES =\n      ImmutableSet.of(\"length\", \"toString\", \"valueOf\");\n\n  // A graph where the nodes are property names or variable names,\n  // and the edges signify the modules where the property is referenced.\n  // For example, if we had the code:\n  //\n  // Foo.prototype.bar = function(x) {\n         //The specific code has been omitted, but there is no error\n        }; // in module 2.;\n  //\n  // then this would be represented in the graph by a node representing\n  // \"bar\", a node representing \"baz\", and an edge between them representing\n  // module #2.\n  //\n  // Similarly, if we had:\n  //\n  // var scotch = function(f) {\n         //The specific code has been omitted, but there is no error\n        };\n  //\n  // then there would be a node for \"scotch\", a node for \"age\", and an edge\n  // from scotch to age.\n  private final LinkedDirectedGraph<NameInfo, JSModule> symbolGraph =\n      LinkedDirectedGraph.createWithoutAnnotations();\n\n  // A dummy node for representing global references.\n  private final NameInfo globalNode = new NameInfo(\"[global]\");\n\n  // A dummy node for representing extern references.\n  private final NameInfo externNode = new NameInfo(\"[extern]\");\n\n  // A dummy node for representing all anonymous functions with no names.\n  private final NameInfo anonymousNode = new NameInfo(\"[anonymous]\");\n\n  // All the real NameInfo for prototype properties, hashed by the name\n  // of the property that they represent.\n  private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();\n\n  // All the NameInfo for global functions, hashed by the name of the\n  // gloval variable that it's assigned to.\n  private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();\n\n  /**\n   * Creates a new pass for analyzing prototype properties.\n   * @param compiler The compiler.\n   * @param moduleGraph The graph for resolving module dependencies. May be\n   *     null if we don't care about module dependencies.\n   * @param canModifyExterns If true, then we can move prototype\n   *     properties that are declared in the externs file.\n   * @param anchorUnusedVars If true, then we must mark all vars as referenced,\n   *     even if they are never used.\n   */\n  AnalyzePrototypeProperties(AbstractCompiler compiler,\n      JSModuleGraph moduleGraph, boolean canModifyExterns,\n      boolean anchorUnusedVars) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void process(Node externRoot, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns information on all prototype properties.\n   */\n  public Collection<NameInfo> getAllNameInfo() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the name info for the property or variable of a given name,\n   * and creates a new one if necessary.\n   *\n   * @param name The name of the symbol.\n   * @param type The type of symbol.\n   */\n  private NameInfo getNameInfoForName(String name, SymbolType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private class ProcessProperties implements NodeTraversal.ScopedCallback {\n    private Stack<NameContext> symbolStack = new Stack<NameContext>();\n\n    private ProcessProperties() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addSymbolUse(String name, JSModule module, SymbolType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether {@code n} is the FUNCTION node in a global function\n     * declaration.\n     */\n    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isPrototypePropertyAssign(Node assign) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a NAME node to see if it's a global function declaration.\n     * If it is, record it and return true. Otherwise, return false.\n     */\n    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes the parent of a GETPROP prototype, which can either be\n     * another GETPROP (in the case of Foo.prototype.bar), or can be\n     * an assignment (in the case of Foo.prototype = ...).\n     */\n    private void processPrototypeParent(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addGlobalUseOfSymbol(String name, JSModule module,\n        SymbolType type) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private class ProcessExternProperties extends AbstractPostOrderCallback {\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private class PropagateReferences\n      implements EdgeCallback<NameInfo, JSModule> {\n    public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  // TODO(user): We can use DefinitionsRemover and UseSite here. Then all\n  // we need to do is call getDefinition() and we'll magically know everything\n  // about the definition.\n\n  /**\n   * The declaration of an abstract symbol.\n   */\n  interface Symbol {\n    /**\n     * Remove the declaration from the AST.\n     */\n    void remove();\n\n    /**\n     * Returns the module where this appears.\n     */\n    JSModule getModule();\n  }\n\n  private enum SymbolType {\n    PROPERTY,\n    VAR;\n  }\n\n  /**\n   * A function initialized as a VAR statement or a function declaration.\n   */\n   class GlobalFunction implements Symbol {\n    private final Node nameNode;\n    private final JSModule module;\n\n    GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Since there are two ways of assigning properties to prototypes, we hide\n   * then behind this interface so they can both be removed regardless of type.\n   */\n  interface Property extends Symbol {\n\n    /** Returns the GETPROP node that refers to the prototype. */\n    Node getPrototype();\n\n    /** Returns the value of this property. */\n    Node getValue();\n  }\n\n  /**\n   * Properties created via EXPR assignment:\n   *\n   * <pre>function Foo() {\n         //The specific code has been omitted, but there is no error\n        };\n   * Foo.prototype.bar = function() {\n         //The specific code has been omitted, but there is no error\n        };</pre>\n   */\n  static class AssignmentProperty implements Property {\n    private final Node exprNode;\n    private final JSModule module;\n\n    /**\n     * @param node An EXPR node.\n     */\n    AssignmentProperty(Node node, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getPrototype() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Node getAssignNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Properties created via object literals:\n   *\n   * <pre>function Foo() {\n         //The specific code has been omitted, but there is no error\n        };\n   * Foo.prototype = {bar: function() {\n         //The specific code has been omitted, but there is no error\n        };</pre>\n   */\n  static class LiteralProperty implements Property {\n    private final Node key;\n    private final Node value;\n    private final Node map;\n    private final Node assign;\n    private final JSModule module;\n\n    LiteralProperty(Node key, Node value, Node map, Node assign,\n        JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getPrototype() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * The context of the current name. This includes the NameInfo and the scope\n   * if it is a scope defining name (function).\n   */\n  private class NameContext {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Information on all properties or global variables of a given name.\n   */\n  class NameInfo {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ProcessProperties": "  private class ProcessProperties implements NodeTraversal.ScopedCallback {\n    private Stack<NameContext> symbolStack = new Stack<NameContext>();\n\n    private ProcessProperties() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addSymbolUse(String name, JSModule module, SymbolType type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Determines whether {@code n} is the FUNCTION node in a global function\n     * declaration.\n     */\n    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private boolean isPrototypePropertyAssign(Node assign) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes a NAME node to see if it's a global function declaration.\n     * If it is, record it and return true. Otherwise, return false.\n     */\n    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Processes the parent of a GETPROP prototype, which can either be\n     * another GETPROP (in the case of Foo.prototype.bar), or can be\n     * an assignment (in the case of Foo.prototype = ...).\n     */\n    private void processPrototypeParent(NodeTraversal t, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private void addGlobalUseOfSymbol(String name, JSModule module,\n        SymbolType type) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "ProcessExternProperties": "  private class ProcessExternProperties extends AbstractPostOrderCallback {\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "PropagateReferences": "  private class PropagateReferences\n      implements EdgeCallback<NameInfo, JSModule> {\n    public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "GlobalFunction": "   class GlobalFunction implements Symbol {\n    private final Node nameNode;\n    private final JSModule module;\n\n    GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    public Node getFunctionNode() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "AssignmentProperty": "  static class AssignmentProperty implements Property {\n    private final Node exprNode;\n    private final JSModule module;\n\n    /**\n     * @param node An EXPR node.\n     */\n    AssignmentProperty(Node node, JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getPrototype() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    private Node getAssignNode() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "LiteralProperty": "  static class LiteralProperty implements Property {\n    private final Node key;\n    private final Node value;\n    private final Node map;\n    private final Node assign;\n    private final JSModule module;\n\n    LiteralProperty(Node key, Node value, Node map, Node assign,\n        JSModule module) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public void remove() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getPrototype() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public Node getValue() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public JSModule getModule() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "NameContext": "  private class NameContext {\n         //The specific code has been omitted, but there is no error\n        }", "NameInfo": "  class NameInfo {\n         //The specific code has been omitted, but there is no error\n        }"}