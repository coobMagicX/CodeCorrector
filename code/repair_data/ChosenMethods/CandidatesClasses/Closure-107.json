{"CommandLineRunner": "public class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n  private static class GuardLevel {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // I don't really care about unchecked warnings in this class.\n  @SuppressWarnings(\"unchecked\")\n  private static class Flags {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Set of options that can be used with the --formatting flag.\n   */\n  private static enum FormattingOption {\n    PRETTY_PRINT,\n    PRINT_INPUT_DELIMITER,\n    SINGLE_QUOTES\n    ;\n\n    private void applyToOptions(CompilerOptions options) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  private final Flags flags = new Flags();\n\n  private boolean isConfigValid = false;\n\n  /**\n   * Create a new command-line runner. You should only need to call\n   * the constructor if you're extending this class. Otherwise, the main\n   * method should instantiate it.\n   */\n  protected CommandLineRunner(String[] args) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Split strings into tokens delimited by whitespace, but treat quoted\n   * strings as single tokens. Non-whitespace characters adjacent to quoted\n   * strings will be returned as part of the token. For example, the string\n   * {@code \"--js='/home/my project/app.js'\"} would be returned as a single\n   * token.\n   *\n   * @param lines strings to tokenize\n   * @return a list of tokens\n   */\n  private List<String> tokenizeKeepingQuotedStrings(List<String> lines) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private List<String> processArgs(String[] args) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void processFlagFile(PrintStream err)\n            throws CmdLineException, IOException {\n    File flagFileInput = new File(flags.flagFile);\n    List<String> argsInFile = tokenizeKeepingQuotedStrings(\n        Files.readLines(flagFileInput, Charset.defaultCharset()));\n\n    flags.flagFile = \"\";\n    List<String> processedFileArgs\n        = processArgs(argsInFile.toArray(new String[] {}));\n    CmdLineParser parserFileArgs = new CmdLineParser(flags);\n    // Command-line warning levels should override flag file settings,\n    // which means they should go last.\n    List<GuardLevel> previous = Lists.newArrayList(Flags.guardLevels);\n    Flags.guardLevels.clear();\n    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\n    Flags.guardLevels.addAll(previous);\n\n    // Currently we are not supporting this (prevent direct/indirect loops)\n    if (!flags.flagFile.equals(\"\")) {\n      err.println(\"ERROR - Arguments in the file cannot contain \"\n          + \"--flagfile option.\");\n      isConfigValid = false;\n    }\n  }\n\n  private void initConfigFromFlags(String[] args, PrintStream err) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  protected CompilerOptions createOptions() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  protected Compiler createCompiler() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  protected List<SourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    List<SourceFile> externs = super.createExterns();\n    if (flags.useOnlyCustomExterns || isInTestMode()) {\n      return externs;\n    } else {\n      List<SourceFile> defaultExterns = getDefaultExterns();\n      defaultExterns.addAll(externs);\n      return defaultExterns;\n    }\n  }\n\n  // The externs expected in externs.zip, in sorted order.\n  private static final List<String> DEFAULT_EXTERNS_NAMES = ImmutableList.of(\n    // JS externs\n    \"es3.js\",\n    \"es5.js\",\n\n    // Event APIs\n    \"w3c_event.js\",\n    \"w3c_event3.js\",\n    \"gecko_event.js\",\n    \"ie_event.js\",\n    \"webkit_event.js\",\n    \"w3c_device_sensor_event.js\",\n\n    // DOM apis\n    \"w3c_dom1.js\",\n    \"w3c_dom2.js\",\n    \"w3c_dom3.js\",\n    \"gecko_dom.js\",\n    \"ie_dom.js\",\n    \"webkit_dom.js\",\n\n    // CSS apis\n    \"w3c_css.js\",\n    \"gecko_css.js\",\n    \"ie_css.js\",\n    \"webkit_css.js\",\n\n    // Top-level namespaces\n    \"google.js\",\n\n    \"chrome.js\",\n\n    \"deprecated.js\",\n    \"fileapi.js\",\n    \"flash.js\",\n    \"gears_symbols.js\",\n    \"gears_types.js\",\n    \"gecko_xml.js\",\n    \"html5.js\",\n    \"ie_vml.js\",\n    \"iphone.js\",\n    \"webstorage.js\",\n    \"w3c_anim_timing.js\",\n    \"w3c_css3d.js\",\n    \"w3c_elementtraversal.js\",\n    \"w3c_geolocation.js\",\n    \"w3c_indexeddb.js\",\n    \"w3c_navigation_timing.js\",\n    \"w3c_range.js\",\n    \"w3c_selectors.js\",\n    \"w3c_xml.js\",\n    \"window.js\",\n    \"webkit_notifications.js\",\n    \"webgl.js\");\n\n  /**\n   * @return a mutable list\n   * @throws IOException\n   */\n  public static List<SourceFile> getDefaultExterns() throws IOException {\n    InputStream input = CommandLineRunner.class.getResourceAsStream(\n        \"/externs.zip\");\n    if (input == null) {\n         //The specific code has been omitted, but there is no error\n        }\n    Preconditions.checkNotNull(input);\n\n    ZipInputStream zip = new ZipInputStream(input);\n    Map<String, SourceFile> externsMap = Maps.newHashMap();\n    for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) {\n      BufferedInputStream entryStream = new BufferedInputStream(\n          ByteStreams.limit(zip, entry.getSize()));\n      externsMap.put(entry.getName(),\n          SourceFile.fromInputStream(\n              // Give the files an odd prefix, so that they do not conflict\n              // with the user's files.\n              \"externs.zip//\" + entry.getName(),\n              entryStream));\n    }\n\n    Preconditions.checkState(\n        externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),\n        \"Externs zip must match our hard-coded list of externs.\");\n\n    // Order matters, so the resources must be added to the result list\n    // in the expected order.\n    List<SourceFile> externs = Lists.newArrayList();\n    for (String key : DEFAULT_EXTERNS_NAMES) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    return externs;\n  }\n\n  /**\n   * @return Whether the configuration is valid.\n   */\n  public boolean shouldRunCompiler() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Runs the Compiler. Exits cleanly in the event of an error.\n   */\n  public static void main(String[] args) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "GuardLevel": "  private static class GuardLevel {\n         //The specific code has been omitted, but there is no error\n        }", "Flags": "  private static class Flags {\n         //The specific code has been omitted, but there is no error\n        }", "BooleanOptionHandler": "    public static class BooleanOptionHandler extends OptionHandler<Boolean> {\n      private static final Set<String> TRUES =\n          Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\");\n      private static final Set<String> FALSES =\n          Sets.newHashSet(\"false\", \"off\", \"no\", \"0\");\n\n      public BooleanOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super Boolean> setter) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = null;\n        try {\n          param = params.getParameter(0);\n        } catch (CmdLineException e) {\n         //The specific code has been omitted, but there is no error\n        }\n\n        if (param == null) {\n         //The specific code has been omitted, but there is no error\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            setter.addValue(true);\n            return 0;\n          }\n          return 1;\n        }\n      }\n\n      @Override\n      public String getDefaultMetaVariable() {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "WarningGuardErrorOptionHandler": "    public static class WarningGuardErrorOptionHandler\n        extends StringOptionHandler {\n      public WarningGuardErrorOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super String> setter) {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "WarningGuardWarningOptionHandler": "    public static class WarningGuardWarningOptionHandler\n        extends StringOptionHandler {\n      public WarningGuardWarningOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super String> setter) {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "WarningGuardOffOptionHandler": "    public static class WarningGuardOffOptionHandler\n        extends StringOptionHandler {\n      public WarningGuardOffOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super String> setter) {\n         //The specific code has been omitted, but there is no error\n        }\n    }", "WarningGuardSetter": "    private static class WarningGuardSetter implements Setter<String> {\n      private final Setter<? super String> proxy;\n      private final CheckLevel level;\n\n      private WarningGuardSetter(\n          Setter<? super String> proxy, CheckLevel level) {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override public boolean isMultiValued() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override public Class<String> getType() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override public void addValue(String value) throws CmdLineException {\n        proxy.addValue(value);\n        guardLevels.add(new GuardLevel(value, level));\n      }\n\n      @Override public FieldSetter asFieldSetter() {\n         //The specific code has been omitted, but there is no error\n        }\n\n      @Override public AnnotatedElement asAnnotatedElement() {\n         //The specific code has been omitted, but there is no error\n        }\n    }"}