{"FlowSensitiveInlineVariables": "class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n\n  /**\n   * Implementation:\n   *\n   * This pass first perform a traversal to gather a list of Candidates that\n   * could be inlined using {@link GatherCandiates}.\n   *\n   * The second step involves verifying that each candidate is actually safe\n   * to inline with {@link Candidate#canInline()} and finally perform inlining\n   * using {@link Candidate#inlineVariable()}.\n   *\n   * The reason for the delayed evaluation of the candidates is because we\n   * need two separate dataflow result.\n   */\n  private final AbstractCompiler compiler;\n\n  // These two pieces of data is persistent in the whole execution of enter\n  // scope.\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n\n  private static final Predicate<Node> SIDE_EFFECT_PREDICATE =\n    new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  };\n\n  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void exitScope(NodeTraversal t) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void process(Node externs, Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gathers a list of possible candidates for inlining based only on\n   * information from {@link MustBeReachingVariableDef}. The list will be stored\n   * in {@code candidates} and the validity of each inlining Candidate should\n   * be later verified with {@link Candidate#canInline()} when\n   * {@link MaybeReachingVariableUse} has been performed.\n   */\n  private class GatherCandiates extends AbstractShallowCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Models the connection between a definition and a use of that definition.\n   */\n  private class Candidate {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given an expression by its root and sub-expression n, return true if there\n   * the predicate is true for some expression on the right of n.\n   *\n   * Example:\n   *\n   * NotChecked(), NotChecked(), n, Checked(), Checked();\n   */\n  private static boolean checkRightOf(\n      Node n, Node expressionRoot, Predicate<Node> predicate) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given an expression by its root and sub-expression n, return true if there\n   * the predicate is true for some expression on the left of n.\n   *\n   * Example:\n   *\n   * Checked(), Checked(), n, NotChecked(), NotChecked();\n   */\n  private static boolean checkLeftOf(\n      Node n, Node expressionRoot, Predicate<Node> predicate) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "GatherCandiates": "  private class GatherCandiates extends AbstractShallowCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Candidate": "  private class Candidate {\n         //The specific code has been omitted, but there is no error\n        }"}