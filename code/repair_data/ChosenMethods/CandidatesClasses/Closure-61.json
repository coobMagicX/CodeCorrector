{"NodeUtil": "public final class NodeUtil {class NodeUtil {\n\n  static final long MAX_POSITIVE_INTEGER_NUMBER = (long)Math.pow(2, 53);\n\n  final static String JSC_PROPERTY_NAME_FN = \"JSCompiler_renameProperty\";\n\n  // TODO(user): Eliminate this class and make all of the static methods\n  // instance methods of com.google.javascript.rhino.Node.\n\n  /** the set of builtin constructors that don't have side effects. */\n  private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =\n      new HashSet<String>(Arrays.asList(\n        \"Array\",\n        \"Date\",\n        \"Error\",\n        \"Object\",\n        \"RegExp\",\n        \"XMLHttpRequest\"));\n\n  // Utility class; do not instantiate.\n  private NodeUtil() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getImpureBooleanValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n  static TernaryValue getPureBooleanValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the value of a node as a String, or null if it cannot be converted.\n   * When it returns a non-null String, this method effectively emulates the\n   * <code>String()</code> JavaScript cast function.\n   */\n  static String getStringValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static String getStringValue(double value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * When converting arrays to string using Array.prototype.toString or\n   * Array.prototype.join, the rules for conversion to String are different\n   * than converting each element individually.  Specifically, \"null\" and\n   * \"undefined\" are converted to an empty string.\n   * @param n A node that is a member of an Array.\n   * @return The string representation.\n   */\n  static String getArrayElementStringValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static String arrayToString(Node literal) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the value of a node as a Number, or null if it cannot be converted.\n   * When it returns a non-null Double, this method effectively emulates the\n   * <code>Number()</code> JavaScript cast function.\n   */\n  static Double getNumberValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static Double getStringNumberValue(String rawJsString) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static String trimJsWhiteSpace(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Copied from Rhino's ScriptRuntime\n   */\n  static TernaryValue isStrWhiteSpaceChar(int c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the function's name. This method recognizes the forms:\n   * <ul>\n   * <li>{@code &#123;'name': function() ...&#125;}</li>\n   * <li>{@code &#123;name: function() ...&#125;}</li>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  public static String getNearestFunctionName(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Returns true if this is an immutable value.\n   */\n  static boolean isImmutableValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if this is a literal value. We define a literal value\n   * as any node that evaluates to the same thing regardless of when or\n   * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n   * the name a is not.\n   *\n   * Function literals do not meet this definition, because they\n   * lexically capture variables. For example, if you have\n   * <code>\n   * function() {\n         //The specific code has been omitted, but there is no error\n        }\n   * </code>\n   * If it is evaluated in a different scope, then it\n   * captures a different variable. Even if the function did not read\n   * any captured vairables directly, it would still fail this definition,\n   * because it affects the lifecycle of variables in the enclosing scope.\n   *\n   * However, a function literal with respect to a particular scope is\n   * a literal.\n   *\n   * @param includeFunctions If true, all function expressions will be\n   *     treated as literals.\n   */\n  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns whether this a BLOCK node with no children.\n   *\n   * @param block The node.\n   */\n  static boolean isEmptyBlock(Node block) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isSimpleOperator(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A \"simple\" operator is one whose children are expressions,\n   * has no direct side-effects (unlike '+='), and has no\n   * conditional aspects (unlike '||').\n   */\n  static boolean isSimpleOperatorType(int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates an EXPR_RESULT.\n   *\n   * @param child The expression itself.\n   * @return Newly created EXPR node with the child as subexpression.\n   */\n  public static Node newExpr(Node child) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if some node in n's subtree changes application state.\n   * If {@code checkForNewObjects} is true, we assume that newly created\n   * mutable objects (like object literals) change state. Otherwise, we assume\n   * that they have no side effects.\n   */\n  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Do calls to this constructor have side effects?\n   *\n   * @param callNode - construtor call node\n   */\n  static boolean constructorCallHasSideEffects(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean constructorCallHasSideEffects(\n      Node callNode, AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // A list of built-in object creation or primitive type cast functions that\n  // can also be called as constructors but lack side-effects.\n  // TODO(johnlenz): consider adding an extern annotation for this.\n  private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS =\n      ImmutableSet.of(\n          \"Object\", \"Array\", \"String\", \"Number\", \"Boolean\", \"RegExp\", \"Error\");\n  private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS =\n      ImmutableSet.of(\"toString\", \"valueOf\");\n  private static final Set<String> REGEXP_METHODS =\n      ImmutableSet.of(\"test\", \"exec\");\n  private static final Set<String> STRING_REGEXP_METHODS =\n      ImmutableSet.of(\"match\", \"replace\", \"search\", \"split\");\n\n  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode - function call node\n   */\n  static boolean functionCallHasSideEffects(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the call has a local result.\n   */\n  static boolean callHasLocalResult(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the new has a local result.\n   */\n  static boolean newHasLocalResult(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if the current node's type implies side effects.\n   *\n   * This is a non-recursive version of the may have side effects\n   * check; used to check wherever the current node's type is one of\n   * the reason's why a subtree has side effects.\n   */\n  static boolean nodeTypeMayHaveSideEffects(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */\n  static boolean canBeSideEffected(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param knownConstants A set of names known to be constant value at\n   * node 'n' (such as locals that are last written before n can execute).\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */\n  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /*\n   *  0 comma ,\n   *  1 assignment = += -= *= /= %= <<= >>= >>>= &= ^= |=\n   *  2 conditional ?:\n   *  3 logical-or ||\n   *  4 logical-and &&\n   *  5 bitwise-or |\n   *  6 bitwise-xor ^\n   *  7 bitwise-and &\n   *  8 equality == !=\n   *  9 relational < <= > >=\n   * 10 bitwise shift << >> >>>\n   * 11 addition/subtraction + -\n   * 12 multiply/divide * / %\n   * 13 negation/increment ! ~ - ++ --\n   * 14 call, member () [] .\n   */\n  static int precedence(int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Apply the supplied predicate against the potential\n   * all possible result of the expression.\n   */\n  static boolean valueCheck(Node n, Predicate<Node> p) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static class NumbericResultPredicate implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =\n      new NumbericResultPredicate();\n\n  /**\n   * Returns true if the result of node evaluation is always a number\n   */\n  static boolean isNumericResult(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isNumericResultHelper(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static class BooleanResultPredicate implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =\n      new BooleanResultPredicate();\n\n  /**\n   * @return Whether the result of node evaluation is always a boolean\n   */\n  static boolean isBooleanResult(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isBooleanResultHelper(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isUndefined(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isNull(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isNullOrUndefined(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static class MayBeStringResultPredicate implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n      new MayBeStringResultPredicate();\n\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean mayBeString(Node n, boolean recurse) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean mayBeStringHelper(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if the operator is commutative.\n   * e.g. (a * b) * c = c * (b * a)\n   * Note 1: \"+\" is not commutative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   * Note 2: only operations on literals and pure functions are commutative.\n   */\n  static boolean isCommutative(int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isAssignmentOp(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static int getOpFromAssignmentOp(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isExpressionNode(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines if the given node contains a function statement or function\n   * expression.\n   */\n  static boolean containsFunction(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if the shallow scope contains references to 'this' keyword\n   */\n  static boolean referencesThis(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a GETPROP or GETELEM node?\n   */\n  static boolean isGet(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a GETPROP node?\n   */\n  static boolean isGetProp(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a NAME node?\n   */\n  static boolean isName(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a NEW node?\n   */\n  static boolean isNew(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a VAR node?\n   */\n  static boolean isVar(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this node the name of a variable being declared?\n   *\n   * @param n The node\n   * @return True if {@code n} is NAME and {@code parent} is VAR\n   */\n  static boolean isVarDeclaration(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * For an assignment or variable declaration get the assigned value.\n   * @return The value node representing the new value.\n   */\n  static Node getAssignedValue(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a STRING node?\n   */\n  static boolean isString(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this node an assignment expression statement?\n   *\n   * @param n The node\n   * @return True if {@code n} is EXPR_RESULT and {@code n}'s\n   *     first child is ASSIGN\n   */\n  static boolean isExprAssign(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this an ASSIGN node?\n   */\n  static boolean isAssign(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this node a call expression statement?\n   *\n   * @param n The node\n   * @return True if {@code n} is EXPR_RESULT and {@code n}'s\n   *     first child is CALL\n   */\n  static boolean isExprCall(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node represents a FOR-IN loop.\n   */\n  static boolean isForIn(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given node is a FOR, DO, or WHILE node.\n   */\n  static boolean isLoopStructure(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param n The node to inspect.\n   * @return If the node, is a FOR, WHILE, or DO, it returns the node for\n   * the code BLOCK, null otherwise.\n   */\n  static Node getLoopCodeBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the specified node has a loop parent that\n   * is within the current scope.\n   */\n  static boolean isWithinLoop(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node.\n   */\n  static boolean isControlStructure(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given node is code node for FOR, DO,\n   * WHILE, WITH, or IF node.\n   */\n  static boolean isControlStructureCodeBlock(Node parent, Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the condition of an ON_TRUE / ON_FALSE CFG edge.\n   * @param n a node with an outgoing conditional CFG edge\n   * @return the condition node or null if the condition is not obviously a node\n   */\n  static Node getConditionExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is of a type that contain other statements.\n   */\n  static boolean isStatementBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is used as a statement.\n   */\n  static boolean isStatement(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isStatementParent(Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Whether the node is part of a switch statement. */\n  static boolean isSwitchCase(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the name is a reference to a variable, function or\n   *       function parameter (not a label or a empty function expression name).\n   */\n  static boolean isReferenceName(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** @return Whether the node is a label name. */\n  static boolean isLabelName(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Whether the child node is the FINALLY block of a try. */\n  static boolean isTryFinallyNode(Node parent, Node child) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Whether the node is a CATCH container BLOCK. */\n  static boolean isTryCatchNodeContainer(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Safely remove children while maintaining a valid node structure. */\n  static void removeChild(Node parent, Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Add a finally block if one does not exist.\n   */\n  static void maybeAddFinally(Node tryNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Merge a block with its parent block.\n   * @return Whether the block was removed.\n   */\n  static boolean tryMergeBlock(Node block) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a CALL node?\n   */\n  static boolean isCall(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param node A node\n   * @return Whether the call is a NEW or CALL node.\n   */\n  static boolean isCallOrNew(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a FUNCTION node?\n   */\n  static boolean isFunction(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Return a BLOCK node for the given FUNCTION node.\n   */\n  static Node getFunctionBody(Node fn) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this a THIS node?\n   */\n  static boolean isThis(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Is this an ARRAYLIT node\n   */\n  static boolean isArrayLiteral(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this node or any of its children a CALL?\n   */\n  static boolean containsCall(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this node a function declaration? A function declaration is a function\n   * that has a name that is added to the current scope (i.e. a function that\n   * is not part of a expression; see {@link #isFunctionExpression}).\n   */\n  static boolean isFunctionDeclaration(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is this node a hoisted function declaration? A function declaration in the\n   * scope root is hoisted to the top of the scope.\n   * See {@link #isFunctionDeclaration}).\n   */\n  static boolean isHoistedFunctionDeclaration(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {\n         //The specific code has been omitted, but there is no error\n        })\n   * (function f() {\n         //The specific code has been omitted, but there is no error\n        })()\n   * [ function f() {\n         //The specific code has been omitted, but there is no error\n        } ]\n   * var f = function f() {\n         //The specific code has been omitted, but there is no error\n        };\n   * for (function f() {\n         //The specific code has been omitted, but there is no error\n        };;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {\n         //The specific code has been omitted, but there is no error\n        }\n   * if (x); else function f() {\n         //The specific code has been omitted, but there is no error\n        }\n   * for (;;) {\n         //The specific code has been omitted, but there is no error\n        }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines if a node is a function expression that has an empty body.\n   *\n   * @param node a node\n   * @return whether the given node is a function expression that is empty\n   */\n  static boolean isEmptyFunctionExpression(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines if a function takes a variable number of arguments by\n   * looking for references to the \"arguments\" var_args object.\n   */\n  static boolean isVarArgsFunction(Node function) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether node is a call to methodName.\n   *    a.f(...)\n   *    a['f'](...)\n   */\n  static boolean isObjectCallMethod(Node callNode, String methodName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.call(...)\n   *    x['call'](...)\n   */\n  static boolean isFunctionObjectCall(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.apply(...)\n   *    x['apply'](...)\n   */\n  static boolean isFunctionObjectApply(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.apply(...)\n   *    x['apply'](...)\n   *  or\n   *    x.call(...)\n   *    x['call'](...)\n   */\n  static boolean isFunctionObjectCallOrApply(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.call(...)\n   *    x['call'](...)\n   * where x is a NAME node.\n   */\n  static boolean isSimpleFunctionObjectCall(Node callNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether this node is strictly on the left hand side of an assign\n   * or var initialization. Notably, this does not include all L-values, only\n   * statements where the node is used only as an L-value.\n   *\n   * @param n The node\n   * @param parent Parent of the node\n   * @return True if n is the left hand of an assign\n   */\n  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether this node is used as an L-value. Notice that sometimes\n   * names are used as both L-values and R-values.\n   *\n   * We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you\n   * treat it as \"assignment to 'undefined' at the top of the scope\". But if\n   * we're honest with ourselves, it doesn't make sense, and we only do this\n   * because it makes sense to treat this as synactically similar to\n   * \"var x = 0;\".\n   *\n   * @param node The node\n   * @return True if n is an L-value.\n   */\n  static boolean isLValue(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   */\n  static boolean isObjectLitKey(Node node, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Get the name of an object literal key.\n   *\n   * @param key A node\n   */\n  static String getObjectLitKeyName(Node key) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param key A OBJECTLIT key node.\n   * @return The type expected when using the key.\n   */\n  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether a node represents an object literal get or set key\n   * (e.g. key1 in {get key1() {\n         //The specific code has been omitted, but there is no error\n        }, set key2(a){\n         //The specific code has been omitted, but there is no error\n        }).\n   *\n   * @param node A node\n   */\n  static boolean isGetOrSetKey(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Converts an operator's token value (see {@link Token}) to a string\n   * representation.\n   *\n   * @param operator the operator's token value to convert\n   * @return the string representation or {@code null} if the token value is\n   * not an operator\n   */\n  static String opToStr(int operator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Converts an operator's token value (see {@link Token}) to a string\n   * representation or fails.\n   *\n   * @param operator the operator's token value to convert\n   * @return the string representation\n   * @throws Error if the token value is not an operator\n   */\n  static String opToStrNoFail(int operator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return true if n or any of its children are of the specified type\n   */\n  static boolean containsType(Node node,\n                              int type,\n                              Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return true if n or any of its children are of the specified type\n   */\n  static boolean containsType(Node node, int type) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Creates function name(params_0, ..., params_n) {\n         //The specific code has been omitted, but there is no error\n        }. */\n  public static Node newFunctionNode(String name, List<Node> params,\n      Node body, int lineno, int charno) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @param lineno The source line offset.\n   * @param charno The source character offset from start of the line.\n   * @return A NAME or GETPROP node\n   */\n  public static Node newQualifiedNameNode(\n      CodingConvention convention, String name, int lineno, int charno) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a node representing a qualified name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return A NAME or GETPROP node\n   */\n  static Node newQualifiedNameNode(\n      CodingConvention convention, String name, Node basisNode,\n      String originalName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the root node of a qualified name. Must be either NAME or THIS.\n   */\n  public static Node getRootOfQualifiedName(Node qName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the debug information (source file info and orignal name)\n   * on the given node.\n   *\n   * @param node The node on which to set the debug information.\n   * @param basisNode The basis node from which to copy the source file info.\n   * @param originalName The original name of the node.\n   */\n  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static Node newName(\n      CodingConvention convention, String name, int lineno, int charno) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node.\n   *\n   * @param name The name for the new NAME node.\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   *\n   * @return The node created.\n   */\n  static Node newName(\n      CodingConvention convention, String name, Node basisNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name The name for the new NAME node.\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return The node created.\n   */\n  static Node newName(\n      CodingConvention convention, String name,\n      Node basisNode, String originalName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Test if all characters in the string are in the Basic Latin (aka ASCII)\n   * character set - that they have UTF-16 values equal to or below 0x7f.\n   * This check can find which identifiers with Unicode characters need to be\n   * escaped in order to allow resulting files to be processed by non-Unicode\n   * aware UNIX tools and editors.\n   * *\n   * See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode\n   * for more on Basic Latin.\n   *\n   * @param s The string to be checked for ASCII-goodness.\n   *\n   * @return True if all characters in the string are in Basic Latin set.\n   */\n\n  static boolean isLatin(String s) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Determines whether the given name can appear on the right side of\n   * the dot operator. Many properties (like reserved words) cannot.\n   */\n  static boolean isValidPropertyName(String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static class VarCollector implements Visitor {\n    final Map<String, Node> vars = Maps.newLinkedHashMap();\n\n    public void visit(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Retrieves vars declared in the current node tree, excluding descent scopes.\n   */\n  public static Collection<Node> getVarsDeclaredInBranch(Node root) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return {@code true} if the node an assignment to a prototype property of\n   *     some constructor.\n   */\n  static boolean isPrototypePropertyDeclaration(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  static boolean isPrototypeProperty(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The class name part of a qualified prototype name.\n   */\n  static Node getPrototypeClassName(Node qName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The string property name part of a qualified prototype name.\n   */\n  static String getPrototypePropertyName(Node qName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Create a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Create a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A predicate for matching name nodes with the specified node.\n   */\n  private static class MatchNameNode implements Predicate<Node>{\n    final String name;\n\n    MatchNameNode(String name){\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * A predicate for matching nodes with the specified type.\n   */\n  static class MatchNodeType implements Predicate<Node>{\n    final int type;\n\n    MatchNodeType(int type){\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n\n  /**\n   * A predicate for matching var or function declarations.\n   */\n  static class MatchDeclaration implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * A predicate for matching anything except function nodes.\n   */\n  static class MatchNotFunction implements Predicate<Node>{\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  static final Predicate<Node> MATCH_NOT_FUNCTION = new MatchNotFunction();\n\n  /**\n   * A predicate for matching statements without exiting the current scope.\n   */\n  static class MatchShallowStatement implements Predicate<Node>{\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * Finds the number of times a type is referenced within the node tree.\n   */\n  static int getNodeTypeReferenceCount(\n      Node node, int type, Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether a simple name is referenced within the node tree.\n   */\n  static boolean isNameReferenced(Node node,\n                                  String name,\n                                  Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Whether a simple name is referenced within the node tree.\n   */\n  static boolean isNameReferenced(Node node, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Finds the number of times a simple name is referenced within the node tree.\n   */\n  static int getNameReferenceCount(Node node, String name) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the predicate is true for the node or any of its children.\n   */\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The number of times the the predicate is true for the node\n   * or any of its children.\n   */\n  static int getCount(\n      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Interface for use with the visit method.\n   * @see #visit\n   */\n  static interface Visitor {\n    void visit(Node node);\n  }\n\n  /**\n   * A pre-order traversal, calling Vistor.visit for each child matching\n   * the predicate.\n   */\n  static void visitPreOrder(Node node,\n                     Visitor vistor,\n                     Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A post-order traversal, calling Vistor.visit for each child matching\n   * the predicate.\n   */\n  static void visitPostOrder(Node node,\n                     Visitor vistor,\n                     Predicate<Node> traverseChildrenPred) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether a TRY node has a finally block.\n   */\n  static boolean hasFinally(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return The BLOCK node containing the CATCH node (if any)\n   * of a TRY.\n   */\n  static Node getCatchBlock(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether BLOCK (from a TRY node) contains a CATCH.\n   * @see NodeUtil#getCatchBlock\n   */\n  static boolean hasCatchHandler(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n    * @param fnNode The function.\n    * @return The Node containing the Function parameters.\n    */\n  public static Node getFunctionParameters(Node fnNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Returns true if a name node represents a constant variable.\n   *\n   * <p>Determining whether a variable is constant has three steps:\n   * <ol>\n   * <li>In CodingConventionAnnotator, any name that matches the\n   *     {@link CodingConvention#isConstant(String)} is annotated with an\n   *     IS_CONSTANT_NAME property.\n   * <li>The normalize pass renames any variable with the IS_CONSTANT_NAME\n   *     annotation and that is initialized to a constant value with\n   *     a variable name inlucding $$constant.\n   * <li>Return true here if the variable includes $$constant in its name.\n   * </ol>\n   *\n   * @param node A NAME or STRING node\n   * @return True if the variable is constant\n   */\n  static boolean isConstantName(Node node) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Whether the given name is constant by coding convention. */\n  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param nameNode A name node\n   * @return The JSDocInfo for the name node\n   */\n  static JSDocInfo getInfoForNameNode(Node nameNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Get the JSDocInfo for a function.\n   */\n  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param n The node.\n   * @return The source name property on the node or its ancestors.\n   */\n  public static String getSourceName(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * A new CALL node with the \"FREE_CALL\" set based on call target.\n   */\n  static Node newCallNode(Node callTarget, Node... parameters) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given the first sibling, this returns the nth\n   * sibling or null if no such sibling exists.\n   * This is like \"getChildAtIndex\" but returns null for non-existent indexes.\n   */\n  private static Node getNthSibling(Node first, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given the function, this returns the nth\n   * argument or null if no such parameter exists.\n   */\n  static Node getArgumentForFunction(Node function, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Given the new or call, this returns the nth\n   * argument of the call or null if no such argument exists.\n   */\n  static Node getArgumentForCallOrNew(Node call, int index) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private static boolean isToStringMethodCall(Node call) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "NumbericResultPredicate": "  static class NumbericResultPredicate implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "BooleanResultPredicate": "  static class BooleanResultPredicate implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "MayBeStringResultPredicate": "  static class MayBeStringResultPredicate implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "VarCollector": "  private static class VarCollector implements Visitor {\n    final Map<String, Node> vars = Maps.newLinkedHashMap();\n\n    public void visit(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "MatchNameNode": "  private static class MatchNameNode implements Predicate<Node>{\n    final String name;\n\n    MatchNameNode(String name){\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "MatchNodeType": "  static class MatchNodeType implements Predicate<Node>{\n    final int type;\n\n    MatchNodeType(int type){\n         //The specific code has been omitted, but there is no error\n        }\n\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "MatchDeclaration": "  static class MatchDeclaration implements Predicate<Node> {\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "MatchNotFunction": "  static class MatchNotFunction implements Predicate<Node>{\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "MatchShallowStatement": "  static class MatchShallowStatement implements Predicate<Node>{\n    public boolean apply(Node n) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}