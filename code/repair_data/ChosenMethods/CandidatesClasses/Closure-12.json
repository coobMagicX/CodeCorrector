{"MaybeReachingVariableUse": "class MaybeReachingVariableUse extends\n    DataFlowAnalysis<Node, MaybeReachingVariableUse.ReachingUses> {\n\n  // The scope of the function that we are analyzing.\n  private final Scope jsScope;\n  private final Set<Var> escaped;\n\n  MaybeReachingVariableUse(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * May use definition lattice representation. It captures a product\n   * lattice for each local (non-escaped) variable. The sub-lattice is\n   * a n + 2 power set element lattice with all the Nodes in the program,\n   * TOP and BOTTOM. This is better explained with an example:\n   *\n   * Consider: A sub-lattice element representing the variable A represented\n   * by { N_4, N_5} where N_x is a Node in the program. This implies at\n   * that particular point in the program the content of A is \"upward exposed\"\n   * at point N_4 and N_5.\n   *\n   * Example:\n   *\n   * A = 1;\n   * ...\n   * N_3:\n   * N_4: print(A);\n   * N_5: y = A;\n   * N_6: A = 1;\n   * N_7: print(A);\n   *\n   * At N_3, reads of A in {N_4, N_5} are said to be upward exposed.\n   */\n  static final class ReachingUses implements LatticeElement {\n    final Multimap<Var, Node> mayUseMap;\n\n    public ReachingUses() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy constructor.\n     *\n     * @param other The constructed object is a replicated copy of this element.\n     */\n    public ReachingUses(ReachingUses other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * The join is a simple union because of the \"may be\" nature of the analysis.\n   *\n   * Consider: A = 1; if (x) {\n         //The specific code has been omitted, but there is no error\n        }; alert(A);\n   *\n   * The read of A \"may be\" exposed to A = 1 in the beginning.\n   */\n  private static class ReachingUsesJoinOp implements JoinOp<ReachingUses> {\n    @Override\n    public ReachingUses apply(List<ReachingUses> from) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  @Override\n  boolean isForward() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  ReachingUses createEntryLattice() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  ReachingUses createInitialEstimateLattice() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Sets the variable for the given name to the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   */\n  private void addToUseIfLocal(String name, Node node, ReachingUses use) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Removes the variable for the given name from the node value in the upward\n   * exposed lattice. Do nothing if the variable name is one of the escaped\n   * variable.\n   */\n  private void removeFromUseIfLocal(String name, ReachingUses use) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets a list of nodes that may be using the value assigned to {@code name}\n   * in {@code defNode}. {@code defNode} must be one of the control flow graph\n   * nodes.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param defNode The list of upward exposed use for the variable.\n   */\n  Collection<Node> getUses(String name, Node defNode) {\n         //The specific code has been omitted, but there is no error\n        }\n}", "ReachingUses": "  static final class ReachingUses implements LatticeElement {\n    final Multimap<Var, Node> mayUseMap;\n\n    public ReachingUses() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Copy constructor.\n     *\n     * @param other The constructed object is a replicated copy of this element.\n     */\n    public ReachingUses(ReachingUses other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public boolean equals(Object other) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public int hashCode() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "ReachingUsesJoinOp": "  private static class ReachingUsesJoinOp implements JoinOp<ReachingUses> {\n    @Override\n    public ReachingUses apply(List<ReachingUses> from) {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}