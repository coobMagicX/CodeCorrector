{"SourceFile": "public class SourceFile implements StaticSourceFile, Serializable {\n  private static final long serialVersionUID = 1L;\n\n  /** A JavaScript source code provider.  The value should\n   * be cached so that the source text stays consistent throughout a single\n   * compile. */\n  public interface Generator {\n    public String getCode();\n  }\n\n  /**\n   * Number of lines in the region returned by {@link #getRegion(int)}.\n   * This length must be odd.\n   */\n  private static final int SOURCE_EXCERPT_REGION_LENGTH = 5;\n\n  private final String fileName;\n  private boolean isExternFile = false;\n\n  // The fileName may not always identify the original file - for example,\n  // supersourced Java inputs, or Java inputs that come from Jar files. This\n  // is an optional field that the creator of an AST or SourceFile can set.\n  // It could be a path to the original file, or in case this SourceFile came\n  // from a Jar, it could be the path to the Jar.\n  private String originalPath = null;\n\n  // Source Line Information\n  private int[] lineOffsets = null;\n\n  // Remember the offset for the previous line query.  If the next line\n  // is after this point, we can start scanning at the previous offset rather\n  // than starting at the beginning of the file.\n  private int lastOffset;\n  private int lastLine;\n\n  private String code = null;\n\n  /**\n   * Construct a new abstract source file.\n   *\n   * @param fileName The file name of the source file. It does not necessarily\n   *     need to correspond to a real path. But it should be unique. Will\n   *     appear in warning messages emitted by the compiler.\n   */\n  public SourceFile(String fileName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public int getLineOffset(int lineno) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** @return The number of lines in this source file. */\n  int getNumLines() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void findLineOffsets() {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation\n\n  /**\n   * Gets all the code in this source file.\n   * @throws IOException\n   */\n  public String getCode() throws IOException {\n    return code;\n  }\n\n  /**\n   * Gets a reader for the code in this source file.\n   */\n  public Reader getCodeReader() throws IOException {\n    return new StringReader(getCode());\n  }\n\n  @VisibleForTesting\n  String getCodeNoCache() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  private void setCode(String sourceCode) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public String getOriginalPath() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public void setOriginalPath(String originalPath) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  // For SourceFile types which cache source code that can be regenerated\n  // easily, flush the cache.  We maintain the cache mostly to speed up\n  // generating source when displaying error messages, so dumping the file\n  // contents after the compile is a fine thing to do.\n  public void clearCachedSource() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  boolean hasSourceInMemory() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns a unique name for the source file. */\n  @Override\n  public String getName() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Returns whether this is an extern. */\n  @Override\n  public boolean isExtern() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /** Sets that this is an extern. */\n  void setIsExtern(boolean newVal) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  /**\n   * Get a region around the indicated line number. The exact definition of a\n   * region is implementation specific, but it must contain the line indicated\n   * by the line number. A region must not start or end by a carriage return.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public Region getRegion(int lineNumber) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  @Override\n  public String toString() {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromFile(String fileName, Charset c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromFile(String fileName) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromFile(File file, Charset c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromFile(File file) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromCode(String fileName, String code) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromCode(String fileName,\n      String originalPath, String code) {\n         //The specific code has been omitted, but there is no error\n        }\n\n  public static SourceFile fromInputStream(String fileName, InputStream s)\n      throws IOException {\n    return fromCode(fileName,\n        CharStreams.toString(new InputStreamReader(s, Charsets.UTF_8)));\n  }\n\n  public static SourceFile fromInputStream(String fileName,\n      String originalPath, InputStream s) throws IOException {\n    return fromCode(fileName, originalPath,\n        CharStreams.toString(new InputStreamReader(s, Charsets.UTF_8)));\n  }\n\n  public static SourceFile fromReader(String fileName, Reader r)\n      throws IOException {\n    return fromCode(fileName, CharStreams.toString(r));\n  }\n\n  public static SourceFile fromGenerator(String fileName,\n      Generator generator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementations\n\n  /**\n   * A source file where the code has been preloaded.\n   */\n  static class Preloaded extends SourceFile {\n    private static final long serialVersionUID = 1L;\n\n    Preloaded(String fileName, String code) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Preloaded(String fileName, String originalPath, String code) {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * A source file where the code will be dynamically generated\n   * from the injected interface.\n   */\n  static class Generated extends SourceFile {\n    private static final long serialVersionUID = 1L;\n    private final Generator generator;\n\n    // Not private, so that LazyInput can extend it.\n    Generated(String fileName, Generator generator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n         //The specific code has been omitted, but there is no error\n        }\n      return cachedCode;\n    }\n\n    // Clear out the generated code when finished with a compile; we can\n    // regenerate it if we ever need it again.\n    @Override\n    public void clearCachedSource() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n\n  /**\n   * A source file where the code is only read into memory if absolutely\n   * necessary. We will try to delay loading the code into memory as long as\n   * possible.\n   */\n  static class OnDisk extends SourceFile {\n    private static final long serialVersionUID = 1L;\n    private final File file;\n\n    // This is stored as a String, but passed in and out as a Charset so that\n    // we can serialize the class.\n    // Default input file format for JSCompiler has always been UTF_8.\n    protected String inputCharset = Charsets.UTF_8.name();\n\n    OnDisk(File file, Charset c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // No Charset provided?\n    OnDisk(File file) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n         //The specific code has been omitted, but there is no error\n        }\n      return cachedCode;\n    }\n\n    /**\n     * Gets a reader for the code in this source file.\n     */\n    @Override\n    public Reader getCodeReader() throws IOException {\n      if (hasSourceInMemory()) {\n        return super.getCodeReader();\n      } else {\n        // If we haven't pulled the code into memory yet, don't.\n        return new FileReader(file);\n      }\n    }\n\n    // Flush the cached code after the compile; we can read it off disk\n    // if we need it again.\n    @Override\n    public void clearCachedSource() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Store the Charset specification as the string version of the name,\n     * rather than the Charset itself.  This allows us to serialize the\n     * SourceFile class.\n     * @param c charset to use when reading the input.\n     */\n    public void setCharset(Charset c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the Charset specifying how we're supposed to read the file\n     * in off disk and into UTF-16.  This is stored as a strong to allow\n     * SourceFile to be serialized.\n     * @return Charset object representing charset to use.\n     */\n    public Charset getCharset() {\n         //The specific code has been omitted, but there is no error\n        }\n  }\n}", "Preloaded": "  static class Preloaded extends SourceFile {\n    private static final long serialVersionUID = 1L;\n\n    Preloaded(String fileName, String code) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    Preloaded(String fileName, String originalPath, String code) {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "Generated": "  static class Generated extends SourceFile {\n    private static final long serialVersionUID = 1L;\n    private final Generator generator;\n\n    // Not private, so that LazyInput can extend it.\n    Generated(String fileName, Generator generator) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n         //The specific code has been omitted, but there is no error\n        }\n      return cachedCode;\n    }\n\n    // Clear out the generated code when finished with a compile; we can\n    // regenerate it if we ever need it again.\n    @Override\n    public void clearCachedSource() {\n         //The specific code has been omitted, but there is no error\n        }\n  }", "OnDisk": "  static class OnDisk extends SourceFile {\n    private static final long serialVersionUID = 1L;\n    private final File file;\n\n    // This is stored as a String, but passed in and out as a Charset so that\n    // we can serialize the class.\n    // Default input file format for JSCompiler has always been UTF_8.\n    protected String inputCharset = Charsets.UTF_8.name();\n\n    OnDisk(File file, Charset c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    // No Charset provided?\n    OnDisk(File file) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    @Override\n    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n         //The specific code has been omitted, but there is no error\n        }\n      return cachedCode;\n    }\n\n    /**\n     * Gets a reader for the code in this source file.\n     */\n    @Override\n    public Reader getCodeReader() throws IOException {\n      if (hasSourceInMemory()) {\n        return super.getCodeReader();\n      } else {\n        // If we haven't pulled the code into memory yet, don't.\n        return new FileReader(file);\n      }\n    }\n\n    // Flush the cached code after the compile; we can read it off disk\n    // if we need it again.\n    @Override\n    public void clearCachedSource() {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Store the Charset specification as the string version of the name,\n     * rather than the Charset itself.  This allows us to serialize the\n     * SourceFile class.\n     * @param c charset to use when reading the input.\n     */\n    public void setCharset(Charset c) {\n         //The specific code has been omitted, but there is no error\n        }\n\n    /**\n     * Get the Charset specifying how we're supposed to read the file\n     * in off disk and into UTF-16.  This is stored as a strong to allow\n     * SourceFile to be serialized.\n     * @return Charset object representing charset to use.\n     */\n    public Charset getCharset() {\n         //The specific code has been omitted, but there is no error\n        }\n  }"}