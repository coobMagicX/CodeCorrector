{"abs": "    public double abs() {\n        if (isNaN()) {\n            return Double.NaN;\n        }\n        \n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        \n        if (Math.abs(real) < Math.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return Math.abs(real);\n            }\n            double q = real / imaginary;\n            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n        } else {\n            if (real == 0.0) {\n                return Math.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return (Math.abs(real) * Math.sqrt(1 + q*q));\n        }\n    }", "add": "    public Complex add(Complex rhs) {   \n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }", "conjugate": "    public Complex conjugate() {\n        if (isNaN()) {\n            return NaN;\n        }   \n        return createComplex(real, -imaginary);\n    }", "divide": "    public Complex divide(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n        \n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (Math.abs(c) < Math.abs(d)) {\n            if (d == 0.0) {\n                return createComplex(real/c, imaginary/c);\n            }\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            if (c == 0.0) {\n                return createComplex(imaginary/d, -real/c);\n            }\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }", "equals": "    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }", "getImaginary": "    public double getImaginary() {\n        return imaginary;\n    }", "getReal": "    public double getReal() {\n        return real;\n    }", "isNaN": "    public boolean isNaN() {\n        return Double.isNaN(real) || Double.isNaN(imaginary);        \n    }", "multiply": "    public Complex multiply(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }", "negate": "    public Complex negate() {\n        if (isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(-real, -imaginary);\n    }", "subtract": "    public Complex subtract(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }", "acos": "    public Complex acos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }", "asin": "    public Complex asin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }", "atan": "    public Complex atan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }", "cos": "    public Complex cos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n            -Math.sin(real) * MathUtils.sinh(imaginary));\n    }", "cosh": "    public Complex cosh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n            MathUtils.sinh(real) * Math.sin(imaginary));\n    }", "exp": "    public Complex exp() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double expReal = Math.exp(real);\n        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n    }", "log": "    public Complex log() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return createComplex(Math.log(abs()),\n            Math.atan2(imaginary, real));        \n    }", "pow": "    public Complex pow(Complex x) {\n        if (x == null) {\n            throw new NullPointerException();\n        }\n        return this.log().multiply(x).exp();\n    }", "sin": "    public Complex sin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n            Math.cos(real) * MathUtils.sinh(imaginary));\n    }", "sinh": "    public Complex sinh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n            MathUtils.cosh(real) * Math.sin(imaginary));\n    }", "sqrt": "    public Complex sqrt() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n        \n        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(Math.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }", "sqrt1z": "    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }", "tan": "    public Complex tan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n        \n        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }", "tanh": "    public Complex tanh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n        \n        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n    }", "createComplex": "    protected Complex createComplex(double real, double imaginary) {\n        return new Complex(real, imaginary);\n    }"}