{"getJsFiles": "    List<String> getJsFiles() {\n      List<String> allJsInputs = Lists.newArrayListWithCapacity(\n          js.size() + arguments.size());\n      allJsInputs.addAll(js);\n      allJsInputs.addAll(arguments);\n      return allJsInputs;\n    }", "parseArguments": "      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = null;\n        try {\n          param = params.getParameter(0);\n        } catch (CmdLineException e) {\n          param = null; // to stop linter complaints\n        }\n\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            setter.addValue(true);\n            return 0;\n          }\n          return 1;\n        }\n      }", "getDefaultMetaVariable": "      public String getDefaultMetaVariable() {\n        return null;\n      }", "isMultiValued": "      @Override public boolean isMultiValued() {\n        return proxy.isMultiValued();\n      }", "getType": "      @Override public Class<String> getType() {\n        return (Class<String>) proxy.getType();\n      }", "addValue": "      @Override public void addValue(String value) throws CmdLineException {\n        proxy.addValue(value);\n        guardLevels.add(new GuardLevel(value, level));\n      }", "asFieldSetter": "      @Override public FieldSetter asFieldSetter() {\n        return proxy.asFieldSetter();\n      }", "asAnnotatedElement": "      @Override public AnnotatedElement asAnnotatedElement() {\n        return proxy.asAnnotatedElement();\n      }", "getWarningGuardSpec": "    public static WarningGuardSpec getWarningGuardSpec() {\n      WarningGuardSpec spec = new WarningGuardSpec();\n      for (GuardLevel guardLevel : guardLevels) {\n        spec.add(guardLevel.level, guardLevel.name);\n      }\n      return spec;\n    }", "tokenizeKeepingQuotedStrings": "  private List<String> tokenizeKeepingQuotedStrings(List<String> lines) {\n    List<String> tokens = Lists.newArrayList();\n    Pattern tokenPattern =\n        Pattern.compile(\"(?:[^ \\t\\f\\\\x0B'\\\"]|(?:'[^']*'|\\\"[^\\\"]*\\\"))+\");\n\n    for (String line : lines) {\n      Matcher matcher = tokenPattern.matcher(line);\n      while (matcher.find()) {\n        tokens.add(matcher.group(0));\n      }\n    }\n    return tokens;\n  }", "processArgs": "  private List<String> processArgs(String[] args) {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    return processedArgs;\n  }", "processFlagFile": "  private void processFlagFile(PrintStream err)\n            throws CmdLineException, IOException {\n    File flagFileInput = new File(flags.flagFile);\n    List<String> argsInFile = tokenizeKeepingQuotedStrings(\n        Files.readLines(flagFileInput, Charset.defaultCharset()));\n\n    flags.flagFile = \"\";\n    List<String> processedFileArgs\n        = processArgs(argsInFile.toArray(new String[] {}));\n    CmdLineParser parserFileArgs = new CmdLineParser(flags);\n    // Command-line warning levels should override flag file settings,\n    // which means they should go last.\n    List<GuardLevel> previous = Lists.newArrayList(Flags.guardLevels);\n    Flags.guardLevels.clear();\n    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\n    Flags.guardLevels.addAll(previous);\n\n    // Currently we are not supporting this (prevent direct/indirect loops)\n    if (!flags.flagFile.equals(\"\")) {\n      err.println(\"ERROR - Arguments in the file cannot contain \"\n          + \"--flagfile option.\");\n      isConfigValid = false;\n    }\n  }", "initConfigFromFlags": "  private void initConfigFromFlags(String[] args, PrintStream err) {\n\n    List<String> processedArgs = processArgs(args);\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    Flags.guardLevels.clear();\n    isConfigValid = true;\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n      // For contains --flagfile flag\n      if (!flags.flagFile.equals(\"\")) {\n        processFlagFile(err);\n      }\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      isConfigValid = false;\n    } catch (IOException ioErr) {\n      err.println(\"ERROR - \" + flags.flagFile + \" read error.\");\n      isConfigValid = false;\n    }\n\n    if (flags.version) {\n      err.println(\n          \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n          \"Version: \" + Compiler.getReleaseVersion() + \"\\n\" +\n          \"Built on: \" + Compiler.getReleaseDate());\n      err.flush();\n    }\n\n    if (flags.processCommonJsModules) {\n      flags.processClosurePrimitives = true;\n      flags.manageClosureDependencies = true;\n      if (flags.commonJsEntryModule == null) {\n        err.println(\"Please specify --common_js_entry_module.\");\n        err.flush();\n        isConfigValid = false;\n      }\n      flags.closureEntryPoint = Lists.newArrayList(\n          ProcessCommonJSModules.toModuleName(flags.commonJsEntryModule));\n    }\n\n    if (!isConfigValid || flags.displayHelp) {\n      isConfigValid = false;\n      parser.printUsage(err);\n    } else {\n      CodingConvention conv;\n      if (flags.thirdParty) {\n        conv = CodingConventions.getDefault();\n      } else if (flags.processJqueryPrimitives) {\n        conv = new JqueryCodingConvention();\n      } else {\n        conv = new ClosureCodingConvention();\n      }\n\n      getCommandLineConfig()\n          .setPrintTree(flags.printTree)\n          .setPrintAst(flags.printAst)\n          .setPrintPassGraph(flags.printPassGraph)\n          .setJscompDevMode(flags.jscompDevMode)\n          .setLoggingLevel(flags.loggingLevel)\n          .setExterns(flags.externs)\n          .setJs(flags.getJsFiles())\n          .setJsOutputFile(flags.jsOutputFile)\n          .setModule(flags.module)\n          .setVariableMapInputFile(flags.variableMapInputFile)\n          .setPropertyMapInputFile(flags.propertyMapInputFile)\n          .setVariableMapOutputFile(flags.variableMapOutputFile)\n          .setCreateNameMapFiles(flags.createNameMapFiles)\n          .setPropertyMapOutputFile(flags.propertyMapOutputFile)\n          .setCodingConvention(conv)\n          .setSummaryDetailLevel(flags.summaryDetailLevel)\n          .setOutputWrapper(flags.outputWrapper)\n          .setModuleWrapper(flags.moduleWrapper)\n          .setModuleOutputPathPrefix(flags.moduleOutputPathPrefix)\n          .setCreateSourceMap(flags.createSourceMap)\n          .setSourceMapFormat(flags.sourceMapFormat)\n          .setWarningGuardSpec(Flags.getWarningGuardSpec())\n          .setDefine(flags.define)\n          .setCharset(flags.charset)\n          .setManageClosureDependencies(flags.manageClosureDependencies)\n          .setOnlyClosureDependencies(flags.onlyClosureDependencies)\n          .setClosureEntryPoints(flags.closureEntryPoint)\n          .setOutputManifest(ImmutableList.of(flags.outputManifest))\n          .setOutputModuleDependencies(flags.outputModuleDependencies)\n          .setAcceptConstKeyword(flags.acceptConstKeyword)\n          .setLanguageIn(flags.languageIn)\n          .setProcessCommonJSModules(flags.processCommonJsModules)\n          .setCommonJSModulePathPrefix(flags.commonJsPathPrefix)\n          .setTransformAMDToCJSModules(flags.transformAmdModules)\n          .setWarningsWhitelistFile(flags.warningsWhitelistFile)\n          .setAngularPass(flags.angularPass)\n          .setTracerMode(flags.tracerMode);\n    }\n  }", "createOptions": "  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    if (flags.processJqueryPrimitives) {\n      options.setCodingConvention(new JqueryCodingConvention());\n    } else {\n      options.setCodingConvention(new ClosureCodingConvention());\n    }\n\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\n\n    CompilationLevel level = flags.compilationLevel;\n    level.setOptionsForCompilationLevel(options);\n\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if (flags.useTypesForOptimization) {\n      level.setTypeBasedOptimizationOptions(options);\n    }\n\n    if (flags.generateExports) {\n      options.setGenerateExports(flags.generateExports);\n    }\n\n    WarningLevel wLevel = flags.warningLevel;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.processClosurePrimitives;\n\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n        flags.processJqueryPrimitives;\n\n    options.angularPass = flags.angularPass;\n\n    if (!flags.translationsFile.isEmpty()) {\n      try {\n        options.messageBundle = new XtbMessageBundle(\n            new FileInputStream(flags.translationsFile),\n            flags.translationsProject);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Reading XTB file\", e);\n      }\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n      // translations file, they might reasonably try to write their own\n      // implementation of goog.getMsg that makes the substitution at\n      // run-time.\n      //\n      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n      // so we might as well inline it. But shut off the i18n warnings,\n      // because the user didn't really ask for i18n.\n      options.messageBundle = new EmptyMessageBundle();\n    }\n\n    return options;\n  }", "createCompiler": "  protected Compiler createCompiler() {\n    return new Compiler(getErrorPrintStream());\n  }", "createExterns": "  protected List<SourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    List<SourceFile> externs = super.createExterns();\n    if (flags.useOnlyCustomExterns || isInTestMode()) {\n      return externs;\n    } else {\n      List<SourceFile> defaultExterns = getDefaultExterns();\n      defaultExterns.addAll(externs);\n      return defaultExterns;\n    }\n  }", "getDefaultExterns": "  public static List<SourceFile> getDefaultExterns() throws IOException {\n    InputStream input = CommandLineRunner.class.getResourceAsStream(\n        \"/externs.zip\");\n    if (input == null) {\n      // In some environments, the externs.zip is relative to this class.\n      input = CommandLineRunner.class.getResourceAsStream(\"externs.zip\");\n    }\n    Preconditions.checkNotNull(input);\n\n    ZipInputStream zip = new ZipInputStream(input);\n    Map<String, SourceFile> externsMap = Maps.newHashMap();\n    for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) {\n      BufferedInputStream entryStream = new BufferedInputStream(\n          ByteStreams.limit(zip, entry.getSize()));\n      externsMap.put(entry.getName(),\n          SourceFile.fromInputStream(\n              // Give the files an odd prefix, so that they do not conflict\n              // with the user's files.\n              \"externs.zip//\" + entry.getName(),\n              entryStream));\n    }\n\n    Preconditions.checkState(\n        externsMap.keySet().equals(Sets.newHashSet(DEFAULT_EXTERNS_NAMES)),\n        \"Externs zip must match our hard-coded list of externs.\");\n\n    // Order matters, so the resources must be added to the result list\n    // in the expected order.\n    List<SourceFile> externs = Lists.newArrayList();\n    for (String key : DEFAULT_EXTERNS_NAMES) {\n      externs.add(externsMap.get(key));\n    }\n\n    return externs;\n  }", "shouldRunCompiler": "  public boolean shouldRunCompiler() {\n    return this.isConfigValid;\n  }", "main": "  public static void main(String[] args) {\n    CommandLineRunner runner = new CommandLineRunner(args);\n    if (runner.shouldRunCompiler()) {\n      runner.run();\n    } else {\n      System.exit(-1);\n    }\n  }"}