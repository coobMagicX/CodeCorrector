{"computeWeightedJacobian": "    protected RealMatrix computeWeightedJacobian(double[] params) {\n        ++jacobianEvaluations;\n\n        final DerivativeStructure[] dsPoint = new DerivativeStructure[params.length];\n        final int nC = params.length;\n        for (int i = 0; i < nC; ++i) {\n            dsPoint[i] = new DerivativeStructure(nC, 1, i, params[i]);\n        }\n        final DerivativeStructure[] dsValue = jF.value(dsPoint);\n        final int nR = getTarget().length;\n        if (dsValue.length != nR) {\n            throw new DimensionMismatchException(dsValue.length, nR);\n        }\n        final double[][] jacobianData = new double[nR][nC];\n        for (int i = 0; i < nR; ++i) {\n            int[] orders = new int[nC];\n            for (int j = 0; j < nC; ++j) {\n                orders[j] = 1;\n                jacobianData[i][j] = dsValue[i].getPartialDerivative(orders);\n                orders[j] = 0;\n            }\n        }\n\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobianData));\n    }", "computeCost": "    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }", "getRMS": "    public double getRMS() {\n        return FastMath.sqrt(getChiSquare() / rows);\n    }", "getWeightSquareRoot": "    public RealMatrix getWeightSquareRoot() {\n        return weightMatrixSqrt.copy();\n    }", "computeCovariances": "    public double[][] computeCovariances(double[] params,\n                                         double threshold) {\n        // Set up the Jacobian.\n        final RealMatrix j = computeWeightedJacobian(params);\n\n        // Compute transpose(J)J.\n        final RealMatrix jTj = j.transpose().multiply(j);\n\n        // Compute the covariances matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(jTj, threshold).getSolver();\n        return solver.getInverse().getData();\n    }", "guessParametersErrors": "    public double[] guessParametersErrors() {\n        if (rows <= cols) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                                                rows, cols, false);\n        }\n        double[] errors = new double[cols];\n        final double c = FastMath.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = computeCovariances(point, 1e-14);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }", "computeSigma": "    public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold) {\n        final int nC = params.length;\n        final double[] sig = new double[nC];\n        final double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < nC; ++i) {\n            sig[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sig;\n    }", "optimize": "    public PointVectorValuePair optimize(final int maxEval,\n                                         final MultivariateDifferentiableVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n        return optimizeInternal(maxEval, f,\n                                new Target(target),\n                                new Weight(weights),\n                                new InitialGuess(startPoint));\n    }", "optimizeInternal": "    protected PointVectorValuePair optimizeInternal(final int maxEval,\n                                                    final MultivariateDifferentiableVectorFunction f,\n                                                    OptimizationData... optData) {\n        // XXX Conversion will be removed when the generic argument of the\n        // base class becomes \"MultivariateDifferentiableVectorFunction\".\n        return super.optimizeInternal(maxEval, FunctionUtils.toDifferentiableMultivariateVectorFunction(f), optData);\n    }", "computeResiduals": "    protected double[] computeResiduals(double[] objectiveValue) {\n        final double[] target = getTarget();\n        if (objectiveValue.length != target.length) {\n            throw new DimensionMismatchException(target.length,\n                                                 objectiveValue.length);\n        }\n\n        final double[] residuals = new double[target.length];\n        for (int i = 0; i < target.length; i++) {\n            residuals[i] = target[i] - objectiveValue[i];\n        }\n\n        return residuals;\n    }", "squareRoot": "    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }"}