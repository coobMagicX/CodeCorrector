{"getPropertiesCount": "  public int getPropertiesCount() {\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype == null) {\n      return this.properties.size();\n    }\n    int localCount = 0;\n    for (String property : properties.keySet()) {\n      if (!implicitPrototype.hasProperty(property)) {\n        localCount++;\n      }\n    }\n    return implicitPrototype.getPropertiesCount() + localCount;\n  }", "hasProperty": "  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isUnknownType() || getSlot(propertyName) != null;\n  }", "hasOwnProperty": "  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }", "getOwnPropertyNames": "  public Set<String> getOwnPropertyNames() {\n    return properties.keySet();\n  }", "isPropertyTypeDeclared": "  public boolean isPropertyTypeDeclared(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return !slot.isTypeInferred();\n  }", "collectPropertyNames": "  void collectPropertyNames(Set<String> props) {\n    for (String prop : properties.keySet()) {\n      props.add(prop);\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototype.collectPropertyNames(props);\n    }\n  }", "isPropertyTypeInferred": "  public boolean isPropertyTypeInferred(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return slot.isTypeInferred();\n  }", "getPropertyType": "  public JSType getPropertyType(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }", "isPropertyInExterns": "  public boolean isPropertyInExterns(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.isFromExterns();\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      return implicitPrototype.isPropertyInExterns(propertyName);\n    }\n    return false;\n  }", "defineProperty": "  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred jsdoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n    return true;\n  }", "removeProperty": "  public boolean removeProperty(String name) {\n    return properties.remove(name) != null;\n  }", "getPropertyNode": "  public Node getPropertyNode(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.getNode();\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      return implicitPrototype.getPropertyNode(propertyName);\n    }\n    return null;\n  }", "getOwnPropertyJSDocInfo": "  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.getJSDocInfo();\n    }\n    return null;\n  }", "setPropertyJSDocInfo": "  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n    if (info != null) {\n      if (!properties.containsKey(propertyName)) {\n        // If docInfo was attached, but the type of the property\n        // was not defined anywhere, then we consider this an explicit\n        // declaration of the property.\n        defineInferredProperty(propertyName, getPropertyType(propertyName),\n            null);\n      }\n\n      // The prototype property is not represented as a normal Property.\n      // We probably don't want to attach any JSDoc to it anyway.\n      Property property = properties.get(propertyName);\n      if (property != null) {\n        property.setJSDocInfo(info);\n      }\n    }\n  }", "matchesStringContext": "  public boolean matchesStringContext() {\n    return isTheObjectType() || isStringObjectType() || isDateType() ||\n        isRegexpType() || isArrayType() || isNumberObjectType() ||\n        isBooleanObjectType() || hasOverridenNativeProperty(\"toString\");\n  }", "hasOverridenNativeProperty": "  private boolean hasOverridenNativeProperty(String propertyName) {\n    if (isNativeObjectType()) {\n      return false;\n    }\n\n    JSType propertyType = getPropertyType(propertyName);\n    ObjectType nativeType =\n        this.isFunctionType() ?\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) :\n        registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);\n    JSType nativePropertyType = nativeType.getPropertyType(propertyName);\n    return propertyType != nativePropertyType;\n  }", "toStringHelper": "  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n\n        ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return \"{...}\";\n    }\n  }", "setPrettyPrint": "  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }", "isPrettyPrint": "  boolean isPrettyPrint() {\n    return prettyPrint;\n  }", "getImplicitPrototype": "  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }", "setImplicitPrototype": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }", "getReferenceName": "  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }", "hasReferenceName": "  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }", "isSubtype": "  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }", "implicitPrototypeChainIsUnknown": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }", "isNativeObjectType": "  public boolean isNativeObjectType() {\n    return nativeType;\n  }", "setOwnerFunction": "  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }", "getOwnerFunction": "  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }", "getCtorImplementedInterfaces": "  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getImplementedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }", "getCtorExtendedInterfaces": "  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }", "resolveInternal": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.setType(safeResolve(prop.getType(), t, scope));\n    }\n    return this;\n  }"}