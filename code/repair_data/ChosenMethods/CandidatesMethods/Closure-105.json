{"process": "  public void process(Node externs, Node jsRoot) {\n    NodeTraversal.traverse(compiler, jsRoot, this);\n  }", "visit": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    int type = n.getType();\n\n    if (type == Token.BLOCK) {\n      tryFoldBlock(t, n, parent);\n      return;\n    }\n\n    Node left = n.getFirstChild();\n    if (left == null) {\n      return;\n    }\n\n    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {\n      String newValue = null;\n\n      switch (left.getType()) {\n        case Token.STRING:\n          newValue = \"string\";\n          break;\n        case Token.NUMBER:\n          newValue = \"number\";\n          break;\n        case Token.TRUE:\n        case Token.FALSE:\n          newValue = \"boolean\";\n          break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n          newValue = \"object\";\n          break;\n        case Token.NAME:\n          // We assume here that programs don't change the value of the\n          // keyword undefined to something other than the value undefined.\n          if (\"undefined\".equals(left.getString())) {\n            newValue = \"undefined\";\n          }\n          break;\n      }\n\n      if (newValue != null) {\n        parent.replaceChild(n, Node.newString(newValue));\n        t.getCompiler().reportCodeChange();\n      }\n\n      return;\n    }\n\n    if (type == Token.NOT ||\n        type == Token.NEG ||\n        type == Token.BITNOT) {\n        Preconditions.checkState(n.hasOneChild());\n\n        if (NodeUtil.isExpressionNode(parent)) {\n          // If the value of the NOT isn't used, then just throw\n          // away the operator\n          parent.replaceChild(n, n.removeFirstChild());\n          t.getCompiler().reportCodeChange();\n          return;\n        }\n\n        // Try to mimize NOT nodes such as !(x==y) into x!=y.\n        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {\n          return;\n        }\n\n        if (!NodeUtil.isLiteralValue(left)) {\n          return;\n        }\n\n        switch (type) {\n          case Token.NOT:\n            int result = NodeUtil.getBooleanValue(left) ? Token.FALSE :\n                         Token.TRUE;\n            parent.replaceChild(n, new Node(result));\n            t.getCompiler().reportCodeChange();\n            break;\n\n          case Token.NEG:\n            try {\n              if (left.getType() == Token.NAME) {\n                if (left.getString().equals(\"Infinity\")) {\n                  // \"-Infinity\" is valid and a literal, don't modify it.\n                  return;\n                } else if (left.getString().equals(\"NaN\")) {\n                  // \"-NaN\" is \"NaN\".\n                  n.removeChild(left);\n                  parent.replaceChild(n, left);\n                  t.getCompiler().reportCodeChange();\n                  return;\n                }\n              }\n\n              double negNum = -left.getDouble();\n              parent.replaceChild(n, Node.newNumber(negNum));\n              t.getCompiler().reportCodeChange();\n            } catch (UnsupportedOperationException ex) {\n              // left is not a number node, so do not replace, but warn the\n              // user because they can't be doing anything good\n              error(t, NEGATING_A_NON_NUMBER_ERROR, left);\n            }\n            break;\n\n          case Token.BITNOT:\n            try {\n              double val = left.getDouble();\n              if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n                int intVal = (int) val;\n                if (intVal == val) {\n                  parent.replaceChild(n, Node.newNumber(~intVal));\n                  t.getCompiler().reportCodeChange();\n                } else {\n                  error(t, FRACTIONAL_BITWISE_OPERAND, left);\n                }\n              } else {\n                error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);\n              }\n            } catch (UnsupportedOperationException ex) {\n              // left is not a number node, so do not replace, but warn the\n              // user because they can't be doing anything good\n              error(t, NEGATING_A_NON_NUMBER_ERROR, left);\n            }\n            break;\n        }\n        return;\n    } else if (type == Token.NEW) {\n      if (Token.NAME == left.getType()) {\n        String className = left.getString();\n        if (\"RegExp\".equals(className)) {\n          tryFoldRegularExpressionConstructor(t, n, parent);\n        } else if (left.getNext() == null) {\n          if (\"Array\".equals(className)) {\n            tryFoldLiteralConstructor(\n                t, n, parent, className, Token.ARRAYLIT);\n          } else if (\"Object\".equals(className)) {\n            tryFoldLiteralConstructor(\n                t, n, parent, className, Token.OBJECTLIT);\n          }\n        }\n      }\n    }\n\n    if (type == Token.EXPR_RESULT) {\n      tryMinimizeCondition(t, left, n);\n      return;\n    }\n\n    if (type == Token.RETURN) {\n      tryReduceReturn(t, n);\n      return;\n    }\n\n    Node right = left.getNext();\n    if (right == null) {\n      return;\n    }\n\n    // TODO(johnlenz) Use type information if available to fold\n    // instanceof.\n    if (type == Token.INSTANCEOF\n        && NodeUtil.isLiteralValue(left)\n        && !NodeUtil.mayHaveSideEffects(right)) {\n      if (NodeUtil.isImmutableValue(left)) {\n        // Non-object types are never instances.\n        parent.replaceChild(n, new Node(Token.FALSE));\n        t.getCompiler().reportCodeChange();\n        return;\n      }\n\n      if (right.getType() == Token.NAME\n          && \"Object\".equals(right.getString())) {\n        parent.replaceChild(n, new Node(Token.TRUE));\n        t.getCompiler().reportCodeChange();\n        return;\n      }\n    }\n\n    if (type == Token.IF || type == Token.HOOK) {\n      tryMinimizeCondition(t, n.getFirstChild(), n);\n      boolean changes = tryFoldHookIf(t, n, parent);\n\n      // bad cascades can occur if we run the second round\n      // of IF optimizations immediately\n      if (type == Token.IF && !changes) {\n        tryMinimizeIf(t, n, parent);\n      }\n      return;\n    }\n\n    if (type == Token.DO) {\n      tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);\n      tryFoldDo(t, n, parent);\n      return;\n    }\n\n    if (type == Token.WHILE) {\n      tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);\n      tryFoldWhile(t, n, parent);\n      return;\n    }\n\n    if (type == Token.FOR) {\n      Node condition = NodeUtil.getConditionExpression(n);\n      if (condition != null) {\n        tryMinimizeCondition(t, condition, n);\n        // The root condition node might have changed, get it again.\n        condition = NodeUtil.getConditionExpression(n);\n        this.tryFoldForCondition(condition, n);\n      }\n        \n      tryFoldFor(t, n, parent);\n      return;\n    }\n\n    if (type == Token.AND ||\n        type == Token.OR) {\n      tryFoldAndOr(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.BITOR ||\n        type == Token.BITAND) {\n      tryFoldBitAndOr(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.LSH ||\n        type == Token.RSH ||\n        type == Token.URSH) {\n      tryFoldShift(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.GETPROP) {\n      tryFoldGetProp(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.CALL) {\n      tryFoldStringJoin(t, n, left, right, parent);\n      tryFoldStringIndexOf(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.ASSIGN) {\n      tryFoldAssign(t, n, left, right);\n    }\n\n    if (!NodeUtil.isLiteralValue(left) ||\n        !NodeUtil.isLiteralValue(right)) {\n\n      if (type == Token.ADD)\n        tryFoldLeftChildAdd(t, n, left, right, parent);\n\n      if (type == Token.LT ||\n          type == Token.GT) {\n        tryFoldComparison(t, n, left, right, parent);\n      }\n\n      return; // The subsequent ops only work if the LHS & RHS are consts\n    }\n\n    if (type == Token.ADD) {\n      tryFoldAdd(t, n, left, right, parent);\n      return;\n    }\n    if (type == Token.SUB ||\n        type == Token.MUL ||\n        type == Token.DIV) {\n      tryFoldArithmetic(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.LT ||\n        type == Token.GT ||\n        type == Token.LE ||\n        type == Token.GE ||\n        type == Token.EQ ||\n        type == Token.NE ||\n        type == Token.SHEQ ||\n        type == Token.SHNE) {\n      tryFoldComparison(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.GETELEM) {\n      tryFoldGetElem(t, n, left, right, parent);\n      return;\n    }\n\n    // other types aren't handled\n  }", "error": "  private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) {\n    t.getCompiler().report(JSError.make(t, n, diagnostic, n.toString()));\n  }", "consumesDanglingElse": "  private boolean consumesDanglingElse(Node n) {\n    while (true) {\n      switch (n.getType()) {\n        case Token.IF:\n          if (n.getChildCount() < 3) return true;\n          // This IF node has no else clause.\n          n = n.getLastChild();\n          continue;\n        case Token.WITH:\n        case Token.WHILE:\n        case Token.FOR:\n          n = n.getLastChild();\n          continue;\n        default:\n          return false;\n      }\n    }\n  }", "tryFoldAssign": "  private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return;\n    }\n\n    if (NodeUtil.mayHaveSideEffects(left)) {\n      return;\n    }\n\n    Node leftChild = right.getFirstChild();\n    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n      return;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return;\n    }\n\n    n.getParent().replaceChild(n, new Node(newType,\n        left.detachFromParent(), right.getLastChild().detachFromParent()));\n    t.getCompiler().reportCodeChange();\n  }", "tryFoldBlock": "  void tryFoldBlock(NodeTraversal t, Node n, Node parent) {\n    // Remove any useless children\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext();  // save c.next, since 'c' may be removed\n      if (!NodeUtil.mayHaveSideEffects(c)) {\n        n.removeChild(c);  // lazy kids\n        t.getCompiler().reportCodeChange();\n      }\n      c = next;\n    }\n\n    if (n.isSyntheticBlock() || parent == null) {\n      return;\n    }\n\n    // Try to remove the block.\n    if (NodeUtil.tryMergeBlock(n)) {\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryFoldHookIf": "  boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) {\n    int type = n.getType();\n    Node cond = n.getFirstChild();\n    Node thenBody = cond.getNext();\n    Node elseBody = thenBody.getNext();\n\n    boolean changes = false;\n\n    if (type == Token.IF) {\n      // if (x) { .. } else { } --> if (x) { ... }\n      if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {\n        n.removeChild(elseBody);\n        elseBody = null;\n        t.getCompiler().reportCodeChange();\n        changes = true;\n      }\n\n      // if (x) { } else { ... } --> if (!x) { ... }\n      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {\n        n.removeChild(elseBody);\n        n.replaceChild(thenBody, elseBody);\n        Node notCond = new Node(Token.NOT);\n        n.replaceChild(cond, notCond);\n        notCond.addChildToFront(cond);\n        cond = notCond;\n        thenBody = cond.getNext();\n        elseBody = null;\n        t.getCompiler().reportCodeChange();\n        changes = true;\n      }\n\n      // if (x()) { }\n      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {\n        if (NodeUtil.mayHaveSideEffects(cond)) {\n          // x() has side effects, just leave the condition on its own.\n          n.removeChild(cond);\n          parent.replaceChild(n, NodeUtil.newExpr(cond));\n        } else {\n          // x() has no side effects, the whole tree is useless now.\n          NodeUtil.removeChild(parent, n);\n        }\n        t.getCompiler().reportCodeChange();\n        return true; // The if has been removed. There is nothing to do.\n      }\n    } else {\n      Preconditions.checkState(type == Token.HOOK);\n      if (NodeUtil.isExpressionNode(parent)) {\n        // Try to remove useless nodes.\n        if (!NodeUtil.mayHaveSideEffects(thenBody)) {\n          // x?void 0:y --> if(!x)y\n          Node ifNode = new Node(Token.IF);\n          if (cond.getType() == Token.NOT) {\n            Node expr = cond.getFirstChild();\n            cond.removeChild(expr);\n            ifNode.addChildToBack(expr);\n          } else {\n            Node not = new Node(Token.NOT);\n            n.removeChild(cond);\n            not.addChildToBack(cond);\n            ifNode.addChildToBack(not);\n          }\n\n          n.removeChild(elseBody);\n          ifNode.addChildToBack(\n              new Node(Token.BLOCK, NodeUtil.newExpr(elseBody)));\n          parent.getParent().replaceChild(parent, ifNode);\n          t.getCompiler().reportCodeChange();\n          return true;\n        } else if (!NodeUtil.mayHaveSideEffects(elseBody)) {\n          // x?y:void 0 --> if(x)y\n          Node ifNode = new Node(Token.IF);\n          n.removeChild(cond);\n          ifNode.addChildToBack(cond);\n          n.removeChild(thenBody);\n\n          ifNode.addChildToBack(\n              new Node(Token.BLOCK, NodeUtil.newExpr(thenBody)));\n          parent.getParent().replaceChild(parent, ifNode);\n          t.getCompiler().reportCodeChange();\n          return true;\n        }\n      }\n    }\n\n    // Try transforms that apply to both IF and HOOK.\n    if (!NodeUtil.isLiteralValue(cond)) {\n      return changes;  // We can't remove branches otherwise!\n    }\n\n    boolean condTrue = NodeUtil.getBooleanValue(cond);\n\n    if (n.getChildCount() == 2) {\n      Preconditions.checkState(type == Token.IF);\n\n      if (condTrue) {\n        // Replace \"if (true) { X }\" with \"X\".\n        Node thenStmt = n.getFirstChild().getNext();\n        n.removeChild(thenStmt);\n        parent.replaceChild(n, thenStmt);\n        t.getCompiler().reportCodeChange();\n      } else {\n        // Replace \"if (false) { X }\" with empty node.\n        NodeUtil.redeclareVarsInsideBranch(n);\n        NodeUtil.removeChild(parent, n);\n        t.getCompiler().reportCodeChange();\n      }\n    } else {\n      // Replace \"if (true) { X } else { Y }\" with X, or\n      // replace \"if (false) { X } else { Y }\" with Y.\n      Node firstBranch = n.getFirstChild().getNext();\n      Node secondBranch = firstBranch.getNext();\n      Node branch = condTrue ? firstBranch : secondBranch;\n      Node notBranch = condTrue ? secondBranch : firstBranch;\n      NodeUtil.redeclareVarsInsideBranch(notBranch);\n      n.removeChild(branch);\n      parent.replaceChild(n, branch);\n      t.getCompiler().reportCodeChange();\n    }\n    return true;\n  }", "tryMinimizeNot": "  private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) {\n    Node notChild = n.getFirstChild();\n    // negative operator of the current one : == -> != for instance.\n    int complementOperator;\n    switch (notChild.getType()) {\n      case Token.EQ:\n        complementOperator = Token.NE;\n        break;\n      case Token.NE:\n        complementOperator = Token.EQ;\n        break;\n      case Token.SHEQ:\n        complementOperator = Token.SHNE;\n        break;\n      case Token.SHNE:\n        complementOperator = Token.SHEQ;\n        break;\n      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n      default:\n        return false;\n    }\n    Node newOperator = n.removeFirstChild();\n    newOperator.setType(complementOperator);\n    parent.replaceChild(n, newOperator);\n    t.getCompiler().reportCodeChange();\n    return true;\n  }", "tryMinimizeIf": "  void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {\n    Node cond = n.getFirstChild();\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (isPropertyAssignmentInExpression(t, expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          return;\n        }\n\n        if (cond.getType() == Token.NOT) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(t, expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return;\n          }\n\n          Node or = new Node(Token.OR, cond.removeFirstChild(),\n              expr.removeFirstChild());\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          t.getCompiler().reportCodeChange();\n\n          return;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) ||\n            isLowerPrecedenceInExpression(t, expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses isn't worth it.\n          return;\n        }\n\n        n.removeChild(cond);\n        Node and = new Node(Token.AND, cond, expr.removeFirstChild());\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        t.getCompiler().reportCodeChange();\n      }\n\n      return;\n    }\n\n    tryRemoveRepeatedStatements(t, n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      t.getCompiler().reportCodeChange();\n      return;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);\n      Node returnNode = new Node(Token.RETURN, hookNode);\n      parent.replaceChild(n, returnNode);\n      t.getCompiler().reportCodeChange();\n      return;\n    }\n\n    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !NodeUtil.mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = new Node(Token.HOOK, cond, thenExpr,\n                elseExpr);\n            Node assign = new Node(thenOp.getType(), assignName,\n                hookNode);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            t.getCompiler().reportCodeChange();\n          }\n        } else if (NodeUtil.isCall(thenOp)) {\n          // if(x)foo();else bar(); -> x?foo():bar()\n          n.removeChild(cond);\n          thenOp.detachFromParent();\n          elseOp.detachFromParent();\n          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp);\n          Node expr = NodeUtil.newExpr(hookNode);\n          parent.replaceChild(n, expr);\n          t.getCompiler().reportCodeChange();\n        }\n      }\n      return;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.getType() == Token.NAME\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        t.getCompiler().reportCodeChange();\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.getType() == Token.NAME\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        t.getCompiler().reportCodeChange();\n      }\n    }\n  }", "tryRemoveRepeatedStatements": "  private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) {\n    Preconditions.checkState(n.getType() == Token.IF);\n\n    Node parent = n.getParent();\n    if (!NodeUtil.isStatementBlock(parent)) {\n      // If the immediate parent is something like a label, we\n      // can't move the statement, so bail.\n      return;\n    }\n\n    Node cond = n.getFirstChild();\n    Node trueBranch = cond.getNext();\n    Node falseBranch = trueBranch.getNext();\n    Preconditions.checkNotNull(trueBranch);\n    Preconditions.checkNotNull(falseBranch);\n\n    while (true) {\n      Node lastTrue = trueBranch.getLastChild();\n      Node lastFalse = falseBranch.getLastChild();\n      if (lastTrue == null || lastFalse == null\n          || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) {\n        break;\n      }\n      lastTrue.detachFromParent();\n      lastFalse.detachFromParent();\n      parent.addChildAfter(lastTrue, n);\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryReduceReturn": "  private void tryReduceReturn(NodeTraversal t, Node n) {\n    Node result = n.getFirstChild();\n    if (result != null) {\n      switch (result.getType()) {\n        case Token.VOID:\n          Node operand = result.getFirstChild();\n          if (!NodeUtil.mayHaveSideEffects(operand)) {\n            n.removeFirstChild();\n            t.getCompiler().reportCodeChange();\n          }\n          return;\n        case Token.NAME:\n          String name = result.getString();\n          if (name.equals(\"undefined\")) {\n            n.removeFirstChild();\n            t.getCompiler().reportCodeChange();\n          }\n          return;\n      }\n    }\n  }", "isPropertyAssignmentInExpression": "  private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) {\n    final boolean[] found = { false };\n    new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() {\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        found[0] |= (n.getType() == Token.GETPROP &&\n                     parent.getType() == Token.ASSIGN);\n      }\n    }).traverse(n);\n    return found[0];\n  }", "isLowerPrecedenceInExpression": "  private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n,\n      final int precedence) {\n    final boolean[] lower = { false };\n    new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() {\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        lower[0] |= NodeUtil.precedence(n.getType()) < precedence;\n      }\n    }).traverse(n);\n    return lower[0];\n  }", "tryFoldAndOr": "  void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right,\n                    Node parent) {\n    Node result = null;\n\n    int type = n.getType();\n    if (NodeUtil.isLiteralValue(left)) {\n      boolean lval = NodeUtil.getBooleanValue(left);\n\n      // (TRUE || x) => TRUE (also, (3 || x) => 3)\n      // (FALSE && x) => FALSE\n      if (lval && type == Token.OR ||\n          !lval && type == Token.AND) {\n        result = left;\n\n      } else {\n        // (FALSE || x) => x\n        // (TRUE && x) => x\n        result = right;\n      }\n    } else if (NodeUtil.isLiteralValue(right)) {\n      // Note: We cannot always fold when the constant is on the\n      // right, because the typed value of the expression will depend\n      // on the type of the constant on the right, even if the boolean\n      // equivalent of the value does not. Specifically, in \"a = x ||\n      // 0\", a will be numeric 0 if x is undefined (and hence is\n      // e.g. a valid array index). However, it is safe to fold\n      // e.g. \"if (x || true)\" because 'if' doesn't care if the\n      // expression is 'true' or '3'.\n      int pt = parent.getType();\n      if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO ||\n          (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||\n          (pt == Token.HOOK && parent.getFirstChild() == n)) {\n        boolean rval = NodeUtil.getBooleanValue(right);\n\n        // (x || FALSE) => x\n        // (x && TRUE) => x\n        if (type == Token.OR && !rval ||\n            type == Token.AND && rval) {\n          result = left;\n        } else {\n          // If x has no side-effects:\n          //   (x || TRUE) => TRUE\n          //   (x && FALSE) => FALSE\n          if (!NodeUtil.mayHaveSideEffects(left)) {\n            result = right;\n          }\n        }\n      }\n    }\n\n    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so\n    // there is not much need to worry about const values on left's\n    // right child.\n\n    if (result != null) {\n      // Fold it!\n      n.removeChild(result);\n      parent.replaceChild(n, result);\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryFoldLeftChildAdd": "  void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right,\n                           Node parent) {\n\n    if (NodeUtil.isLiteralValue(right) &&\n        left.getType() == Token.ADD &&\n        left.getChildCount() == 2) {\n\n      Node ll = left.getFirstChild();\n      Node lr = ll.getNext();\n\n      // Left's right child MUST be a string. We would not want to fold\n      // foo() + 2 + 'a' because we don't know what foo() will return, and\n      // therefore we don't know if left is a string concat, or a numeric add.\n      if (lr.getType() != Token.STRING)\n        return;\n\n      String leftString = NodeUtil.getStringValue(lr);\n      String rightString = NodeUtil.getStringValue(right);\n      if (leftString != null && rightString != null) {\n        left.removeChild(ll);\n        String result = leftString + rightString;\n        n.replaceChild(left, ll);\n        n.replaceChild(right, Node.newString(result));\n        t.getCompiler().reportCodeChange();\n      }\n    }\n  }", "tryFoldAdd": "  void tryFoldAdd(NodeTraversal t, Node n, Node left, Node right,\n                  Node parent) {\n    if (left.getType() == Token.STRING ||\n        right.getType() == Token.STRING) {\n\n      // Add strings.\n      String leftString = NodeUtil.getStringValue(left);\n      String rightString = NodeUtil.getStringValue(right);\n      if (leftString != null && rightString != null) {\n        parent.replaceChild(n, Node.newString(leftString + rightString));\n        t.getCompiler().reportCodeChange();\n      }\n    } else {\n      // Try arithmetic add\n      tryFoldArithmetic(t, n, left, right, parent);\n    }\n  }", "tryFoldArithmetic": "  void tryFoldArithmetic(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      switch (n.getType()) {\n        case Token.ADD:\n          result = lval + rval;\n          break;\n        case Token.SUB:\n          result = lval - rval;\n          break;\n        case Token.MUL:\n          result = lval * rval;\n          break;\n        case Token.DIV:\n          if (rval == 0) {\n            error(t, DIVIDE_BY_0_ERROR, right);\n            return;\n          }\n          result = lval / rval;\n          break;\n        default:\n          throw new Error(\"Unknown arithmetic operator\");\n      }\n\n      // length of the left and right value plus 1 byte for the operator.\n      if (String.valueOf(result).length() <=\n          String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n        parent.replaceChild(n, Node.newNumber(result));\n        t.getCompiler().reportCodeChange();\n      }\n   }\n  }", "tryFoldBitAndOr": "  void tryFoldBitAndOr(NodeTraversal t, Node n, Node left, Node right,\n                       Node parent) {\n\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // For now, we are being extra conservative, and only folding ints in\n      // the range MIN_VALUE-MAX_VALUE\n      if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n          rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n\n        // Fall back through and let the javascript use the larger values\n        return;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        return;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.BITAND:\n          result = lvalInt & rvalInt;\n          break;\n        case Token.BITOR:\n          result = lvalInt | rvalInt;\n          break;\n        default:\n          throw new Error(\"Unknown bitwise operator\");\n      }\n      parent.replaceChild(n, Node.newNumber(result));\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryFoldShift": "  void tryFoldShift(NodeTraversal t, Node n, Node left, Node right,\n                    Node parent) {\n\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // check ranges.  We do not do anything that would clip the double to\n      // a 32-bit range, since the user likely does not intend that.\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return;\n      }\n\n      // only the lower 5 bits are used when shifting, so don't do anything\n      // if the shift amount is outside [0,32)\n      if (!(rval >= 0 && rval < 32)) {\n        error(t, SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        error(t, FRACTIONAL_BITWISE_OPERAND, left);\n        return;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        error(t, FRACTIONAL_BITWISE_OPERAND, right);\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.LSH:\n          result = lvalInt << rvalInt;\n          break;\n        case Token.RSH:\n          result = lvalInt >> rvalInt;\n          break;\n        case Token.URSH:\n          result = lvalInt >>> rvalInt;\n          break;\n        default:\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n      }\n      parent.replaceChild(n, Node.newNumber(result));\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryFoldComparison": "  void tryFoldComparison(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n\n    int op = n.getType();\n    boolean result;\n\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n\n    boolean rightLiteral = NodeUtil.isLiteralValue(right);\n    boolean undefinedRight = ((Token.NAME == right.getType()\n          && right.getString().equals(\"undefined\"))\n          || (Token.VOID == right.getType()\n              && NodeUtil.isLiteralValue(right.getFirstChild())));\n\n    switch (left.getType()) {\n      case Token.VOID:\n        if (!NodeUtil.isLiteralValue(left.getFirstChild())) {\n          return;\n        } else if (!rightLiteral) {\n          return;\n        } else {\n          boolean nullRight = (Token.NULL == right.getType());\n          boolean equivalent = undefinedRight || nullRight;\n          switch (op) {\n            case Token.EQ:\n              // undefined is only equal to\n              result = equivalent;\n              break;\n            case Token.NE:\n              result = !equivalent;\n              break;\n            case Token.SHEQ:\n              result = undefinedRight;\n              break;\n            case Token.SHNE:\n              result = !undefinedRight;\n              break;\n            case Token.LT:\n            case Token.GT:\n            case Token.LE:\n            case Token.GE:\n              result = false;\n              break;\n            default:\n              return;\n          }\n        }\n        break;\n\n      case Token.NULL:\n        if (undefinedRight) {\n          result = (op == Token.EQ);\n          break;\n        }\n        // fall through\n      case Token.TRUE:\n      case Token.FALSE:\n        if (undefinedRight) {\n          result = false;\n          break;\n        }\n        // fall through\n      case Token.THIS:\n        int tt = right.getType();\n        if (tt != Token.THIS &&\n            tt != Token.TRUE &&\n            tt != Token.FALSE &&\n            tt != Token.NULL)\n          return;\n        switch (op) {\n          case Token.EQ:\n            result = left.getType() == right.getType();\n            break;\n\n          case Token.NE:\n            result = left.getType() != right.getType();\n            break;\n\n          default:\n            return;  // we only handle == and != here\n        }\n        break;\n\n      case Token.STRING:\n        if (undefinedRight) {\n          result = false;\n          break;\n        }\n        if (Token.STRING != right.getType()) {\n          return;  // Only eval if they are the same type\n        }\n        switch (op) {\n          case Token.EQ:\n            result = left.getString().equals(right.getString());\n            break;\n\n          case Token.NE:\n            result = !left.getString().equals(right.getString());\n            break;\n\n          default:\n            return;  // we only handle == and != here\n        }\n        break;\n\n      case Token.NUMBER:\n        if (undefinedRight) {\n          result = false;\n          break;\n        }\n        if (Token.NUMBER != right.getType()) {\n          return;  // Only eval if they are the same type\n        }\n        double lv = left.getDouble();\n        double rv = right.getDouble();\n\n        switch (op) {\n          case Token.EQ: result = lv == rv; break;\n          case Token.NE: result = lv != rv; break;\n          case Token.LE: result = lv <= rv; break;\n          case Token.LT: result = lv <  rv; break;\n          case Token.GE: result = lv >= rv; break;\n          case Token.GT: result = lv >  rv; break;\n          default:\n            return;  // don't handle that op\n        }\n        break;\n\n      case Token.NAME:\n        if (rightLiteral) {\n          boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n          if (undefinedLeft) {\n            boolean nullRight = (Token.NULL == right.getType());\n            boolean equivalent = undefinedRight || nullRight;\n            switch (op) {\n              case Token.EQ:\n                // undefined is only equal to\n                result = equivalent;\n                break;\n              case Token.NE:\n                result = !equivalent;\n                break;\n              case Token.SHEQ:\n                result = undefinedRight;\n                break;\n              case Token.SHNE:\n                result = !undefinedRight;\n                break;\n              case Token.LT:\n              case Token.GT:\n              case Token.LE:\n              case Token.GE:\n                result = false;\n                break;\n              default:\n                return;\n            }\n            break;\n          }\n        }\n\n        if (Token.NAME != right.getType()) {\n          return;  // Only eval if they are the same type\n        }\n        String ln = left.getString();\n        String rn = right.getString();\n        if (!ln.equals(rn)) {\n          return;  // Not the same value name.\n        }\n\n        switch (op) {\n          // If we knew the named value wouldn't be NaN, it would be nice\n          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n          case Token.LT:\n          case Token.GT:\n            result = false;\n            break;\n          default:\n            return;  // don't handle that op\n        }\n        break;\n\n      default:\n        // assert, this should cover all consts\n        return;\n    }\n\n    parent.replaceChild(n, new Node(result ? Token.TRUE :\n                                    Token.FALSE));\n    t.getCompiler().reportCodeChange();\n  }", "tryFoldStringIndexOf": "  void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,\n                            Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node lstringNode = left.getFirstChild();\n    Node functionName = lstringNode.getNext();\n\n    if ((lstringNode.getType() != Token.STRING) ||\n        (!functionName.getString().equals(\"indexOf\") &&\n        !functionName.getString().equals(\"lastIndexOf\"))) {\n      return;\n    }\n\n    String lstring = NodeUtil.getStringValue(lstringNode);\n    boolean isIndexOf = functionName.getString().equals(\"indexOf\");\n    Node firstArg = right;\n    Node secondArg = right.getNext();\n    String searchValue = NodeUtil.getStringValue(firstArg);\n    // searchValue must be a valid string.\n    if (searchValue == null) {\n      return;\n    }\n    int fromIndex = isIndexOf ? 0 : lstring.length();\n    if (secondArg != null) {\n      // Third-argument and non-numeric second arg are problematic. Discard.\n      if ((secondArg.getNext() != null) ||\n          (secondArg.getType() != Token.NUMBER)) {\n        return;\n      } else {\n        fromIndex = (int) secondArg.getDouble();\n      }\n    }\n    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n                             : lstring.lastIndexOf(searchValue, fromIndex);\n    Node newNode = Node.newNumber(indexVal);\n    parent.replaceChild(n, newNode);\n\n    t.getCompiler().reportCodeChange();\n  }", "tryFoldStringJoin": "  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    int foldedSize = 0;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb.length() > 0) {\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder();\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n\n    if (sb.length() > 0) {\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        break;\n\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\"), foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        parent.replaceChild(n, foldedStringNode);\n        break;\n\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }", "tryFoldGetElem": "  void tryFoldGetElem(NodeTraversal t, Node n, Node left, Node right,\n                      Node parent) {\n    if (left.getType() == Token.ARRAYLIT) {\n\n      if (right.getType() != Token.NUMBER) {\n        // Sometimes people like to use complex expressions to index into\n        // arrays, or strings to index into array methods.\n        return;\n      }\n\n      double index = right.getDouble();\n      int intIndex = (int) index;\n      if (intIndex != index) {\n        t.getCompiler().report(JSError.make(t, right,\n            INVALID_GETELEM_INDEX_ERROR, String.valueOf(index)));\n        return;\n      }\n\n      if (intIndex < 0) {\n        t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR,\n            String.valueOf(intIndex)));\n        return;\n      }\n\n      Node elem = left.getFirstChild();\n      for (int i = 0; elem != null && i < intIndex; i++) {\n        elem = elem.getNext();\n      }\n\n      if (elem == null) {\n        t.getCompiler().report(JSError.make(t, n, INDEX_OUT_OF_BOUNDS_ERROR,\n            String.valueOf(intIndex)));\n        return;\n      }\n\n      // Replace the entire GETELEM with the value\n      left.removeChild(elem);\n      parent.replaceChild(n, elem);\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryFoldGetProp": "  void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,\n                      Node parent) {\n    if (right.getType() == Token.STRING &&\n        right.getString().equals(\"length\")) {\n      int knownLength = -1;\n      switch (left.getType()) {\n        case Token.ARRAYLIT:\n          if (NodeUtil.mayHaveSideEffects(left)) {\n            // Nope, can't fold this, without handling the side-effects.\n            return;\n          }\n          knownLength = left.getChildCount();\n          break;\n        case Token.STRING:\n          knownLength = left.getString().length();\n          break;\n        default:\n          // Not a foldable case, forget it.\n          return;\n      }\n\n      Preconditions.checkState(knownLength != -1);\n      Node lengthNode = Node.newNumber(knownLength);\n      parent.replaceChild(n, lengthNode);\n      t.getCompiler().reportCodeChange();\n    }\n  }", "tryFoldRegularExpressionConstructor": "  void tryFoldRegularExpressionConstructor(\n      NodeTraversal t, Node n, Node parent) {\n    Node constructor = n.getFirstChild();\n    Node pattern = constructor.getNext();  // e.g.  ^foobar$\n    Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n\n    if (null == pattern || (null != flags && null != flags.getNext())) {\n      // too few or too many arguments\n      return;\n    }\n\n    if (// is pattern folded\n        pattern.getType() == Token.STRING\n        // make sure empty pattern doesn't fold to //\n        && !\"\".equals(pattern.getString())\n\n        // NOTE(nicksantos): Make sure that the regexp isn't longer than\n        // 100 chars, or it blows up the regexp parser in Opera 9.2.\n        && pattern.getString().length() < 100\n\n        && (null == flags || flags.getType() == Token.STRING)\n        // don't escape patterns with unicode escapes since Safari behaves badly\n        // (read can't parse or crashes) on regex literals with unicode escapes\n        && !containsUnicodeEscape(pattern.getString())) {\n\n      // Make sure that / is escaped, so that it will fit safely in /brackets/.\n      // pattern is a string value with \\\\ and similar already escaped\n      pattern = makeForwardSlashBracketSafe(pattern);\n\n      Node regexLiteral;\n      if (null == flags || \"\".equals(flags.getString())) {\n        // fold to /foobar/\n        regexLiteral = new Node(Token.REGEXP, pattern);\n      } else {\n        // fold to /foobar/gi\n        if (!areValidRegexpFlags(flags.getString())) {\n          error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n          return;\n        }\n        if (!areSafeFlagsToFold(flags.getString())) {\n          return;\n        }\n        n.removeChild(flags);\n        regexLiteral = new Node(Token.REGEXP, pattern, flags);\n      }\n\n      parent.replaceChild(n, regexLiteral);\n      t.getCompiler().reportCodeChange();\n    }\n  }", "areSafeFlagsToFold": "  private static boolean areSafeFlagsToFold(String flags) {\n    return flags.indexOf('g') < 0;\n  }", "makeForwardSlashBracketSafe": "  private static Node makeForwardSlashBracketSafe(Node n) {\n    String s = n.getString();\n    // sb contains everything in s[0:pos]\n    StringBuilder sb = null;\n    int pos = 0;\n    for (int i = 0; i < s.length(); ++i) {\n      switch (s.charAt(i)) {\n        case '\\\\':  // skip over the next char after a '\\\\'.\n          ++i;\n          break;\n        case '/':  // escape it\n          if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n          sb.append(s, pos, i).append('\\\\');\n          pos = i;\n          break;\n      }\n    }\n\n    // don't discard useful line-number info if there were no changes\n    if (null == sb) { return n.cloneTree(); }\n\n    sb.append(s, pos, s.length());\n    return Node.newString(sb.toString());\n  }", "tryFoldLiteralConstructor": "  void tryFoldLiteralConstructor(\n      NodeTraversal t, Node n, Node parent, String className, int type) {\n    // Ignore calls to local functions with the same name.\n    Scope.Var var = t.getScope().getVar(className);\n    if (var != null && var.isLocal()) {\n      return;\n    }\n\n    Node literalNode = new Node(type);\n    parent.replaceChild(n, literalNode);\n    t.getCompiler().reportCodeChange();\n  }", "containsUnicodeEscape": "  static boolean containsUnicodeEscape(String s) {\n    String esc = CodeGenerator.regexpEscape(s);\n    for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n      int nSlashes = 0;\n      while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n        ++nSlashes;\n      }\n      // if there are an even number of slashes before the \\ u then it is a\n      // unicode literal.\n      if (0 == (nSlashes & 1)) { return true; }\n    }\n    return false;\n  }", "tryFoldWhile": "  void tryFoldWhile(NodeTraversal t, Node n, Node parent) {\n    Preconditions.checkArgument(n.getType() == Token.WHILE);\n    Node cond = NodeUtil.getConditionExpression(n);\n    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {\n      return;\n    }\n    NodeUtil.redeclareVarsInsideBranch(n);\n    NodeUtil.removeChild(parent, n);\n    t.getCompiler().reportCodeChange();\n  }", "tryFoldFor": "  void tryFoldFor(NodeTraversal t, Node n, Node parent) {\n    Preconditions.checkArgument(n.getType() == Token.FOR);\n    // This is not a FOR-IN loop\n    if (n.getChildCount() != 4) return;\n    // There isn't an initializer\n    if (n.getFirstChild().getType() != Token.EMPTY) return;\n\n    Node cond = NodeUtil.getConditionExpression(n);\n    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {\n      return;\n    }\n    NodeUtil.redeclareVarsInsideBranch(n);\n    NodeUtil.removeChild(parent, n);\n    t.getCompiler().reportCodeChange();\n  }", "tryFoldDo": "  void tryFoldDo(NodeTraversal t, Node n, Node parent) {\n    Preconditions.checkArgument(n.getType() == Token.DO);\n\n    Node cond = NodeUtil.getConditionExpression(n);\n    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {\n      return;\n    }\n\n    // TODO(johnlenz): The do-while can be turned into a label with\n    // named breaks and the label optimized away (maybe).\n    if (hasBreakOrContinue(n)) {\n      return;\n    }\n\n    Preconditions.checkState(\n        NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));\n    Node block = n.removeFirstChild();\n\n    parent.replaceChild(n, block);\n    t.getCompiler().reportCodeChange();\n  }", "hasBreakOrContinue": "  boolean hasBreakOrContinue(Node n) {\n    // TODO(johnlenz): This is overkill as named breaks may refer to outer\n    // loops or labels, and any break my refer to an inner loop.\n    // More generally, this check may be more expensive than we like.\n    return NodeUtil.has(\n        n,\n        Predicates.<Node>or(\n            new NodeUtil.MatchNodeType(Token.BREAK),\n            new NodeUtil.MatchNodeType(Token.CONTINUE)),\n        Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));\n  }", "tryMinimizeCondition": "  void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              n = newRoot; // continue from here.\n              t.getCompiler().reportCodeChange();\n\n              // The child has moved up, to minimize it recurse.\n              tryMinimizeCondition(t, n, parent);\n              return;\n            }\n          case Token.AND:\n          case Token.OR: {\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              if (leftParent.getType() != Token.NOT\n                  || rightParent.getType() != Token.NOT) {\n                // No NOTs to elminate.\n                break;\n              }\n              Node left = leftParent.removeFirstChild();\n              Node right = rightParent.removeFirstChild();\n\n              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n              Node newRoot = new Node(newOp, left, right);\n              parent.replaceChild(n, newRoot);\n              n = newRoot; // continue from here.\n              t.getCompiler().reportCodeChange();\n\n              // Unlike the NOT case above, we know that AND and OR are\n              // valid root to check minimize so just break out and check\n              // the children.\n            }\n            break;\n        }\n        break;\n\n      case Token.OR:\n      case Token.AND:\n        // check the children.\n        break;\n\n      default:\n        // if(true) --> if(1)\n        if (NodeUtil.isLiteralValue(n)) {\n          boolean result = NodeUtil.getBooleanValue(n);\n          int equivalentResult = result ? 1 : 0;\n          maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext();  // c may be removed.\n      tryMinimizeCondition(t, c, n);\n      c = next;\n    }\n  }", "tryFoldForCondition": "  private void tryFoldForCondition(Node n, Node parent) {\n    if (NodeUtil.isLiteralValue(n)) {\n      boolean result = NodeUtil.getBooleanValue(n);\n      if (result) {\n        parent.replaceChild(n, new Node(Token.EMPTY));\n        compiler.reportCodeChange();\n      }\n    }\n  }", "maybeReplaceChildWithNumber": "  private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent,\n      int num) {\n    Node newNode = Node.newNumber(num);\n    if(!newNode.isEquivalentTo(n)) {\n      parent.replaceChild(n, newNode);\n      t.getCompiler().reportCodeChange();\n    }\n  }", "isExpressBlock": "  private boolean isExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        return NodeUtil.isExpressionNode(n.getFirstChild());\n      }\n    }\n\n    return false;\n  }", "getBlockExpression": "  private Node getBlockExpression(Node n) {\n    Preconditions.checkState(isExpressBlock(n));\n    return n.getFirstChild();\n  }", "isReturnExpressBlock": "  private boolean isReturnExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.getType() == Token.RETURN) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }", "getBlockReturnExpression": "  private Node getBlockReturnExpression(Node n) {\n    Preconditions.checkState(isReturnExpressBlock(n));\n    return n.getFirstChild().getFirstChild();\n  }", "getBlockVar": "  private Node getBlockVar(Node n) {\n    Preconditions.checkState(isVarBlock(n));\n    return n.getFirstChild();\n  }"}