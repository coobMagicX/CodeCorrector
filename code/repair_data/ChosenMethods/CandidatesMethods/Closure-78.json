{"optimizeSubtree": "  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.CALL:\n        return tryFoldKnownMethods(subtree);\n\n      case Token.NEW:\n        return tryFoldCtorCall(subtree);\n\n      case Token.TYPEOF:\n        return tryFoldTypeof(subtree);\n\n      case Token.NOT:\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldUnaryOperator(subtree);\n\n      case Token.VOID:\n        return tryReduceVoid(subtree);\n\n      default:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldBinaryOperator(subtree);\n    }\n  }", "tryFoldChildAddString": "  private Node tryFoldChildAddString(Node n, Node left, Node right) {\n\n    if (NodeUtil.isLiteralValue(right, false) &&\n        left.getType() == Token.ADD) {\n\n      Node ll = left.getFirstChild();\n      Node lr = ll.getNext();\n\n      // Left's right child MUST be a string. We would not want to fold\n      // foo() + 2 + 'a' because we don't know what foo() will return, and\n      // therefore we don't know if left is a string concat, or a numeric add.\n      if (lr.getType() == Token.STRING) {\n        String leftString = NodeUtil.getStringValue(lr);\n        String rightString = NodeUtil.getStringValue(right);\n        if (leftString != null && rightString != null) {\n          left.removeChild(ll);\n          String result = leftString + rightString;\n          n.replaceChild(left, ll);\n          n.replaceChild(right, Node.newString(result));\n          reportCodeChange();\n          return n;\n        }\n      }\n    }\n\n    if (NodeUtil.isLiteralValue(left, false) &&\n        right.getType() == Token.ADD) {\n\n      Node rl = right.getFirstChild();\n      Node rr = right.getLastChild();\n\n      // Left's right child MUST be a string. We would not want to fold\n      // foo() + 2 + 'a' because we don't know what foo() will return, and\n      // therefore we don't know if left is a string concat, or a numeric add.\n      if (rl.getType() == Token.STRING) {\n        String leftString = NodeUtil.getStringValue(left);\n        String rightString = NodeUtil.getStringValue(rl);\n        if (leftString != null && rightString != null) {\n          right.removeChild(rr);\n          String result = leftString + rightString;\n          n.replaceChild(right, rr);\n          n.replaceChild(left, Node.newString(result));\n          reportCodeChange();\n          return n;\n        }\n      }\n    }\n\n    return n;\n  }", "tryFoldAddConstantString": "  private Node tryFoldAddConstantString(Node n, Node left, Node right) {\n    if (left.getType() == Token.STRING ||\n        right.getType() == Token.STRING) {\n      // Add strings.\n      String leftString = NodeUtil.getStringValue(left);\n      String rightString = NodeUtil.getStringValue(right);\n      if (leftString != null && rightString != null) {\n        Node newStringNode = Node.newString(leftString + rightString);\n        n.getParent().replaceChild(n, newStringNode);\n        reportCodeChange();\n        return newStringNode;\n      }\n    }\n\n\n\n    return n;\n  }", "performArithmeticOp": "  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <=\n        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n  }", "tryFoldLeftChildOp": "  private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n    int opType = n.getType();\n    Preconditions.checkState(\n        (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n        || n.getType() == Token.ADD);\n\n    Preconditions.checkState(\n        n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n\n    // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n    // other values are converted to numbers elsewhere.\n    Double rightValObj = NodeUtil.getNumberValue(right);\n    if (rightValObj != null && left.getType() == opType) {\n      Preconditions.checkState(left.getChildCount() == 2);\n\n      Node ll = left.getFirstChild();\n      Node lr = ll.getNext();\n\n      Node valueToCombine = ll;\n      Node replacement = performArithmeticOp(opType, valueToCombine, right);\n      if (replacement == null) {\n        valueToCombine = lr;\n        replacement = performArithmeticOp(opType, valueToCombine, right);\n      }\n      if (replacement != null) {\n        // Remove the child that has been combined\n        left.removeChild(valueToCombine);\n        // Replace the left op with the remaining child.\n        n.replaceChild(left, left.removeFirstChild());\n        // New \"-Infinity\" node need location info explicitly\n        // added.\n        replacement.copyInformationFromForTree(right);\n        n.replaceChild(right, replacement);\n        reportCodeChange();\n      }\n    }\n\n    return n;\n  }", "tryFoldAdd": "  private Node tryFoldAdd(Node node, Node left, Node right) {\n    Preconditions.checkArgument(node.getType() == Token.ADD);\n\n    if (NodeUtil.mayBeString(node, true)) {\n      if (NodeUtil.isLiteralValue(left, false) &&\n          NodeUtil.isLiteralValue(right, false)) {\n        // '6' + 7\n        return tryFoldAddConstantString(node, left, right);\n      } else {\n        // a + 7 or 6 + a\n        return tryFoldChildAddString(node, left, right);\n      }\n    } else {\n      // Try arithmetic add\n      Node result = tryFoldArithmeticOp(node, left, right);\n      if (result != node) {\n        return result;\n      }\n      return tryFoldLeftChildOp(node, left, right);\n    }\n  }", "inForcedStringContext": "  private boolean inForcedStringContext(Node n) {\n    return n.getParent().getType() == Token.GETELEM &&\n        n.getParent().getLastChild() == n;\n  }", "tryFoldInForcedStringContext": "  private Node tryFoldInForcedStringContext(Node n) {\n    // For now, we only know how to fold ctors.\n    Preconditions.checkArgument(n.getType() == Token.NEW);\n\n    Node objectType = n.getFirstChild();\n    if (objectType.getType() != Token.NAME) {\n      return n;\n    }\n\n    if (objectType.getString().equals(\"String\")) {\n      Node value = objectType.getNext();\n      String stringValue = null;\n      if (value == null) {\n        stringValue = \"\";\n      } else {\n        if (!NodeUtil.isImmutableValue(value)) {\n          return n;\n        }\n\n        stringValue = NodeUtil.getStringValue(value);\n      }\n\n      if (stringValue == null) {\n        return n;\n      }\n\n      Node parent = n.getParent();\n      Node newString = Node.newString(stringValue);\n\n      parent.replaceChild(n, newString);\n      newString.copyInformationFrom(parent);\n      reportCodeChange();\n\n      return newString;\n    }\n    return n;\n  }", "tryFoldKnownStringMethods": "  private Node tryFoldKnownStringMethods(Node subtree) {\n    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n\n    // check if this is a call on a string method\n    // then dispatch to specific folding method.\n    Node callTarget = subtree.getFirstChild();\n    if (callTarget == null) {\n      return subtree;\n    }\n\n    if (!NodeUtil.isGet(callTarget)) {\n      return subtree;\n    }\n\n    Node stringNode = callTarget.getFirstChild();\n    Node functionName = stringNode.getNext();\n\n    if ((stringNode.getType() != Token.STRING) || (\n        (functionName.getType() != Token.STRING))) {\n      return subtree;\n    }\n\n    String functionNameString = functionName.getString();\n    Node firstArg = callTarget.getNext();\n    if (firstArg == null) {\n      if (functionNameString.equals(\"toLowerCase\")) {\n        subtree = tryFoldStringToLowerCase(subtree, stringNode);\n      } else if (functionNameString.equals(\"toUpperCase\")) {\n        subtree = tryFoldStringToUpperCase(subtree, stringNode);\n      }\n      return subtree;\n    } else if (NodeUtil.isImmutableValue(firstArg)) {\n      if (functionNameString.equals(\"indexOf\") ||\n          functionNameString.equals(\"lastIndexOf\")) {\n        subtree = tryFoldStringIndexOf(subtree, functionNameString,\n            stringNode, firstArg);\n      } else if (functionNameString.equals(\"substr\")) {\n        subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);\n      } else if (functionNameString.equals(\"substring\")) {\n        subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);\n      }\n    }\n\n    return subtree;\n  }", "tryFoldStringToLowerCase": "  private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n    // From Rhino, NativeString.java. See ECMA 15.5.4.11\n    String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE);\n    Node replacement = Node.newString(lowered);\n    subtree.getParent().replaceChild(subtree, replacement);\n    reportCodeChange();\n    return replacement;\n  }", "tryFoldStringToUpperCase": "  private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n    // From Rhino, NativeString.java. See ECMA 15.5.4.12\n    String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE);\n    Node replacement = Node.newString(uppered);\n    subtree.getParent().replaceChild(subtree, replacement);\n    reportCodeChange();\n    return replacement;\n  }", "tryFoldStringIndexOf": "  private Node tryFoldStringIndexOf(\n      Node n, String functionName, Node lstringNode, Node firstArg) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(lstringNode.getType() == Token.STRING);\n\n    String lstring = NodeUtil.getStringValue(lstringNode);\n    boolean isIndexOf = functionName.equals(\"indexOf\");\n    Node secondArg = firstArg.getNext();\n    String searchValue = NodeUtil.getStringValue(firstArg);\n    // searchValue must be a valid string.\n    if (searchValue == null) {\n      return n;\n    }\n    int fromIndex = isIndexOf ? 0 : lstring.length();\n    if (secondArg != null) {\n      // Third-argument and non-numeric second arg are problematic. Discard.\n      if ((secondArg.getNext() != null) ||\n          (secondArg.getType() != Token.NUMBER)) {\n        return n;\n      } else {\n        fromIndex = (int) secondArg.getDouble();\n      }\n    }\n    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n                             : lstring.lastIndexOf(searchValue, fromIndex);\n    Node newNode = Node.newNumber(indexVal);\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldStringSubstr": "  private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n\n    int start, length;\n    String stringAsString = stringNode.getString();\n\n    // TODO(nicksantos): We really need a NodeUtil.getNumberValue\n    // function.\n    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n      start = (int) arg1.getDouble();\n    } else {\n      return n;\n    }\n\n    Node arg2 = arg1.getNext();\n    if (arg2 != null) {\n      if (arg2.getType() == Token.NUMBER) {\n        length = (int) arg2.getDouble();\n      } else {\n        return n;\n      }\n\n      if (arg2.getNext() != null) {\n        // If we got more args than we expected, bail out.\n        return n;\n      }\n    } else {\n      // parameter 2 not passed\n      length = stringAsString.length() - start;\n    }\n\n    // Don't handle these cases. The specification actually does\n    // specify the behavior in some of these cases, but we haven't\n    // done a thorough investigation that it is correctly implemented\n    // in all browsers.\n    if ((start + length) > stringAsString.length() ||\n        (length < 0) ||\n        (start < 0)) {\n      return n;\n    }\n\n    String result = stringAsString.substring(start, start + length);\n    Node resultNode = Node.newString(result);\n\n    Node parent = n.getParent();\n    parent.replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n  }", "tryFoldStringSubstring": "  private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n\n    int start, end;\n    String stringAsString = stringNode.getString();\n\n    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n      start = (int) arg1.getDouble();\n    } else {\n      return n;\n    }\n\n    Node arg2 = arg1.getNext();\n    if (arg2 != null) {\n      if (arg2.getType() == Token.NUMBER) {\n        end = (int) arg2.getDouble();\n      } else {\n        return n;\n      }\n\n      if (arg2.getNext() != null) {\n        // If we got more args than we expected, bail out.\n        return n;\n      }\n    } else {\n      // parameter 2 not passed\n      end = stringAsString.length();\n    }\n\n    // Don't handle these cases. The specification actually does\n    // specify the behavior in some of these cases, but we haven't\n    // done a thorough investigation that it is correctly implemented\n    // in all browsers.\n    if ((end > stringAsString.length()) ||\n        (start > stringAsString.length()) ||\n        (end < 0) ||\n        (start < 0)) {\n      return n;\n    }\n\n    String result = stringAsString.substring(start, end);\n    Node resultNode = Node.newString(result);\n\n    Node parent = n.getParent();\n    parent.replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n  }"}