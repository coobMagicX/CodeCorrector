{"process": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }", "hotSwapScript": "  public void hotSwapScript(Node scriptRoot) {\n    NodeTraversal.traverse(compiler, scriptRoot, this);\n  }", "enterScope": "  public void enterScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth++;\n      }\n\n      if (methodDepth == 0) {\n        currentClass = getClassOfMethod(n, parent);\n      }\n      methodDepth++;\n    }\n  }", "exitScope": "  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth--;\n      }\n\n      methodDepth--;\n      if (methodDepth == 0) {\n        currentClass = null;\n      }\n    }\n  }", "getClassOfMethod": "  private JSType getClassOfMethod(Node n, Node parent) {\n    if (parent.getType() == Token.ASSIGN) {\n      Node lValue = parent.getFirstChild();\n      if (lValue.isQualifiedName()) {\n        if (lValue.getType() == Token.GETPROP) {\n          // We have an assignment of the form \"a.b = ...\".\n          JSType lValueType = lValue.getJSType();\n          if (lValueType != null && lValueType.isConstructor()) {\n            // If a.b is a constructor, then everything in this function\n            // belongs to the \"a.b\" type.\n            return ((FunctionType) lValueType).getInstanceType();\n          } else {\n            // If a.b is not a constructor, then treat this as a method\n            // of whatever type is on \"a\".\n            return normalizeClassType(lValue.getFirstChild().getJSType());\n          }\n        } else {\n          // We have an assignment of the form \"a = ...\", so pull the\n          // type off the \"a\".\n          return normalizeClassType(lValue.getJSType());\n        }\n      }\n    } else if (NodeUtil.isFunctionDeclaration(n) ||\n               parent.getType() == Token.NAME) {\n      return normalizeClassType(n.getJSType());\n    }\n\n    return null;\n  }", "normalizeClassType": "  private JSType normalizeClassType(JSType type) {\n    if (type == null || type.isUnknownType()) {\n      return type;\n    } else if (type.isConstructor()) {\n      return ((FunctionType) type).getInstanceType();\n    } else if (type.isFunctionPrototypeType()) {\n      FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n      if (owner.isConstructor()) {\n        return owner.getInstanceType();\n      }\n    }\n    return type;\n  }", "shouldTraverse": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }", "visit": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        checkNameDeprecation(t, n, parent);\n        checkNameVisibility(t, n, parent);\n        break;\n      case Token.GETPROP:\n        checkPropertyDeprecation(t, n, parent);\n        checkPropertyVisibility(t, n, parent);\n        checkConstantProperty(t, n);\n        break;\n      case Token.NEW:\n        checkConstructorDeprecation(t, n, parent);\n        break;\n    }\n  }", "checkConstructorDeprecation": "  private void checkConstructorDeprecation(NodeTraversal t, Node n,\n      Node parent) {\n    JSType type = n.getJSType();\n\n    if (type != null) {\n      String deprecationInfo = getTypeDeprecationInfo(type);\n\n      if (deprecationInfo != null &&\n          shouldEmitDeprecationWarning(t, n, parent)) {\n\n        if (!deprecationInfo.isEmpty()) {\n            compiler.report(\n                t.makeError(n, DEPRECATED_CLASS_REASON,\n                    type.toString(), deprecationInfo));\n        } else {\n          compiler.report(\n              t.makeError(n, DEPRECATED_CLASS, type.toString()));\n        }\n      }\n    }\n  }", "checkNameDeprecation": "  private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking definitions or constructors.\n    if (parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||\n        parent.getType() == Token.NEW) {\n      return;\n    }\n\n    Scope.Var var = t.getScope().getVar(n.getString());\n    JSDocInfo docInfo = var == null ? null : var.getJSDocInfo();\n\n    if (docInfo != null && docInfo.isDeprecated() &&\n        shouldEmitDeprecationWarning(t, n, parent)) {\n\n      if (docInfo.getDeprecationReason() != null) {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME_REASON, n.getString(),\n                docInfo.getDeprecationReason()));\n      } else {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME, n.getString()));\n      }\n    }\n  }", "checkPropertyDeprecation": "  private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking constructors.\n    if (parent.getType() == Token.NEW) {\n      return;\n    }\n\n    ObjectType objectType =\n        ObjectType.cast(dereference(n.getFirstChild().getJSType()));\n    String propertyName = n.getLastChild().getString();\n\n    if (objectType != null) {\n      String deprecationInfo\n          = getPropertyDeprecationInfo(objectType, propertyName);\n\n      if (deprecationInfo != null &&\n          shouldEmitDeprecationWarning(t, n, parent)) {\n\n        if (!deprecationInfo.isEmpty()) {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP_REASON, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true),\n                  deprecationInfo));\n        } else {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true)));\n        }\n      }\n    }\n  }", "checkNameVisibility": "  private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n    Var var = t.getScope().getVar(name.getString());\n    if (var != null) {\n      JSDocInfo docInfo = var.getJSDocInfo();\n      if (docInfo != null) {\n        // If a name is private, make sure that we're in the same file.\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE &&\n            !t.getInput().getName().equals(docInfo.getSourceName())) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          compiler.report(\n              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                  name.getString(), docInfo.getSourceName()));\n        }\n      }\n    }\n  }", "checkConstantProperty": "  private void checkConstantProperty(NodeTraversal t,\n      Node getprop) {\n    // Check whether the property is modified\n    Node parent = getprop.getParent();\n    if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n        && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {\n      return;\n    }\n\n    ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    // Check whether constant properties are reassigned\n    if (objectType != null) {\n      ObjectType oType = objectType;\n      while (oType != null) {\n        if (oType.hasReferenceName()) {\n          if (initializedConstantProperties.containsEntry(\n                  oType.getReferenceName(), propertyName)) {\n            compiler.report(\n                t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE,\n                    propertyName));\n            break;\n          }\n        }\n        oType = oType.getImplicitPrototype();\n      }\n\n      JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (info != null && info.isConstant()\n          && objectType.hasReferenceName()) {\n        initializedConstantProperties.put(objectType.getReferenceName(),\n            propertyName);\n      }\n\n      // Add the prototype when we're looking at an instance object\n      if (objectType.isInstanceType()) {\n        ObjectType prototype = objectType.getImplicitPrototype();\n        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }", "checkPropertyVisibility": "  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = t.inGlobalScope() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }", "isValidPrivateConstructorAccess": "  private static boolean isValidPrivateConstructorAccess(Node parent) {\n    return parent.getType() != Token.NEW;\n  }", "shouldEmitDeprecationWarning": "  private boolean shouldEmitDeprecationWarning(\n      NodeTraversal t, Node n, Node parent) {\n    // In the global scope, there are only two kinds of accesses that should\n    // be flagged for warnings:\n    // 1) Calls of deprecated functions and methods.\n    // 2) Instantiations of deprecated classes.\n    // For now, we just let everything else by.\n    if (t.inGlobalScope()) {\n      if (!((parent.getType() == Token.CALL && parent.getFirstChild() == n) ||\n              n.getType() == Token.NEW)) {\n        return false;\n      }\n    }\n\n    // We can always assign to a deprecated property, to keep it up to date.\n    if (n.getType() == Token.GETPROP && n == parent.getFirstChild() &&\n        NodeUtil.isAssignmentOp(parent)) {\n      return false;\n    }\n\n    return !canAccessDeprecatedTypes(t);\n  }", "canAccessDeprecatedTypes": "  private boolean canAccessDeprecatedTypes(NodeTraversal t) {\n    Node scopeRoot = t.getScopeRoot();\n    Node scopeRootParent = scopeRoot.getParent();\n    return\n      // Case #1\n      (deprecatedDepth > 0) ||\n      // Case #2\n      (getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null) ||\n        // Case #3\n      (scopeRootParent != null && scopeRootParent.getType() == Token.ASSIGN &&\n       getTypeDeprecationInfo(\n           getClassOfMethod(scopeRoot, scopeRootParent)) != null);\n  }", "isDeprecatedFunction": "  private static boolean isDeprecatedFunction(Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n      JSType type = n.getJSType();\n      if (type != null) {\n        return getTypeDeprecationInfo(type) != null;\n      }\n    }\n\n    return false;\n  }", "getTypeDeprecationInfo": "  private static String getTypeDeprecationInfo(JSType type) {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) {\n      ObjectType implicitProto = objType.getImplicitPrototype();\n      if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n      }\n    }\n    return null;\n  }", "getPropertyDeprecationInfo": "  private static String getPropertyDeprecationInfo(ObjectType type,\n                                                   String prop) {\n    JSDocInfo info = type.getOwnPropertyJSDocInfo(prop);\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    ObjectType implicitProto = type.getImplicitPrototype();\n    if (implicitProto != null) {\n      return getPropertyDeprecationInfo(implicitProto, prop);\n    }\n    return null;\n  }", "dereference": "  private static JSType dereference(JSType type) {\n    return type == null ? null : type.dereference();\n  }"}