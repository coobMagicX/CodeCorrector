{"getImpureBooleanValue": "  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }", "getPureBooleanValue": "  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }", "getStringValue": "  static String getStringValue(double value) {\n    long longValue = (long) value;\n\n    // Return \"1\" instead of \"1.0\"\n    if (longValue == value) {\n      return Long.toString(longValue);\n    } else {\n      return Double.toString(value);\n    }\n  }", "getArrayElementStringValue": "  static String getArrayElementStringValue(Node n) {\n    return (NodeUtil.isNullOrUndefined(n) || n.isEmpty())\n        ? \"\" : getStringValue(n);\n  }", "arrayToString": "  static String arrayToString(Node literal) {\n    Node first = literal.getFirstChild();\n    StringBuilder result = new StringBuilder();\n    int nextSlot = 0;\n    int nextSkipSlot = 0;\n    for (Node n = first; n != null; n = n.getNext()) {\n      String childValue = getArrayElementStringValue(n);\n      if (childValue == null) {\n        return null;\n      }\n      if (n != first) {\n        result.append(',');\n      }\n      result.append(childValue);\n\n      nextSlot++;\n    }\n    return result.toString();\n  }", "getNumberValue": "  static Double getNumberValue(Node n) {\n    switch (n.getType()) {\n      case Token.TRUE:\n        return 1.0;\n\n      case Token.FALSE:\n      case Token.NULL:\n        return 0.0;\n\n      case Token.NUMBER:\n        return n.getDouble();\n\n      case Token.VOID:\n        if (mayHaveSideEffects(n.getFirstChild())) {\n          return null;\n        } else {\n          return Double.NaN;\n        }\n\n      case Token.NAME:\n        // Check for known constants\n        String name = n.getString();\n        if (name.equals(\"undefined\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"NaN\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"Infinity\")) {\n          return Double.POSITIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NEG:\n        if (n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\")) {\n          return Double.NEGATIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.\n        }\n        break;\n\n      case Token.STRING:\n        return getStringNumberValue(n.getString());\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        String value = getStringValue(n);\n        return value != null ? getStringNumberValue(value) : null;\n    }\n\n    return null;\n  }", "getStringNumberValue": "  static Double getStringNumberValue(String rawJsString) {\n    if (rawJsString.contains(\"\\u000b\")) {\n      // vertical tab is not always whitespace\n      return null;\n    }\n\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n      return 0.0;\n    }\n\n    if (s.length() > 2\n        && s.charAt(0) == '0'\n        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n      // Attempt to convert hex numbers.\n      try {\n        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n      } catch (NumberFormatException e) {\n        return Double.NaN;\n      }\n    }\n\n    if (s.length() > 3\n        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n        && s.charAt(1) == '0'\n        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n      // hex numbers with explicit signs vary between browsers.\n      return null;\n    }\n\n    // Firefox and IE treat the \"Infinity\" differently. Firefox is case\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\")\n        || s.equals(\"-infinity\")\n        || s.equals(\"+infinity\")) {\n      return null;\n    }\n\n    try {\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      return Double.NaN;\n    }\n  }", "getFunctionName": "  static String getFunctionName(Node n) {\n    Preconditions.checkState(n.isFunction());\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.NAME:\n        // var name = function() ...\n        // var name2 = function name1() ...\n        return parent.getQualifiedName();\n\n      case Token.ASSIGN:\n        // qualified.name = function() ...\n        // qualified.name2 = function name1() ...\n        return parent.getFirstChild().getQualifiedName();\n\n      default:\n        // function name() ...\n        String name = n.getFirstChild().getQualifiedName();\n        return name;\n    }\n  }", "getNearestFunctionName": "  public static String getNearestFunctionName(Node n) {\n    if (!n.isFunction()) {\n      return null;\n    }\n\n    String name = getFunctionName(n);\n    if (name != null) {\n      return name;\n    }\n\n    // Check for the form { 'x' : function() { } }\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.SETTER_DEF:\n      case Token.GETTER_DEF:\n      case Token.STRING_KEY:\n        // Return the name of the literal's key.\n        return parent.getString();\n      case Token.NUMBER:\n        return getStringValue(parent);\n    }\n\n    return null;\n  }", "isSymmetricOperation": "  static boolean isSymmetricOperation(Node n) {\n    switch (n.getType()) {\n      case Token.EQ: // equal\n      case Token.NE: // not equal\n      case Token.SHEQ: // exactly equal\n      case Token.SHNE: // exactly not equal\n      case Token.MUL: // multiply, unlike add it only works on numbers\n                      // or results NaN if any of the operators is not a number\n        return true;\n    }\n    return false;\n  }", "isRelationalOperation": "  static boolean isRelationalOperation(Node n) {\n    switch (n.getType()) {\n      case Token.GT: // equal\n      case Token.GE: // not equal\n      case Token.LT: // exactly equal\n      case Token.LE: // exactly not equal\n        return true;\n    }\n    return false;\n  }", "getInverseOperator": "  static int getInverseOperator(int type) {\n    switch (type) {\n      case Token.GT:\n        return Token.LT;\n      case Token.LT:\n        return Token.GT;\n      case Token.GE:\n        return Token.LE;\n      case Token.LE:\n        return Token.GE;\n    }\n    return Token.ERROR;\n  }", "isValidDefineValue": "  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n      case Token.POS:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }", "newExpr": "  static Node newExpr(Node child) {\n    return IR.exprResult(child).srcref(child);\n  }", "checkForStateChangeHelper": "  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.PARAM_LIST:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n        if (checkForNewObjects) {\n          return true;\n        }\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (checkForStateChangeHelper(\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n        }\n        return false;\n\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null) {\n          return true;\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Function expressions don't have side-effects, but function\n        // declarations change the namespace. Either way, we don't need to\n        // check the children, since they aren't executed at declaration time.\n        return checkForNewObjects || !isFunctionExpression(n);\n\n      case Token.NEW:\n        if (checkForNewObjects) {\n          return true;\n        }\n\n        if (!constructorCallHasSideEffects(n)) {\n          // loop below will see if the constructor parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (!functionCallHasSideEffects(n, compiler)) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperator(n)) {\n          break;\n        }\n\n        if (isAssignmentOp(n)) {\n          Node assignTarget = n.getFirstChild();\n          if (assignTarget.isName()) {\n            return true;\n          }\n\n          // Assignments will have side effects if\n          // a) The RHS has side effects, or\n          // b) The LHS has side effects, or\n          // c) A name on the LHS will exist beyond the life of this statement.\n          if (checkForStateChangeHelper(\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\n              checkForStateChangeHelper(\n                  n.getLastChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n\n          if (isGet(assignTarget)) {\n            // If the object being assigned to is a local object, don't\n            // consider this a side-effect as it can't be referenced\n            // elsewhere.  Don't do this recursively as the property might\n            // be an alias of another object, unlike a literal below.\n            Node current = assignTarget.getFirstChild();\n            if (evaluatesToLocalValue(current)) {\n              return false;\n            }\n\n            // A literal value as defined by \"isLiteralValue\" is guaranteed\n            // not to be an alias, or any components which are aliases of\n            // other objects.\n            // If the root object is a literal don't consider this a\n            // side-effect.\n            while (isGet(current)) {\n              current = current.getFirstChild();\n            }\n\n            return !isLiteralValue(current, true);\n          } else {\n            // TODO(johnlenz): remove this code and make this an exception. This\n            // is here only for legacy reasons, the AST is not valid but\n            // preserve existing behavior.\n            return !isLiteralValue(assignTarget, true);\n          }\n        }\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "constructorCallHasSideEffects": "  static boolean constructorCallHasSideEffects(\n      Node callNode, AbstractCompiler compiler) {\n    if (!callNode.isNew()) {\n      throw new IllegalStateException(\n          \"Expected NEW node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n    if (nameNode.isName() &&\n        CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {\n      return false;\n    }\n\n    return true;\n  }", "functionCallHasSideEffects": "  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (!callNode.isCall()) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Math.floor has no side-effects.\n      // TODO(nicksantos): This is a terrible terrible hack, until\n      // I create a definitionProvider that understands namespacing.\n      if (nameNode.getFirstChild().isName()) {\n        if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n          return false;\n        }\n      }\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp()\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString()\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }", "newHasLocalResult": "  static boolean newHasLocalResult(Node n) {\n    Preconditions.checkState(n.isNew());\n    return n.isOnlyModifiesThisCall();\n  }", "nodeTypeMayHaveSideEffects": "  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    if (isAssignmentOp(n)) {\n      return true;\n    }\n\n    switch(n.getType()) {\n      case Token.DELPROP:\n      case Token.DEC:\n      case Token.INC:\n      case Token.THROW:\n        return true;\n      case Token.CALL:\n        return NodeUtil.functionCallHasSideEffects(n, compiler);\n      case Token.NEW:\n        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n      case Token.NAME:\n        // A variable definition.\n        return n.hasChildren();\n      default:\n        return false;\n    }\n  }", "canBeSideEffected": "  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.NEW:\n        // Function calls or constructor can reference changed values.\n        // TODO(johnlenz): Add some mechanism for determining that functions\n        // are unaffected by side effects.\n        return true;\n      case Token.NAME:\n        // Non-constant names values may have been changed.\n        return !isConstantName(n)\n            && !knownConstants.contains(n.getString());\n\n      // Properties on constant NAMEs can still be side-effected.\n      case Token.GETPROP:\n      case Token.GETELEM:\n        return true;\n\n      case Token.FUNCTION:\n        // Function expression are not changed by side-effects,\n        // and function declarations are not part of expressions.\n        Preconditions.checkState(isFunctionExpression(n));\n        return false;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (canBeSideEffected(c, knownConstants)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "precedence": "  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.CALL:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      // Data values\n      case Token.ARRAYLIT:\n      case Token.EMPTY:  // TODO(johnlenz): remove this.\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Token.name(type) +\n                               \" (type \" + type + \")\");\n    }\n  }", "isUndefined": "  static boolean isUndefined(Node n) {\n    switch (n.getType()) {\n      case Token.VOID:\n        return true;\n      case Token.NAME:\n        return n.getString().equals(\"undefined\");\n    }\n    return false;\n  }", "isNullOrUndefined": "  static boolean isNullOrUndefined(Node n) {\n    return n.isNull() || isUndefined(n);\n  }", "allResultsMatch": "  static boolean allResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return allResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return allResultsMatch(n.getFirstChild(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n        return allResultsMatch(n.getFirstChild().getNext(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      default:\n        return p.apply(n);\n    }\n  }", "anyResultsMatch": "  static boolean anyResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return anyResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return anyResultsMatch(n.getFirstChild(), p)\n            || anyResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n        return anyResultsMatch(n.getFirstChild().getNext(), p)\n            || anyResultsMatch(n.getLastChild(), p);\n      default:\n        return p.apply(n);\n    }\n  }", "apply": "    public boolean apply(Node n) {\n      Node parent = n.getParent();\n      return n.isBlock()\n          || (!n.isFunction() && (parent == null\n              || isControlStructure(parent)\n              || isStatementBlock(parent)));\n    }", "isNumericResult": "  static boolean isNumericResult(Node n) {\n    return allResultsMatch(n, NUMBERIC_RESULT_PREDICATE);\n  }", "isNumericResultHelper": "  static boolean isNumericResultHelper(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n        return !mayBeString(n.getFirstChild())\n            && !mayBeString(n.getLastChild());\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.INC:\n      case Token.DEC:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NUMBER:\n        return true;\n      case Token.NAME:\n        String name = n.getString();\n        if (name.equals(\"NaN\")) {\n          return true;\n        }\n        if (name.equals(\"Infinity\")) {\n          return true;\n        }\n        return false;\n      default:\n        return false;\n    }\n  }", "isBooleanResult": "  static boolean isBooleanResult(Node n) {\n    return allResultsMatch(n, BOOLEAN_RESULT_PREDICATE);\n  }", "isBooleanResultHelper": "  static boolean isBooleanResultHelper(Node n) {\n    switch (n.getType()) {\n      // Primitives\n      case Token.TRUE:\n      case Token.FALSE:\n      // Comparisons\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      // Queries\n      case Token.IN:\n      case Token.INSTANCEOF:\n      // Inversion\n      case Token.NOT:\n      // delete operator returns a boolean.\n      case Token.DELPROP:\n        return true;\n      default:\n        return false;\n    }\n  }", "mayBeString": "  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }", "mayBeStringHelper": "  static boolean mayBeStringHelper(Node n) {\n    return !isNumericResult(n) && !isBooleanResult(n)\n        && !isUndefined(n) && !n.isNull();\n  }", "isAssignmentOp": "  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }", "getOpFromAssignmentOp": "  static int getOpFromAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN_BITOR:\n        return Token.BITOR;\n      case Token.ASSIGN_BITXOR:\n        return Token.BITXOR;\n      case Token.ASSIGN_BITAND:\n        return Token.BITAND;\n      case Token.ASSIGN_LSH:\n        return Token.LSH;\n      case Token.ASSIGN_RSH:\n        return Token.RSH;\n      case Token.ASSIGN_URSH:\n        return Token.URSH;\n      case Token.ASSIGN_ADD:\n        return Token.ADD;\n      case Token.ASSIGN_SUB:\n        return Token.SUB;\n      case Token.ASSIGN_MUL:\n        return Token.MUL;\n      case Token.ASSIGN_DIV:\n        return Token.DIV;\n      case Token.ASSIGN_MOD:\n        return Token.MOD;\n    }\n    throw new IllegalArgumentException(\"Not an assignment op:\" + n);\n  }", "containsFunction": "  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }", "referencesThis": "  static boolean referencesThis(Node n) {\n    Node start = (n.isFunction()) ? n.getLastChild() : n;\n    return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);\n  }", "isVarDeclaration": "  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.isName() && n.getParent().isVar();\n  }", "getAssignedValue": "  static Node getAssignedValue(Node n) {\n    Preconditions.checkState(n.isName());\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      return n.getFirstChild();\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      return n.getNext();\n    } else {\n      return null;\n    }\n  }", "isExprAssign": "  static boolean isExprAssign(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isAssign();\n  }", "isForIn": "  static boolean isForIn(Node n) {\n    return n.isFor()\n        && n.getChildCount() == 3;\n  }", "isWithinLoop": "  static boolean isWithinLoop(Node n) {\n    for (Node parent : n.getAncestors()) {\n      if (NodeUtil.isLoopStructure(parent)) {\n        return true;\n      }\n\n      if (parent.isFunction()) {\n        break;\n      }\n    }\n    return false;\n  }", "isControlStructure": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        return false;\n    }\n  }", "isControlStructureCodeBlock": "  static boolean isControlStructureCodeBlock(Node parent, Node n) {\n    switch (parent.getType()) {\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.LABEL:\n      case Token.WITH:\n        return parent.getLastChild() == n;\n      case Token.DO:\n        return parent.getFirstChild() == n;\n      case Token.IF:\n        return parent.getFirstChild() != n;\n      case Token.TRY:\n        return parent.getFirstChild() == n || parent.getLastChild() == n;\n      case Token.CATCH:\n        return parent.getLastChild() == n;\n      case Token.SWITCH:\n      case Token.CASE:\n        return parent.getFirstChild() != n;\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        Preconditions.checkState(isControlStructure(parent));\n        return false;\n    }\n  }", "getConditionExpression": "  static Node getConditionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.IF:\n      case Token.WHILE:\n        return n.getFirstChild();\n      case Token.DO:\n        return n.getLastChild();\n      case Token.FOR:\n        switch (n.getChildCount()) {\n          case 3:\n            return null;\n          case 4:\n            return n.getFirstChild().getNext();\n        }\n        throw new IllegalArgumentException(\"malformed 'for' statement \" + n);\n      case Token.CASE:\n        return null;\n    }\n    throw new IllegalArgumentException(n + \" does not have a condition.\");\n  }", "isStatementBlock": "  static boolean isStatementBlock(Node n) {\n    return n.isScript() || n.isBlock();\n  }", "isStatement": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }", "isStatementParent": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }", "isReferenceName": "  static boolean isReferenceName(Node n) {\n    return n.isName() && !n.getString().isEmpty();\n  }", "isTryFinallyNode": "  static boolean isTryFinallyNode(Node parent, Node child) {\n    return parent.isTry() && parent.getChildCount() == 3\n        && child == parent.getLastChild();\n  }", "isTryCatchNodeContainer": "  static boolean isTryCatchNodeContainer(Node n) {\n    Node parent = n.getParent();\n    return parent.isTry()\n        && parent.getFirstChild().getNext() == n;\n  }", "maybeAddFinally": "  static void maybeAddFinally(Node tryNode) {\n    Preconditions.checkState(tryNode.isTry());\n    if (!NodeUtil.hasFinally(tryNode)) {\n      tryNode.addChildrenToBack(IR.block().srcref(tryNode));\n    }\n  }", "isCallOrNew": "  static boolean isCallOrNew(Node node) {\n    return node.isCall() || node.isNew();\n  }", "getFunctionBody": "  static Node getFunctionBody(Node fn) {\n    Preconditions.checkArgument(fn.isFunction());\n    return fn.getLastChild();\n  }", "isFunctionDeclaration": "  static boolean isFunctionDeclaration(Node n) {\n    return n.isFunction() && isStatement(n);\n  }", "isHoistedFunctionDeclaration": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().isScript()\n            || n.getParent().getParent().isFunction());\n  }", "isFunctionExpression": "  static boolean isFunctionExpression(Node n) {\n    return n.isFunction() && !isStatement(n);\n  }", "isBleedingFunctionName": "  static boolean isBleedingFunctionName(Node n) {\n    return n.isName() && !n.getString().isEmpty() &&\n        isFunctionExpression(n.getParent());\n  }", "isEmptyFunctionExpression": "  static boolean isEmptyFunctionExpression(Node node) {\n    return isFunctionExpression(node) && isEmptyBlock(node.getLastChild());\n  }", "isVarArgsFunction": "  static boolean isVarArgsFunction(Node function) {\n    // TODO(johnlenz): rename this function\n    Preconditions.checkArgument(function.isFunction());\n    return isNameReferenced(\n        function.getLastChild(),\n        \"arguments\",\n        MATCH_NOT_FUNCTION);\n  }", "isFunctionObjectCall": "  static boolean isFunctionObjectCall(Node callNode) {\n    return isObjectCallMethod(callNode, \"call\");\n  }", "isFunctionObjectApply": "  static boolean isFunctionObjectApply(Node callNode) {\n    return isObjectCallMethod(callNode, \"apply\");\n  }", "isVarOrSimpleAssignLhs": "  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n    return (parent.isAssign() && parent.getFirstChild() == n) ||\n           parent.isVar();\n  }", "getObjectLitKeyName": "  static String getObjectLitKeyName(Node key) {\n    switch (key.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return key.getString();\n    }\n    throw new IllegalStateException(\"Unexpected node type: \" + key);\n  }", "opToStrNoFail": "  static String opToStrNoFail(int operator) {\n    String res = opToStr(operator);\n    if (res == null) {\n      throw new Error(\"Unknown op \" + operator + \": \" +\n                      Token.name(operator));\n    }\n    return res;\n  }", "containsType": "  static boolean containsType(Node node, int type) {\n    return containsType(node, type, Predicates.<Node>alwaysTrue());\n  }", "redeclareVarsInsideBranch": "  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n              .srcref(nameNode))\n          .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }", "copyNameAnnotations": "  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }", "getAddingRoot": "  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null != (ancestor = ancestor.getParent())) {\n      int type = ancestor.getType();\n      if (type == Token.SCRIPT) {\n        addingRoot = ancestor;\n        break;\n      } else if (type == Token.FUNCTION) {\n        addingRoot = ancestor.getLastChild();\n        break;\n      }\n    }\n\n    // make sure that the adding root looks ok\n    Preconditions.checkState(addingRoot.isBlock() ||\n        addingRoot.isScript());\n    Preconditions.checkState(addingRoot.getFirstChild() == null ||\n        !addingRoot.getFirstChild().isScript());\n    return addingRoot;\n  }", "newQualifiedNameNode": "  static Node newQualifiedNameNode(\n      CodingConvention convention, String name, Node basisNode,\n      String originalName) {\n    Node node = newQualifiedNameNode(convention, name);\n    setDebugInformation(node, basisNode, originalName);\n    return node;\n  }", "getRootOfQualifiedName": "  static Node getRootOfQualifiedName(Node qName) {\n    for (Node current = qName; true;\n         current = current.getFirstChild()) {\n      if (current.isName() || current.isThis()) {\n        return current;\n      }\n      Preconditions.checkState(current.isGetProp());\n    }\n  }", "setDebugInformation": "  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }", "newName": "  static Node newName(\n      CodingConvention convention, String name,\n      Node basisNode, String originalName) {\n    Node nameNode = newName(convention, name, basisNode);\n    nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n    return nameNode;\n  }", "isLatin": "  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }", "isValidSimpleName": "  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }", "isValidQualifiedName": "  public static boolean isValidQualifiedName(String name) {\n    if (name.endsWith(\".\") || name.startsWith(\".\")) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }", "isValidPropertyName": "  static boolean isValidPropertyName(String name) {\n    return isValidSimpleName(name);\n  }", "visit": "    public void visit(Node n) {\n      if (n.isName()) {\n        Node parent = n.getParent();\n        if (parent != null && parent.isVar()) {\n          String name = n.getString();\n          if (!vars.containsKey(name)) {\n            vars.put(name, n);\n          }\n        }\n      }\n    }", "getVarsDeclaredInBranch": "  static Collection<Node> getVarsDeclaredInBranch(Node root) {\n    VarCollector collector = new VarCollector();\n    visitPreOrder(\n        root,\n        collector,\n        MATCH_NOT_FUNCTION);\n    return collector.vars.values();\n  }", "isPrototypePropertyDeclaration": "  static boolean isPrototypePropertyDeclaration(Node n) {\n    if (!isExprAssign(n)) {\n      return false;\n    }\n    return isPrototypeProperty(n.getFirstChild().getFirstChild());\n  }", "getPrototypeClassName": "  static Node getPrototypeClassName(Node qName) {\n    Node cur = qName;\n    while (cur.isGetProp()) {\n      if (cur.getLastChild().getString().equals(\"prototype\")) {\n        return cur.getFirstChild();\n      } else {\n        cur = cur.getFirstChild();\n      }\n    }\n    return null;\n  }", "getPrototypePropertyName": "  static String getPrototypePropertyName(Node qName) {\n    String qNameStr = qName.getQualifiedName();\n    int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n    int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n    return qNameStr.substring(memberIndex);\n  }", "newUndefinedNode": "  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode != null) {\n        node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }", "newVarNode": "  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value != null) {\n      Preconditions.checkState(value.getNext() == null);\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }", "getNodeTypeReferenceCount": "  static int getNodeTypeReferenceCount(\n      Node node, int type, Predicate<Node> traverseChildrenPred) {\n    return getCount(node, new MatchNodeType(type), traverseChildrenPred);\n  }", "isNameReferenced": "  static boolean isNameReferenced(Node node, String name) {\n    return isNameReferenced(node, name, Predicates.<Node>alwaysTrue());\n  }", "getNameReferenceCount": "  static int getNameReferenceCount(Node node, String name) {\n    return getCount(\n        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());\n  }", "has": "  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "getCount": "  static int getCount(\n      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {\n    int total = 0;\n\n    if (pred.apply(n)) {\n      total++;\n    }\n\n    if (traverseChildrenPred.apply(n)) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        total += getCount(c, pred, traverseChildrenPred);\n      }\n    }\n\n    return total;\n  }", "hasFinally": "  static boolean hasFinally(Node n) {\n    Preconditions.checkArgument(n.isTry());\n    return n.getChildCount() == 3;\n  }", "hasCatchHandler": "  static boolean hasCatchHandler(Node n) {\n    Preconditions.checkArgument(n.isBlock());\n    return n.hasChildren() && n.getFirstChild().isCatch();\n  }", "getFunctionParameters": "  public static Node getFunctionParameters(Node fnNode) {\n    // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n    Preconditions.checkArgument(fnNode.isFunction());\n    return fnNode.getFirstChild().getNext();\n  }", "isConstantName": "  static boolean isConstantName(Node node) {\n    return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n  }", "isConstantByConvention": "  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.isGetProp() &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }", "getFunctionJSDocInfo": "  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.isFunction());\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.isAssign()) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.isName()) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }", "getSourceName": "  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }", "getInputId": "  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }", "newCallNode": "  static Node newCallNode(Node callTarget, Node... parameters) {\n    boolean isFreeCall = !isGet(callTarget);\n    Node call = IR.call(callTarget);\n    call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n    for (Node parameter : parameters) {\n      call.addChildToBack(parameter);\n    }\n    return call;\n  }", "getNthSibling": "  private static Node getNthSibling(Node first, int index) {\n    Node sibling = first;\n    while (index != 0 && sibling != null) {\n      sibling = sibling.getNext();\n      index--;\n    }\n    return sibling;\n  }", "getArgumentForFunction": "  static Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n  }", "getArgumentForCallOrNew": "  static Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n      call.getFirstChild().getNext(), index);\n  }", "isToStringMethodCall": "  private static boolean isToStringMethodCall(Node call) {\n    Node getNode = call.getFirstChild();\n    if (isGet(getNode)) {\n      Node propNode = getNode.getLastChild();\n      return propNode.isString() && \"toString\".equals(propNode.getString());\n    }\n    return false;\n  }", "getBestJSDocInfo": "  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return null;\n      }\n\n      if (parent.isName()) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isAssign()) {\n        return parent.getJSDocInfo();\n      } else if (isObjectLitKey(parent, parent.getParent())) {\n        return parent.getJSDocInfo();\n      } else if (parent.isFunction()) {\n        return parent.getJSDocInfo();\n      } else if (parent.isVar() && parent.hasOneChild()) {\n        return parent.getJSDocInfo();\n      } else if ((parent.isHook() && parent.getFirstChild() != n) ||\n                 parent.isOr() ||\n                 parent.isAnd() ||\n                 (parent.isComma() && parent.getFirstChild() != n)) {\n        return getBestJSDocInfo(parent);\n      }\n    }\n    return info;\n  }", "getBestLValueOwner": "  static Node getBestLValueOwner(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      return getBestLValue(lValue.getParent());\n    } else if (isGet(lValue)) {\n      return lValue.getFirstChild();\n    }\n\n    return null;\n  }", "getBestLValueName": "  static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }", "isExpressionResultUsed": "  static boolean isExpressionResultUsed(Node expr) {\n    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n    Node parent = expr.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n        return false;\n      case Token.HOOK:\n      case Token.AND:\n      case Token.OR:\n        return (expr == parent.getFirstChild())\n            ? true : isExpressionResultUsed(parent);\n      case Token.COMMA:\n        Node gramps = parent.getParent();\n        if (gramps.isCall() &&\n            parent == gramps.getFirstChild()) {\n          // Semantically, a direct call to eval is different from an indirect\n          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n          // expression to a comma to be a no-op if it's used to indirect\n          // an eval. This we pretend that this is \"used\".\n          if (expr == parent.getFirstChild() &&\n              parent.getChildCount() == 2 &&\n              expr.getNext().isName() &&\n              \"eval\".equals(expr.getNext().getString())) {\n            return true;\n          }\n        }\n\n        return (expr == parent.getFirstChild())\n            ? false : isExpressionResultUsed(parent);\n      case Token.FOR:\n        if (!NodeUtil.isForIn(parent)) {\n          // Only an expression whose result is in the condition part of the\n          // expression is used.\n          return (parent.getChildAtIndex(1) == expr);\n        }\n        break;\n    }\n    return true;\n  }", "isExecutedExactlyOnce": "  static boolean isExecutedExactlyOnce(Node n) {\n    inspect: do {\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.IF:\n        case Token.HOOK:\n        case Token.AND:\n        case Token.OR:\n          if (parent.getFirstChild() != n) {\n            return false;\n          }\n          // other ancestors may be conditional\n          continue inspect;\n        case Token.FOR:\n          if (NodeUtil.isForIn(parent)) {\n            if (parent.getChildAtIndex(1) != n) {\n              return false;\n            }\n          } else {\n            if (parent.getFirstChild() != n) {\n              return false;\n            }\n          }\n          // other ancestors may be conditional\n          continue inspect;\n        case Token.WHILE:\n        case Token.DO:\n          return false;\n        case Token.TRY:\n          // Consider all code under a try/catch to be conditionally executed.\n          if (!hasFinally(parent) || parent.getLastChild() != n) {\n            return false;\n          }\n          continue inspect;\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n          return false;\n        case Token.SCRIPT:\n        case Token.FUNCTION:\n          // Done, we've reached the scope root.\n          break inspect;\n      }\n    } while ((n = n.getParent()) != null);\n    return true;\n  }", "booleanNode": "  static Node booleanNode(boolean value) {\n    return value ? IR.trueNode() : IR.falseNode();\n  }", "numberNode": "  static Node numberNode(double value, Node srcref) {\n    Node result;\n    if (Double.isNaN(value)) {\n      result = IR.name(\"NaN\");\n    } else if (value == Double.POSITIVE_INFINITY) {\n      result = IR.name(\"Infinity\");\n    } else if (value == Double.NEGATIVE_INFINITY) {\n      result = IR.neg(IR.name(\"Infinity\"));\n    } else {\n      result = IR.number(value);\n    }\n    if (srcref != null) {\n      result.srcrefTree(srcref);\n    }\n    return result;\n  }"}