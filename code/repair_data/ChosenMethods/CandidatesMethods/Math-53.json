{"abs": "    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }", "add": "    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }", "conjugate": "    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n        return createComplex(real, -imaginary);\n    }", "divide": "    public Complex divide(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }", "equals": "    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN) {\n                return isNaN;\n            } else {\n                return (real == rhs.real) && (imaginary == rhs.imaginary);\n            }\n        }\n        return false;\n    }", "getImaginary": "    public double getImaginary() {\n        return imaginary;\n    }", "getReal": "    public double getReal() {\n        return real;\n    }", "multiply": "    public Complex multiply(double rhs) {\n        if (isNaN || Double.isNaN(rhs)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs, imaginary * rhs);\n    }", "negate": "    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }", "subtract": "    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }", "acos": "    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }", "asin": "    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }", "atan": "    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }", "cos": "    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n    }", "cosh": "    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n            MathUtils.sinh(real) * FastMath.sin(imaginary));\n    }", "exp": "    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n    }", "log": "    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n            FastMath.atan2(imaginary, real));\n    }", "pow": "    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }", "sin": "    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n            FastMath.cos(real) * MathUtils.sinh(imaginary));\n    }", "sinh": "    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n            MathUtils.cosh(real) * FastMath.sin(imaginary));\n    }", "sqrt": "    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }", "sqrt1z": "    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }", "tan": "    public Complex tan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }", "tanh": "    public Complex tanh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n    }", "createComplex": "    protected Complex createComplex(double realPart, double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }"}