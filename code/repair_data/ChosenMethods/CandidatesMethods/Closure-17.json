{"resolve": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }", "visit": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 2) {\n        // We only need to worry about escaped variables at depth 3.\n        // An variable escaped at depth 2 is, by definition, a global variable.\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }", "identifyNameNode": "    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n      }\n    }", "getDeclaredTypeInAnnotation": "    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode =\n          node.isGetProp() ? node.getFirstChild() :\n          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n          null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }", "assertDefinitionNode": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }", "shouldUseFunctionLiteralType": "    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }", "createFunctionTypeFromNodes": "    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() != null &&\n            var.getType().isFunctionType()) {\n          FunctionType aliasedType  = var.getType().toMaybeFunctionType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.isFunction();\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = type.toMaybeFunctionType();\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode);\n          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n          Var ownerVar = null;\n          String propName = null;\n          ObjectType ownerType = null;\n          if (ownerName != null) {\n            ownerVar = scope.getVar(ownerName);\n            if (ownerVar != null) {\n              ownerType = ObjectType.cast(ownerVar.getType());\n            }\n            if (name != null) {\n              propName = name.substring(ownerName.length() + 1);\n            }\n          }\n\n          FunctionType overriddenPropType = null;\n          if (ownerType != null && propName != null) {\n            overriddenPropType =\n                findOverriddenFunction(ownerType, propName);\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setContents(getFunctionAnalysisResults(fnRoot))\n              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n            builder.inferThisType(\n                info, ownerType.getOwnerFunction().getInstanceType());\n            searchedForThisType = true;\n          } else if (ownerNode != null && ownerNode.isThis()) {\n            // If 'this' has a type, use that instead.\n            // This is a hack, necessary because CollectProperties (below)\n            // doesn't run with the scope that it's building,\n            // so scope.getTypeOfThis() will be wrong.\n            JSType injectedThisType = ownerNode.getJSType();\n            builder.inferThisType(\n                info,\n                injectedThisType == null ?\n                scope.getTypeOfThis() : injectedThisType);\n            searchedForThisType = true;\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }", "createEnumTypeFromNodes": "    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n        JSDocInfo info, Node lValueNode) {\n      Preconditions.checkNotNull(info);\n      Preconditions.checkState(info.hasEnumParameterType());\n\n      EnumType enumType = null;\n      if (rValue != null && rValue.isQualifiedName()) {\n        // Handle an aliased enum.\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof EnumType) {\n          enumType = (EnumType) var.getType();\n        }\n      }\n\n      if (enumType == null) {\n        JSType elementsType =\n            info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType = typeRegistry.createEnumType(name, rValue, elementsType);\n\n        if (rValue != null && rValue.isObjectLit()) {\n          // collect enum elements\n          Node key = rValue.getFirstChild();\n          while (key != null) {\n            String keyName = NodeUtil.getStringValue(key);\n            if (keyName == null) {\n              // GET and SET don't have a String value;\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else if (!codingConvention.isValidEnumKey(keyName)) {\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else {\n              enumType.defineElement(keyName, key);\n            }\n            key = key.getNext();\n          }\n        }\n      }\n\n      if (name != null && scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n      }\n\n      return enumType;\n    }", "getDeclaredType": "    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValue.getJSType();\n              } else if (rValue.isOr()) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }", "build": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents != null) {\n        for (String varName : contents.getEscapedVarNames()) {\n          Var v = scope.getVar(varName);\n          Preconditions.checkState(v.getScope() == scope);\n          v.markEscaped();\n        }\n      }\n    }", "process": "    @Override public void process(Node externs, Node root) {\n      if (externs == null) {\n        NodeTraversal.traverse(compiler, root, this);\n      } else {\n        NodeTraversal.traverseRoots(\n            compiler, ImmutableList.of(externs, root), this);\n      }\n    }"}