{"resolve": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }", "declareNativeFunctionType": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }", "visit": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }", "identifyNameNode": "    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n\n        if (valueNode != null &&\n            LEGACY_TYPEDEF.equals(valueNode.getQualifiedName())) {\n          registry.identifyNonNullableName(nameNode.getQualifiedName());\n        }\n      }\n    }", "assertDefinitionNode": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }", "createFunctionTypeFromNodes": "    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          FunctionType aliasedType  = (FunctionType) var.getType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.getType() == Token.FUNCTION;\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          FunctionType overriddenPropType = null;\n          if (lvalueNode != null &&\n              lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                overriddenPropType =\n                    findOverriddenFunction(ownerType, propName);\n              }\n            }\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setSourceNode(fnRoot)\n              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (lvalueNode != null &&\n              lvalueNode.getType() == Token.GETPROP) {\n            Node objNode = lvalueNode.getFirstChild();\n            if (objNode.getType() == Token.GETPROP &&\n                objNode.getLastChild().getString().equals(\"prototype\")) {\n              builder.inferThisType(info, objNode.getFirstChild());\n              searchedForThisType = true;\n            } else if (objNode.getType() == Token.THIS) {\n              builder.inferThisType(info, objNode.getJSType());\n              searchedForThisType = true;\n            }\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info, (Node) null);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .inferReturnStatementsAsLastResort(fnBlock)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }", "createEnumTypeFromNodes": "    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n        JSDocInfo info, Node lValueNode) {\n      Preconditions.checkNotNull(info);\n      Preconditions.checkState(info.hasEnumParameterType());\n\n      EnumType enumType = null;\n      if (rValue != null && rValue.isQualifiedName()) {\n        // Handle an aliased enum.\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof EnumType) {\n          enumType = (EnumType) var.getType();\n        }\n      }\n\n      if (enumType == null) {\n        JSType elementsType =\n            info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType = typeRegistry.createEnumType(name, elementsType);\n\n        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n          // collect enum elements\n          Node key = rValue.getFirstChild();\n          while (key != null) {\n            String keyName = NodeUtil.getStringValue(key);\n            if (keyName == null) {\n              // GET and SET don't have a String value;\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else if (enumType.hasOwnProperty(keyName)) {\n              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n            } else if (!codingConvention.isValidEnumKey(keyName)) {\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else {\n              enumType.defineElement(keyName, key);\n            }\n            key = key.getNext();\n          }\n        }\n      }\n\n      if (name != null && scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n      }\n\n      return enumType;\n    }", "defineSlot": "    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.getType() == Token.NAME && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.getType() == Token.VAR ||\n           parent.getType() == Token.FUNCTION);\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        boolean isExtern = input.isExtern();\n        Var newVar =\n            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(GLOBAL_THIS);\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern, n);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n          }\n        }\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.getType() == Token.OBJECTLIT ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n\n        // We need to do some additional work for constructors and interfaces.\n        if (type instanceof FunctionType &&\n            // We don't want to look at empty function types.\n            !type.isEmptyType()) {\n          FunctionType fnType = (FunctionType) type;\n          if ((fnType.isConstructor() || fnType.isInterface()) &&\n              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n            // Declare var.prototype in the scope chain.\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), input,\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n\n            // Make sure the variable is initialized to something if\n            // it constructs itself.\n            if (newVar.getInitialValue() == null &&\n                !isExtern &&\n                // We want to make sure that when we declare a new instance\n                // type (with @constructor) that there's actually a ctor for it.\n                // This doesn't apply to structural constructors\n                // (like function(new:Array). Checking the constructed\n                // type against the variable name is a sufficient check for\n                // this.\n                variableName.equals(\n                    fnType.getInstanceType().getReferenceName())) {\n              compiler.report(\n                  JSError.make(sourceName, n,\n                      fnType.isConstructor() ?\n                          CTOR_INITIALIZER : IFACE_INITIALIZER,\n                      variableName));\n            }\n          }\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type instanceof FunctionType\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn(((FunctionType) type).getInstanceType());\n      }\n    }", "build": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n    }", "declareArguments": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments"}