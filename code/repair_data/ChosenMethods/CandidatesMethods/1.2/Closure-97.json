{"tryFoldBinaryOperator": "  private Node tryFoldBinaryOperator(Node subtree) {\n    Node left = subtree.getFirstChild();\n\n    if (left == null) {\n      return subtree;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return subtree;\n    }\n\n    // If we've reached here, node is truly a binary operator.\n    switch(subtree.getType()) {\n      case Token.GETPROP:\n        return tryFoldGetProp(subtree, left, right);\n\n      case Token.GETELEM:\n        return tryFoldGetElem(subtree, left, right);\n\n      case Token.INSTANCEOF:\n        return tryFoldInstanceof(subtree, left, right);\n\n      case Token.AND:\n      case Token.OR:\n        return tryFoldAndOr(subtree, left, right);\n\n      case Token.BITAND:\n      case Token.BITOR:\n        return tryFoldBitAndOr(subtree, left, right);\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        return tryFoldShift(subtree, left, right);\n\n      case Token.ASSIGN:\n        return tryFoldAssign(subtree, left, right);\n\n      case Token.ADD:\n        return tryFoldAdd(subtree, left, right);\n\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n        return tryFoldArithmetic(subtree, left, right);\n\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return tryFoldComparison(subtree, left, right);\n\n      default:\n        return subtree;\n    }\n  }", "tryFoldUnaryOperator": "  private Node tryFoldUnaryOperator(Node n) {\n    Preconditions.checkState(n.hasOneChild());\n\n    Node left = n.getFirstChild();\n    Node parent = n.getParent();\n\n    if (left == null) {\n      return n;\n    }\n\n    // TODO(dcc): Just dropping the unary op makes some tests\n    // (e.g. PeepholeIntegration.testMinimizeExpr) very confusing because it\n    // leads to transformations like \"!!true\" --> \"!false\" --> \"false\".\n    // Do we really need to do this here?\n\n    if (NodeUtil.isExpressionNode(parent)) {\n      // If the value isn't used, then just throw\n      // away the operator\n      parent.replaceChild(n, n.removeFirstChild());\n      reportCodeChange();\n      return null;\n    }\n\n    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n    if (leftVal == TernaryValue.UNKNOWN) {\n      return n;\n    }\n\n    switch (n.getType()) {\n      case Token.NOT:\n        int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;\n        Node replacementNode = new Node(result);\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      case Token.NEG:\n        try {\n          if (left.getType() == Token.NAME) {\n            if (left.getString().equals(\"Infinity\")) {\n              // \"-Infinity\" is valid and a literal, don't modify it.\n              return n;\n            } else if (left.getString().equals(\"NaN\")) {\n              // \"-NaN\" is \"NaN\".\n              n.removeChild(left);\n              parent.replaceChild(n, left);\n              reportCodeChange();\n              return left;\n            }\n          }\n\n          double negNum = -left.getDouble();\n\n          Node negNumNode = Node.newNumber(negNum);\n          parent.replaceChild(n, negNumNode);\n          reportCodeChange();\n          return negNumNode;\n        } catch (UnsupportedOperationException ex) {\n          // left is not a number node, so do not replace, but warn the\n          // user because they can't be doing anything good\n          error(NEGATING_A_NON_NUMBER_ERROR, left);\n          return n;\n        }\n      case Token.BITNOT:\n        try {\n          double val = left.getDouble();\n          if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n            int intVal = (int) val;\n            if (intVal == val) {\n              Node notIntValNode = Node.newNumber(~intVal);\n              parent.replaceChild(n, notIntValNode);\n              reportCodeChange();\n              return notIntValNode;\n            } else {\n              error(FRACTIONAL_BITWISE_OPERAND, left);\n              return n;\n            }\n          } else {\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n            return n;\n          }\n        } catch (UnsupportedOperationException ex) {\n          // left is not a number node, so do not replace, but warn the\n          // user because they can't be doing anything good\n          error(NEGATING_A_NON_NUMBER_ERROR, left);\n          return n;\n        }\n        default:\n          return n;\n    }\n  }", "tryFoldInstanceof": "  private Node tryFoldInstanceof(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);\n\n    // TODO(johnlenz) Use type information if available to fold\n    // instanceof.\n    if (NodeUtil.isLiteralValue(left)\n        && !NodeUtil.mayHaveSideEffects(right)) {\n\n      Node replacementNode = null;\n\n      if (NodeUtil.isImmutableValue(left)) {\n        // Non-object types are never instances.\n        replacementNode = new Node(Token.FALSE);\n      } else if (right.getType() == Token.NAME\n          && \"Object\".equals(right.getString())) {\n        replacementNode = new Node(Token.TRUE);\n      }\n\n      if (replacementNode != null) {\n        n.getParent().replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      }\n    }\n\n    return n;\n  }", "tryFoldAssign": "  private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return n;\n    }\n\n    if (NodeUtil.mayHaveSideEffects(left)) {\n      return n;\n    }\n\n    Node leftChild = right.getFirstChild();\n    if (!areNodesEqualForInlining(left, leftChild)) {\n      return n;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return n;\n    }\n\n    Node newNode = new Node(newType,\n        left.detachFromParent(), right.getLastChild().detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldAndOr": "  private Node tryFoldAndOr(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n\n    Node result = null;\n\n    int type = n.getType();\n\n    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n\n    if (leftVal != TernaryValue.UNKNOWN) {\n      boolean lval = leftVal.toBoolean(true);\n\n      // (TRUE || x) => TRUE (also, (3 || x) => 3)\n      // (FALSE && x) => FALSE\n      if (lval && type == Token.OR ||\n          !lval && type == Token.AND) {\n        result = left;\n\n      } else {\n        // (FALSE || x) => x\n        // (TRUE && x) => x\n        result = right;\n      }\n    } else {\n      TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n      if (rightVal != TernaryValue.UNKNOWN) {\n\n      // Note: We cannot always fold when the constant is on the\n      // right, because the typed value of the expression will depend\n      // on the type of the constant on the right, even if the boolean\n      // equivalent of the value does not. Specifically, in \"a = x ||\n      // 0\", a will be numeric 0 if x is undefined (and hence is\n      // e.g. a valid array index). However, it is safe to fold\n      // e.g. \"if (x || true)\" because 'if' doesn't care if the\n      // expression is 'true' or '3'.\n      int pt = parent.getType();\n      if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO ||\n          (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||\n          (pt == Token.HOOK && parent.getFirstChild() == n)) {\n        boolean rval = rightVal.toBoolean(true);\n\n        // (x || FALSE) => x\n        // (x && TRUE) => x\n        if (type == Token.OR && !rval ||\n            type == Token.AND && rval) {\n          result = left;\n        } else {\n          // If x has no side-effects:\n          //   (x || TRUE) => TRUE\n          //   (x && FALSE) => FALSE\n          if (!NodeUtil.mayHaveSideEffects(left)) {\n            result = right;\n          }\n        }\n        }\n      }\n    }\n\n    // Note: The parser parses 'x && FALSE && y' as 'x && (FALSE && y)', so\n    // there is not much need to worry about const values on left's\n    // right child.\n\n    if (result != null) {\n      // Fold it!\n      n.removeChild(result);\n      parent.replaceChild(n, result);\n      reportCodeChange();\n\n      return result;\n    } else {\n      return n;\n    }\n  }", "tryFoldLeftChildAdd": "  private Node tryFoldLeftChildAdd(Node n, Node left, Node right) {\n\n    if (NodeUtil.isLiteralValue(right) &&\n        left.getType() == Token.ADD &&\n        left.getChildCount() == 2) {\n\n      Node ll = left.getFirstChild();\n      Node lr = ll.getNext();\n\n      // Left's right child MUST be a string. We would not want to fold\n      // foo() + 2 + 'a' because we don't know what foo() will return, and\n      // therefore we don't know if left is a string concat, or a numeric add.\n      if (lr.getType() != Token.STRING) {\n        return n;\n      }\n\n      String leftString = NodeUtil.getStringValue(lr);\n      String rightString = NodeUtil.getStringValue(right);\n      if (leftString != null && rightString != null) {\n        left.removeChild(ll);\n        String result = leftString + rightString;\n        n.replaceChild(left, ll);\n        n.replaceChild(right, Node.newString(result));\n        reportCodeChange();\n      }\n    }\n\n    return n;\n  }", "tryFoldAddConstant": "  private Node tryFoldAddConstant(Node n, Node left, Node right) {\n    if (left.getType() == Token.STRING ||\n        right.getType() == Token.STRING) {\n\n      // Add strings.\n      String leftString = NodeUtil.getStringValue(left);\n      String rightString = NodeUtil.getStringValue(right);\n      if (leftString != null && rightString != null) {\n        Node newStringNode = Node.newString(leftString + rightString);\n        n.getParent().replaceChild(n, newStringNode);\n        reportCodeChange();\n        return newStringNode;\n      }\n    } else {\n      // Try arithmetic add\n      return tryFoldArithmetic(n, left, right);\n    }\n\n    return n;\n  }", "tryFoldBitAndOr": "  private Node tryFoldBitAndOr(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.BITAND\n        || n.getType() == Token.BITOR);\n\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n      double resultDouble;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // For now, we are being extra conservative, and only folding ints in\n      // the range MIN_VALUE-MAX_VALUE\n      if (lval < Integer.MIN_VALUE || lval > Integer.MAX_VALUE ||\n          rval < Integer.MIN_VALUE || rval > Integer.MAX_VALUE) {\n\n        // Fall back through and let the javascript use the larger values\n        return n;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        return n;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        return n;\n      }\n\n      switch (n.getType()) {\n        case Token.BITAND:\n          resultDouble = lvalInt & rvalInt;\n          break;\n        case Token.BITOR:\n          resultDouble = lvalInt | rvalInt;\n          break;\n        default:\n          throw new Error(\"Unknown bitwise operator\");\n      }\n\n      Node newNumber = Node.newNumber(resultDouble);\n      n.getParent().replaceChild(n, newNumber);\n      reportCodeChange();\n    }\n\n    return n;\n  }", "tryFoldShift": "  private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // check ranges.  We do not do anything that would clip the double to\n      // a 32-bit range, since the user likely does not intend that.\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n      }\n\n      // only the lower 5 bits are used when shifting, so don't do anything\n      // if the shift amount is outside [0,32)\n      if (!(rval >= 0 && rval < 32)) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        error(FRACTIONAL_BITWISE_OPERAND, left);\n        return n;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        error(FRACTIONAL_BITWISE_OPERAND, right);\n        return n;\n      }\n\n      switch (n.getType()) {\n        case Token.LSH:\n          result = lvalInt << rvalInt;\n          break;\n        case Token.RSH:\n          result = lvalInt >> rvalInt;\n          break;\n        case Token.URSH:\n          // JavaScript handles zero shifts on signed numbers differently than\n          // Java as an Java int can not represent the unsigned 32-bit number\n          // where JavaScript can so use a long here.\n          result = lvalInt >>> rvalInt;\n          break;\n        default:\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n      }\n\n      Node newNumber = Node.newNumber(result);\n      n.getParent().replaceChild(n, newNumber);\n      reportCodeChange();\n\n      return newNumber;\n    }\n\n    return n;\n  }", "tryFoldComparison": "  private Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {\n      // We only handle non-literal operands for LT and GT.\n      if (n.getType() != Token.GT && n.getType() != Token.LT) {\n        return n;\n      }\n    }\n\n    int op = n.getType();\n    boolean result;\n\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n\n    boolean rightLiteral = NodeUtil.isLiteralValue(right);\n    boolean undefinedRight = ((Token.NAME == right.getType()\n          && right.getString().equals(\"undefined\"))\n          || (Token.VOID == right.getType()\n              && NodeUtil.isLiteralValue(right.getFirstChild())));\n\n    switch (left.getType()) {\n      case Token.VOID:\n        if (!NodeUtil.isLiteralValue(left.getFirstChild())) {\n          return n;\n        } else if (!rightLiteral) {\n          return n;\n        } else {\n          boolean nullRight = (Token.NULL == right.getType());\n          boolean equivalent = undefinedRight || nullRight;\n          switch (op) {\n            case Token.EQ:\n              // undefined is only equal to\n              result = equivalent;\n              break;\n            case Token.NE:\n              result = !equivalent;\n              break;\n            case Token.SHEQ:\n              result = undefinedRight;\n              break;\n            case Token.SHNE:\n              result = !undefinedRight;\n              break;\n            case Token.LT:\n            case Token.GT:\n            case Token.LE:\n            case Token.GE:\n              result = false;\n              break;\n            default:\n              return n;\n          }\n        }\n        break;\n\n      case Token.NULL:\n        if (undefinedRight) {\n          result = (op == Token.EQ);\n          break;\n        }\n        // fall through\n      case Token.TRUE:\n      case Token.FALSE:\n        if (undefinedRight) {\n          result = false;\n          break;\n        }\n        // fall through\n      case Token.THIS:\n        int tt = right.getType();\n        if (tt != Token.THIS &&\n            tt != Token.TRUE &&\n            tt != Token.FALSE &&\n            tt != Token.NULL) {\n          return n;\n        }\n        switch (op) {\n          case Token.SHEQ:\n          case Token.EQ:\n            result = left.getType() == right.getType();\n            break;\n\n          case Token.SHNE:\n          case Token.NE:\n            result = left.getType() != right.getType();\n            break;\n\n          default:\n            return n;  // we only handle == and != here\n        }\n        break;\n\n      case Token.STRING:\n        if (undefinedRight) {\n          result = false;\n          break;\n        }\n        if (Token.STRING != right.getType()) {\n          return n;  // Only eval if they are the same type\n        }\n        switch (op) {\n          case Token.SHEQ:\n          case Token.EQ:\n            result = left.getString().equals(right.getString());\n            break;\n\n          case Token.SHNE:\n          case Token.NE:\n            result = !left.getString().equals(right.getString());\n            break;\n\n          default:\n            return n;  // we only handle == and != here\n        }\n        break;\n\n      case Token.NUMBER:\n        if (undefinedRight) {\n          result = false;\n          break;\n        }\n        if (Token.NUMBER != right.getType()) {\n          return n;  // Only eval if they are the same type\n        }\n        double lv = left.getDouble();\n        double rv = right.getDouble();\n\n        switch (op) {\n          case Token.SHEQ:\n          case Token.EQ: result = lv == rv; break;\n          case Token.SHNE:\n          case Token.NE: result = lv != rv; break;\n          case Token.LE: result = lv <= rv; break;\n          case Token.LT: result = lv <  rv; break;\n          case Token.GE: result = lv >= rv; break;\n          case Token.GT: result = lv >  rv; break;\n          default:\n            return n;  // don't handle that op\n        }\n        break;\n\n      case Token.NAME:\n        if (rightLiteral) {\n          boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n          if (undefinedLeft) {\n            boolean nullRight = (Token.NULL == right.getType());\n            boolean equivalent = undefinedRight || nullRight;\n            switch (op) {\n              case Token.EQ:\n                // undefined is only equal to\n                result = equivalent;\n                break;\n              case Token.NE:\n                result = !equivalent;\n                break;\n              case Token.SHEQ:\n                result = undefinedRight;\n                break;\n              case Token.SHNE:\n                result = !undefinedRight;\n                break;\n              case Token.LT:\n              case Token.GT:\n              case Token.LE:\n              case Token.GE:\n                result = false;\n                break;\n              default:\n                return n;\n            }\n            break;\n          }\n        }\n\n        if (Token.NAME != right.getType()) {\n          return n;  // Only eval if they are the same type\n        }\n        String ln = left.getString();\n        String rn = right.getString();\n        if (!ln.equals(rn)) {\n          return n;  // Not the same value name.\n        }\n\n        switch (op) {\n          // If we knew the named value wouldn't be NaN, it would be nice\n          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n          case Token.LT:\n          case Token.GT:\n            result = false;\n            break;\n          default:\n            return n;  // don't handle that op\n        }\n        break;\n\n      default:\n        // assert, this should cover all consts\n        return n;\n    }\n\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldKnownMethods": "  private Node tryFoldKnownMethods(Node subtree) {\n    // For now we only support .join() and .indexOf()\n\n    subtree = tryFoldStringJoin(subtree);\n\n    if (subtree.getType() == Token.CALL) {\n      subtree = tryFoldStringIndexOf(subtree);\n    }\n\n    return subtree;\n  }", "tryFoldStringIndexOf": "  private Node tryFoldStringIndexOf(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n\n    Node left = n.getFirstChild();\n\n    if (left == null) {\n      return n;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return n;\n    }\n\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return n;\n    }\n\n    Node lstringNode = left.getFirstChild();\n    Node functionName = lstringNode.getNext();\n\n    if ((lstringNode.getType() != Token.STRING) ||\n        (!functionName.getString().equals(\"indexOf\") &&\n        !functionName.getString().equals(\"lastIndexOf\"))) {\n      return n;\n    }\n\n    String lstring = NodeUtil.getStringValue(lstringNode);\n    boolean isIndexOf = functionName.getString().equals(\"indexOf\");\n    Node firstArg = right;\n    Node secondArg = right.getNext();\n    String searchValue = NodeUtil.getStringValue(firstArg);\n    // searchValue must be a valid string.\n    if (searchValue == null) {\n      return n;\n    }\n    int fromIndex = isIndexOf ? 0 : lstring.length();\n    if (secondArg != null) {\n      // Third-argument and non-numeric second arg are problematic. Discard.\n      if ((secondArg.getNext() != null) ||\n          (secondArg.getType() != Token.NUMBER)) {\n        return n;\n      } else {\n        fromIndex = (int) secondArg.getDouble();\n      }\n    }\n    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n                             : lstring.lastIndexOf(searchValue, fromIndex);\n    Node newNode = Node.newNumber(indexVal);\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldStringJoin": "  private Node tryFoldStringJoin(Node n) {\n    Node left = n.getFirstChild();\n\n    if (left == null) {\n      return n;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return n;\n    }\n\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return n;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(right),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n;\n  }"}