{"traverseEdge": "    public boolean traverseEdge(JsName from,\n                                RefType callSite,\n                                JsName to) {\n      if (from.referenced && !to.referenced) {\n        to.referenced = true;\n        return true;\n      } else {\n        return false;\n      }\n    }", "toString": "    public String toString() {\n      StringBuilder out = new StringBuilder();\n      out.append(name);\n\n      if (prototypeNames.size() > 0) {\n        out.append(\" (CLASS)\\n\");\n        out.append(\" - FUNCTIONS: \");\n        Iterator<String> pIter = prototypeNames.iterator();\n        while (pIter.hasNext()) {\n          out.append(pIter.next());\n          if (pIter.hasNext()) {\n            out.append(\", \");\n          }\n        }\n      }\n\n      return out.toString();\n    }", "compareTo": "    public int compareTo(JsName rhs) {\n      return this.name.compareTo(rhs.name);\n    }", "name": "    public JsName name() {\n      return name;\n    }", "remove": "    public void remove() {\n      changeProxy.replaceWith(getGramps(), getParent(), IR.falseNode());\n    }", "getParent": "    Node getParent() {\n      return node.getParent();\n    }", "getGramps": "    Node getGramps() {\n      return node.getParent() == null ? null : node.getParent().getParent();\n    }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!(n.isName() || (NodeUtil.isGet(n) && !parent.isGetProp()))) {\n        // This is not a simple or qualified name.\n        return;\n      }\n\n      NameInformation nameInfo = createNameInformation(t, n);\n      if (nameInfo == null) {\n        // The name is not a global name\n        return;\n      }\n\n      if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass != null) {\n          recordReference(\n              nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n\n        // Make sure that we record a reference to the function that does\n        // the inheritance, so that the inherits() function itself does\n        // not get stripped.\n        String nodeName = n.getQualifiedName();\n        if (nodeName != null) {\n          recordReference(\n              nameInfo.name, nodeName, RefType.REGULAR);\n        }\n\n        return;\n      }\n\n      if (parent.isInstanceOf() &&\n          parent.getLastChild() == n &&\n          // Don't cover GETELEMs with a global root node.\n          n.isQualifiedName()) {\n        JsName checkedClass = getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n));\n        checkedClass.hasInstanceOfReference = true;\n        return;\n      }\n\n      // Determine which name might be potentially referring to this one by\n      // looking up the nearest enclosing dependency scope. It's unnecessary to\n      // determine all enclosing dependency scopes because this callback should\n      // create a chain of references between them.\n      List<NameInformation> referers = getDependencyScope(n);\n      if (referers.isEmpty()) {\n        maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null);\n      } else {\n        for (NameInformation referring : referers) {\n          maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring);\n        }\n        recordAliases(referers);\n      }\n    }", "recordConsumers": "    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.ASSIGN:\n          if (n == parent.getLastChild()) {\n            recordAssignment(t, parent, recordNode);\n          }\n          recordConsumers(t, parent, recordNode);\n          break;\n        case Token.NAME:\n          NameInformation ns = createNameInformation(t, parent);\n          recordDepScope(recordNode, ns);\n          break;\n        case Token.OR:\n          recordConsumers(t, parent, recordNode);\n          break;\n        case Token.AND:\n          // In \"a && b\" only \"b\" can be meaningfully aliased.\n          // \"a\" must be falsy, which it must be an immutable, non-Object\n        case Token.COMMA:\n        case Token.HOOK:\n          if (n != parent.getFirstChild()) {\n            recordConsumers(t, parent, recordNode);\n          }\n          break;\n      }\n    }", "recordAssignment": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }", "recordDepScope": "    private void recordDepScope(Node node, NameInformation name) {\n      Preconditions.checkNotNull(name);\n      scopes.put(node, name);\n    }", "recordSet": "    private void recordSet(String name, Node node) {\n      JsName jsn = getName(name, true);\n      JsNameRefNode nameRefNode = new JsNameRefNode(jsn, node);\n      refNodes.add(nameRefNode);\n\n      // Now, look at all parent names and record that their properties have\n      // been written to.\n      if (node.isGetElem()) {\n        recordWriteOnProperties(name);\n      } else if (name.indexOf('.') != -1) {\n        recordWriteOnProperties(name.substring(0, name.lastIndexOf('.')));\n      }\n    }", "recordPrototypeSet": "    private void recordPrototypeSet(String className, String prototypeProperty,\n        Node node) {\n      JsName name = getName(className, true);\n      name.prototypeNames.add(prototypeProperty);\n      refNodes.add(new PrototypeSetNode(name, node));\n      recordWriteOnProperties(className);\n    }", "recordWriteOnProperties": "    private void recordWriteOnProperties(String parentName) {\n      do {\n        JsName parent = getName(parentName, true);\n        if (parent.hasWrittenDescendants) {\n          // If we already recorded this name, then all its parents must\n          // also be recorded. short-circuit this loop.\n          return;\n        } else {\n          parent.hasWrittenDescendants = true;\n        }\n\n        if (parentName.indexOf('.') == -1) {\n          return;\n        }\n        parentName = parentName.substring(0, parentName.lastIndexOf('.'));\n      } while(true);\n    }", "addAllChildren": "    private void addAllChildren(Node n) {\n      nodesToKeep.add(n);\n      for (Node child = n.getFirstChild();\n           child != null;\n           child = child.getNext()) {\n        addAllChildren(child);\n      }\n    }", "addSimplifiedChildren": "    private void addSimplifiedChildren(Node n) {\n      NodeTraversal.traverse(\n          compiler, n,\n          new GatherSideEffectSubexpressionsCallback(\n              compiler, new NodeAccumulator()));\n    }", "addSimplifiedExpression": "    private void addSimplifiedExpression(Node n, Node parent) {\n      if (parent.isVar()) {\n        Node value = n.getFirstChild();\n        if (value != null) {\n          addSimplifiedChildren(value);\n        }\n      } else if (n.isAssign() &&\n          (parent.isExprResult() ||\n           parent.isFor() ||\n           parent.isReturn())) {\n        for (Node child : n.children()) {\n          addSimplifiedChildren(child);\n        }\n      } else if (n.isCall() &&\n                 parent.isExprResult()) {\n        addSimplifiedChildren(n);\n      } else {\n        addAllChildren(n);\n      }\n    }", "shouldTraverse": "    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (parent == null) {\n        return true;\n      }\n\n      // Gather the list of nodes that either have side effects, are\n      // arguments to function calls with side effects or are used in\n      // control structure predicates.  These names are always\n      // referenced when the enclosing function is called.\n      if (n.isFor()) {\n        if (!NodeUtil.isForIn(n)) {\n          Node decl = n.getFirstChild();\n          Node pred = decl.getNext();\n          Node step = pred.getNext();\n          addSimplifiedExpression(decl, n);\n          addSimplifiedExpression(pred, n);\n          addSimplifiedExpression(step, n);\n        } else { // n.getChildCount() == 3\n          Node decl = n.getFirstChild();\n          Node iter = decl.getNext();\n          addAllChildren(decl);\n          addAllChildren(iter);\n        }\n      }\n\n      if (parent.isVar() ||\n          parent.isExprResult() ||\n          parent.isReturn() ||\n          parent.isThrow()) {\n        addSimplifiedExpression(n, parent);\n      }\n\n      if ((parent.isIf() ||\n           parent.isWhile() ||\n           parent.isWith() ||\n           parent.isSwitch() ||\n           parent.isCase()) &&\n          parent.getFirstChild() == n) {\n        addAllChildren(n);\n      }\n\n      if (parent.isDo() && parent.getLastChild() == n) {\n        addAllChildren(n);\n      }\n\n      return true;\n    }", "maybeRecordReferenceOrAlias": "    private void maybeRecordReferenceOrAlias(\n        NodeTraversal t, Node n, Node parent,\n        NameInformation nameInfo, NameInformation referring) {\n      String referringName = \"\";\n      if (referring != null) {\n        referringName = referring.isPrototype\n                      ? referring.prototypeClass\n                      : referring.name;\n      }\n\n      String name = nameInfo.name;\n\n      // A value whose result is the return value of a function call\n      // can be an alias to global object.\n      // Here we add an alias to the general \"global\" object\n      // to act as a placeholder for the actual (unnamed) value.\n      if (maybeHiddenAlias(n)) {\n        recordAlias(name, WINDOW);\n      }\n\n      // An externally referenceable name must always be defined, so we add a\n      // reference to it from the global scope (a.k.a. window).\n      if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n      }\n\n      // An assignment implies a reference from the enclosing dependency scope.\n      // For example, foo references bar in: function foo() {bar=5}.\n      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        if (referring != null) {\n          recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n      }\n\n      if (nodesToKeep.contains(n)) {\n        List<NameInformation> functionScopes =\n            getEnclosingFunctionDependencyScope(t);\n        if (!functionScopes.isEmpty()) {\n          for (NameInformation functionScope : functionScopes) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n          }\n        } else {\n          recordReference(WINDOW, name, RefType.REGULAR);\n          if (referring != null) {\n            maybeRecordAlias(name, parent, referring, referringName);\n          }\n        }\n      } else if (referring != null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n          RefType depType = referring.onlyAffectsClassDef ?\n              RefType.INHERITANCE : RefType.REGULAR;\n          recordReference(referringName, name, depType);\n        }\n      } else {\n        // No named dependency scope found.  Unfortunately that might\n        // mean that the expression is a child of an function expression\n        // or assignment with a complex lhs.  In those cases,\n        // protect this node by creating a reference to WINDOW.\n        for (Node ancestor : n.getAncestors()) {\n          if (NodeUtil.isAssignmentOp(ancestor) ||\n              ancestor.isFunction()) {\n            recordReference(WINDOW, name, RefType.REGULAR);\n            break;\n          }\n        }\n      }\n    }", "maybeHiddenAlias": "    private boolean maybeHiddenAlias(Node n) {\n      Node parent = n.getParent();\n      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        Node rhs = (parent.isVar())\n            ? n.getFirstChild() : parent.getLastChild();\n        return (rhs != null && !NodeUtil.evaluatesToLocalValue(\n            rhs, NON_LOCAL_RESULT_PREDICATE));\n      }\n      return false;\n    }", "classDefiningCallsHaveSideEffects": "      public boolean classDefiningCallsHaveSideEffects() {\n        return false;\n      }", "keepSubTree": "      public void keepSubTree(Node original) {\n        addAllChildren(original);\n      }", "keepSimplifiedShortCircuitExpression": "      public void keepSimplifiedShortCircuitExpression(Node original) {\n        Node condition = original.getFirstChild();\n        Node thenBranch = condition.getNext();\n        addAllChildren(condition);\n        addSimplifiedChildren(thenBranch);\n      }", "keepSimplifiedHookExpression": "      public void keepSimplifiedHookExpression(Node hook,\n                                               boolean thenHasSideEffects,\n                                               boolean elseHasSideEffects) {\n        Node condition = hook.getFirstChild();\n        Node thenBranch = condition.getNext();\n        Node elseBranch = thenBranch.getNext();\n        addAllChildren(condition);\n        if (thenHasSideEffects) {\n          addSimplifiedChildren(thenBranch);\n        }\n        if (elseHasSideEffects) {\n          addSimplifiedChildren(elseBranch);\n        }\n      }", "nodeRemoved": "    public void nodeRemoved(Node n) {\n      compiler.reportCodeChange();\n    }", "process": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExternals());\n    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());\n    NodeTraversal.traverse(\n        compiler, root, new HoistVariableAndFunctionDeclarations());\n    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());\n    NodeTraversal.traverse(compiler, root, new FindReferences());\n\n    // Create bi-directional references between parent names and their\n    // descendants. This may create new names.\n    referenceParentNames();\n\n    // If we modify the property of an alias, make sure that modification\n    // gets reflected in the original object.\n    referenceAliases();\n\n    calculateReferences();\n\n    if (removeUnreferenced) {\n      removeUnreferenced();\n    }\n  }", "recordReference": "  private void recordReference(String fromName, String toName,\n                               RefType depType) {\n    if (fromName.equals(toName)) {\n      // Don't bother recording self-references.\n      return;\n    }\n\n    JsName from = getName(fromName, true);\n    JsName to = getName(toName, true);\n    referenceGraph.createNode(from);\n    referenceGraph.createNode(to);\n    if (!referenceGraph.isConnectedInDirection(from, depType, to)) {\n      referenceGraph.connect(from, depType, to);\n    }\n  }", "removeUnreferenced": "  void removeUnreferenced() {\n    RemoveListener listener = new RemoveListener();\n    changeProxy.registerListener(listener);\n\n    for (RefNode refNode : refNodes) {\n      JsName name = refNode.name();\n      if (!name.referenced && !name.externallyDefined) {\n        refNode.remove();\n      }\n    }\n\n    changeProxy.unregisterListener(listener);\n  }", "getHtmlReport": "  String getHtmlReport() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<html><body><style type=\\\"text/css\\\">\"\n        + \"body, td, p {font-family: Arial; font-size: 83%} \"\n        + \"ul {margin-top:2px; margin-left:0px; padding-left:1em;} \"\n        + \"li {margin-top:3px; margin-left:24px; padding-left:0px;\"\n        + \"padding-bottom: 4px}</style>\");\n    sb.append(\"OVERALL STATS<ul>\");\n    appendListItem(sb, \"Total Names: \" + countOf(TriState.BOTH, TriState.BOTH));\n    appendListItem(sb, \"Total Classes: \"\n        + countOf(TriState.TRUE, TriState.BOTH));\n    appendListItem(sb, \"Total Static Functions: \"\n        + countOf(TriState.FALSE, TriState.BOTH));\n    appendListItem(sb, \"Referenced Names: \"\n        + countOf(TriState.BOTH, TriState.TRUE));\n    appendListItem(sb, \"Referenced Classes: \"\n        + countOf(TriState.TRUE, TriState.TRUE));\n    appendListItem(sb, \"Referenced Functions: \"\n        + countOf(TriState.FALSE, TriState.TRUE));\n    sb.append(\"</ul>\");\n\n    sb.append(\"ALL NAMES<ul>\\n\");\n    for (JsName node : allNames.values()) {\n      sb.append(\"<li>\" + nameAnchor(node.name) + \"<ul>\");\n      if (node.prototypeNames.size() > 0) {\n        sb.append(\"<li>PROTOTYPES: \");\n        Iterator<String> protoIter = node.prototypeNames.iterator();\n        while (protoIter.hasNext()) {\n          sb.append(protoIter.next());\n          if (protoIter.hasNext()) {\n            sb.append(\", \");\n          }\n        }\n      }\n\n      if (referenceGraph.hasNode(node)) {\n        List<DiGraphEdge<JsName, RefType>> refersTo =\n            referenceGraph.getOutEdges(node);\n        if (refersTo.size() > 0) {\n          sb.append(\"<li>REFERS TO: \");\n          Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();\n          while (toIter.hasNext()) {\n            sb.append(nameLink(toIter.next().getDestination().getValue().name));\n            if (toIter.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n        }\n\n        List<DiGraphEdge<JsName, RefType>> referencedBy =\n            referenceGraph.getInEdges(node);\n        if (referencedBy.size() > 0) {\n          sb.append(\"<li>REFERENCED BY: \");\n          Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();\n          while (fromIter.hasNext()) {\n            sb.append(\n                nameLink(fromIter.next().getDestination().getValue().name));\n            if (fromIter.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n        }\n      }\n      sb.append(\"</li>\");\n      sb.append(\"</ul></li>\");\n    }\n    sb.append(\"</ul>\");\n    sb.append(\"</body></html>\");\n\n    return sb.toString();\n  }", "appendListItem": "  private void appendListItem(StringBuilder sb, String text) {\n    sb.append(\"<li>\" + text + \"</li>\\n\");\n  }", "nameLink": "  private String nameLink(String name) {\n    return \"<a href=\\\"#\" + name + \"\\\">\" + name + \"</a>\";\n  }", "nameAnchor": "  private String nameAnchor(String name) {\n    return \"<a name=\\\"\" + name + \"\\\">\" + name + \"</a>\";\n  }", "getName": "  private JsName getName(String name, boolean canCreate) {\n    if (canCreate) {\n      createName(name);\n    }\n    return allNames.get(name);\n  }", "createName": "  private void createName(String name) {\n    JsName jsn = allNames.get(name);\n    if (jsn == null) {\n      jsn = new JsName();\n      jsn.name = name;\n      allNames.put(name, jsn);\n    }\n  }", "referenceAliases": "  private void referenceAliases() {\n    for (Map.Entry<String, AliasSet> entry : aliases.entrySet()) {\n      JsName name = getName(entry.getKey(), false);\n      if (name.hasWrittenDescendants || name.hasInstanceOfReference) {\n        for (String alias : entry.getValue().names) {\n          recordReference(alias, entry.getKey(), RefType.REGULAR);\n        }\n      }\n    }\n  }", "referenceParentNames": "  private void referenceParentNames() {\n    // Duplicate set of nodes to process so we don't modify set we are\n    // currently iterating over\n    Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values());\n\n    for (JsName name : allNamesCopy) {\n      String curName = name.name;\n      JsName curJsName = name;\n      while (curName.indexOf('.') != -1) {\n        String parentName = curName.substring(0, curName.lastIndexOf('.'));\n        if (!globalNames.contains(parentName)) {\n\n          JsName parentJsName = getName(parentName, true);\n\n          recordReference(curJsName.name, parentJsName.name, RefType.REGULAR);\n          recordReference(parentJsName.name, curJsName.name, RefType.REGULAR);\n\n          curJsName = parentJsName;\n        }\n        curName = parentName;\n      }\n    }\n  }", "createNameInformation": "  private NameInformation createNameInformation(\n      String name, Scope scope, Node rootNameNode) {\n    // Check the scope. Currently we're only looking at globally scoped vars.\n    String rootName = rootNameNode.getString();\n    Var v = scope.getVar(rootName);\n    boolean isExtern = (v == null && externalNames.contains(rootName));\n    boolean isGlobalRef = (v != null && v.isGlobal()) || isExtern ||\n        rootName.equals(WINDOW);\n    if (!isGlobalRef) {\n      return null;\n    }\n\n    NameInformation nameInfo = new NameInformation();\n\n    // If a prototype property or method, fill in prototype information.\n    int idx = name.indexOf(PROTOTYPE_SUBSTRING);\n    if (idx != -1) {\n      nameInfo.isPrototype = true;\n      nameInfo.prototypeClass = name.substring(0, idx);\n      nameInfo.prototypeProperty = name.substring(\n          idx + PROTOTYPE_SUBSTRING_LEN);\n    }\n\n    nameInfo.name = name;\n    nameInfo.isExternallyReferenceable =\n        isExtern || isExternallyReferenceable(scope, name);\n    return nameInfo;\n  }", "isExternallyReferenceable": "  private boolean isExternallyReferenceable(Scope scope, String name) {\n    if (compiler.getCodingConvention().isExported(name)) {\n      return true;\n    }\n    if (scope.isLocal()) {\n      return false;\n    }\n    for (String s : globalNames) {\n      if (name.startsWith(s)) {\n        return true;\n      }\n    }\n    return false;\n  }", "getDependencyScope": "  private List<NameInformation> getDependencyScope(Node n) {\n    for (Node node : n.getAncestors()) {\n      List<NameInformation> refs = scopes.get(node);\n      if (!refs.isEmpty()) {\n        return refs;\n      }\n    }\n\n    return Collections.emptyList();\n  }", "getEnclosingFunctionDependencyScope": "  private List<NameInformation> getEnclosingFunctionDependencyScope(\n      NodeTraversal t) {\n    Node function = t.getEnclosingFunction();\n    if (function == null) {\n      return Collections.emptyList();\n    }\n\n    List<NameInformation> refs = scopes.get(function);\n    if (!refs.isEmpty()) {\n      return refs;\n    }\n\n    // Function expression.  try to get a name from the parent var\n    // declaration or assignment.\n    Node parent = function.getParent();\n    if (parent != null) {\n      // Account for functions defined in the form:\n      //   var a = cond ? function a() {} : function b() {};\n      while (parent.isHook()) {\n        parent = parent.getParent();\n      }\n\n      if (parent.isName()) {\n        return scopes.get(parent);\n      }\n\n      if (parent.isAssign()) {\n        return scopes.get(parent);\n      }\n    }\n\n    return Collections.emptyList();\n  }", "calculateReferences": "  private void calculateReferences() {\n    JsName window = getName(WINDOW, true);\n    window.referenced = true;\n    JsName function = getName(FUNCTION, true);\n    function.referenced = true;\n\n    // Propagate \"referenced\" property to a fixed point.\n    FixedPointGraphTraversal.newTraversal(new ReferencePropagationCallback())\n        .computeFixedPoint(referenceGraph);\n  }", "countOf": "  private int countOf(TriState isClass, TriState referenced) {\n    int count = 0;\n    for (JsName name : allNames.values()) {\n\n      boolean nodeIsClass = name.prototypeNames.size() > 0;\n\n      boolean classMatch = isClass == TriState.BOTH\n          || (nodeIsClass && isClass == TriState.TRUE)\n          || (!nodeIsClass && isClass == TriState.FALSE);\n\n      boolean referenceMatch = referenced == TriState.BOTH\n          || (name.referenced && referenced == TriState.TRUE)\n          || (!name.referenced && referenced == TriState.FALSE);\n\n      if (classMatch && referenceMatch && !name.externallyDefined) {\n        count++;\n      }\n    }\n    return count;\n  }", "getSideEffectNodes": "  private List<Node> getSideEffectNodes(Node n) {\n    List<Node> subexpressions = Lists.newArrayList();\n    NodeTraversal.traverse(\n        compiler, n,\n        new GatherSideEffectSubexpressionsCallback(\n            compiler,\n            new GetReplacementSideEffectSubexpressions(\n                compiler, subexpressions)));\n\n    List<Node> replacements =\n        Lists.newArrayListWithExpectedSize(subexpressions.size());\n    for (Node subexpression : subexpressions) {\n      replacements.add(NodeUtil.newExpr(subexpression));\n    }\n    return replacements;\n  }", "replaceWithRhs": "  private void replaceWithRhs(Node parent, Node n) {\n    if (valueConsumedByParent(n, parent)) {\n      // parent reads from n directly; replace it with n's rhs + lhs\n      // subexpressions with side effects.\n      List<Node> replacements = getRhsSubexpressions(n);\n      List<Node> newReplacements = Lists.newArrayList();\n      for (int i = 0; i < replacements.size() - 1; i++) {\n        newReplacements.addAll(getSideEffectNodes(replacements.get(i)));\n      }\n      Node valueExpr = replacements.get(replacements.size() - 1);\n      valueExpr.detachFromParent();\n      newReplacements.add(valueExpr);\n      changeProxy.replaceWith(\n          parent, n, collapseReplacements(newReplacements));\n    } else if (n.isAssign() && !parent.isFor()) {\n      // assignment appears in a RHS expression.  we have already\n      // considered names in the assignment's RHS as being referenced;\n      // replace the assignment with its RHS.\n      // TODO(user) make the pass smarter about these cases and/or run\n      // this pass and RemoveConstantExpressions together in a loop.\n      Node replacement = n.getLastChild();\n      replacement.detachFromParent();\n      changeProxy.replaceWith(parent, n, replacement);\n    } else {\n      replaceTopLevelExpressionWithRhs(parent, n);\n    }\n  }", "replaceTopLevelExpressionWithRhs": "  private void replaceTopLevelExpressionWithRhs(Node parent, Node n) {\n    // validate inputs\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.FOR:\n      case Token.LABEL:\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported parent node type in replaceWithRhs \" +\n            Token.name(parent.getType()));\n    }\n\n    switch (n.getType()) {\n      case Token.EXPR_RESULT:\n      case Token.FUNCTION:\n      case Token.VAR:\n        break;\n      case Token.ASSIGN:\n        Preconditions.checkArgument(parent.isFor(),\n            \"Unsupported assignment in replaceWithRhs. parent: %s\",\n            Token.name(parent.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported node type in replaceWithRhs \" +\n            Token.name(n.getType()));\n    }\n\n    // gather replacements\n    List<Node> replacements = Lists.newArrayList();\n    for (Node rhs : getRhsSubexpressions(n)) {\n      replacements.addAll(getSideEffectNodes(rhs));\n    }\n\n    if (parent.isFor()) {\n      // tweak replacements array s.t. it is a single expression node.\n      if (replacements.isEmpty()) {\n        replacements.add(IR.empty());\n      } else {\n        Node expr = collapseReplacements(replacements);\n        replacements.clear();\n        replacements.add(expr);\n      }\n    }\n\n    changeProxy.replaceWith(parent, n, replacements);\n  }", "valueConsumedByParent": "  private boolean valueConsumedByParent(Node n, Node parent) {\n    if (NodeUtil.isAssignmentOp(parent)) {\n      return parent.getLastChild() == n;\n    }\n\n    switch (parent.getType()) {\n      case Token.NAME:\n      case Token.RETURN:\n        return true;\n      case Token.AND:\n      case Token.OR:\n      case Token.HOOK:\n        return parent.getFirstChild() == n;\n      case Token.FOR:\n        return parent.getFirstChild().getNext() == n;\n      case Token.IF:\n      case Token.WHILE:\n        return parent.getFirstChild() == n;\n      case Token.DO:\n        return parent.getLastChild() == n;\n      default:\n        return false;\n    }\n  }", "collapseReplacements": "  private Node collapseReplacements(List<Node> replacements) {\n    Node expr = null;\n    for (Node rep : replacements) {\n      if (rep.isExprResult()) {\n        rep = rep.getFirstChild();\n        rep.detachFromParent();\n      }\n\n      if (expr == null) {\n        expr = rep;\n      } else {\n        expr = IR.comma(expr, rep);\n      }\n    }\n\n    return expr;\n  }", "getRhsSubexpressions": "  private List<Node> getRhsSubexpressions(Node n) {\n    switch (n.getType()) {\n      case Token.EXPR_RESULT:\n        // process body\n        return getRhsSubexpressions(n.getFirstChild());\n      case Token.FUNCTION:\n        // function nodes have no RHS\n        return Collections.emptyList();\n      case Token.NAME:\n        {\n          // parent is a var node.  RHS is the first child\n          Node rhs = n.getFirstChild();\n          if (rhs != null) {\n            return Lists.newArrayList(rhs);\n          } else {\n            return Collections.emptyList();\n          }\n        }\n      case Token.ASSIGN:\n        {\n          // add LHS and RHS expressions - LHS may be a complex expression\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          return Lists.newArrayList(lhs, rhs);\n        }\n      case Token.VAR:\n        {\n          // recurse on all children\n          List<Node> nodes = Lists.newArrayList();\n          for (Node child : n.children()) {\n            nodes.addAll(getRhsSubexpressions(child));\n          }\n          return nodes;\n        }\n      default:\n        throw new IllegalArgumentException(\"AstChangeProxy::getRhs \" + n);\n    }\n  }"}