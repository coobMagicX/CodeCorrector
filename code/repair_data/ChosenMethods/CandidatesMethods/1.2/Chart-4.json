{"getOrientation": "    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }", "setOrientation": "    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }", "getAxisOffset": "    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }", "setAxisOffset": "    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }", "getDomainAxis": "    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }", "setDomainAxis": "    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "setDomainAxes": "    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }", "getDomainAxisLocation": "    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }", "setDomainAxisLocation": "    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "getDomainAxisEdge": "    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }", "getDomainAxisCount": "    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }", "clearDomainAxes": "    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }", "configureDomainAxes": "    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }", "getRangeAxis": "    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }", "setRangeAxis": "    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "getRangeAxisLocation": "    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }", "setRangeAxisLocation": "    public void setRangeAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "getRangeAxisEdge": "    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }", "setRangeAxes": "    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }", "getRangeAxisCount": "    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }", "clearRangeAxes": "    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }", "configureRangeAxes": "    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }", "getDataset": "    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }", "setDataset": "    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }", "getDatasetCount": "    public int getDatasetCount() {\n        return this.datasets.size();\n    }", "indexOf": "    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }", "mapDatasetToDomainAxis": "    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        List axisIndices = new java.util.ArrayList(1);\n        axisIndices.add(new Integer(axisIndex));\n        mapDatasetToDomainAxes(index, axisIndices);\n    }", "mapDatasetToDomainAxes": "    public void mapDatasetToDomainAxes(int index, List axisIndices) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires 'index' >= 0.\");\n        }\n        checkAxisIndices(axisIndices);\n        Integer key = new Integer(index);\n        this.datasetToDomainAxesMap.put(key, new ArrayList(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }", "mapDatasetToRangeAxis": "    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        List axisIndices = new java.util.ArrayList(1);\n        axisIndices.add(new Integer(axisIndex));\n        mapDatasetToRangeAxes(index, axisIndices);\n    }", "mapDatasetToRangeAxes": "    public void mapDatasetToRangeAxes(int index, List axisIndices) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires 'index' >= 0.\");\n        }\n        checkAxisIndices(axisIndices);\n        Integer key = new Integer(index);\n        this.datasetToRangeAxesMap.put(key, new ArrayList(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }", "checkAxisIndices": "    private void checkAxisIndices(List indices) {\n        // axisIndices can be:\n        // 1.  null;\n        // 2.  non-empty, containing only Integer objects that are unique.\n        if (indices == null) {\n            return;  // OK\n        }\n        int count = indices.size();\n        if (count == 0) {\n            throw new IllegalArgumentException(\"Empty list not permitted.\");\n        }\n        HashSet set = new HashSet();\n        for (int i = 0; i < count; i++) {\n            Object item = indices.get(i);\n            if (!(item instanceof Integer)) {\n                throw new IllegalArgumentException(\n                        \"Indices must be Integer instances.\");\n            }\n            if (set.contains(item)) {\n                throw new IllegalArgumentException(\"Indices must be unique.\");\n            }\n            set.add(item);\n        }\n    }", "getRendererCount": "    public int getRendererCount() {\n        return this.renderers.size();\n    }", "getRenderer": "    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }", "setRenderer": "    public void setRenderer(int index, XYItemRenderer renderer,\n                            boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "setRenderers": "    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);\n        }\n        fireChangeEvent();\n    }", "getDatasetRenderingOrder": "    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }", "setDatasetRenderingOrder": "    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }", "getSeriesRenderingOrder": "    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }", "setSeriesRenderingOrder": "    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }", "getIndexOf": "    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }", "getRendererForDataset": "    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }", "getWeight": "    public int getWeight() {\n        return this.weight;\n    }", "setWeight": "    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }", "isDomainGridlinesVisible": "    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }", "setDomainGridlinesVisible": "    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }", "isDomainMinorGridlinesVisible": "    public boolean isDomainMinorGridlinesVisible() {\n        return this.domainMinorGridlinesVisible;\n    }", "setDomainMinorGridlinesVisible": "    public void setDomainMinorGridlinesVisible(boolean visible) {\n        if (this.domainMinorGridlinesVisible != visible) {\n            this.domainMinorGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }", "getDomainGridlineStroke": "    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }", "setDomainGridlineStroke": "    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }", "getDomainMinorGridlineStroke": "    public Stroke getDomainMinorGridlineStroke() {\n        return this.domainMinorGridlineStroke;\n    }", "setDomainMinorGridlineStroke": "    public void setDomainMinorGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainMinorGridlineStroke = stroke;\n        fireChangeEvent();\n    }", "getDomainGridlinePaint": "    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }", "setDomainGridlinePaint": "    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }", "getDomainMinorGridlinePaint": "    public Paint getDomainMinorGridlinePaint() {\n        return this.domainMinorGridlinePaint;\n    }", "setDomainMinorGridlinePaint": "    public void setDomainMinorGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainMinorGridlinePaint = paint;\n        fireChangeEvent();\n    }", "isRangeGridlinesVisible": "    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }", "setRangeGridlinesVisible": "    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }", "getRangeGridlineStroke": "    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }", "setRangeGridlineStroke": "    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }", "getRangeGridlinePaint": "    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }", "setRangeGridlinePaint": "    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }", "isRangeMinorGridlinesVisible": "    public boolean isRangeMinorGridlinesVisible() {\n        return this.rangeMinorGridlinesVisible;\n    }", "setRangeMinorGridlinesVisible": "    public void setRangeMinorGridlinesVisible(boolean visible) {\n        if (this.rangeMinorGridlinesVisible != visible) {\n            this.rangeMinorGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }", "getRangeMinorGridlineStroke": "    public Stroke getRangeMinorGridlineStroke() {\n        return this.rangeMinorGridlineStroke;\n    }", "setRangeMinorGridlineStroke": "    public void setRangeMinorGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeMinorGridlineStroke = stroke;\n        fireChangeEvent();\n    }", "getRangeMinorGridlinePaint": "    public Paint getRangeMinorGridlinePaint() {\n        return this.rangeMinorGridlinePaint;\n    }", "setRangeMinorGridlinePaint": "    public void setRangeMinorGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeMinorGridlinePaint = paint;\n        fireChangeEvent();\n    }", "isDomainZeroBaselineVisible": "    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }", "setDomainZeroBaselineVisible": "    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }", "getDomainZeroBaselineStroke": "    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }", "setDomainZeroBaselineStroke": "    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }", "getDomainZeroBaselinePaint": "    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }", "setDomainZeroBaselinePaint": "    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }", "isRangeZeroBaselineVisible": "    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }", "setRangeZeroBaselineVisible": "    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }", "getRangeZeroBaselineStroke": "    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }", "setRangeZeroBaselineStroke": "    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }", "getRangeZeroBaselinePaint": "    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }", "setRangeZeroBaselinePaint": "    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }", "getDomainTickBandPaint": "    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }", "setDomainTickBandPaint": "    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }", "getRangeTickBandPaint": "    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }", "setRangeTickBandPaint": "    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }", "getQuadrantOrigin": "    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }", "setQuadrantOrigin": "    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }", "getQuadrantPaint": "    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }", "setQuadrantPaint": "    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }", "addDomainMarker": "    public void addDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "clearDomainMarkers": "    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }", "removeDomainMarker": "    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }", "addRangeMarker": "    public void addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "clearRangeMarkers": "    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }", "removeRangeMarker": "    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }", "addAnnotation": "    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "removeAnnotation": "    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }", "getAnnotations": "    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }", "clearAnnotations": "    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }", "calculateAxisSpace": "    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        Rectangle2D revPlotArea = space.shrink(plotArea, null);\n        space = calculateDomainAxisSpace(g2, revPlotArea, space);\n        return space;\n    }", "calculateDomainAxisSpace": "    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n                                                 Rectangle2D plotArea,\n                                                 AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }", "calculateRangeAxisSpace": "    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n                                                Rectangle2D plotArea,\n                                                AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }", "draw": "    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n            PlotState parentState, PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n        createAndAddEntity((Rectangle2D) dataArea.clone(), info, null, null);\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n\n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);\n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea,\n                            getDomainAxisEdge());\n                }\n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea,\n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea,\n                            getRangeAxisEdge());\n                }\n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea,\n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);\n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        // draw the markers that are associated with a specific renderer...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            // render data items...\n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        // draw domain crosshair if required...\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            }\n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }", "drawBackground": "    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }", "drawQuadrants": "    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        if (xAxis == null) {  // we can't draw quadrants without a valid x-axis\n            return;\n        }\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        if (yAxis == null) {  // we can't draw quadrants without a valid y-axis\n            return;\n        }\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymax, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymax, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymin, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymin, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }", "drawDomainTickBands": "    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                        previous, end);\n            }\n        }\n    }", "drawRangeTickBands": "    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                        previous, end);\n            }\n        }\n    }", "drawAxes": "    protected Map drawAxes(Graphics2D g2,\n                           Rectangle2D plotArea,\n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }", "render": "    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index,\n            PlotRenderingInfo info, CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            if (xAxis == null || yAxis == null) {\n                return foundData;  // can't render anything without axes\n            }\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            XYDatasetSelectionState selectionState = state.getSelectionState();\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem = Math.max(itemBounds[0] - 1, 0);\n                            lastItem = Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            boolean selected = false;\n                            if (selectionState != null) {\n                                selected = selectionState.isSelected(series,\n                                        item);\n                            }\n                            renderer.drawItem(g2, state, dataArea, this,\n                                    xAxis, yAxis, dataset, series, item,\n                                    selected, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem = Math.max(itemBounds[0] - 1, 0);\n                            lastItem = Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            boolean selected = false;\n                            if (selectionState != null) {\n                                selected = selectionState.isSelected(series,\n                                        item);\n                            }\n                            renderer.drawItem(g2, state, dataArea, this, \n                                    xAxis, yAxis, dataset, series, item,\n                                    selected, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n        }\n        return foundData;\n    }", "getDomainAxisForDataset": "    public ValueAxis getDomainAxisForDataset(int index) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (index < 0 || index >= upper) {\n            throw new IllegalArgumentException(\"Index \" + index\n                    + \" out of bounds.\");\n        }\n        ValueAxis valueAxis = null;\n        List axisIndices = (List) this.datasetToDomainAxesMap.get(\n                new Integer(index));\n        if (axisIndices != null) {\n            // the first axis in the list is used for data <--> Java2D\n            Integer axisIndex = (Integer) axisIndices.get(0);\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n    }", "getRangeAxisForDataset": "    public ValueAxis getRangeAxisForDataset(int index) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (index < 0 || index >= upper) {\n            throw new IllegalArgumentException(\"Index \" + index\n                    + \" out of bounds.\");\n        }\n        ValueAxis valueAxis = null;\n        List axisIndices = (List) this.datasetToRangeAxesMap.get(\n                new Integer(index));\n        if (axisIndices != null) {\n            // the first axis in the list is used for data <--> Java2D\n            Integer axisIndex = (Integer) axisIndices.get(0);\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n    }", "drawDomainGridlines": "    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible() || isDomainMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            Iterator iterator = ticks.iterator();\n            boolean paintLine = false;\n            while (iterator.hasNext()) {\n                paintLine = false;\n                ValueTick tick = (ValueTick) iterator.next();\n                if ((tick.getTickType() == TickType.MINOR)\n                        && isDomainMinorGridlinesVisible()) {\n                    gridStroke = getDomainMinorGridlineStroke();\n                    gridPaint = getDomainMinorGridlinePaint();\n                    paintLine = true;\n                }\n                else if ((tick.getTickType() == TickType.MAJOR)\n                        && isDomainGridlinesVisible()) {\n                    gridStroke = getDomainGridlineStroke();\n                    gridPaint = getDomainGridlinePaint();\n                    paintLine = true;\n                }\n                XYItemRenderer r = getRenderer();\n                if ((r instanceof AbstractXYItemRenderer) && paintLine) {\n                    ((AbstractXYItemRenderer) r).drawDomainLine(g2, this,\n                            getDomainAxis(), dataArea, tick.getValue(),\n                            gridPaint, gridStroke);\n                }\n            }\n        }\n    }", "drawRangeGridlines": "    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible() || isRangeMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                boolean paintLine = false;\n                while (iterator.hasNext()) {\n                    paintLine = false;\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if ((tick.getTickType() == TickType.MINOR)\n                            && isRangeMinorGridlinesVisible()) {\n                        gridStroke = getRangeMinorGridlineStroke();\n                        gridPaint = getRangeMinorGridlinePaint();\n                        paintLine = true;\n                    }\n                    else if ((tick.getTickType() == TickType.MAJOR)\n                            && isRangeGridlinesVisible()) {\n                        gridStroke = getRangeGridlineStroke();\n                        gridPaint = getRangeGridlinePaint();\n                        paintLine = true;\n                    }\n                    if ((tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) && paintLine) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(),\n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }", "drawZeroDomainBaseline": "    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0,\n                    this.domainZeroBaselinePaint,\n                    this.domainZeroBaselineStroke);\n        }\n    }", "drawZeroRangeBaseline": "    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0,\n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }", "drawAnnotations": "    public void drawAnnotations(Graphics2D g2,\n                                Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }", "drawDomainMarkers": "    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }", "drawRangeMarkers": "    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }", "getDomainMarkers": "    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }", "getRangeMarkers": "    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }", "drawHorizontalLine": "    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }", "drawDomainCrosshair": "    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy,\n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }", "drawVerticalLine": "    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }", "drawRangeCrosshair": "    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy,\n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }", "handleClick": "    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis xaxis = getDomainAxis();\n            if (xaxis != null) {\n                double hvalue = xaxis.java2DToValue(x, info.getDataArea(),\n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis yaxis = getRangeAxis();\n            if (yaxis != null) {\n                double vvalue = yaxis.java2DToValue(y, info.getDataArea(),\n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }", "getDatasetsMappedToDomainAxis": "    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            List mappedAxes = (List) this.datasetToDomainAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }", "getDatasetsMappedToRangeAxis": "    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            List mappedAxes = (List) this.datasetToRangeAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }", "getDomainAxisIndex": "    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }", "getRangeAxisIndex": "    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }", "getDataRange": "    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }", "datasetChanged": "    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }", "rendererChanged": "    public void rendererChanged(RendererChangeEvent event) {\n        // if the event was caused by a change to series visibility, then\n        // the axis ranges might need updating...\n        if (event.getSeriesVisibilityChanged()) {\n            configureDomainAxes();\n            configureRangeAxes();\n        }\n        fireChangeEvent();\n    }", "isDomainCrosshairVisible": "    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }", "setDomainCrosshairVisible": "    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }", "isDomainCrosshairLockedOnData": "    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }", "setDomainCrosshairLockedOnData": "    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }", "getDomainCrosshairValue": "    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }", "setDomainCrosshairValue": "    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }", "getDomainCrosshairStroke": "    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }", "setDomainCrosshairStroke": "    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }", "getDomainCrosshairPaint": "    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }", "setDomainCrosshairPaint": "    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }", "isRangeCrosshairVisible": "    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }", "setRangeCrosshairVisible": "    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }", "isRangeCrosshairLockedOnData": "    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }", "setRangeCrosshairLockedOnData": "    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }", "getRangeCrosshairValue": "    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }", "setRangeCrosshairValue": "    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }", "getRangeCrosshairStroke": "    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }", "setRangeCrosshairStroke": "    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }", "getRangeCrosshairPaint": "    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }", "setRangeCrosshairPaint": "    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }", "getFixedDomainAxisSpace": "    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }", "setFixedDomainAxisSpace": "    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "getFixedRangeAxisSpace": "    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }", "setFixedRangeAxisSpace": "    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }", "isDomainPannable": "    public boolean isDomainPannable() {\n        return this.domainPannable;\n    }", "setDomainPannable": "    public void setDomainPannable(boolean pannable) {\n        this.domainPannable = pannable;\n    }", "isRangePannable": "    public boolean isRangePannable() {\n        return this.rangePannable;\n    }", "setRangePannable": "    public void setRangePannable(boolean pannable) {\n        this.rangePannable = pannable;\n    }", "panDomainAxes": "    public void panDomainAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isDomainPannable()) {\n            return;\n        }\n        int domainAxisCount = getDomainAxisCount();\n        for (int i = 0; i < domainAxisCount; i++) {\n            ValueAxis axis = getDomainAxis(i);\n            if (axis == null) {\n                continue;\n            }\n            if (axis.isInverted()) {\n                percent = -percent;\n            }\n            axis.pan(percent);\n        }\n    }", "panRangeAxes": "    public void panRangeAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isRangePannable()) {\n            return;\n        }\n        int rangeAxisCount = getRangeAxisCount();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            ValueAxis axis = getRangeAxis(i);\n            if (axis == null) {\n                continue;\n            }\n            if (axis.isInverted()) {\n                percent = -percent;\n            }\n            axis.pan(percent);\n        }\n    }", "zoomDomainAxes": "    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }", "zoomRangeAxes": "    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }", "isDomainZoomable": "    public boolean isDomainZoomable() {\n        return true;\n    }", "isRangeZoomable": "    public boolean isRangeZoomable() {\n        return true;\n    }", "getSeriesCount": "    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }", "getFixedLegendItems": "    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }", "setFixedLegendItems": "    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }", "getLegendItems": "    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }", "equals": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainMinorGridlinesVisible\n                != that.domainMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeMinorGridlinesVisible\n                != that.rangeMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxesMap,\n                that.datasetToDomainAxesMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxesMap,\n                that.datasetToRangeAxesMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke,\n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint,\n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke,\n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint,\n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainMinorGridlineStroke,\n                that.domainMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainMinorGridlinePaint,\n                that.domainMinorGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeMinorGridlineStroke,\n                that.rangeMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeMinorGridlinePaint,\n                that.rangeMinorGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint,\n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke,\n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint,\n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke,\n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke,\n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint,\n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke,\n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint,\n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers,\n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers,\n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers,\n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers,\n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers,\n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers,\n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers,\n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers,\n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedLegendItems,\n                that.fixedLegendItems)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint,\n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint,\n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i],\n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }", "clone": "    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList)\n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxesMap = new TreeMap();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap = new TreeMap();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        if (this.fixedLegendItems != null) {\n            clone.fixedLegendItems\n                    = (LegendItemCollection) this.fixedLegendItems.clone();\n        }\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }", "writeObject": "    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.domainMinorGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainMinorGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeMinorGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeMinorGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }", "readObject": "    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.domainMinorGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainMinorGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and\n        // renderers...\n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }", "canSelectByPoint": "    public boolean canSelectByPoint() {\n        return false;  // TODO: make this true later\n}", "canSelectByRegion": "    public boolean canSelectByRegion() {\n        return true;\n    }", "select": "    public void select(GeneralPath region, Rectangle2D dataArea,\n            RenderingSource source) {\n        // cycle through the datasets and change the selection state for the\n        // items that fall within the specified region\n        int datasetCount = this.datasets.size();\n        for (int d = 0; d < datasetCount; d++) {\n            XYDataset dataset = (XYDataset) this.datasets.get(d);\n            if (dataset == null) {\n                continue;\n            }\n            XYDatasetSelectionState state = findSelectionStateForDataset(\n                    dataset, source);\n            if (state == null) {\n                continue;\n            }\n            GeneralPath path = convertToDataSpace(region, dataArea, dataset);\n            // now we have to iterate over all the dataset values and\n            // convert each point to Java2D space and then check if it should\n            // be selected.\n            int seriesCount = dataset.getSeriesCount();\n            for (int s = 0; s < seriesCount; s++) {\n                int itemCount = dataset.getItemCount(s);\n                for (int i = 0; i < itemCount; i++) {\n                    double x = dataset.getXValue(s, i);\n                    double y = dataset.getYValue(s, i);\n                    if (path.contains(x, y)) {\n                        state.setSelected(s, i, true);\n                        // FIXME:  we should fire just one dataset change event\n                        // for the whole selection\n                    }\n                }\n            }\n        }\n    }", "findSelectionStateForDataset": "    private XYDatasetSelectionState findSelectionStateForDataset(\n            XYDataset dataset, Object source) {\n        if (dataset instanceof SelectableXYDataset) {\n            SelectableXYDataset sd = (SelectableXYDataset) dataset;\n            XYDatasetSelectionState s = sd.getSelectionState();\n            return s;\n        }\n        throw new RuntimeException();\n        //return null;  // TODO: implement\n    }", "convertToDataSpace": "    private GeneralPath convertToDataSpace(GeneralPath path,\n            Rectangle2D dataArea, XYDataset dataset) {\n        GeneralPath result = new GeneralPath(path.getWindingRule());\n        int datasetIndex = indexOf(dataset);\n        ValueAxis xAxis = getDomainAxisForDataset(datasetIndex);\n        ValueAxis yAxis = getRangeAxisForDataset(datasetIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge();\n        RectangleEdge yAxisEdge = getRangeAxisEdge();\n        double[] coords = new double[6];\n        PathIterator iterator = path.getPathIterator(null);\n        while (!iterator.isDone()) {\n            int segType = iterator.currentSegment(coords);\n            double xx = xAxis.java2DToValue(coords[0], dataArea, xAxisEdge);\n            double yy = yAxis.java2DToValue(coords[1], dataArea, yAxisEdge);\n            if (segType == PathIterator.SEG_MOVETO) {\n                result.moveTo((float) xx, (float) yy);\n            }\n            else if (segType == PathIterator.SEG_LINETO) {\n                result.lineTo((float) xx, (float) yy);\n            }\n            else if (segType == PathIterator.SEG_CLOSE) {\n                result.closePath();\n            }\n            iterator.next();\n        }\n        return result;\n    }", "clearSelection": "    public void clearSelection() {\n        // cycle through the datasets and clear the selection state\n        int datasetCount = this.datasets.size();\n        for (int d = 0; d < datasetCount; d++) {\n            XYDataset dataset = (XYDataset) this.datasets.get(d);\n            if (dataset instanceof AbstractXYDataset) {\n                // TODO: we could add an interface that *any* dataset could\n                // implement if it provides a selection state\n                AbstractXYDataset axyd = (AbstractXYDataset) dataset;\n                if (axyd.getSelectionState() != null) {\n                    XYDatasetSelectionState selState = axyd.getSelectionState();\n                    selState.clearSelection();\n                }\n            }\n        }\n    }"}