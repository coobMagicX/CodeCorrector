{"process": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }", "getReferences": "    public ReferenceCollection getReferences(Var var) {\n      return referenceMap.get(var);\n    }", "visit": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n      Var v;\n      if (n.getString().equals(\"arguments\")) {\n        v = t.getScope().getArgumentsVar();\n      } else {\n        v = t.getScope().getVar(n.getString());\n      }\n      if (v != null && varFilter.apply(v)) {\n        addReference(v, new Reference(n, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }", "isBlockBoundary": "  private static boolean isBlockBoundary(Node n, Node parent) {\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DO:\n        case Token.FOR:\n        case Token.TRY:\n        case Token.WHILE:\n        case Token.WITH:\n          // NOTE: TRY has up to 3 child blocks:\n          // TRY\n          //   BLOCK\n          //   BLOCK\n          //     CATCH\n          //   BLOCK\n          // Note that there is an explicit CATCH token but no explicit\n          // FINALLY token. For simplicity, we consider each BLOCK\n          // a separate basic BLOCK.\n          return true;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.OR:\n          // The first child of a conditional is not a boundary,\n          // but all the rest of the children are.\n          return n != parent.getFirstChild();\n\n      }\n    }\n\n    return n.isCase();\n  }", "addReference": "  private void addReference(Var v, Reference reference) {\n    // Create collection if none already\n    ReferenceCollection referenceInfo = referenceMap.get(v);\n    if (referenceInfo == null) {\n      referenceInfo = new ReferenceCollection();\n      referenceMap.put(v, referenceInfo);\n    }\n\n    // Add this particular reference\n    referenceInfo.add(reference);\n  }", "iterator": "    public Iterator<Reference> iterator() {\n      return references.iterator();\n    }", "add": "    void add(Reference reference) {\n      references.add(reference);\n    }", "getInitializingReference": "    Reference getInitializingReference() {\n      if (isInitializingDeclarationAt(0)) {\n        return references.get(0);\n      } else if (isInitializingAssignmentAt(1)) {\n        return references.get(1);\n      }\n      return null;\n    }", "getInitializingReferenceForConstants": "    Reference getInitializingReferenceForConstants() {\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n          return references.get(i);\n        }\n      }\n      return null;\n    }", "getOneAndOnlyAssignment": "    private Reference getOneAndOnlyAssignment() {\n      Reference assignment = null;\n      int size = references.size();\n      for (int i = 0; i < size; i++) {\n        Reference ref = references.get(i);\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          if (assignment == null) {\n            assignment = ref;\n          } else {\n            return null;\n          }\n        }\n      }\n      return assignment;\n    }", "firstReferenceIsAssigningDeclaration": "    boolean firstReferenceIsAssigningDeclaration() {\n      int size = references.size();\n      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n        return true;\n      }\n      return false;\n    }", "createRefForTest": "    static Reference createRefForTest(CompilerInput input) {\n      return new Reference(new Node(Token.NAME), null, null,\n          input.getInputId());\n    }", "getBasicBlock": "    BasicBlock getBasicBlock() {\n      return basicBlock;\n    }", "getParent": "    BasicBlock getParent() {\n      return parent;\n    }", "isGlobalScopeBlock": "    boolean isGlobalScopeBlock() {\n      return getParent() == null;\n    }"}