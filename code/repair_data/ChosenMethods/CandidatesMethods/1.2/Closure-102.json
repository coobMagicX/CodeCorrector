{"reportCodeChange": "  private void reportCodeChange(String changeDescription) {\n    if (assertOnChange) {\n      throw new IllegalStateException(\n          \"Normalize constraints violated:\\n\" + changeDescription);\n    }\n    compiler.reportCodeChange();\n  }", "process": "    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }", "shouldTraverse": "    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }", "doStatementNormalizations": "  private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.LABEL) {\n      normalizeLabels(n);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n    // are the only legal place for VARs and FOR statements.\n    if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n      extractForInitializer(n, null, null);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs, as all these\n    // are the only legal place for VARs.\n    if (NodeUtil.isStatementBlock(n)) {\n      splitVarDeclarations(n);\n    }\n\n    if (n.getType() == Token.FUNCTION) {\n      moveNamedFunctions(n.getLastChild());\n    }\n  }", "extractForInitializer": "  private void extractForInitializer(\n      Node n, Node before, Node beforeParent) {\n\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      Node insertBefore = (before == null) ? c : before;\n      Node insertBeforeParent = (before == null) ? n : beforeParent;\n      switch (c.getType()) {\n        case Token.LABEL:\n          extractForInitializer(c, insertBefore, insertBeforeParent);\n          break;\n        case Token.FOR:\n          if (!NodeUtil.isForIn(c)\n              && c.getFirstChild().getType() != Token.EMPTY) {\n            Node init = c.getFirstChild();\n            c.replaceChild(init, new Node(Token.EMPTY));\n\n            Node newStatement;\n            // Only VAR statements, and expressions are allowed,\n            // but are handled differently.\n            if (init.getType() == Token.VAR) {\n              newStatement = init;\n            } else {\n              newStatement = NodeUtil.newExpr(init);\n            }\n\n            insertBeforeParent.addChildBefore(newStatement, insertBefore);\n            reportCodeChange(\"FOR initializer\");\n          }\n          break;\n      }\n    }\n  }", "splitVarDeclarations": "  private void splitVarDeclarations(Node n) {\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      if (c.getType() == Token.VAR) {\n        if (assertOnChange && !c.hasChildren()) {\n          throw new IllegalStateException(\"Empty VAR node.\");\n        }\n\n        while (c.getFirstChild() != c.getLastChild()) {\n          Node name = c.getFirstChild();\n          c.removeChild(name);\n          Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());\n          n.addChildBefore(newVar, c);\n          reportCodeChange(\"VAR with multiple children\");\n        }\n      }\n    }\n  }", "moveNamedFunctions": "  private void moveNamedFunctions(Node functionBody) {\n    Preconditions.checkState(\n        functionBody.getParent().getType() == Token.FUNCTION);\n    Node previous = null;\n    Node current = functionBody.getFirstChild();\n    // Skip any declarations at the beginning of the function body, they\n    // are already in the right place.\n    while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n      previous = current;\n      current = current.getNext();\n    }\n\n    // Find any remaining declarations and move them.\n    Node insertAfter = previous;\n    while (current != null) {\n      // Save off the next node as the current node maybe removed.\n      Node next = current.getNext();\n      if (NodeUtil.isFunctionDeclaration(current)) {\n        // Remove the declaration from the body.\n        Preconditions.checkNotNull(previous);\n        functionBody.removeChildAfter(previous);\n\n        // Readd the function at the top of the function body (after any\n        // previous declarations).\n        insertAfter = addToFront(functionBody, current, insertAfter);\n        compiler.reportCodeChange();\n      } else {\n        // Update the previous only if the current node hasn't been moved.\n        previous = current;\n      }\n      current = next;\n    }\n  }", "addToFront": "  private Node addToFront(Node parent, Node newChild, Node after) {\n    if (after == null) {\n      parent.addChildToFront(newChild);\n    } else {\n      parent.addChildAfter(newChild, after);\n    }\n    return newChild;\n  }", "removeDuplicateDeclarations": "  private void removeDuplicateDeclarations(Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverse(root);\n  }", "onRedeclaration": "    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        //\n        // Remove the parent VAR. There are three cases that need to be handled:\n        //  1) \"var a = b;\" which is replaced with \"a = b\"\n        //  2) \"label:var a;\" which is replaced with \"label:;\".  Ideally, the\n        //     label itself would be removed but that is not possible in the\n        //     context in which \"onRedeclaration\" is called.\n        //  3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n        // Cases we don't need to handle are VARs with multiple children,\n        // which have already been split into separate declarations, so there\n        // is no need to handle that here, and \"for (var a;;);\", which has\n        // been moved out of the loop.\n        //\n        // The result of this is that in each case the parent node is replaced\n        // which is generally dangerous in a traversal but is fine here with\n        // the scope creator, as the next node of interest is the parent's\n        // next sibling.\n        //\n        if (n.hasChildren()) {\n          // The var is being initialize, preserve the new value.\n          parent.removeChild(n);\n          // Convert \"var name = value\" to \"name = value\"\n          Node value = n.getFirstChild();\n          n.removeChild(value);\n          Node replacement = new Node(Token.ASSIGN, n, value);\n          gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n        } else {\n          // It is an empty reference remove it.\n          if (NodeUtil.isStatementBlock(gramps)) {\n            gramps.removeChild(parent);\n          } else if (gramps.getType() == Token.FOR) {\n            // This is the \"for (var a in b)...\" case.  We don't need to worry\n            // about initializers in \"for (var a;;)...\" as those are moved out\n            // as part of the other normalizations.\n            parent.removeChild(n);\n            gramps.replaceChild(parent, n);\n          } else {\n            Preconditions.checkState(gramps.getType() == Token.LABEL);\n            gramps.replaceChild(parent, new Node(Token.EMPTY));\n          }\n        }\n        reportCodeChange(\"Duplicate VAR declaration\");\n      }\n    }", "enterScope": "    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }", "exitScope": "    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }"}