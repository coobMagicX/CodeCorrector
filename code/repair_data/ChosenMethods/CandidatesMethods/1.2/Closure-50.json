{"tryFoldKnownMethods": "  private Node tryFoldKnownMethods(Node subtree) {\n    // For now we only support string methods .join(),\n    // .indexOf(), .substring() and .substr()\n    // and numeric methods parseInt() and parseFloat().\n\n    subtree = tryFoldArrayJoin(subtree);\n\n    if (subtree.getType() == Token.CALL) {\n      Node callTarget = subtree.getFirstChild();\n      if (callTarget == null) {\n        return subtree;\n      }\n\n      if (NodeUtil.isGet(callTarget)) {\n        subtree = tryFoldKnownStringMethods(subtree);\n      } else {\n        subtree = tryFoldKnownNumericMethods(subtree);\n      }\n    }\n\n    return subtree;\n  }", "tryFoldKnownStringMethods": "  private Node tryFoldKnownStringMethods(Node subtree) {\n    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n\n    // check if this is a call on a string method\n    // then dispatch to specific folding method.\n    Node callTarget = subtree.getFirstChild();\n    if (callTarget == null) {\n      return subtree;\n    }\n\n    if (!NodeUtil.isGet(callTarget)) {\n      return subtree;\n    }\n\n    Node stringNode = callTarget.getFirstChild();\n    Node functionName = stringNode.getNext();\n\n    if ((stringNode.getType() != Token.STRING) ||\n        (functionName.getType() != Token.STRING)) {\n      return subtree;\n    }\n\n    String functionNameString = functionName.getString();\n    Node firstArg = callTarget.getNext();\n    if (firstArg == null) {\n      if (functionNameString.equals(\"toLowerCase\")) {\n        subtree = tryFoldStringToLowerCase(subtree, stringNode);\n      } else if (functionNameString.equals(\"toUpperCase\")) {\n        subtree = tryFoldStringToUpperCase(subtree, stringNode);\n      }\n      return subtree;\n    } else if (NodeUtil.isImmutableValue(firstArg)) {\n      if (functionNameString.equals(\"indexOf\") ||\n          functionNameString.equals(\"lastIndexOf\")) {\n        subtree = tryFoldStringIndexOf(subtree, functionNameString,\n            stringNode, firstArg);\n      } else if (functionNameString.equals(\"substr\")) {\n        subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);\n      } else if (functionNameString.equals(\"substring\")) {\n        subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);\n      } else if (functionNameString.equals(\"charAt\")) {\n        subtree = tryFoldStringCharAt(subtree, stringNode, firstArg);\n      } else if (functionNameString.equals(\"charCodeAt\")) {\n        subtree = tryFoldStringCharCodeAt(subtree, stringNode, firstArg);\n      }\n    }\n\n    return subtree;\n  }", "tryFoldKnownNumericMethods": "  private Node tryFoldKnownNumericMethods(Node subtree) {\n    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n\n    if (isASTNormalized()) {\n      // check if this is a call on a string method\n      // then dispatch to specific folding method.\n      Node callTarget = subtree.getFirstChild();\n\n      if (!NodeUtil.isName(callTarget)) {\n        return subtree;\n      }\n\n      String functionNameString = callTarget.getString();\n      Node firstArgument = callTarget.getNext();\n      if ((firstArgument != null) &&\n          (firstArgument.getType() == Token.STRING ||\n           firstArgument.getType() == Token.NUMBER)) {\n        if (functionNameString.equals(\"parseInt\") ||\n            functionNameString.equals(\"parseFloat\")) {\n          subtree = tryFoldParseNumber(subtree, functionNameString,\n              firstArgument);\n        }\n      }\n    }\n    return subtree;\n  }", "tryFoldStringToLowerCase": "  private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n    // From Rhino, NativeString.java. See ECMA 15.5.4.11\n    String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE);\n    Node replacement = Node.newString(lowered);\n    subtree.getParent().replaceChild(subtree, replacement);\n    reportCodeChange();\n    return replacement;\n  }", "tryFoldStringToUpperCase": "  private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n    // From Rhino, NativeString.java. See ECMA 15.5.4.12\n    String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE);\n    Node replacement = Node.newString(uppered);\n    subtree.getParent().replaceChild(subtree, replacement);\n    reportCodeChange();\n    return replacement;\n  }", "normalizeNumericString": "  private String normalizeNumericString(String input) {\n    if (input == null || input.length() == 0) {\n      return input;\n    }\n\n    int startIndex = 0, endIndex = input.length() - 1;\n    while (startIndex < input.length() && input.charAt(startIndex) == '0') {\n      startIndex++;\n    }\n    while (endIndex >= 0 && input.charAt(endIndex) == '0') {\n      endIndex--;\n    }\n    if (startIndex >= endIndex) {\n      return input;\n    }\n\n    return input.substring(startIndex, endIndex + 1);\n  }", "tryFoldParseNumber": "  private Node tryFoldParseNumber(\n      Node n, String functionName, Node firstArg) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n\n    boolean isParseInt = functionName.equals(\"parseInt\");\n    Node secondArg = firstArg.getNext();\n\n    // Second argument is only used as the radix for parseInt\n    int radix = 0;\n    if (secondArg != null) {\n      if (!isParseInt) {\n        return n;\n      }\n\n      // Third-argument and non-numeric second arg are problematic. Discard.\n      if ((secondArg.getNext() != null) ||\n          (secondArg.getType() != Token.NUMBER)) {\n        return n;\n      } else {\n        double tmpRadix = secondArg.getDouble();\n        if (tmpRadix != (int)tmpRadix)\n          return n;\n        radix = (int)tmpRadix;\n        if (radix < 0 || radix == 1 || radix > 36) {\n          return n;\n        }\n      }\n    }\n\n    // stringVal must be a valid string.\n    String stringVal = null;\n    Double checkVal;\n    if (firstArg.getType() == Token.NUMBER) {\n      checkVal = NodeUtil.getNumberValue(firstArg);\n      if (!(radix == 0 || radix == 10) && isParseInt) {\n        //Convert a numeric first argument to a different base\n        stringVal = String.valueOf(checkVal.intValue());\n      } else {\n        // If parseFloat is called with a numeric argument,\n        // replace it with just the number.\n        // If parseInt is called with a numeric first argument and the radix\n        // is 10 or omitted, just replace it with the number\n        Node numericNode;\n        if (isParseInt) {\n          numericNode = Node.newNumber(checkVal.intValue());\n        } else {\n          numericNode = Node.newNumber(checkVal);\n        }\n        n.getParent().replaceChild(n, numericNode);\n        reportCodeChange();\n        return numericNode;\n      }\n    } else {\n      stringVal = NodeUtil.getStringValue(firstArg);\n      if (stringVal == null) {\n        return n;\n      }\n\n      //Check that the string is in a format we can recognize\n      checkVal = NodeUtil.getStringNumberValue(stringVal);\n      if (checkVal == null) {\n        return n;\n      }\n\n      stringVal = NodeUtil.trimJsWhiteSpace(stringVal);\n    }\n\n    Node newNode;\n    if (isParseInt) {\n      if (radix == 0 || radix == 16) {\n        if (stringVal.length() > 1 &&\n            stringVal.substring(0, 2).equalsIgnoreCase(\"0x\")) {\n          radix = 16;\n          stringVal = stringVal.substring(2);\n        } else if (radix == 0) {\n          // if a radix is not specified or is 0 and the most\n          // significant digit is \"0\", the string will parse\n          // with a radix of 8 on some browsers, so leave\n          // this case alone. This check does not apply in\n          // script mode ECMA5 or greater\n          if (!isEcmaScript5OrGreater() &&\n              stringVal.substring(0, 1).equals(\"0\")) {\n            return n;\n          }\n\n          radix = 10;\n        }\n      }\n      int newVal = 0;\n      try {\n        newVal = Integer.parseInt(stringVal, radix);\n      } catch (NumberFormatException e) {\n        return n;\n      }\n\n      newNode = Node.newNumber(newVal);\n    } else {\n      String normalizedNewVal = \"0\";\n      try {\n        double newVal = Double.parseDouble(stringVal);\n        newNode = Node.newNumber(newVal);\n        normalizedNewVal = normalizeNumericString(String.valueOf(newVal));\n      }\n      catch(NumberFormatException e) {\n        return n;\n      }\n      // Make sure that the parsed number matches the original string\n      // This prevents rounding differences between the java implementation\n      // and native script.\n      if (!normalizeNumericString(stringVal).equals(normalizedNewVal)) {\n        return n;\n      }\n    }\n\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldStringIndexOf": "  private Node tryFoldStringIndexOf(\n      Node n, String functionName, Node lstringNode, Node firstArg) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(lstringNode.getType() == Token.STRING);\n\n    String lstring = NodeUtil.getStringValue(lstringNode);\n    boolean isIndexOf = functionName.equals(\"indexOf\");\n    Node secondArg = firstArg.getNext();\n    String searchValue = NodeUtil.getStringValue(firstArg);\n    // searchValue must be a valid string.\n    if (searchValue == null) {\n      return n;\n    }\n    int fromIndex = isIndexOf ? 0 : lstring.length();\n    if (secondArg != null) {\n      // Third-argument and non-numeric second arg are problematic. Discard.\n      if ((secondArg.getNext() != null) ||\n          (secondArg.getType() != Token.NUMBER)) {\n        return n;\n      } else {\n        fromIndex = (int) secondArg.getDouble();\n      }\n    }\n    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n                             : lstring.lastIndexOf(searchValue, fromIndex);\n    Node newNode = Node.newNumber(indexVal);\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldArrayJoin": "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node right = callTarget.getNext();\n    if (right != null) {\n      if (!NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n      // \",\" is the default, it doesn't need to be explicit\n\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    // one for each comma.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // No folding could actually be performed.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n;\n  }", "tryFoldStringSubstr": "  private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n\n    int start, length;\n    String stringAsString = stringNode.getString();\n\n    // TODO(nicksantos): We really need a NodeUtil.getNumberValue\n    // function.\n    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n      start = (int) arg1.getDouble();\n    } else {\n      return n;\n    }\n\n    Node arg2 = arg1.getNext();\n    if (arg2 != null) {\n      if (arg2.getType() == Token.NUMBER) {\n        length = (int) arg2.getDouble();\n      } else {\n        return n;\n      }\n\n      if (arg2.getNext() != null) {\n        // If we got more args than we expected, bail out.\n        return n;\n      }\n    } else {\n      // parameter 2 not passed\n      length = stringAsString.length() - start;\n    }\n\n    // Don't handle these cases. The specification actually does\n    // specify the behavior in some of these cases, but we haven't\n    // done a thorough investigation that it is correctly implemented\n    // in all browsers.\n    if ((start + length) > stringAsString.length() ||\n        (length < 0) ||\n        (start < 0)) {\n      return n;\n    }\n\n    String result = stringAsString.substring(start, start + length);\n    Node resultNode = Node.newString(result);\n\n    Node parent = n.getParent();\n    parent.replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n  }", "tryFoldStringSubstring": "  private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n\n    int start, end;\n    String stringAsString = stringNode.getString();\n\n    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n      start = (int) arg1.getDouble();\n    } else {\n      return n;\n    }\n\n    Node arg2 = arg1.getNext();\n    if (arg2 != null) {\n      if (arg2.getType() == Token.NUMBER) {\n        end = (int) arg2.getDouble();\n      } else {\n        return n;\n      }\n\n      if (arg2.getNext() != null) {\n        // If we got more args than we expected, bail out.\n        return n;\n      }\n    } else {\n      // parameter 2 not passed\n      end = stringAsString.length();\n    }\n\n    // Don't handle these cases. The specification actually does\n    // specify the behavior in some of these cases, but we haven't\n    // done a thorough investigation that it is correctly implemented\n    // in all browsers.\n    if ((end > stringAsString.length()) ||\n        (start > stringAsString.length()) ||\n        (end < 0) ||\n        (start < 0)) {\n      return n;\n    }\n\n    String result = stringAsString.substring(start, end);\n    Node resultNode = Node.newString(result);\n\n    Node parent = n.getParent();\n    parent.replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n  }", "tryFoldStringCharAt": "  private Node tryFoldStringCharAt(Node n, Node stringNode, Node arg1) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n\n    int index;\n    String stringAsString = stringNode.getString();\n\n    if (arg1 != null && arg1.getType() == Token.NUMBER\n        && arg1.getNext() == null) {\n      index = (int) arg1.getDouble();\n    } else {\n      return n;\n    }\n\n    if (index < 0 || stringAsString.length() <= index) {\n      // http://es5.github.com/#x15.5.4.4 says \"\" is returned when index is\n      // out of bounds but we bail.\n      return n;\n    }\n\n    Node resultNode = Node.newString(\n        stringAsString.substring(index, index + 1));\n    Node parent = n.getParent();\n    parent.replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n  }", "tryFoldStringCharCodeAt": "  private Node tryFoldStringCharCodeAt(Node n, Node stringNode, Node arg1) {\n    Preconditions.checkArgument(n.getType() == Token.CALL);\n    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n\n    int index;\n    String stringAsString = stringNode.getString();\n\n    if (arg1 != null && arg1.getType() == Token.NUMBER\n        && arg1.getNext() == null) {\n      index = (int) arg1.getDouble();\n    } else {\n      return n;\n    }\n\n    if (index < 0 || stringAsString.length() <= index) {\n      // http://es5.github.com/#x15.5.4.5 says NaN is returned when index is\n      // out of bounds but we bail.\n      return n;\n    }\n\n    Node resultNode = Node.newNumber(stringAsString.charAt(index));\n    Node parent = n.getParent();\n    parent.replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n  }"}