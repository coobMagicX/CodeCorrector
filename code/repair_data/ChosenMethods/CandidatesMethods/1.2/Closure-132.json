{"tryJoinForCondition": "  private void tryJoinForCondition(Node n) {\n    if (!late) {\n      return;\n    }\n\n    Node block = n.getLastChild();\n    Node maybeIf = block.getFirstChild();\n    if (maybeIf != null && maybeIf.isIf()) {\n      Node maybeBreak = maybeIf.getChildAtIndex(1).getFirstChild();\n      if (maybeBreak != null && maybeBreak.isBreak()\n          && !maybeBreak.hasChildren()) {\n\n        // Preserve the IF ELSE expression is there is one.\n        if (maybeIf.getChildCount() == 3) {\n          block.replaceChild(maybeIf,\n              maybeIf.getLastChild().detachFromParent());\n        } else {\n          block.removeFirstChild();\n        }\n\n        Node ifCondition = maybeIf.removeFirstChild();\n        Node fixedIfCondition = IR.not(ifCondition)\n            .srcref(ifCondition);\n\n        // OK, join the IF expression with the FOR expression\n        Node forCondition = NodeUtil.getConditionExpression(n);\n        if (forCondition.isEmpty()) {\n          n.replaceChild(forCondition, fixedIfCondition);\n        } else {\n          Node replacement = new Node(Token.AND);\n          n.replaceChild(forCondition, replacement);\n          replacement.addChildToBack(forCondition);\n          replacement.addChildToBack(fixedIfCondition);\n        }\n\n        reportCodeChange();\n      }\n    }\n  }", "tryFoldSimpleFunctionCall": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null && value.getNext() == null &&\n          NodeUtil.isImmutableValue(value)) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }", "tryFoldImmediateCallToBoundFunction": "  private Node tryFoldImmediateCallToBoundFunction(Node n) {\n    // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    Bind bind = getCodingConvention().describeFunctionBind(callTarget, false);\n    if (bind != null) {\n      // replace the call target\n      bind.target.detachFromParent();\n      n.replaceChild(callTarget, bind.target);\n      callTarget = bind.target;\n\n      // push the parameters\n      addParameterAfter(bind.parameters, callTarget);\n\n      // add the this value before the parameters if necessary\n      if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {\n        // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n        Node newCallTarget = IR.getprop(\n            callTarget.cloneTree(),\n            IR.string(\"call\").srcref(callTarget));\n        n.replaceChild(callTarget, newCallTarget);\n        n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);\n        n.putBooleanProp(Node.FREE_CALL, false);\n      } else {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n      reportCodeChange();\n    }\n    return n;\n  }", "statementMustExitParent": "  private boolean statementMustExitParent(Node n) {\n    switch (n.getType()) {\n      case Token.THROW:\n      case Token.RETURN:\n        return true;\n      case Token.BLOCK:\n        if (n.hasChildren()) {\n          Node child = n.getLastChild();\n          return statementMustExitParent(child);\n        }\n        return false;\n      // TODO(johnlenz): handle TRY/FINALLY\n      case Token.FUNCTION:\n      default:\n        return false;\n    }\n  }", "tryReplaceUndefined": "  private Node tryReplaceUndefined(Node n) {\n    // TODO(johnlenz): consider doing this as a normalization.\n    if (isASTNormalized()\n        && NodeUtil.isUndefined(n)\n        && !NodeUtil.isLValue(n)) {\n      Node replacement = NodeUtil.newUndefinedNode(n);\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n    return n;\n  }", "tryReduceReturn": "  private Node tryReduceReturn(Node n) {\n    Node result = n.getFirstChild();\n\n    if (result != null) {\n      switch (result.getType()) {\n        case Token.VOID:\n          Node operand = result.getFirstChild();\n          if (!mayHaveSideEffects(operand)) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n        case Token.NAME:\n          String name = result.getString();\n          if (name.equals(\"undefined\")) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n      }\n    }\n\n    return n;\n  }", "tryRemoveRedundantExit": "  private Node tryRemoveRedundantExit(Node n) {\n    Node exitExpr = n.getFirstChild();\n\n    Node follow = ControlFlowAnalysis.computeFollowNode(n);\n\n    // Skip pass all the finally blocks because both the fall through and return\n    // will also trigger all the finally blocks.\n    Node prefinallyFollows = follow;\n    follow = skipFinallyNodes(follow);\n    if (prefinallyFollows != follow) {\n      // There were finally clauses\n      if (!isPure(exitExpr)) {\n        // Can't replace the return\n        return n;\n      }\n    }\n\n    if (follow == null && (n.isThrow() || exitExpr != null)) {\n      // Can't complete remove a throw here or a return with a result.\n      return n;\n    }\n\n    // When follow is null, this mean the follow of a break target is the\n    // end of a function. This means a break is same as return.\n    if (follow == null || areMatchingExits(n, follow)) {\n      n.detachFromParent();\n      reportCodeChange();\n      return null;\n    }\n\n    return n;\n  }", "skipFinallyNodes": "  Node skipFinallyNodes(Node n) {\n    while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) {\n      n = ControlFlowAnalysis.computeFollowNode(n);\n    }\n    return n;\n  }", "areMatchingExits": "  boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n    return nodeThis.isEquivalentTo(nodeThat)\n        && (!isExceptionPossible(nodeThis)\n            || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));\n  }", "isExceptionPossible": "  boolean isExceptionPossible(Node n) {\n    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?\n    Preconditions.checkState(n.isReturn()\n        || n.isThrow());\n    return n.isThrow()\n        || (n.hasChildren()\n            && !NodeUtil.isLiteralValue(n.getLastChild(), true));\n  }", "getExceptionHandler": "  Node getExceptionHandler(Node n) {\n    return ControlFlowAnalysis.getExceptionHandler(n);\n  }", "tryMinimizeNot": "  private Node tryMinimizeNot(Node n) {\n    Node parent = n.getParent();\n\n    Node notChild = n.getFirstChild();\n    // negative operator of the current one : == -> != for instance.\n    int complementOperator;\n    switch (notChild.getType()) {\n      case Token.EQ:\n        complementOperator = Token.NE;\n        break;\n      case Token.NE:\n        complementOperator = Token.EQ;\n        break;\n      case Token.SHEQ:\n        complementOperator = Token.SHNE;\n        break;\n      case Token.SHNE:\n        complementOperator = Token.SHEQ;\n        break;\n      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n      default:\n        return n;\n    }\n    Node newOperator = n.removeFirstChild();\n    newOperator.setType(complementOperator);\n    parent.replaceChild(n, newOperator);\n    reportCodeChange();\n    return newOperator;\n  }", "tryMinimizeIf": "  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }", "tryRemoveRepeatedStatements": "  private void tryRemoveRepeatedStatements(Node n) {\n    Preconditions.checkState(n.isIf());\n\n    Node parent = n.getParent();\n    if (!NodeUtil.isStatementBlock(parent)) {\n      // If the immediate parent is something like a label, we\n      // can't move the statement, so bail.\n      return;\n    }\n\n    Node cond = n.getFirstChild();\n    Node trueBranch = cond.getNext();\n    Node falseBranch = trueBranch.getNext();\n    Preconditions.checkNotNull(trueBranch);\n    Preconditions.checkNotNull(falseBranch);\n\n    while (true) {\n      Node lastTrue = trueBranch.getLastChild();\n      Node lastFalse = falseBranch.getLastChild();\n      if (lastTrue == null || lastFalse == null\n          || !areNodesEqualForInlining(lastTrue, lastFalse)) {\n        break;\n      }\n      lastTrue.detachFromParent();\n      lastFalse.detachFromParent();\n      parent.addChildAfter(lastTrue, n);\n      reportCodeChange();\n    }\n  }", "isFoldableExpressBlock": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n        if (maybeExpr.isExprResult()) {\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n          if (maybeExpr.getFirstChild().isCall()) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            if (calledFn.isGetElem()) {\n              return false;\n            } else if (calledFn.isGetProp() &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n        return false;\n      }\n    }\n\n    return false;\n  }", "getBlockExpression": "  private Node getBlockExpression(Node n) {\n    Preconditions.checkState(isFoldableExpressBlock(n));\n    return n.getFirstChild();\n  }", "isReturnBlock": "  private boolean isReturnBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        return first.isReturn();\n      }\n    }\n\n    return false;\n  }", "isReturnExpressBlock": "  private boolean isReturnExpressBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.isReturn()) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }", "isReturnExpression": "  private boolean isReturnExpression(Node n) {\n    if (n.isReturn()) {\n      return n.hasOneChild();\n    }\n    return false;\n  }", "getBlockReturnExpression": "  private Node getBlockReturnExpression(Node n) {\n    Preconditions.checkState(isReturnExpressBlock(n));\n    return n.getFirstChild().getFirstChild();\n  }", "isVarBlock": "  private boolean isVarBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.isVar()) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }", "getBlockVar": "  private Node getBlockVar(Node n) {\n    Preconditions.checkState(isVarBlock(n));\n    return n.getFirstChild();\n  }", "consumesDanglingElse": "  private boolean consumesDanglingElse(Node n) {\n    while (true) {\n      switch (n.getType()) {\n        case Token.IF:\n          if (n.getChildCount() < 3) {\n            return true;\n          }\n          // This IF node has no else clause.\n          n = n.getLastChild();\n          continue;\n        case Token.WITH:\n        case Token.WHILE:\n        case Token.FOR:\n          n = n.getLastChild();\n          continue;\n        default:\n          return false;\n      }\n    }\n  }", "isLowerPrecedenceInExpression": "  private boolean isLowerPrecedenceInExpression(Node n,\n      final int precedence) {\n    Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return NodeUtil.precedence(input.getType()) < precedence;\n      }\n    };\n\n    return NodeUtil.has(n, isLowerPrecedencePredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }", "isLowerPrecedence": "  private boolean isLowerPrecedence(Node n, final int precedence) {\n    return NodeUtil.precedence(n.getType()) < precedence;\n  }", "isHigherPrecedence": "  private boolean isHigherPrecedence(Node n, final int precedence) {\n    return NodeUtil.precedence(n.getType()) > precedence;\n  }", "isPropertyAssignmentInExpression": "  private boolean isPropertyAssignmentInExpression(Node n) {\n    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n        new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return (input.isGetProp() &&\n            input.getParent().isAssign());\n      }\n    };\n\n    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }", "tryMinimizeCondition": "  private Node tryMinimizeCondition(Node n) {\n    Node parent = n.getParent();\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // NOT children are handled below.\n              return newRoot;\n            }\n          case Token.AND:\n          case Token.OR: {\n              // !(!x && !y) --> x || y\n              // !(!x || !y) --> x && y\n              // !(!x && y) --> x || !y\n              // !(!x || y) --> x && !y\n              // !(x && !y) --> !x || y\n              // !(x || !y) --> !x && y\n              // !(x && y) --> !x || !y\n              // !(x || y) --> !x && !y\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              Node left, right;\n\n              // Check special case when such transformation cannot reduce\n              // due to the added ()\n              // It only occurs when both of expressions are not NOT expressions\n              if (!leftParent.isNot()\n                  && !rightParent.isNot()) {\n                // If an expression has higher precedence than && or ||,\n                // but lower precedence than NOT, an additional () is needed\n                // Thus we do not preceed\n                int op_precedence = NodeUtil.precedence(first.getType());\n                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(leftParent, op_precedence))\n                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(rightParent, op_precedence))) {\n                  return n;\n                }\n              }\n\n              if (leftParent.isNot()) {\n                left = leftParent.removeFirstChild();\n              } else {\n                leftParent.detachFromParent();\n                left = IR.not(leftParent).srcref(leftParent);\n              }\n              if (rightParent.isNot()) {\n                right = rightParent.removeFirstChild();\n              } else {\n                rightParent.detachFromParent();\n                right = IR.not(rightParent).srcref(rightParent);\n              }\n\n              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n              Node newRoot = new Node(newOp, left, right);\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // AND and OR children below.\n              return newRoot;\n            }\n\n           default:\n             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n             if (nVal != TernaryValue.UNKNOWN) {\n               boolean result = nVal.not().toBoolean(true);\n               int equivalentResult = result ? 1 : 0;\n               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n        }\n        // No need to traverse, tryMinimizeCondition is called on the NOT\n        // children in the general case in the main post-order traversal.\n        return n;\n\n      case Token.OR:\n      case Token.AND: {\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the children, this can't be done in the general case.\n        left = tryMinimizeCondition(left);\n        right = tryMinimizeCondition(right);\n\n        // Remove useless conditionals\n        // Handle four cases:\n        //   x || false --> x\n        //   x || true  --> true\n        //   x && true --> x\n        //   x && false  --> false\n        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n          int type = n.getType();\n          Node replacement = null;\n          boolean rval = rightVal.toBoolean(true);\n\n          // (x || FALSE) => x\n          // (x && TRUE) => x\n          if (type == Token.OR && !rval ||\n              type == Token.AND && rval) {\n            replacement = left;\n          } else if (!mayHaveSideEffects(left)) {\n            replacement = right;\n          }\n\n          if (replacement != null) {\n            n.detachChildren();\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n          }\n        }\n        return n;\n      }\n\n      case Token.HOOK: {\n        Node condition = n.getFirstChild();\n        Node trueNode = n.getFirstChild().getNext();\n        Node falseNode = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the result children, this can't be done in the general case.\n        // The condition is handled in the general case in #optimizeSubtree\n        trueNode = tryMinimizeCondition(trueNode);\n        falseNode = tryMinimizeCondition(falseNode);\n\n        // Handle four cases:\n        //   x ? true : false --> x\n        //   x ? false : true --> !x\n        //   x ? true : y     --> x || y\n        //   x ? y : false    --> x && y\n        Node replacement = null;\n        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n        if (trueNodeVal == TernaryValue.TRUE\n            && falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = condition;\n        } else if (trueNodeVal == TernaryValue.FALSE\n            && falseNodeVal == TernaryValue.TRUE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = IR.not(condition);\n        } else if (trueNodeVal == TernaryValue.TRUE) {\n          // Remove useless true case.\n          n.detachChildren();\n          replacement = IR.or(condition, falseNode);\n        } else if (falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless false case\n          n.detachChildren();\n          replacement = IR.and(condition, trueNode);\n        }\n\n        if (replacement != null) {\n          parent.replaceChild(n, replacement);\n          n = replacement;\n          reportCodeChange();\n        }\n\n        return n;\n      }\n\n      default:\n        // while(true) --> while(1)\n        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n        if (nVal != TernaryValue.UNKNOWN) {\n          boolean result = nVal.toBoolean(true);\n          int equivalentResult = result ? 1 : 0;\n          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return n;\n    }\n  }", "maybeReplaceChildWithNumber": "  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n    Node newNode = IR.number(num);\n    if (!newNode.isEquivalentTo(n)) {\n      parent.replaceChild(n, newNode);\n      reportCodeChange();\n\n      return newNode;\n    }\n\n    return n;\n  }", "tryFoldStandardConstructors": "  private Node tryFoldStandardConstructors(Node n) {\n    Preconditions.checkState(n.isNew());\n\n    // If name normalization has been run then we know that\n    // new Object() does in fact refer to what we think it is\n    // and not some custom-defined Object().\n    if (isASTNormalized()) {\n      if (n.getFirstChild().isName()) {\n        String className = n.getFirstChild().getString();\n        if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n          n.setType(Token.CALL);\n          n.putBooleanProp(Node.FREE_CALL, true);\n          reportCodeChange();\n        }\n      }\n    }\n\n    return n;\n  }", "tryFoldLiteralConstructor": "  private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.isCall()\n        || n.isNew());\n\n    Node constructorNameNode = n.getFirstChild();\n\n    Node newLiteralNode = null;\n\n    // We require the AST to be normalized to ensure that, say,\n    // Object() really refers to the built-in Object constructor\n    // and not a user-defined constructor with the same name.\n\n    if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) {\n\n      String className = constructorNameNode.getString();\n\n      if (\"RegExp\".equals(className)) {\n        // \"RegExp(\"boo\", \"g\")\" --> /boo/g\n        return tryFoldRegularExpressionConstructor(n);\n      } else {\n        boolean constructorHasArgs = constructorNameNode.getNext() != null;\n\n        if (\"Object\".equals(className) && !constructorHasArgs) {\n          // \"Object()\" --> \"{}\"\n          newLiteralNode = IR.objectlit();\n        } else if (\"Array\".equals(className)) {\n          // \"Array(arg0, arg1, ...)\" --> \"[arg0, arg1, ...]\"\n          Node arg0 = constructorNameNode.getNext();\n          FoldArrayAction action = isSafeToFoldArrayConstructor(arg0);\n\n          if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||\n              action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n            newLiteralNode = IR.arraylit();\n            n.removeChildren();\n            if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n              newLiteralNode.addChildrenToFront(arg0);\n            }\n          }\n        }\n\n        if (newLiteralNode != null) {\n          n.getParent().replaceChild(n, newLiteralNode);\n          reportCodeChange();\n          return newLiteralNode;\n        }\n      }\n    }\n    return n;\n  }", "isSafeToFoldArrayConstructor": "  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n    FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD;\n\n    if (arg == null) {\n      action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n    } else if (arg.getNext() != null) {\n      action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n    } else {\n      switch (arg.getType()) {\n        case Token.STRING:\n          // \"Array('a')\" --> \"['a']\"\n          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n          break;\n        case Token.NUMBER:\n          // \"Array(0)\" --> \"[]\"\n          if (arg.getDouble() == 0) {\n            action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n          }\n          break;\n        case Token.ARRAYLIT:\n          // \"Array([args])\" --> \"[[args]]\"\n          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n          break;\n        default:\n      }\n    }\n    return action;\n  }", "tryFoldRegularExpressionConstructor": "  private Node tryFoldRegularExpressionConstructor(Node n) {\n    Node parent = n.getParent();\n    Node constructor = n.getFirstChild();\n    Node pattern = constructor.getNext();  // e.g.  ^foobar$\n    Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n\n    if (null == pattern || (null != flags && null != flags.getNext())) {\n      // too few or too many arguments\n      return n;\n    }\n\n    if (// is pattern folded\n        pattern.isString()\n        // make sure empty pattern doesn't fold to //\n        && !\"\".equals(pattern.getString())\n\n        // NOTE(nicksantos): Make sure that the regexp isn't longer than\n        // 100 chars, or it blows up the regexp parser in Opera 9.2.\n        && pattern.getString().length() < 100\n\n        && (null == flags || flags.isString())\n        // don't escape patterns with Unicode escapes since Safari behaves badly\n        // (read can't parse or crashes) on regex literals with Unicode escapes\n        && (isEcmaScript5OrGreater()\n            || !containsUnicodeEscape(pattern.getString()))) {\n\n      // Make sure that / is escaped, so that it will fit safely in /brackets/\n      // and make sure that no LineTerminatorCharacters appear literally inside\n      // the pattern.\n      // pattern is a string value with \\\\ and similar already escaped\n      pattern = makeForwardSlashBracketSafe(pattern);\n\n      Node regexLiteral;\n      if (null == flags || \"\".equals(flags.getString())) {\n        // fold to /foobar/\n        regexLiteral = IR.regexp(pattern);\n      } else {\n        // fold to /foobar/gi\n        if (!areValidRegexpFlags(flags.getString())) {\n          report(INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n          return n;\n        }\n        if (!areSafeFlagsToFold(flags.getString())) {\n          return n;\n        }\n        n.removeChild(flags);\n        regexLiteral = IR.regexp(pattern, flags);\n      }\n\n      parent.replaceChild(n, regexLiteral);\n      reportCodeChange();\n      return regexLiteral;\n    }\n\n    return n;\n  }", "tryMinimizeArrayLiteral": "  private Node tryMinimizeArrayLiteral(Node n) {\n    boolean allStrings = true;\n    for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n      if (!cur.isString()) {\n        allStrings = false;\n      }\n    }\n\n    if (allStrings) {\n      return tryMinimizeStringArrayLiteral(n);\n    } else {\n      return n;\n    }\n  }", "tryMinimizeStringArrayLiteral": "  private Node tryMinimizeStringArrayLiteral(Node n) {\n    if(!late) {\n      return n;\n    }\n\n    int numElements = n.getChildCount();\n    // We save two bytes per element.\n    int saving = numElements * 2 - STRING_SPLIT_OVERHEAD;\n    if (saving <= 0) {\n      return n;\n    }\n\n    String[] strings = new String[n.getChildCount()];\n    int idx = 0;\n    for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n      strings[idx++] = cur.getString();\n    }\n\n    // These delimiters are chars that appears a lot in the program therefore\n    // probably have a small Huffman encoding.\n    String delimiter = pickDelimiter(strings);\n    if (delimiter != null) {\n      String template = Joiner.on(delimiter).join(strings);\n      Node call = IR.call(\n          IR.getprop(\n              IR.string(template),\n              IR.string(\"split\")),\n          IR.string(\"\" + delimiter));\n      call.copyInformationFromForTree(n);\n      n.getParent().replaceChild(n, call);\n      reportCodeChange();\n      return call;\n    }\n    return n;\n  }", "makeForwardSlashBracketSafe": "  private static Node makeForwardSlashBracketSafe(Node n) {\n    String s = n.getString();\n    // sb contains everything in s[0:pos]\n    StringBuilder sb = null;\n    int pos = 0;\n    boolean isEscaped = false, inCharset = false;\n    for (int i = 0; i < s.length(); ++i) {\n      char ch = s.charAt(i);\n      switch (ch) {\n        case '\\\\':\n          isEscaped = !isEscaped;\n          continue;\n        case '/':\n          // Escape a literal forward slash if it is not already escaped and is\n          // not inside a character set.\n          //     new RegExp('/') -> /\\//\n          // but the following do not need extra escaping\n          //     new RegExp('\\\\/') -> /\\//\n          //     new RegExp('[/]') -> /[/]/\n          if (!isEscaped && !inCharset) {\n            if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n            sb.append(s, pos, i).append('\\\\');\n            pos = i;\n          }\n          break;\n        case '[':\n          if (!isEscaped) {\n            inCharset = true;\n          }\n          break;\n        case ']':\n          if (!isEscaped) {\n            inCharset = false;\n          }\n          break;\n        case '\\r': case '\\n': case '\\u2028': case '\\u2029':\n          // LineTerminators cannot appear raw inside a regular\n          // expression literal.\n          // They can't appear legally in a quoted string, but when\n          // the quoted string from\n          //     new RegExp('\\n')\n          // reaches here, the quoting has been removed.\n          // Requote just these code-points.\n          if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n          if (isEscaped) {\n            sb.append(s, pos, i - 1);\n          } else {\n            sb.append(s, pos, i);\n          }\n          switch (ch) {\n            case '\\r': sb.append(\"\\\\r\"); break;\n            case '\\n': sb.append(\"\\\\n\"); break;\n            case '\\u2028': sb.append(\"\\\\u2028\"); break;\n            case '\\u2029': sb.append(\"\\\\u2029\"); break;\n          }\n          pos = i + 1;\n          break;\n      }\n      isEscaped = false;\n    }\n\n    if (null == sb) { return n.cloneTree(); }\n\n    sb.append(s, pos, s.length());\n    return IR.string(sb.toString()).srcref(n);\n  }", "containsUnicodeEscape": "  static boolean containsUnicodeEscape(String s) {\n    String esc = REGEXP_ESCAPER.regexpEscape(s);\n    for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n      int nSlashes = 0;\n      while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n        ++nSlashes;\n      }\n      // if there are an even number of slashes before the \\ u then it is a\n      // Unicode literal.\n      if (0 == (nSlashes & 1)) { return true; }\n    }\n    return false;\n  }"}