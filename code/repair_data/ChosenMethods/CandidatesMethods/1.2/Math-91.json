{"abs": "    public Fraction abs() {\n        Fraction ret;\n        if (numerator >= 0) {\n            ret = this;\n        } else {\n            ret = negate();\n        }\n        return ret;        \n    }", "doubleValue": "    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }", "equals": "    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else {\n            try {\n                // since fractions are always in lowest terms, numerators and\n                // denominators can be compared directly for equality.\n                Fraction rhs = (Fraction)other;\n                ret = (numerator == rhs.numerator) &&\n                    (denominator == rhs.denominator);\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n        \n        return ret;\n    }", "negate": "    public Fraction negate() {\n        if (numerator==Integer.MIN_VALUE) {\n            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n                                                                 numerator, denominator);\n        }\n        return new Fraction(-numerator, denominator);\n    }", "reciprocal": "    public Fraction reciprocal() {\n        return new Fraction(denominator, numerator);\n    }", "add": "    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }", "subtract": "    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }", "multiply": "    public Fraction multiply(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don't overflow unless the result *must* overflow.\n        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n        return getReducedFraction\n        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n    }", "divide": "    public Fraction divide(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"the fraction to divide by must not be zero: {0}/{1}\",\n                    fraction.numerator, fraction.denominator);\n        }\n        return multiply(fraction.reciprocal());\n    }", "getReducedFraction": "    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"zero denominator in fraction {0}/{1}\",\n                    numerator, denominator);\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow in fraction {0}/{1}, cannot negate\",\n                        numerator, denominator);\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = MathUtils.gcd(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }"}