{"hasExternsRoot": "  boolean hasExternsRoot() {\n    return externsRoot != null;\n  }", "getRootNode": "  public Node getRootNode() {\n    return root.getParent();\n  }", "getParentScope": "  public StaticScope<JSType> getParentScope() {\n    return null;\n  }", "getSlot": "  public Name getSlot(String name) {\n    return getOwnSlot(name);\n  }", "getOwnSlot": "  public Name getOwnSlot(String name) {\n    ensureGenerated();\n    return nameMap.get(name);\n  }", "getTypeOfThis": "  public JSType getTypeOfThis() {\n    return compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n  }", "getReferences": "  public Iterable<Ref> getReferences(Name slot) {\n    ensureGenerated();\n    return Collections.unmodifiableList(slot.getRefs());\n  }", "getScope": "  public StaticScope<JSType> getScope(Name slot) {\n    return this;\n  }", "getAllSymbols": "  public Iterable<Name> getAllSymbols() {\n    ensureGenerated();\n    return Collections.unmodifiableCollection(getNameIndex().values());\n  }", "ensureGenerated": "  private void ensureGenerated() {\n    if (!generated) {\n      process();\n    }\n  }", "getNameForest": "  List<Name> getNameForest() {\n    ensureGenerated();\n    return globalNames;\n  }", "getNameIndex": "  Map<String, Name> getNameIndex() {\n    ensureGenerated();\n    return nameMap;\n  }", "scanNewNodes": "  void scanNewNodes(List<AstChange> newNodes) {\n    BuildGlobalNamespace builder = new BuildGlobalNamespace();\n\n    for (AstChange info : newNodes) {\n      if (!info.node.isQualifiedName() && !NodeUtil.isObjectLitKey(info.node)) {\n        continue;\n      }\n      scanFromNode(builder, info.module, info.scope, info.node);\n    }\n  }", "scanFromNode": "  private void scanFromNode(\n    BuildGlobalNamespace builder, JSModule module, Scope scope, Node n) {\n    // Check affected parent nodes first.\n    if (n.isName() || n.isGetProp()) {\n      scanFromNode(builder, module, scope, n.getParent());\n    }\n    builder.collect(module, scope, n);\n  }", "process": "    @Override public void process(Node externs, Node root) {\n      GlobalNamespace namespace = new GlobalNamespace(compiler, externs, root);\n\n      Set<String> currentSymbols = Sets.newTreeSet();\n      for (String name : namespace.getNameIndex().keySet()) {\n        if (isInterestingSymbol.apply(name)) {\n          currentSymbols.add(name);\n        }\n      }\n\n      String passName = compiler.getLastPassName();\n      if (passName == null) {\n        passName = \"[Unknown pass]\";\n      }\n\n      for (String sym : currentSymbols) {\n        if (!previousSymbolsInTree.contains(sym)) {\n          stream.println(String.format(\"%s: Added by %s\", sym, passName));\n        }\n      }\n\n      for (String sym : previousSymbolsInTree) {\n        if (!currentSymbols.contains(sym)) {\n          stream.println(String.format(\"%s: Removed by %s\", sym, passName));\n        }\n      }\n\n      previousSymbolsInTree = currentSymbols;\n    }", "isGlobalNameReference": "  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }", "getTopVarName": "  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }", "isGlobalVarReference": "  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }", "isGlobalScope": "  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {}", "collect": "    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n                  return;\n                }\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) {\n            return;\n          }\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        handleGet(module, scope, n, parent, name);\n      }\n    }", "getNameForObjLitKey": "    String getNameForObjLitKey(Node n) {\n      Node parent = n.getParent();\n      Preconditions.checkState(parent.isObjectLit());\n\n      Node gramps = parent.getParent();\n      if (gramps == null) {\n        return null;\n      }\n\n      Node greatGramps = gramps.getParent();\n      String name;\n      switch (gramps.getType()) {\n        case Token.NAME:\n          // VAR\n          //   NAME (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps == null || !greatGramps.isVar()) {\n            return null;\n          }\n          name = gramps.getString();\n          break;\n        case Token.ASSIGN:\n          // ASSIGN (gramps)\n          //   NAME|GETPROP\n          //   OBJLIT (parent)\n          //     STRING (n)\n          Node lvalue = gramps.getFirstChild();\n          name = lvalue.getQualifiedName();\n          break;\n        case Token.STRING_KEY:\n          // OBJLIT\n          //   STRING (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps != null &&\n              greatGramps.isObjectLit()) {\n            name = getNameForObjLitKey(gramps);\n          } else {\n            return null;\n          }\n          break;\n        default:\n          return null;\n      }\n      if (name != null) {\n        String key = n.getString();\n        if (TokenStream.isJSIdentifier(key)) {\n          return name + '.' + key;\n        }\n      }\n      return null;\n    }", "getValueType": "    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) {\n            return t;\n          }\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }", "handleSetFromGlobal": "    void handleSetFromGlobal(JSModule module, Scope scope,\n        Node n, Node parent, String name,\n        boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n        return;\n      }\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(module, scope, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(module, scope, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }", "isTypeDeclaration": "    private boolean isTypeDeclaration(Node n, Node parent) {\n      Node valueNode = NodeUtil.getRValueOfLValue(n);\n      JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      // Heed the annotations only if they're sensibly used.\n      return info != null && valueNode != null &&\n             (info.isConstructor() && valueNode.isFunction() ||\n              info.isInterface() && valueNode.isFunction() ||\n              info.hasEnumParameterType() && valueNode.isObjectLit());\n    }", "handleSetFromLocal": "    void handleSetFromLocal(JSModule module, Scope scope, Node n, Node parent,\n                            String name) {\n      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n        return;\n      }\n\n      Name nameObj = getOrCreateName(name);\n      Ref set = new Ref(module, scope, n, nameObj,\n          Ref.Type.SET_FROM_LOCAL, currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(module, scope, n, nameObj,\n            Ref.Type.ALIASING_GET, currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      }\n    }", "handleGet": "    void handleGet(JSModule module, Scope scope, Node n, Node parent,\n        String name, Ref.Type type) {\n      Name nameObj = getOrCreateName(name);\n\n      // No need to look up additional ancestors, since they won't be used.\n      nameObj.addRef(\n          new Ref(module, scope, n, nameObj, type, currentPreOrderIndex++));\n    }", "isClassDefiningCall": "    private boolean isClassDefiningCall(Node callNode) {\n      SubclassRelationship classes =\n          compiler.getCodingConvention().getClassesDefinedByCall(callNode);\n      return classes != null;\n    }", "determineGetTypeForHookOrBooleanExpr": "    Ref.Type determineGetTypeForHookOrBooleanExpr(\n        JSModule module, Scope scope, Node parent, String name) {\n      Node prev = parent;\n      for (Node anc : parent.getAncestors()) {\n        switch (anc.getType()) {\n          case Token.INSTANCEOF:\n          case Token.EXPR_RESULT:\n          case Token.VAR:\n          case Token.IF:\n          case Token.WHILE:\n          case Token.FOR:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            return Ref.Type.DIRECT_GET;\n          case Token.HOOK:\n            if (anc.getFirstChild() == prev) {\n              return Ref.Type.DIRECT_GET;\n            }\n            break;\n          case Token.ASSIGN:\n            if (!name.equals(anc.getFirstChild().getQualifiedName())) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.NAME:  // a variable declaration\n            if (!name.equals(anc.getString())) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.CALL:\n            if (anc.getFirstChild() != prev) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.DELPROP:\n            return Ref.Type.DELETE_PROP;\n        }\n        prev = anc;\n      }\n      return Ref.Type.ALIASING_GET;\n    }", "maybeHandlePrototypePrefix": "    boolean maybeHandlePrototypePrefix(JSModule module, Scope scope,\n        Node n, Node parent, String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(module, scope, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }", "isNestedAssign": "    boolean isNestedAssign(Node parent) {\n      return parent.isAssign() &&\n             !parent.getParent().isExprResult();\n    }", "getOrCreateName": "    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }", "getBaseName": "    String getBaseName() {\n      return baseName;\n    }", "getName": "    public String getName() {\n      return getFullName();\n    }", "getFullName": "    String getFullName() {\n      return parent == null ? baseName : parent.getFullName() + '.' + baseName;\n    }", "getDeclaration": "    public Ref getDeclaration() {\n      return declaration;\n    }", "isTypeInferred": "    public boolean isTypeInferred() {\n      return false;\n    }", "getType": "    public JSType getType() {\n      return null;\n    }", "getRefs": "    List<Ref> getRefs() {\n      return refs == null ? ImmutableList.<Ref>of() : refs;\n    }", "addRefInternal": "    void addRefInternal(Ref ref) {\n      if (refs == null) {\n        refs = Lists.newArrayList();\n      }\n      refs.add(ref);\n    }", "canEliminate": "    boolean canEliminate() {\n      if (!canCollapseUnannotatedChildNames() || totalGets > 0) {\n        return false;\n      }\n\n      if (props != null) {\n        for (Name n : props) {\n          if (!n.canCollapse()) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }", "isSimpleStubDeclaration": "    boolean isSimpleStubDeclaration() {\n      if (getRefs().size() == 1) {\n        Ref ref = refs.get(0);\n        if (ref.node.getParent() != null &&\n            ref.node.getParent().isExprResult()) {\n          return true;\n        }\n      }\n      return false;\n    }", "canCollapse": "    boolean canCollapse() {\n      return !inExterns && !isGetOrSetDefinition() && (declaredType ||\n          (parent == null || parent.canCollapseUnannotatedChildNames()) &&\n          (globalSets > 0 || localSets > 0) &&\n          deleteProps == 0);\n    }", "isGetOrSetDefinition": "    boolean isGetOrSetDefinition() {\n      return this.type == Type.GET || this.type == Type.SET;\n    }", "canCollapseUnannotatedChildNames": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || isGetOrSetDefinition()\n          || globalSets != 1 || localSets != 0 || deleteProps != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (declaredType) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }", "needsToBeStubbed": "    boolean needsToBeStubbed() {\n      return globalSets == 0 && localSets > 0;\n    }", "setDeclaredType": "    void setDeclaredType() {\n      declaredType = true;\n      for (Name ancestor = parent; ancestor != null;\n           ancestor = ancestor.parent) {\n        ancestor.hasDeclaredTypeDescendant = true;\n      }\n    }", "isDeclaredType": "    boolean isDeclaredType() {\n      return declaredType;\n    }", "isNamespace": "    boolean isNamespace() {\n      return hasDeclaredTypeDescendant && type == Type.OBJECTLIT;\n    }", "isSimpleName": "    boolean isSimpleName() {\n      return parent == null;\n    }", "toString": "    @Override public String toString() {\n      return getFullName() + \" (\" + type + \"): globalSets=\" + globalSets +\n          \", localSets=\" + localSets + \", totalGets=\" + totalGets +\n          \", aliasingGets=\" + aliasingGets + \", callGets=\" + callGets;\n    }", "getJSDocInfo": "    public JSDocInfo getJSDocInfo() {\n      return docInfo;\n    }", "getDocInfoForDeclaration": "    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }", "getNode": "    public Node getNode() {\n      return node;\n    }", "getSourceFile": "    public StaticSourceFile getSourceFile() {\n      return source;\n    }", "getSymbol": "    public StaticSlot<JSType> getSymbol() {\n      return name;\n    }", "getModule": "    JSModule getModule() {\n      return module;\n    }", "getSourceName": "    String getSourceName() {\n      return source == null ? \"\" : source.getName();\n    }", "getTwin": "    Ref getTwin() {\n      return twin;\n    }", "isSet": "    boolean isSet() {\n      return type == Type.SET_FROM_GLOBAL || type == Type.SET_FROM_LOCAL;\n    }", "markTwins": "    static void markTwins(Ref a, Ref b) {\n      Preconditions.checkArgument(\n          (a.type == Type.ALIASING_GET || b.type == Type.ALIASING_GET) &&\n          (a.type == Type.SET_FROM_GLOBAL || a.type == Type.SET_FROM_LOCAL ||\n           b.type == Type.SET_FROM_GLOBAL || b.type == Type.SET_FROM_LOCAL));\n      a.twin = b;\n      b.twin = a;\n    }", "cloneAndReclassify": "    Ref cloneAndReclassify(Type type) {\n      return new Ref(this, type, this.preOrderIndex);\n    }", "createRefForTesting": "    static Ref createRefForTesting(Type type) {\n      return new Ref(type, -1);\n    }"}