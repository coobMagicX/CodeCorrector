{"expectValidTypeofName": "  void expectValidTypeofName(NodeTraversal t, Node n, String found) {\n    report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found));\n  }", "expectAnyObject": "  void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) {\n    JSType anyObjectType = getNativeType(NO_OBJECT_TYPE);\n    if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {\n      mismatch(t, n, msg, type, anyObjectType);\n    }\n  }", "expectString": "  void expectString(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesStringContext()) {\n      mismatch(t, n, msg, type, STRING_TYPE);\n    }\n  }", "expectNumber": "  void expectNumber(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext()) {\n      mismatch(t, n, msg, type, NUMBER_TYPE);\n    }\n  }", "expectStringOrNumber": "  void expectStringOrNumber(\n      NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.matchesStringContext()) {\n      mismatch(t, n, msg, type, NUMBER_STRING);\n    }\n  }", "expectNotNullOrUndefined": "  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }", "containsForwardDeclaredUnresolvedName": "  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n    if (type.isUnionType()) {\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        if (containsForwardDeclaredUnresolvedName(alt)) {\n          return true;\n        }\n      }\n    }\n    return type.isNoResolvedType();\n  }", "expectIndexMatch": "  void expectIndexMatch(NodeTraversal t, Node n, JSType objType,\n                        JSType indexType) {\n    Preconditions.checkState(n.isGetElem());\n    Node indexNode = n.getLastChild();\n    if (objType.isStruct()) {\n      report(JSError.make(t.getSourceName(), indexNode,\n                          ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\"));\n    }\n    if (objType.isUnknownType()) {\n      expectStringOrNumber(t, indexNode, indexType, \"property access\");\n    } else {\n      ObjectType dereferenced = objType.dereference();\n      if (dereferenced != null && dereferenced\n          .getTemplateTypeMap()\n          .hasTemplateKey(typeRegistry.getObjectIndexKey())) {\n        expectCanAssignTo(t, indexNode, indexType, dereferenced\n            .getTemplateTypeMap().getTemplateType(typeRegistry.getObjectIndexKey()),\n            \"restricted index type\");\n      } else if (dereferenced != null && dereferenced.isArrayType()) {\n        expectNumber(t, indexNode, indexType, \"array access\");\n      } else if (objType.matchesObjectContext()) {\n        expectString(t, indexNode, indexType, \"property access\");\n      } else {\n        mismatch(t, n, \"only arrays or objects can be accessed\",\n            objType,\n            typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE));\n      }\n    }\n  }", "expectCanAssignToPropertyOf": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      return false;\n    }\n    return true;\n  }", "expectCanAssignTo": "  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.isSubtype(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    return true;\n  }", "expectArgumentMatchesParameter": "  void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType,\n      JSType paramType, Node callNode, int ordinal) {\n    if (!argType.isSubtype(paramType)) {\n      mismatch(t, n,\n          String.format(\"actual parameter %d of %s does not match \" +\n              \"formal parameter\", ordinal,\n              getReadableJSTypeName(callNode.getFirstChild(), false)),\n          argType, paramType);\n    }\n  }", "expectCanOverride": "  void expectCanOverride(NodeTraversal t, Node n, JSType overridingType,\n      JSType hiddenType, String propertyName, JSType ownerType) {\n    if (!overridingType.isSubtype(hiddenType)) {\n      registerMismatch(overridingType, hiddenType,\n          report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName,\n            ownerType.toString(), hiddenType.toString(),\n            overridingType.toString())));\n    }\n  }", "expectSuperType": "  void expectSuperType(NodeTraversal t, Node n, ObjectType superObject,\n      ObjectType subObject) {\n    FunctionType subCtor = subObject.getConstructor();\n    ObjectType implicitProto = subObject.getImplicitPrototype();\n    ObjectType declaredSuper =\n        implicitProto == null ? null : implicitProto.getImplicitPrototype();\n    if (declaredSuper != null && declaredSuper.isTemplatizedType()) {\n      declaredSuper =\n          declaredSuper.toMaybeTemplatizedType().getReferencedType();\n    }\n    if (declaredSuper != null &&\n        !(superObject instanceof UnknownType) &&\n        !declaredSuper.isEquivalentTo(superObject)) {\n      if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {\n        registerMismatch(superObject, declaredSuper, report(\n            t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));\n      } else {\n        mismatch(t.getSourceName(), n,\n            \"mismatch in declaration of superclass type\",\n            superObject, declaredSuper);\n      }\n\n      // Correct the super type.\n      if (!subCtor.hasCachedValues()) {\n        subCtor.setPrototypeBasedOn(superObject);\n      }\n    }\n  }", "expectCanCast": "  void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) {\n    if (!type.canCastTo(castType)) {\n      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n          type.toString(), castType.toString())));\n    }\n  }", "expectUndeclaredVariable": "  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    // Only report duplicate declarations that have types. Other duplicates\n    // will be reported by the syntactic scope creator later in the\n    // compilation process.\n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      // If there are two typed declarations of the same variable, that\n      // is an error and the second declaration is ignored, except in the\n      // case of native types. A null input type means that the declaration\n      // was made in TypedScopeCreator#createInitialScope and is a\n      // native type. We should redeclare it at the new input site.\n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        // Always warn about duplicates if the overridden type does not\n        // match the original type.\n        //\n        // If the types match, suppress the warning iff there was a @suppress\n        // tag, or if the original declaration was a stub.\n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }", "expectAllInterfaceProperties": "  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }", "expectInterfaceProperty": "  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      found = found.restrictByNotNullOrUndefined();\n\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      TemplateTypeMap typeMap = implementedInterface.getTemplateTypeMap();\n      if (!typeMap.isEmpty()) {\n        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n            typeRegistry, typeMap);\n        required = required.visit(replacer);\n      }\n      required = required.restrictByNotNullOrUndefined();\n\n      if (!found.isSubtype(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(found, required, report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }", "mismatch": "  private void mismatch(String sourceName, Node n,\n                        String msg, JSType found, JSType required) {\n    registerMismatch(found, required, report(\n        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n                     formatFoundRequired(msg, found, required))));\n  }", "formatFoundRequired": "  private String formatFoundRequired(String description, JSType found,\n      JSType required) {\n    return MessageFormat.format(FOUND_REQUIRED, description, found, required);\n  }", "getReadableJSTypeName": "  String getReadableJSTypeName(Node n, boolean dereference) {\n\n    // The best type name is the actual type name.\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }", "getJSType": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(user): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }", "getNativeType": "  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }", "report": "  private JSError report(JSError error) {\n    if (shouldReport) {\n      compiler.report(error);\n    }\n    return error;\n  }", "equals": "    @Override public boolean equals(Object object) {\n      if (object instanceof TypeMismatch) {\n        TypeMismatch that = (TypeMismatch) object;\n        return (that.typeA.isEquivalentTo(this.typeA)\n                && that.typeB.isEquivalentTo(this.typeB))\n            || (that.typeB.isEquivalentTo(this.typeA)\n                && that.typeA.isEquivalentTo(this.typeB));\n      }\n      return false;\n    }", "toString": "    @Override public String toString() {\n      return \"(\" + typeA + \", \" + typeB + \")\";\n    }"}