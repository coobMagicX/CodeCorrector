{"process": "  public void process(Node externRoot, Node root) {\n    if (!canModifyExterns) {\n      NodeTraversal.traverse(compiler, externRoot,\n          new ProcessExternProperties());\n    }\n\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\n\n    FixedPointGraphTraversal<NameInfo, JSModule> t =\n        FixedPointGraphTraversal.newTraversal(new PropagateReferences());\n    t.computeFixedPoint(symbolGraph,\n        Sets.newHashSet(externNode, globalNode));\n  }", "getAllNameInfo": "  public Collection<NameInfo> getAllNameInfo() {\n    List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values());\n    result.addAll(varNameInfo.values());\n    return result;\n  }", "getNameInfoForName": "  private NameInfo getNameInfoForName(String name, SymbolType type) {\n    Map<String, NameInfo> map = type == PROPERTY ?\n        propertyNameInfo : varNameInfo;\n    if (map.containsKey(name)) {\n      return map.get(name);\n    } else {\n      NameInfo nameInfo = new NameInfo(name);\n      map.put(name, nameInfo);\n      symbolGraph.createNode(nameInfo);\n      return nameInfo;\n    }\n  }", "enterScope": "    public void enterScope(NodeTraversal t) {\n      symbolStack.peek().scope = t.getScope();\n    }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.GETPROP) {\n        symbolGraph.connect(externNode, firstModule,\n            getNameInfoForName(n.getLastChild().getString(), PROPERTY));\n      }\n    }", "isGlobalFunctionDeclaration": "    private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\n      return t.inGlobalScope() &&\n          (NodeUtil.isFunctionDeclaration(n) ||\n           n.getType() == Token.FUNCTION &&\n           n.getParent().getType() == Token.NAME);\n    }", "isPrototypePropertyAssign": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && n.getType() == Token.GETPROP\n          ) {\n        // We want to exclude the assignment itself from the usage list\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          if (child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }", "processGlobalFunctionDeclaration": "    private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n        Node nameNode, Node parent, Node gramps) {\n      Node firstChild = nameNode.getFirstChild();\n\n      if (// Check for a named FUNCTION.\n          isGlobalFunctionDeclaration(t, parent) ||\n          // Check for a VAR declaration.\n          firstChild != null &&\n          isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(\n            new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) ||\n            anchorUnusedVars) {\n          addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n\n        return true;\n      }\n      return false;\n    }", "processPrototypeParent": "    private void processPrototypeParent(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n          Node dest = n.getFirstChild().getNext();\n          Node parent = n.getParent();\n          Node grandParent = parent.getParent();\n\n          if (dest.getType() == Token.STRING &&\n              NodeUtil.isExprAssign(grandParent) &&\n              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n            String name = dest.getString();\n            Property prop = new AssignmentProperty(grandParent, t.getModule());\n            getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n          }\n          break;\n\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n          Node map = n.getFirstChild().getNext();\n          if (map.getType() == Token.OBJECTLIT) {\n            for (Node key = map.getFirstChild();\n                 key != null; key = key.getNext()) {\n              // May be STRING, GET, or SET,\n              String name = key.getString();\n              Property prop = new LiteralProperty(\n                  key, key.getFirstChild(), map, n, t.getModule());\n              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n            }\n          }\n          break;\n      }\n    }", "remove": "    public void remove() {\n      map.removeChild(key);\n    }", "getFunctionNode": "    public Node getFunctionNode() {\n      Node parent = nameNode.getParent();\n\n      if (NodeUtil.isFunction(parent)) {\n        return parent;\n      } else {\n        // we are the name of a var node, so the function is name's second child\n        return nameNode.getChildAtIndex(1);\n      }\n    }", "getAssignNode": "    private Node getAssignNode() {\n      return exprNode.getFirstChild();\n    }", "toString": "    @Override public String toString() { return name; }", "isReferenced": "    boolean isReferenced() {\n      return referenced;\n    }", "markReference": "    boolean markReference(JSModule module) {\n      boolean hasChanged = false;\n      if (!referenced) {\n        referenced = true;\n        hasChanged = true;\n      }\n\n      if (moduleGraph != null) {\n        JSModule originalDeepestCommon = deepestCommonModuleRef;\n\n        if (deepestCommonModuleRef == null) {\n          deepestCommonModuleRef = module;\n        } else {\n          deepestCommonModuleRef =\n              moduleGraph.getDeepestCommonDependencyInclusive(\n                  deepestCommonModuleRef, module);\n        }\n\n        if (originalDeepestCommon != deepestCommonModuleRef) {\n          hasChanged = true;\n        }\n      }\n\n      return hasChanged;\n    }", "getDeepestCommonModuleRef": "    JSModule getDeepestCommonModuleRef() {\n      return deepestCommonModuleRef;\n    }", "getDeclarations": "    Deque<Symbol> getDeclarations() {\n      return declarations;\n    }"}