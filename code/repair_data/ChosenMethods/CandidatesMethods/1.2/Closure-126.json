{"process": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }", "visit": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        tryMinimizeExits(\n            n.getLastChild(), Token.BREAK, n.getFirstChild().getString());\n        break;\n\n      case Token.FOR:\n      case Token.WHILE:\n        tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n        break;\n\n      case Token.DO:\n        tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n\n        Node cond = NodeUtil.getConditionExpression(n);\n        if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {\n          // Normally, we wouldn't be able to optimize BREAKs inside a loop\n          // but as we know the condition will always false, we can treat them\n          // as we would a CONTINUE.\n          tryMinimizeExits(n.getFirstChild(), Token.BREAK, null);\n        }\n        break;\n\n      case Token.FUNCTION:\n        tryMinimizeExits(n.getLastChild(), Token.RETURN, null);\n        break;\n    }\n  }", "tryMinimizeExits": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }", "tryMinimizeIfBlockExits": "  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\n      if (!srcBlock.hasChildren()) {\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n      compiler.reportCodeChange();\n    }\n  }", "matchingExitNode": "  private static boolean matchingExitNode(Node n, int type, String labelName) {\n    if (n.getType() == type) {\n      if (type == Token.RETURN) {\n        // only returns without expressions.\n        return !n.hasChildren();\n      } else {\n        if (labelName == null) {\n          return !n.hasChildren();\n        } else {\n          return n.hasChildren()\n            && labelName.equals(n.getFirstChild().getString());\n        }\n      }\n    }\n    return false;\n  }", "moveAllFollowing": "  private static void moveAllFollowing(\n      Node start, Node srcParent, Node destParent) {\n    for (Node n = start.getNext(); n != null; n = start.getNext()) {\n      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);\n      srcParent.removeChild(n);\n      if (isFunctionDeclaration) {\n        destParent.addChildToFront(n);\n      } else {\n        destParent.addChildToBack(n);\n      }\n    }\n  }"}