{"getTypes": "    UnionFind<T> getTypes() {\n      if (types == null) {\n        types = new StandardUnionFind<T>();\n      }\n      return types;\n    }", "addType": "    boolean addType(T type, T top, T relatedType) {\n      checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name);\n      if (typeSystem.isInvalidatingType(top)) {\n        invalidate();\n        return false;\n      } else {\n        if (typeSystem.isTypeToSkip(top)) {\n          addTypeToSkip(top);\n        }\n\n        if (relatedType == null) {\n          getTypes().add(top);\n        } else {\n          getTypes().union(top, relatedType);\n        }\n        typeSystem.recordInterfaces(type, top, this);\n        return true;\n      }\n    }", "addTypeToSkip": "    void addTypeToSkip(T type) {\n      for (T skipType : typeSystem.getTypesToSkipForType(type)) {\n        typesToSkip.add(skipType);\n        getTypes().union(skipType, type);\n      }\n    }", "expandTypesToSkip": "    void expandTypesToSkip() {\n      // If we are not going to rename any properties, then we do not need to\n      // update the list of invalid types, as they are all invalid.\n      if (shouldRename()) {\n        int count = 0;\n        while (true) {\n          // It should usually only take one time through this do-while.\n          checkState(++count < 10, \"Stuck in loop expanding types to skip.\");\n\n          // Make sure that the representative type for each type to skip is\n          // marked as being skipped.\n          Set<T> rootTypesToSkip = Sets.newHashSet();\n          for (T subType : typesToSkip) {\n            rootTypesToSkip.add(types.find(subType));\n          }\n          typesToSkip.addAll(rootTypesToSkip);\n\n          Set<T> newTypesToSkip = Sets.newHashSet();\n          Set<T> allTypes = types.elements();\n          int originalTypesSize = allTypes.size();\n          for (T subType : allTypes) {\n            if (!typesToSkip.contains(subType)\n                && typesToSkip.contains(types.find(subType))) {\n              newTypesToSkip.add(subType);\n            }\n          }\n\n          for (T newType : newTypesToSkip) {\n            addTypeToSkip(newType);\n          }\n\n          // If there were not any new types added, we are done here.\n          if (types.elements().size() == originalTypesSize) {\n            break;\n          }\n        }\n      }\n    }", "shouldRename": "    boolean shouldRename(T type) {\n      return !skipRenaming && !typesToSkip.contains(type);\n    }", "invalidate": "    boolean invalidate() {\n      boolean changed = !skipRenaming;\n      skipRenaming = true;\n      types = null;\n      return changed;\n    }", "scheduleRenaming": "    boolean scheduleRenaming(Node node, T type) {\n      if (!skipRenaming) {\n        if (typeSystem.isInvalidatingType(type)) {\n          invalidate();\n          return false;\n        }\n        renameNodes.add(node);\n        rootTypes.put(node, type);\n      }\n      return true;\n    }", "forJSTypeSystem": "  static DisambiguateProperties<JSType> forJSTypeSystem(\n      AbstractCompiler compiler,\n      Map<String, CheckLevel> propertiesToErrorFor) {\n    return new DisambiguateProperties<JSType>(\n        compiler, new JSTypeSystem(compiler), propertiesToErrorFor);\n  }", "forConcreteTypeSystem": "  static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(\n      AbstractCompiler compiler, TightenTypes tt,\n      Map<String, CheckLevel> propertiesToErrorFor) {\n    return new DisambiguateProperties<ConcreteType>(\n        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()),\n            propertiesToErrorFor);\n  }", "process": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(\n        compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);\n    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n      addInvalidatingType(mis.typeA, mis.src);\n      addInvalidatingType(mis.typeB, mis.src);\n    }\n\n    NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n    NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n    renameProperties();\n  }", "recordInvalidationError": "  private void recordInvalidationError(JSType t, JSError error) {\n    if (!t.isObject()) {\n      return;\n    }\n    if (invalidationMap != null) {\n      invalidationMap.put(t, error);\n    }\n  }", "addInvalidatingType": "    @Override public void addInvalidatingType(JSType type) {\n      checkState(!type.isUnionType());\n      invalidatingTypes.add(type);\n    }", "getProperty": "  protected Property getProperty(String name) {\n    if (!properties.containsKey(name)) {\n      properties.put(name, new Property(name));\n    }\n    return properties.get(name);\n  }", "getTypeWithProperty": "    @Override public ConcreteType getTypeWithProperty(String field,\n                                                      ConcreteType type) {\n      if (type.isInstance()) {\n        ConcreteInstanceType instanceType = (ConcreteInstanceType) type;\n        return instanceType.getInstanceTypeWithProperty(field);\n      } else if (type.isFunction()) {\n        if (\"prototype\".equals(field)\n            || codingConvention.isSuperClassReference(field)) {\n          return type;\n        }\n      } else if (type.isNone()) {\n        // If the receiver is none, then this code is never reached.  We will\n        // return a new fake type to ensure that this access is renamed\n        // differently from any other, so it can be easily removed.\n        return new ConcreteUniqueType(++nextUniqueId);\n      } else if (type.isUnion()) {\n        // If only one has the property, return that.\n        for (ConcreteType t : ((ConcreteUnionType) type).getAlternatives()) {\n          ConcreteType ret = getTypeWithProperty(field, t);\n          if (ret != null) {\n            return ret;\n          }\n        }\n      }\n      return null;\n    }", "shouldTraverse": "    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }", "enterScope": "    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        scopes.push(typeSystem.getRootScope());\n      } else {\n        scopes.push(typeSystem.getFunctionScope(t.getScopeRoot()));\n      }\n    }", "exitScope": "    public void exitScope(NodeTraversal t) {\n      scopes.pop();\n    }", "getScope": "    protected StaticScope<T> getScope() {\n      return scopes.peek();\n    }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isGetProp()) {\n        handleGetProp(t, n);\n      } else if (n.isObjectLit()) {\n        handleObjectLit(t, n);\n      }\n    }", "handleGetProp": "    private void handleGetProp(NodeTraversal t, Node n) {\n      String name = n.getLastChild().getString();\n      T type = typeSystem.getType(getScope(), n.getFirstChild(), name);\n\n      Property prop = getProperty(name);\n      if (!prop.scheduleRenaming(n.getLastChild(),\n                                 processProperty(t, prop, type, null))) {\n        if (propertiesToErrorFor.containsKey(name)) {\n          String suggestion = \"\";\n          if (type instanceof JSType) {\n            JSType jsType = (JSType) type;\n            if (jsType.isAllType() || jsType.isUnknownType()) {\n              if (n.getFirstChild().isThis()) {\n                suggestion = \"The \\\"this\\\" object is unknown in the function,\" +\n                    \"consider using @this\";\n              } else {\n                String qName = n.getFirstChild().getQualifiedName();\n                suggestion = \"Consider casting \" + qName +\n                    \" if you know it's type.\";\n              }\n            } else {\n              List<String> errors = Lists.newArrayList();\n              printErrorLocations(errors, jsType);\n              if (!errors.isEmpty()) {\n                suggestion = \"Consider fixing errors for the following types:\\n\";\n                suggestion += Joiner.on(\"\\n\").join(errors);\n              }\n            }\n          }\n          compiler.report(JSError.make(\n              t.getSourceName(), n, propertiesToErrorFor.get(name),\n              Warnings.INVALIDATION, name,\n              (type == null ? \"null\" : type.toString()),\n              n.toString(), suggestion));\n        }\n      }\n    }", "handleObjectLit": "    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING, GET, SET\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }", "printErrorLocations": "    private void printErrorLocations(List<String> errors, JSType t) {\n      if (!t.isObject() || t.isAllType()) {\n        return;\n      }\n\n      if (t.isUnionType()) {\n        for (JSType alt : t.toMaybeUnionType().getAlternates()) {\n          printErrorLocations(errors, alt);\n        }\n        return;\n      }\n\n      for (JSError error : invalidationMap.get(t)) {\n        if (errors.size() > MAX_INVALDIATION_WARNINGS_PER_PROPERTY) {\n          return;\n        }\n\n        errors.add(\n            t.toString() + \" at \" + error.sourceName + \":\" + error.lineNumber);\n      }\n    }", "processProperty": "    private T processProperty(\n        NodeTraversal t, Property prop, T type, T relatedType) {\n      type = typeSystem.restrictByNotNullOrUndefined(type);\n      if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) {\n        return null;\n      }\n\n      Iterable<T> alternatives = typeSystem.getTypeAlternatives(type);\n      if (alternatives != null) {\n        T firstType = relatedType;\n        for (T subType : alternatives) {\n          T lastType = processProperty(t, prop, subType, firstType);\n          if (lastType != null) {\n            firstType = firstType == null ? lastType : firstType;\n          }\n        }\n        return firstType;\n      } else {\n        T topType = typeSystem.getTypeWithProperty(prop.name, type);\n        if (typeSystem.isInvalidatingType(topType)) {\n          return null;\n        }\n        prop.addType(type, topType, relatedType);\n        return topType;\n      }\n    }", "renameProperties": "  void renameProperties() {\n    int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,\n        instancesSkipped = 0, singleTypeProps = 0;\n\n    Set<String> reported = Sets.newHashSet();\n    for (Property prop : properties.values()) {\n      if (prop.shouldRename()) {\n        Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);\n\n        ++propsRenamed;\n        prop.expandTypesToSkip();\n        for (Node node : prop.renameNodes) {\n          T rootType = prop.rootTypes.get(node);\n          if (prop.shouldRename(rootType)) {\n            String newName = propNames.get(rootType);\n            node.setString(newName);\n            compiler.reportCodeChange();\n            ++instancesRenamed;\n          } else {\n            ++instancesSkipped;\n\n            CheckLevel checkLevelForProp = propertiesToErrorFor.get(prop.name);\n            if (checkLevelForProp != null &&\n                checkLevelForProp != CheckLevel.OFF &&\n                !reported.contains(prop.name)) {\n              reported.add(prop.name);\n              compiler.report(JSError.make(\n                  NodeUtil.getSourceName(node), node,\n                  checkLevelForProp,\n                  Warnings.INVALIDATION_ON_TYPE, prop.name,\n                  rootType.toString(), \"\"));\n            }\n          }\n        }\n      } else {\n        if (prop.skipRenaming) {\n          ++propsSkipped;\n        } else {\n          ++singleTypeProps;\n        }\n      }\n    }\n    logger.fine(\"Renamed \" + instancesRenamed + \" instances of \"\n                + propsRenamed + \" properties.\");\n    logger.fine(\"Skipped renaming \" + instancesSkipped + \" invalidated \"\n                + \"properties, \" + propsSkipped + \" instances of properties \"\n                + \"that were skipped for specific types and \" + singleTypeProps\n                + \" properties that were referenced from only one type.\");\n  }", "buildPropNames": "  private Map<T, String> buildPropNames(UnionFind<T> types, String name) {\n    Map<T, String> names = Maps.newHashMap();\n    for (Set<T> set : types.allEquivalenceClasses()) {\n      checkState(!set.isEmpty());\n\n      String typeName = null;\n      for (T type : set) {\n        if (typeName == null || type.toString().compareTo(typeName) < 0) {\n          typeName = type.toString();\n        }\n      }\n\n      String newName;\n      if (\"{...}\".equals(typeName)) {\n        newName = name;\n      } else {\n        newName = typeName.replaceAll(\"[^\\\\w$]\", \"_\") + \"$\" + name;\n      }\n\n      for (T type : set) {\n        names.put(type, newName);\n      }\n    }\n    return names;\n  }", "getRenamedTypesForTesting": "  Multimap<String, Collection<T>> getRenamedTypesForTesting() {\n    Multimap<String, Collection<T>> ret = HashMultimap.create();\n    for (Map.Entry<String, Property> entry : properties.entrySet()) {\n      Property prop = entry.getValue();\n      if (!prop.skipRenaming) {\n        for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) {\n          if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) {\n            ret.put(entry.getKey(), c);\n          }\n        }\n      }\n    }\n    return ret;\n  }", "getRootScope": "    @Override public StaticScope<ConcreteType> getRootScope() {\n      return tt.getTopScope();\n    }", "getFunctionScope": "    @Override public StaticScope<ConcreteType> getFunctionScope(Node decl) {\n      ConcreteFunctionType func = tt.getConcreteFunction(decl);\n      return (func != null) ?\n          func.getScope() : (StaticScope<ConcreteType>) null;\n    }", "getType": "    public ConcreteType getType(\n        StaticScope<ConcreteType> scope, Node node, String prop) {\n      if (scope != null) {\n        ConcreteType c = tt.inferConcreteType(\n            (TightenTypes.ConcreteScope) scope, node);\n        return maybeAddAutoboxes(c, node, prop);\n      } else {\n        return null;\n      }\n    }", "isInvalidatingType": "    @Override public boolean isInvalidatingType(ConcreteType type) {\n      // We will disallow types on functions so that 'prototype' is not renamed.\n      // TODO(user): Support properties on functions as well.\n      return (type == null) || type.isAll() || type.isFunction()\n        || (type.isInstance()\n            && invalidatingTypes.contains(type.toInstance().instanceType));\n    }", "getTypesToSkipForType": "    public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) {\n      return ImmutableSet.of(type);\n    }", "getTypesToSkipForTypeNonUnion": "    private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {\n      Set<JSType> types = Sets.newHashSet();\n      JSType skipType = type;\n      while (skipType != null) {\n        types.add(skipType);\n\n        ObjectType objSkipType = skipType.toObjectType();\n        if (objSkipType != null) {\n          skipType = objSkipType.getImplicitPrototype();\n        } else {\n          break;\n        }\n      }\n      return types;\n    }", "isTypeToSkip": "    @Override public boolean isTypeToSkip(ConcreteType type) {\n      // Skip anonymous object literals and enum types.\n      return type.isInstance()\n        && !(type.toInstance().isFunctionPrototype()\n             || type.toInstance().instanceType.isInstanceType());\n    }", "restrictByNotNullOrUndefined": "    public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) {\n      // These are not represented in concrete types.\n      return type;\n    }", "getTypeAlternatives": "    public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) {\n      if (type.isUnion()) {\n        return ((ConcreteUnionType) type).getAlternatives();\n      } else {\n        return null;\n      }\n    }", "getInstanceFromPrototype": "    @Override public ConcreteType getInstanceFromPrototype(ConcreteType type) {\n      if (type.isInstance()) {\n        ConcreteInstanceType instanceType = (ConcreteInstanceType) type;\n        if (instanceType.isFunctionPrototype()) {\n          return instanceType.getConstructorType().getInstanceType();\n        }\n      }\n      return null;\n    }", "recordInterfaces": "    public void recordInterfaces(ConcreteType type, ConcreteType relatedType,\n        DisambiguateProperties<ConcreteType>.Property p) {\n      // No need to record interfaces when using concrete types.\n    }", "maybeAddAutoboxes": "    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, JSType jsType, String prop) {\n      jsType = jsType.restrictByNotNullOrUndefined();\n      if (jsType.isUnionType()) {\n        for (JSType alt : jsType.toMaybeUnionType().getAlternates()) {\n          cType = maybeAddAutoboxes(cType, alt, prop);\n        }\n        return cType;\n      } else if (jsType.isEnumElementType()) {\n        return maybeAddAutoboxes(\n            cType, jsType.toMaybeEnumElementType().getPrimitiveType(), prop);\n      }\n\n      if (jsType.autoboxesTo() != null) {\n        JSType autoboxed = jsType.autoboxesTo();\n        return cType.unionWith(tt.getConcreteInstance((ObjectType) autoboxed));\n      } else if (jsType.unboxesTo() != null) {\n        return cType.unionWith(tt.getConcreteInstance((ObjectType) jsType));\n      }\n\n      return cType;\n    }"}