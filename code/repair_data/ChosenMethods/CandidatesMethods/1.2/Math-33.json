{"initializeColumnLabels": "    protected void initializeColumnLabels() {\n      if (getNumObjectiveFunctions() == 2) {\n        columnLabels.add(\"W\");\n      }\n      columnLabels.add(\"Z\");\n      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n        columnLabels.add(\"x\" + i);\n      }\n      if (!restrictToNonNegative) {\n        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n      }\n      for (int i = 0; i < getNumSlackVariables(); i++) {\n        columnLabels.add(\"s\" + i);\n      }\n      for (int i = 0; i < getNumArtificialVariables(); i++) {\n        columnLabels.add(\"a\" + i);\n      }\n      columnLabels.add(\"RHS\");\n    }", "createTableau": "    protected RealMatrix createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        // initialize the constraint rows\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            // decision variable coefficients\n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            // x-\n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            // RHS\n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            // slack variables\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n            }\n\n            // artificial variables\n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }", "normalizeConstraints": "    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    }", "normalize": "    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(),\n                                    constraint.getRelationship(), constraint.getValue());\n    }", "getNumObjectiveFunctions": "    protected final int getNumObjectiveFunctions() {\n        return this.numArtificialVariables > 0 ? 2 : 1;\n    }", "getConstraintTypeCounts": "    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }", "getInvertedCoefficientSum": "    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n        double sum = 0;\n        for (double coefficient : coefficients.toArray()) {\n            sum -= coefficient;\n        }\n        return sum;\n    }", "getBasicRow": "    protected Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = 0; i < getHeight(); i++) {\n            final double entry = getEntry(i, col);\n            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {\n                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }", "dropPhase1Objective": "    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }", "isOptimal": "    boolean isOptimal() {\n        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }", "getSolution": "    protected PointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n          if (basicRow != null && basicRow == 0) {\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained\n              // variables that are still part of the objective function\n              coefficients[i] = 0;\n          } else if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new PointValuePair(coefficients, f.getValue(coefficients));\n    }", "divideRow": "    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }", "getWidth": "    protected final int getWidth() {\n        return tableau.getColumnDimension();\n    }", "getHeight": "    protected final int getHeight() {\n        return tableau.getRowDimension();\n    }", "getEntry": "    protected final double getEntry(final int row, final int column) {\n        return tableau.getEntry(row, column);\n    }", "setEntry": "    protected final void setEntry(final int row, final int column,\n                                  final double value) {\n        tableau.setEntry(row, column, value);\n    }", "getSlackVariableOffset": "    protected final int getSlackVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables;\n    }", "getArtificialVariableOffset": "    protected final int getArtificialVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n    }", "getRhsOffset": "    protected final int getRhsOffset() {\n        return getWidth() - 1;\n    }", "getNumDecisionVariables": "    protected final int getNumDecisionVariables() {\n        return numDecisionVariables;\n    }", "getOriginalNumDecisionVariables": "    protected final int getOriginalNumDecisionVariables() {\n        return f.getCoefficients().getDimension();\n    }", "getNumSlackVariables": "    protected final int getNumSlackVariables() {\n        return numSlackVariables;\n    }", "getNumArtificialVariables": "    protected final int getNumArtificialVariables() {\n        return numArtificialVariables;\n    }", "getData": "    protected final double[][] getData() {\n        return tableau.getData();\n    }", "equals": "    public boolean equals(Object other) {\n\n      if (this == other) {\n        return true;\n      }\n\n      if (other instanceof SimplexTableau) {\n          SimplexTableau rhs = (SimplexTableau) other;\n          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&\n                 (numDecisionVariables   == rhs.numDecisionVariables) &&\n                 (numSlackVariables      == rhs.numSlackVariables) &&\n                 (numArtificialVariables == rhs.numArtificialVariables) &&\n                 (epsilon                == rhs.epsilon) &&\n                 (maxUlps                == rhs.maxUlps) &&\n                 f.equals(rhs.f) &&\n                 constraints.equals(rhs.constraints) &&\n                 tableau.equals(rhs.tableau);\n      }\n      return false;\n    }", "writeObject": "    private void writeObject(ObjectOutputStream oos)\n        throws IOException {\n        oos.defaultWriteObject();\n        MatrixUtils.serializeRealMatrix(tableau, oos);\n    }", "readObject": "    private void readObject(ObjectInputStream ois)\n      throws ClassNotFoundException, IOException {\n        ois.defaultReadObject();\n        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n    }"}