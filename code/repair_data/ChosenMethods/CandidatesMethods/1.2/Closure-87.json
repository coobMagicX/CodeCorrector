{"tryReduceReturn": "  private Node tryReduceReturn(Node n) {\n    Node result = n.getFirstChild();\n\n    boolean possibleException = result != null &&\n        ControlFlowAnalysis.mayThrowException(result);\n\n    // Try to use a substitute that with a break because it is shorter.\n\n    // First lets pretend it is a break with no labels.\n    Node breakTarget = n;\n    boolean safe = true;\n\n    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n        breakTarget = breakTarget.getParent()) {\n      if (NodeUtil.isFunction(breakTarget) ||\n          breakTarget.getType() == Token.SCRIPT) {\n\n          // We can switch the return to a break if the return value has\n          // side effect and it must encounter a finally.\n\n          // example: return alert('a') -> finally { alert('b') } ->\n          //          return alert('a')\n          // prints a then b. If the first return is a break,\n          // it prints b then a.\n        safe = false;\n        break;\n      }\n    }\n\n    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n\n    // Skip pass all the finally blocks because both the break and return will\n    // also trigger all the finally blocks. However, the order of execution is\n    // slightly changed. Consider:\n    //\n    // return a() -> finally { b() } -> return a()\n    //\n    // which would call a() first. However, changing the first return to a\n    // break will result in calling b().\n    while (follow != null &&\n        NodeUtil.isTryFinallyNode(follow.getParent(), follow)) {\n      if (result != null &&\n          // TODO(user): Use the new side effects API for more accuracy.\n          (NodeUtil.canBeSideEffected(result) ||\n           NodeUtil.mayHaveSideEffects(result))) {\n        safe = false;\n        break;\n      }\n      follow = ControlFlowAnalysis.computeFollowNode(follow);\n    }\n\n    if (safe) {\n      if (follow == null) {\n        // When follow is null, this mean the follow of a break target is the\n        // end of a function. This means a break is same as return.\n        if (result == null) {\n          n.setType(Token.BREAK);\n          reportCodeChange();\n          return n;\n        }\n\n      } else if (follow.getType() == Token.RETURN &&\n          (result == follow.getFirstChild() ||\n           (result != null && follow.hasChildren() &&\n            result.checkTreeEqualsSilent(follow.getFirstChild())) &&\n            ControlFlowAnalysis.getExceptionHandler(n) ==\n            ControlFlowAnalysis.getExceptionHandler(follow)\n           )) {\n        // When the follow is a return, if both doesn't return anything\n        // or both returns the same thing. This mean we can replace it with a\n        // break.\n        n.removeChildren();\n        n.setType(Token.BREAK);\n        reportCodeChange();\n        return n;\n      }\n      // If any of the above is executed, we must return because n is no longer\n      // a \"return\" node.\n    }\n\n    // TODO(user): consider cases such as if (x) { return 1} return 1;\n\n    if (result != null) {\n      switch (result.getType()) {\n        case Token.VOID:\n          Node operand = result.getFirstChild();\n          if (!mayHaveSideEffects(operand)) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n        case Token.NAME:\n          String name = result.getString();\n          if (name.equals(\"undefined\")) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n        default:\n          //Do nothing\n            break;\n      }\n    }\n\n    return n;\n  }", "tryMinimizeNot": "  private Node tryMinimizeNot(Node n) {\n    Node parent = n.getParent();\n\n    Node notChild = n.getFirstChild();\n    // negative operator of the current one : == -> != for instance.\n    int complementOperator;\n    switch (notChild.getType()) {\n      case Token.EQ:\n        complementOperator = Token.NE;\n        break;\n      case Token.NE:\n        complementOperator = Token.EQ;\n        break;\n      case Token.SHEQ:\n        complementOperator = Token.SHNE;\n        break;\n      case Token.SHNE:\n        complementOperator = Token.SHEQ;\n        break;\n      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n      default:\n        return n;\n    }\n    Node newOperator = n.removeFirstChild();\n    newOperator.setType(complementOperator);\n    parent.replaceChild(n, newOperator);\n    reportCodeChange();\n    return newOperator;\n  }", "tryMinimizeIf": "  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          return n;\n        }\n\n        if (cond.getType() == Token.NOT) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = new Node(Token.OR, cond.removeFirstChild(),\n          expr.removeFirstChild()).copyInformationFrom(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses isn't worth it.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\n                       .copyInformationFrom(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                          .copyInformationFrom(n);\n      Node returnNode = new Node(Token.RETURN, hookNode);\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                                .copyInformationFrom(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .copyInformationFrom(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        } else if (NodeUtil.isCall(thenOp)) {\n          // if(x)foo();else bar(); -> x?foo():bar()\n          n.removeChild(cond);\n          thenOp.detachFromParent();\n          elseOp.detachFromParent();\n          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\n                              .copyInformationFrom(n);\n          Node expr = NodeUtil.newExpr(hookNode);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n\n          return expr;\n        }\n      }\n      return n;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.getType() == Token.NAME\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                            .copyInformationFrom(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.getType() == Token.NAME\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                            .copyInformationFrom(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }", "tryRemoveRepeatedStatements": "  private void tryRemoveRepeatedStatements(Node n) {\n    Preconditions.checkState(n.getType() == Token.IF);\n\n    Node parent = n.getParent();\n    if (!NodeUtil.isStatementBlock(parent)) {\n      // If the immediate parent is something like a label, we\n      // can't move the statement, so bail.\n      return;\n    }\n\n    Node cond = n.getFirstChild();\n    Node trueBranch = cond.getNext();\n    Node falseBranch = trueBranch.getNext();\n    Preconditions.checkNotNull(trueBranch);\n    Preconditions.checkNotNull(falseBranch);\n\n    while (true) {\n      Node lastTrue = trueBranch.getLastChild();\n      Node lastFalse = falseBranch.getLastChild();\n      if (lastTrue == null || lastFalse == null\n          || !areNodesEqualForInlining(lastTrue, lastFalse)) {\n        break;\n      }\n      lastTrue.detachFromParent();\n      lastFalse.detachFromParent();\n      parent.addChildAfter(lastTrue, n);\n      reportCodeChange();\n    }\n  }", "isFoldableExpressBlock": "  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n\n          return NodeUtil.isExpressionNode(maybeExpr);\n      }\n    }\n\n    return false;\n  }", "getBlockExpression": "  private Node getBlockExpression(Node n) {\n    Preconditions.checkState(isFoldableExpressBlock(n));\n    return n.getFirstChild();\n  }", "isReturnExpressBlock": "  private boolean isReturnExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.getType() == Token.RETURN) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }", "getBlockReturnExpression": "  private Node getBlockReturnExpression(Node n) {\n    Preconditions.checkState(isReturnExpressBlock(n));\n    return n.getFirstChild().getFirstChild();\n  }", "isVarBlock": "  private boolean isVarBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.getType() == Token.VAR) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }", "getBlockVar": "  private Node getBlockVar(Node n) {\n    Preconditions.checkState(isVarBlock(n));\n    return n.getFirstChild();\n  }", "consumesDanglingElse": "  private boolean consumesDanglingElse(Node n) {\n    while (true) {\n      switch (n.getType()) {\n        case Token.IF:\n          if (n.getChildCount() < 3) {\n            return true;\n          }\n          // This IF node has no else clause.\n          n = n.getLastChild();\n          continue;\n        case Token.WITH:\n        case Token.WHILE:\n        case Token.FOR:\n          n = n.getLastChild();\n          continue;\n        default:\n          return false;\n      }\n    }\n  }", "isLowerPrecedenceInExpression": "  private boolean isLowerPrecedenceInExpression(Node n,\n      final int precedence) {\n    Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return NodeUtil.precedence(input.getType()) < precedence;\n      }\n    };\n\n    return NodeUtil.has(n, isLowerPrecedencePredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }", "isPropertyAssignmentInExpression": "  private boolean isPropertyAssignmentInExpression(Node n) {\n    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n        new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return (input.getType() == Token.GETPROP &&\n            input.getParent().getType() == Token.ASSIGN);\n      }\n    };\n\n    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }", "tryMinimizeCondition": "  private Node tryMinimizeCondition(Node n) {\n    Node parent = n.getParent();\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // NOT children are handled below.\n              return newRoot;\n            }\n          case Token.AND:\n          case Token.OR: {\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              if (leftParent.getType() == Token.NOT\n                  && rightParent.getType() == Token.NOT) {\n                Node left = leftParent.removeFirstChild();\n                Node right = rightParent.removeFirstChild();\n\n                int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n                Node newRoot = new Node(newOp, left, right);\n                parent.replaceChild(n, newRoot);\n                reportCodeChange();\n                // No need to traverse, tryMinimizeCondition is called on the\n                // AND and OR children below.\n                return newRoot;\n              }\n            }\n            break;\n        }\n        // No need to traverse, tryMinimizeCondition is called on the NOT\n        // children in the general case in the main post-order traversal.\n        return n;\n\n      case Token.OR:\n      case Token.AND: {\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the children, this can't be done in the general case.\n        left = tryMinimizeCondition(left);\n        right = tryMinimizeCondition(right);\n\n        // Remove useless conditionals\n        // Handle four cases:\n        //   x || false --> x\n        //   x || true  --> true\n        //   x && true --> x\n        //   x && false  --> false\n        TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n        if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) {\n          int type = n.getType();\n          Node replacement = null;\n          boolean rval = rightVal.toBoolean(true);\n\n          // (x || FALSE) => x\n          // (x && TRUE) => x\n          if (type == Token.OR && !rval ||\n              type == Token.AND && rval) {\n            replacement = left;\n          } else if (!mayHaveSideEffects(left)) {\n            replacement = right;\n          }\n\n          if (replacement != null) {\n            n.detachChildren();\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n          }\n        }\n        return n;\n      }\n\n      case Token.HOOK: {\n        Node condition = n.getFirstChild();\n        Node trueNode = n.getFirstChild().getNext();\n        Node falseNode = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the result children, this can't be done in the general case.\n        // The condition is handled in the general case in #optimizeSubtree\n        trueNode = tryMinimizeCondition(trueNode);\n        falseNode = tryMinimizeCondition(falseNode);\n\n        // Handle four cases:\n        //   x ? true : false --> x\n        //   x ? false : true --> !x\n        //   x ? true : y     --> x || y\n        //   x ? y : false    --> x && y\n        Node replacement = null;\n        if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE\n            && NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = condition;\n        } else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.FALSE\n            && NodeUtil.getBooleanValue(falseNode) == TernaryValue.TRUE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = new Node(Token.NOT, condition);\n        } else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE) {\n          // Remove useless true case.\n          n.detachChildren();\n          replacement = new Node(Token.OR, condition, falseNode);\n        } else if (NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {\n          // Remove useless false case\n          n.detachChildren();\n          replacement = new Node(Token.AND, condition, trueNode);\n        }\n\n        if (replacement != null) {\n          parent.replaceChild(n, replacement);\n          n = replacement;\n          reportCodeChange();\n        }\n\n        return n;\n      }\n\n      default:\n        // while(true) --> while(1)\n        TernaryValue nVal = NodeUtil.getBooleanValue(n);\n        if (nVal != TernaryValue.UNKNOWN) {\n          boolean result = nVal.toBoolean(true);\n          int equivalentResult = result ? 1 : 0;\n          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return n;\n    }\n  }", "maybeReplaceChildWithNumber": "  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n    Node newNode = Node.newNumber(num);\n    if (!newNode.isEquivalentTo(n)) {\n      parent.replaceChild(n, newNode);\n      reportCodeChange();\n\n      return newNode;\n    }\n\n    return n;\n  }", "tryFoldStandardConstructors": "  private Node tryFoldStandardConstructors(Node n) {\n    Preconditions.checkState(n.getType() == Token.NEW);\n\n    // If name normalization has been run then we know that\n    // new Object() does in fact refer to what we think it is\n    // and not some custom-defined Object().\n    if (isASTNormalized()) {\n      if (n.getFirstChild().getType() == Token.NAME) {\n        String className = n.getFirstChild().getString();\n        if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n            n.setType(Token.CALL);\n            reportCodeChange();\n        }\n      }\n    }\n\n    return n;\n  }", "tryFoldLiteralConstructor": "  private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.CALL\n        || n.getType() == Token.NEW);\n\n    Node constructorNameNode = n.getFirstChild();\n\n    Node newLiteralNode = null;\n\n    // We require the AST to be normalized to ensure that, say,\n    // Object() really refers to the built-in Object constructor\n    // and not a user-defined constructor with the same name.\n\n    if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) {\n\n      String className = constructorNameNode.getString();\n\n      if (\"RegExp\".equals(className)) {\n        // \"RegExp(\"boo\", \"g\")\" --> /boo/g\n        return tryFoldRegularExpressionConstructor(n);\n      } else {\n        boolean constructorHasArgs = constructorNameNode.getNext() != null;\n\n        if (\"Object\".equals(className) && !constructorHasArgs) {\n          // \"Object()\" --> \"{}\"\n          newLiteralNode = new Node(Token.OBJECTLIT);\n        } else if (\"Array\".equals(className)) {\n          // \"Array(arg0, arg1, ...)\" --> \"[arg0, arg1, ...]\"\n          Node arg0 = constructorNameNode.getNext();\n          FoldArrayAction action = isSafeToFoldArrayConstructor(arg0);\n\n          if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||\n              action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n            newLiteralNode = new Node(Token.ARRAYLIT);\n            n.removeChildren();\n            if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n              newLiteralNode.addChildrenToFront(arg0);\n            }\n          }\n        }\n\n        if (newLiteralNode != null) {\n          n.getParent().replaceChild(n, newLiteralNode);\n          reportCodeChange();\n          return newLiteralNode;\n        }\n      }\n    }\n    return n;\n  }", "isSafeToFoldArrayConstructor": "  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n    FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD;\n\n    if (arg == null) {\n      action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n    } else if (arg.getNext() != null) {\n      action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n    } else {\n      switch (arg.getType()) {\n        case (Token.STRING):\n          // \"Array('a')\" --> \"['a']\"\n          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n          break;\n        case (Token.NUMBER):\n          // \"Array(0)\" --> \"[]\"\n          if (arg.getDouble() == 0) {\n            action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n          }\n          break;\n        case (Token.ARRAYLIT):\n          // \"Array([args])\" --> \"[[args]]\"\n          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n          break;\n        default:\n      }\n    }\n    return action;\n  }", "tryFoldRegularExpressionConstructor": "  private Node tryFoldRegularExpressionConstructor(Node n) {\n    Node parent = n.getParent();\n    Node constructor = n.getFirstChild();\n    Node pattern = constructor.getNext();  // e.g.  ^foobar$\n    Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n\n    // Only run on normalized AST to make sure RegExp() is actually\n    // the RegExp we expect (if the AST has been normalized then\n    // other RegExp's will have been renamed to something like RegExp$1)\n    if (!isASTNormalized()) {\n      return n;\n    }\n\n    if (null == pattern || (null != flags && null != flags.getNext())) {\n      // too few or too many arguments\n      return n;\n    }\n\n    if (// is pattern folded\n        pattern.getType() == Token.STRING\n        // make sure empty pattern doesn't fold to //\n        && !\"\".equals(pattern.getString())\n\n        // NOTE(nicksantos): Make sure that the regexp isn't longer than\n        // 100 chars, or it blows up the regexp parser in Opera 9.2.\n        && pattern.getString().length() < 100\n\n        && (null == flags || flags.getType() == Token.STRING)\n        // don't escape patterns with unicode escapes since Safari behaves badly\n        // (read can't parse or crashes) on regex literals with unicode escapes\n        && !containsUnicodeEscape(pattern.getString())) {\n\n      // Make sure that / is escaped, so that it will fit safely in /brackets/.\n      // pattern is a string value with \\\\ and similar already escaped\n      pattern = makeForwardSlashBracketSafe(pattern);\n\n      Node regexLiteral;\n      if (null == flags || \"\".equals(flags.getString())) {\n        // fold to /foobar/\n        regexLiteral = new Node(Token.REGEXP, pattern);\n      } else {\n        // fold to /foobar/gi\n        if (!areValidRegexpFlags(flags.getString())) {\n          error(INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n          return n;\n        }\n        if (!areSafeFlagsToFold(flags.getString())) {\n          return n;\n        }\n        n.removeChild(flags);\n        regexLiteral = new Node(Token.REGEXP, pattern, flags);\n      }\n\n      parent.replaceChild(n, regexLiteral);\n      reportCodeChange();\n      return regexLiteral;\n    }\n\n    return n;\n  }", "containsUnicodeEscape": "  static boolean containsUnicodeEscape(String s) {\n    String esc = CodeGenerator.regexpEscape(s);\n    for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n      int nSlashes = 0;\n      while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n        ++nSlashes;\n      }\n      // if there are an even number of slashes before the \\ u then it is a\n      // unicode literal.\n      if (0 == (nSlashes & 1)) { return true; }\n    }\n    return false;\n  }"}