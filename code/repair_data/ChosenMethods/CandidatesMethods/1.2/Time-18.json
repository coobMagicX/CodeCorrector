{"convertByYear": "    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }", "convertByWeekyear": "    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\n        long newInstant;\n        newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n        return newInstant;\n    }", "getDateTimeMillis": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant;\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }", "equals": "    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }", "assemble": "    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, cutover);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\n            fields.weekyears = fields.weekyear.getDurationField();\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }", "julianToGregorianByYear": "    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }", "gregorianToJulianByYear": "    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }", "julianToGregorianByWeekyear": "    long julianToGregorianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);\n    }", "gregorianToJulianByWeekyear": "    long gregorianToJulianByWeekyear(long instant) {\n        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n    }", "get": "        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }", "add": "        public long add(long instant, long value) {\n            return iField.add(instant, value);\n        }", "set": "        public long set(long instant, String text, Locale locale) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, text, locale);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            } else {\n                instant = iJulianField.set(instant, text, locale);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Cannot verify that new value stuck because set may be lenient.\n                }\n            }\n            return instant;\n        }"}