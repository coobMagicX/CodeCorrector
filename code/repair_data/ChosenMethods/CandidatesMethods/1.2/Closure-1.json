{"process": "  public void process(\n      Node externs, Node root, SimpleDefinitionFinder defFinder) {\n    if (modifyCallSites) {\n      Preconditions.checkNotNull(defFinder);\n      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n    }\n    traverseAndRemoveUnusedReferences(root);\n    if (callSiteOptimizer != null) {\n      callSiteOptimizer.applyChanges();\n    }\n  }", "traverseNode": "  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        // If this function is a removable var, then create a continuation\n        // for it instead of traversing immediately.\n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          // Put this in the assign map. It might count as a reference,\n          // but we won't know that until we have an index of all assigns.\n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              // If the var is unreferenced and performing this assign has\n              // no secondary side effects, then we can create a continuation\n              // for it instead of traversing immediately.\n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        Var modifiedVar = null;\n\n        // Look for calls to inheritance-defining calls (such as goog.inherits).\n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          modifiedVar = scope.getVar(subclassRelationship.subclassName);\n        } else {\n          // Look for calls to addSingletonGetter calls.\n          String className = codingConvention.getSingletonGetterClassName(n);\n          if (className != null) {\n            modifiedVar = scope.getVar(className);\n          }\n        }\n\n        // Don't try to track the inheritance calls for non-globals. It would\n        // be more correct to only not track when the subclass does not\n        // reference a constructor, but checking that it is a global is\n        // easier and mostly the same.\n        if (modifiedVar != null && modifiedVar.isGlobal()\n            && !referenced.contains(modifiedVar)) {\n          // Save a reference to the EXPR node.\n          classDefiningCalls.put(modifiedVar, parent);\n          continuations.put(modifiedVar, new Continuation(n, scope));\n          return;\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.isVar()) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n            // If the var is unreferenced and creating its value has no side\n            // effects, then we can create a continuation for it instead\n            // of traversing immediately.\n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          // If arguments is escaped, we just assume the worst and continue\n          // on all the parameters.\n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          // All name references that aren't declarations or assigns\n          // are references to other vars.\n          if (var != null) {\n            // If that var hasn't already been marked referenced, then\n            // start tracking it.  If this is an assign, do nothing\n            // for now.\n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }", "isRemovableVar": "  private boolean isRemovableVar(Var var) {\n    // Global variables are off-limits if the user might be using them.\n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    // Referenced variables are off-limits.\n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    // Exported variables are off-limits.\n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }", "traverseFunction": "  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }", "collectMaybeUnreferencedVars": "  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }", "removeUnreferencedFunctionArgs": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }", "getFunctionArgList": "  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }", "optimize": "    public void optimize(Scope fnScope, Set<Var> referenced) {\n      Node function = fnScope.getRootNode();\n      Preconditions.checkState(function.isFunction());\n      Node argList = getFunctionArgList(function);\n\n      // In this path we try to modify all the call sites to remove unused\n      // function parameters.\n      boolean changeCallSignature = canChangeSignature(function);\n      markUnreferencedFunctionArgs(\n          fnScope, function, referenced,\n          argList.getFirstChild(), 0, changeCallSignature);\n    }", "markUnreferencedFunctionArgs": "    private boolean markUnreferencedFunctionArgs(\n        Scope scope, Node function, Set<Var> referenced,\n        Node param, int paramIndex,\n        boolean canChangeSignature) {\n      if (param != null) {\n        // Take care of the following siblings first.\n        boolean hasFollowing = markUnreferencedFunctionArgs(\n            scope, function, referenced, param.getNext(), paramIndex+1,\n            canChangeSignature);\n\n        Var var = scope.getVar(param.getString());\n        if (!referenced.contains(var)) {\n          Preconditions.checkNotNull(var);\n\n          // Remove call parameter if we can generally change the signature\n          // or if it is the last parameter in the parameter list.\n          boolean modifyAllCallSites = canChangeSignature || !hasFollowing;\n          if (modifyAllCallSites) {\n            modifyAllCallSites = canRemoveArgFromCallSites(\n                function, paramIndex);\n          }\n\n          tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);\n\n          // Remove an unused function parameter if all the call sites can\n          // be modified to remove it, or if it is the last parameter.\n          if (modifyAllCallSites || !hasFollowing) {\n            toRemove.add(param);\n            return hasFollowing;\n          }\n        }\n        return true;\n      } else {\n        // Anything past the last formal parameter can be removed from the call\n        // sites.\n        tryRemoveAllFollowingArgs(function, paramIndex-1);\n        return false;\n      }\n    }", "canModifyCallers": "    boolean canModifyCallers(Node function) {\n      if (NodeUtil.isVarArgsFunction(function)) {\n        return false;\n      }\n\n      DefinitionSite defSite = defFinder.getDefinitionForFunction(function);\n      if (defSite == null) {\n        return false;\n      }\n\n      Definition definition = defSite.definition;\n\n      // Be conservative, don't try to optimize any declaration that isn't as\n      // simple function declaration or assignment.\n      if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) {\n        return false;\n      }\n\n      return defFinder.canModifyDefinition(definition);\n    }", "getFunctionDefinition": "    private Definition getFunctionDefinition(Node function) {\n      DefinitionSite definitionSite = defFinder.getDefinitionForFunction(\n          function);\n      Preconditions.checkNotNull(definitionSite);\n      Definition definition = definitionSite.definition;\n      Preconditions.checkState(!definitionSite.inExterns);\n      Preconditions.checkState(definition.getRValue() == function);\n      return definition;\n    }", "markReferencedVar": "  private boolean markReferencedVar(Var var) {\n    if (referenced.add(var)) {\n      for (Continuation c : continuations.get(var)) {\n        c.apply();\n      }\n      return true;\n    }\n    return false;\n  }", "removeUnreferencedVars": "  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      // Remove calls to inheritance-defining functions where the unreferenced\n      // class is the subclass.\n      for (Node exprCallNode : classDefiningCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      // Regardless of what happens to the original declaration,\n      // we need to remove all assigns, because they may contain references\n      // to other unreferenced variables.\n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.isVar() ||\n          toRemove.isFunction() ||\n          toRemove.isParamList() &&\n          parent.isFunction(),\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.isParamList() &&\n          parent.isFunction()) {\n        // Don't remove function arguments here. That's a special case\n        // that's taken care of in removeUnreferencedFunctionArgs.\n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        // Don't remove bleeding functions.\n      } else if (parent != null &&\n          parent.isFor() &&\n          parent.getChildCount() < 4) {\n        // foreach iterations have 3 children. Leave them alone.\n      } else if (toRemove.isVar() &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n        // If this is a single var declaration, we can at least remove the\n        // declaration itself and just leave the value, e.g.,\n        // var a = foo(); => foo();\n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              IR.exprResult(nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.isVar() &&\n          toRemove.getChildCount() > 1) {\n        // For var declarations with multiple names (i.e. var a, b, c),\n        // only remove the unreferenced name\n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }", "apply": "    void apply() {\n      if (NodeUtil.isFunctionDeclaration(node)) {\n        traverseFunction(node, scope);\n      } else {\n        for (Node child = node.getFirstChild();\n             child != null; child = child.getNext()) {\n          traverseNode(child, node, scope);\n        }\n      }\n    }", "remove": "    void remove() {\n      Node parent = assignNode.getParent();\n      if (mayHaveSecondarySideEffects) {\n        Node replacement = assignNode.getLastChild().detachFromParent();\n\n        // Aggregate any expressions in GETELEMs.\n        for (Node current = assignNode.getFirstChild();\n             !current.isName();\n             current = current.getFirstChild()) {\n          if (current.isGetElem()) {\n            replacement = IR.comma(\n                current.getLastChild().detachFromParent(), replacement);\n            replacement.copyInformationFrom(current);\n          }\n        }\n\n        parent.replaceChild(assignNode, replacement);\n      } else {\n        Node gramps = parent.getParent();\n        if (parent.isExprResult()) {\n          gramps.removeChild(parent);\n        } else {\n          parent.replaceChild(assignNode,\n              assignNode.getLastChild().detachFromParent());\n        }\n      }\n    }"}