{"resolve": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }", "createScope": "  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }", "createInitialScope": "  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));\n\n    Scope s = new Scope(root, compiler);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // The typedef construct needs the any type, so that it can be assigned\n    // to anything. This is kind of a hack, and an artifact of the typedef\n    // syntax we've chosen.\n    declareNativeValueType(s, \"goog.typedef\", NO_TYPE);\n\n    // ActiveXObject is unqiuely special, because it can be used to construct\n    // any type (the type that it creates is related to the arguments you\n    // pass to it).\n    declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n\n    return s;\n  }", "declareNativeFunctionType": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }", "declareNativeValueType": "  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }", "declareNativeType": "  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }", "visit": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }", "identifyEnumInNameNode": "    private void identifyEnumInNameNode(Node nameNode, JSDocInfo info) {\n      if (info != null && info.hasEnumParameterType()) {\n        registry.identifyEnumName(nameNode.getQualifiedName());\n      }\n    }", "getPrototypePropertyOwner": "  private static Node getPrototypePropertyOwner(Node n) {\n    if (n.getType() == Token.GETPROP) {\n      Node firstChild = n.getFirstChild();\n      if (firstChild.getType() == Token.GETPROP &&\n          firstChild.getLastChild().getString().equals(\"prototype\")) {\n        Node maybeOwner = firstChild.getFirstChild();\n        if (maybeOwner.isQualifiedName()) {\n          return maybeOwner;\n        }\n      }\n    }\n    return null;\n  }", "attachLiteralTypes": "  private void attachLiteralTypes(Node n) {\n    switch (n.getType()) {\n      case Token.NULL:\n        n.setJSType(getNativeType(NULL_TYPE));\n        break;\n\n      case Token.VOID:\n        n.setJSType(getNativeType(VOID_TYPE));\n        break;\n\n      case Token.STRING:\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.NUMBER:\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.REGEXP:\n        n.setJSType(getNativeType(REGEXP_TYPE));\n        break;\n\n      case Token.REF_SPECIAL:\n        n.setJSType(getNativeType(UNKNOWN_TYPE));\n        break;\n\n      case Token.OBJECTLIT:\n        if (n.getJSType() == null) {\n          n.setJSType(typeRegistry.createAnonymousObjectType());\n        }\n        break;\n\n      // NOTE(nicksantos): If we ever support Array tuples,\n      // we will need to put ARRAYLIT here as well.\n    }\n  }", "getNativeType": "  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }", "setDeferredType": "    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }", "resolveTypes": "    void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }", "getDeclaredTypeInAnnotation": "    JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode = node.getType() == Token.GETPROP ?\n          node.getFirstChild() : null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n\n          // constructors are often handled separately.\n          if (info.isConstructor() && typeRegistry.getType(fnName) != null) {\n            return null;\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(\n                  fnName, compiler, node, sourceName, scope)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferParameterTypes(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (objNode != null) {\n            if (objNode.getType() == Token.GETPROP &&\n                objNode.getLastChild().getString().equals(\"prototype\")) {\n              builder.inferThisType(info, objNode.getFirstChild());\n              searchedForThisType = true;\n            } else if (objNode.getType() == Token.THIS) {\n              builder.inferThisType(info, objNode.getJSType());\n              searchedForThisType = true;\n            }\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info, (Node) null);\n          }\n\n          jsType = builder.buildAndRegister();\n        }\n      }\n      return jsType;\n    }", "assertDefinitionNode": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }", "defineCatch": "    void defineCatch(Node n, Node parent) {\n      assertDefinitionNode(n, Token.CATCH);\n      Node catchName = n.getFirstChild();\n      defineSlot(catchName, n, null);\n    }", "defineVar": "    void defineVar(Node n, Node parent) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, parent, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, parent,\n            (info != null) ? info : name.getJSDocInfo());\n      }\n    }", "defineDeclaredFunction": "    void defineDeclaredFunction(Node n, Node parent) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      JSDocInfo info = n.getJSDocInfo();\n      int parentType = parent.getType();\n      Preconditions.checkState(\n          (scope.isLocal() || parentType != Token.ASSIGN) &&\n          parentType != Token.NAME,\n          \"function defined as standalone function when it is being \" +\n          \"assigned\");\n      String functionName = n.getFirstChild().getString();\n      FunctionType functionType = getFunctionType(functionName, n, info,\n          null);\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }", "defineNamedTypeAssign": "    void defineNamedTypeAssign(Node n, Node parent) {\n      assertDefinitionNode(n, Token.ASSIGN);\n      JSDocInfo info = n.getJSDocInfo();\n\n      // TODO(nicksantos): We should support direct assignment to a\n      // prototype, as in:\n      // Foo.prototype = {\n      //   a: function() { ... },\n      //   b: function() { ... }\n      // };\n      // Right now (6/23/08), we understand most of this syntax, but we\n      // don't tie the \"a\" and \"b\" methods to the context of Foo.\n\n      Node rvalue = n.getLastChild();\n      Node lvalue = n.getFirstChild();\n      info = (info != null) ? info : rvalue.getJSDocInfo();\n      if (rvalue.getType() == Token.FUNCTION ||\n          info != null && info.isConstructor()) {\n        getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n            lvalue);\n      } else if (info != null && info.hasEnumParameterType()) {\n        JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,\n            info.getEnumParameterType().evaluate(scope, typeRegistry));\n        if (type != null) {\n          setDeferredType(lvalue, type);\n        }\n      }\n    }", "defineName": "    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      if (value != null && value.getType() == Token.FUNCTION) {\n        // function\n        String functionName = name.getString();\n        FunctionType functionType =\n            getFunctionType(functionName, value, info, null);\n        if (functionType.isReturnTypeInferred() &&\n            scope.isLocal()) {\n          defineSlot(name, var, null);\n        } else {\n          defineSlot(name, var, functionType);\n        }\n      } else {\n        // variable's type\n        JSType type = null;\n        if (info == null) {\n          // the variable's type will be inferred\n          CompilerInput input = compiler.getInput(sourceName);\n          Preconditions.checkNotNull(input, sourceName);\n          type = input.isExtern() ?\n              getNativeType(UNKNOWN_TYPE) : null;\n        } else if (info.hasEnumParameterType()) {\n          type = getEnumType(name.getString(), var, value,\n              info.getEnumParameterType().evaluate(scope, typeRegistry));\n        } else if (info.isConstructor()) {\n          type = getFunctionType(name.getString(), value, info, name);\n        } else {\n          type = getDeclaredTypeInAnnotation(sourceName, name, info);\n        }\n\n        defineSlot(name, var, type);\n      }\n    }", "getFunctionType": "    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Global function aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        // Find the type of any overridden function.\n        FunctionType overriddenPropType = null;\n        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n            lvalueNode.isQualifiedName()) {\n          Var var = scope.getVar(\n              lvalueNode.getFirstChild().getQualifiedName());\n          if (var != null) {\n            ObjectType ownerType = ObjectType.cast(var.getType());\n            if (ownerType != null) {\n              String propName = lvalueNode.getLastChild().getString();\n              overriddenPropType = findOverriddenFunction(ownerType, propName);\n            }\n          }\n        }\n\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n            .inferReturnStatementsAsLastResort(fnBlock)\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        setDeferredType(rValue, functionType);\n      }\n\n      // all done\n      return functionType;\n    }", "findOverriddenFunction": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType instanceof FunctionType) {\n            return (FunctionType) propType;\n          }\n        }\n      }\n\n      return null;\n    }", "getEnumType": "    private EnumType getEnumType(String name, Node parent,\n        Node value, JSType elementsType) {\n      EnumType enumType = null;\n\n      // no value with @enum\n      if (value != null) {\n        if (value.getType() == Token.OBJECTLIT) {\n          // collect enum elements\n          enumType = typeRegistry.createEnumType(name, elementsType);\n\n          // populate the enum type.\n          Node key = value.getFirstChild();\n          while (key != null) {\n            String keyName = NodeUtil.getStringValue(key);\n\n            if (enumType.hasOwnProperty(keyName)) {\n              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n            } else if (!codingConvention.isValidEnumKey(keyName)) {\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else {\n              enumType.defineElement(keyName);\n            }\n            key = key.getNext();\n            key = (key == null) ? null : key.getNext();\n          }\n        } else if (value.isQualifiedName()) {\n          Var var = scope.getVar(value.getQualifiedName());\n          if (var != null && var.getType() instanceof EnumType) {\n            enumType = (EnumType) var.getType();\n          }\n        }\n      }\n\n      if (enumType == null) {\n        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n      } else if (scope.isGlobal()) {\n        if (name != null && !name.isEmpty()) {\n          typeRegistry.declareType(name, enumType.getElementsType());\n        }\n      }\n\n      return enumType;\n    }", "defineSlot": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.getType() == Token.VAR ||\n             parent.getType() == Token.FUNCTION);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }", "isQnameRootedInGlobalScope": "    private boolean isQnameRootedInGlobalScope(Node n) {\n      Node root = NodeUtil.getRootOfQualifiedName(n);\n      if (root.getType() == Token.NAME) {\n        Var var = scope.getVar(root.getString());\n        if (var != null) {\n          return var.isGlobal();\n        }\n      }\n      return false;\n    }", "getDeclaredGetPropType": "    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n        Node n, Node rhsValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, n, info);\n      } else if (info != null && info.hasEnumParameterType()) {\n        return n.getJSType();\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.FUNCTION) {\n        return rhsValue.getJSType();\n      } else {\n        return getDeclaredTypeInAnnotation(t, n, info);\n      }\n    }", "checkForClassDefiningCalls": "    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n      SubclassRelationship relationship =\n          codingConvention.getClassesDefinedByCall(n);\n      if (relationship != null) {\n        ObjectType superClass = ObjectType.cast(\n            typeRegistry.getType(relationship.superclassName));\n        ObjectType subClass = ObjectType.cast(\n            typeRegistry.getType(relationship.subclassName));\n        if (superClass != null && subClass != null) {\n          FunctionType superCtor = superClass.getConstructor();\n          FunctionType subCtor = subClass.getConstructor();\n\n          if (relationship.type == SubclassType.INHERITS) {\n            validator.expectSuperType(t, n, superClass, subClass);\n          }\n\n          if (superCtor != null && subCtor != null) {\n            codingConvention.applySubclassRelationship(\n                superCtor, subCtor, relationship.type);\n          }\n        }\n      }\n\n      String singletonGetterClassName =\n          codingConvention.getSingletonGetterClassName(n);\n      if (singletonGetterClassName != null) {\n        ObjectType objectType = ObjectType.cast(\n            typeRegistry.getType(singletonGetterClassName));\n        if (objectType != null) {\n          FunctionType functionType = objectType.getConstructor();\n\n          if (functionType != null) {\n            FunctionType getterType =\n                typeRegistry.createFunctionType(objectType);\n            codingConvention.applySingletonGetter(functionType, getterType,\n                objectType);\n          }\n        }\n      }\n\n      DelegateRelationship delegateRelationship =\n          codingConvention.getDelegateRelationship(n);\n      if (delegateRelationship != null) {\n        applyDelegateRelationship(delegateRelationship);\n      }\n\n      ObjectLiteralCast objectLiteralCast =\n          codingConvention.getObjectLiteralCast(t, n);\n      if (objectLiteralCast != null) {\n        ObjectType type = ObjectType.cast(\n            typeRegistry.getType(objectLiteralCast.typeName));\n        if (type != null && type.getConstructor() != null) {\n          setDeferredType(objectLiteralCast.objectNode, type);\n        } else {\n          compiler.report(JSError.make(t.getSourceName(), n,\n                  CONSTRUCTOR_EXPECTED));\n        }\n      }\n    }", "applyDelegateRelationship": "    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n      ObjectType delegatorObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegator));\n      ObjectType delegateBaseObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegateBase));\n      ObjectType delegateSuperObject = ObjectType.cast(\n          typeRegistry.getType(codingConvention.getDelegateSuperclassName()));\n      if (delegatorObject != null &&\n          delegateBaseObject != null &&\n          delegateSuperObject != null) {\n        FunctionType delegatorCtor = delegatorObject.getConstructor();\n        FunctionType delegateBaseCtor = delegateBaseObject.getConstructor();\n        FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();\n\n        if (delegatorCtor != null && delegateBaseCtor != null &&\n            delegateSuperCtor != null) {\n          FunctionParamBuilder functionParamBuilder =\n              new FunctionParamBuilder(typeRegistry);\n          functionParamBuilder.addRequiredParams(\n              getNativeType(U2U_CONSTRUCTOR_TYPE));\n          FunctionType findDelegate = typeRegistry.createFunctionType(\n              typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n              functionParamBuilder.build());\n\n          FunctionType delegateProxy = typeRegistry.createConstructorType(\n              delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX,\n              null, null, null);\n          delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n\n          codingConvention.applyDelegateRelationship(\n              delegateSuperObject, delegateBaseObject, delegatorObject,\n              delegateProxy, findDelegate);\n          delegateProxyPrototypes.add(delegateProxy.getPrototype());\n        }\n      }\n    }", "maybeDeclareQualifiedName": "    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }", "resolveStubDeclarations": "    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, isExtern);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }", "checkForTypedef": "    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recusive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.forwardDeclareType(typedef);\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.declareType(typedef, realType);\n      if (candidate.getType() == Token.GETPROP) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }", "checkForOldStyleTypedef": "    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n      // old-style typedefs\n      String typedef = codingConvention.identifyTypeDefAssign(candidate);\n      if (typedef != null) {\n        // TODO(nicksantos|user): This is a terrible, terrible hack\n        // to bail out on recusive typedefs. We'll eventually need\n        // to handle these properly.\n        typeRegistry.forwardDeclareType(typedef);\n\n        JSDocInfo info = candidate.getJSDocInfo();\n        JSType realType = null;\n        if (info != null && info.getType() != null) {\n          realType = info.getType().evaluate(scope, typeRegistry);\n        }\n\n        if (realType == null) {\n          compiler.report(\n              JSError.make(\n                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n        }\n\n        typeRegistry.declareType(typedef, realType);\n\n        // Duplicate typedefs get handled when we try to register\n        // this typedef in the scope.\n      }\n    }", "build": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n    }", "handleFunctionInputs": "    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }", "declareArguments": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments"}