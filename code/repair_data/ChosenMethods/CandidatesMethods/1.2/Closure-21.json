{"process": "    public void process(Node externs, Node root) {\n      NodeTraversal.traverse(compiler, root, this);\n    }", "hotSwapScript": "  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n    NodeTraversal.traverse(compiler, scriptRoot, this);\n  }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall()) {\n        Node target = n.getFirstChild();\n        // TODO(johnlenz): add this to the coding convention\n        // so we can remove goog.reflect.sinkValue as well.\n        if (target.isName() && target.getString().equals(PROTECTOR_FN)) {\n          Node expr = n.getLastChild();\n          n.detachChildren();\n          parent.replaceChild(n, expr);\n        }\n      }\n    }", "protectSideEffects": "  private void protectSideEffects() {\n    if (!problemNodes.isEmpty()) {\n      addExtern();\n      for (Node n : problemNodes) {\n        Node name = IR.name(PROTECTOR_FN).srcref(n);\n        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        Node replacement = IR.call(name).srcref(n);\n        replacement.putBooleanProp(Node.FREE_CALL, true);\n        n.getParent().replaceChild(n, replacement);\n        replacement.addChildToBack(n);\n      }\n      compiler.reportCodeChange();\n    }\n  }", "addExtern": "  private void addExtern() {\n    Node name = IR.name(PROTECTOR_FN);\n    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    Node var = IR.var(name);\n    // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordNoAlias();\n    var.setJSDocInfo(builder.build(var));\n    CompilerInput input = compiler.getSynthesizedExternsInput();\n    input.getAstRoot(compiler).addChildrenToBack(var);\n    compiler.reportCodeChange();\n  }"}