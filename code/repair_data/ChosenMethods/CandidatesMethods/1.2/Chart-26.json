{"setVisible": "    public void setVisible(boolean flag) {\n        if (flag != this.visible) {\n            this.visible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }", "getLabel": "    public String getLabel() {\n        return this.label;\n    }", "setLabel": "    public void setLabel(String label) {\n        \n        String existing = this.label;\n        if (existing != null) {\n            if (!existing.equals(label)) {\n                this.label = label;\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n        else {\n            if (label != null) {\n                this.label = label;\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n\n    }", "getLabelFont": "    public Font getLabelFont() {\n        return this.labelFont;\n    }", "setLabelFont": "    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        if (!this.labelFont.equals(font)) {\n            this.labelFont = font;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }", "getLabelPaint": "    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }", "setLabelPaint": "    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getLabelInsets": "    public RectangleInsets getLabelInsets() {\n        return this.labelInsets;\n    }", "setLabelInsets": "    public void setLabelInsets(RectangleInsets insets) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");   \n        }\n        if (!insets.equals(this.labelInsets)) {\n            this.labelInsets = insets;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }", "getLabelAngle": "    public double getLabelAngle() {\n        return this.labelAngle;\n    }", "setLabelAngle": "    public void setLabelAngle(double angle) {\n        this.labelAngle = angle;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getLabelToolTip": "    public String getLabelToolTip() {\n        return this.labelToolTip;\n    }", "setLabelToolTip": "    public void setLabelToolTip(String text) {\n        this.labelToolTip = text;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getLabelURL": "    public String getLabelURL() {\n        return this.labelURL;\n    }", "setLabelURL": "    public void setLabelURL(String url) {\n        this.labelURL = url;\n        notifyListeners(new AxisChangeEvent(this));        \n    }", "setAxisLineVisible": "    public void setAxisLineVisible(boolean visible) {\n        this.axisLineVisible = visible;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getAxisLinePaint": "    public Paint getAxisLinePaint() {\n        return this.axisLinePaint;\n    }", "setAxisLinePaint": "    public void setAxisLinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.axisLinePaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getAxisLineStroke": "    public Stroke getAxisLineStroke() {\n        return this.axisLineStroke;\n    }", "setAxisLineStroke": "    public void setAxisLineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.axisLineStroke = stroke;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "isTickLabelsVisible": "    public boolean isTickLabelsVisible() {\n        return this.tickLabelsVisible;\n    }", "setTickLabelsVisible": "    public void setTickLabelsVisible(boolean flag) {\n\n        if (flag != this.tickLabelsVisible) {\n            this.tickLabelsVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }", "getTickLabelFont": "    public Font getTickLabelFont() {\n        return this.tickLabelFont;\n    }", "setTickLabelFont": "    public void setTickLabelFont(Font font) {\n\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n\n        if (!this.tickLabelFont.equals(font)) {\n            this.tickLabelFont = font;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }", "getTickLabelPaint": "    public Paint getTickLabelPaint() {\n        return this.tickLabelPaint;\n    }", "setTickLabelPaint": "    public void setTickLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.tickLabelPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getTickLabelInsets": "    public RectangleInsets getTickLabelInsets() {\n        return this.tickLabelInsets;\n    }", "setTickLabelInsets": "    public void setTickLabelInsets(RectangleInsets insets) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");\n        }\n        if (!this.tickLabelInsets.equals(insets)) {\n            this.tickLabelInsets = insets;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }", "isTickMarksVisible": "    public boolean isTickMarksVisible() {\n        return this.tickMarksVisible;\n    }", "setTickMarksVisible": "    public void setTickMarksVisible(boolean flag) {\n        if (flag != this.tickMarksVisible) {\n            this.tickMarksVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }", "getTickMarkInsideLength": "    public float getTickMarkInsideLength() {\n        return this.tickMarkInsideLength;\n    }", "setTickMarkInsideLength": "    public void setTickMarkInsideLength(float length) {\n        this.tickMarkInsideLength = length;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getTickMarkOutsideLength": "    public float getTickMarkOutsideLength() {\n        return this.tickMarkOutsideLength;\n    }", "setTickMarkOutsideLength": "    public void setTickMarkOutsideLength(float length) {\n        this.tickMarkOutsideLength = length;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getTickMarkStroke": "    public Stroke getTickMarkStroke() {\n        return this.tickMarkStroke;\n    }", "setTickMarkStroke": "    public void setTickMarkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        if (!this.tickMarkStroke.equals(stroke)) {\n            this.tickMarkStroke = stroke;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }", "getTickMarkPaint": "    public Paint getTickMarkPaint() {\n        return this.tickMarkPaint;\n    }", "setTickMarkPaint": "    public void setTickMarkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.tickMarkPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }", "getPlot": "    public Plot getPlot() {\n        return this.plot;\n    }", "setPlot": "    public void setPlot(Plot plot) {\n        this.plot = plot;\n        configure();\n    }", "getFixedDimension": "    public double getFixedDimension() {\n        return this.fixedDimension;\n    }", "setFixedDimension": "    public void setFixedDimension(double dimension) {\n        this.fixedDimension = dimension;\n    }", "configure": "    public abstract void configure();\n\n    /**\n     * Estimates the space (height or width) required to draw the axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the plot (including axes) should \n     *                  be drawn.\n     * @param edge  the axis location.\n     * @param space  space already reserved.\n     *\n     * @return The space required to draw the axis (including pre-reserved \n     *         space).\n     */\n    public abstract AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n                                           Rectangle2D plotArea, \n                                           RectangleEdge edge, \n                                           AxisSpace space);\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a \n     * printer).\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param cursor  the cursor location (determines where to draw the axis).\n     * @param plotArea  the area within which the axes and plot should be drawn.\n     * @param dataArea  the area within which the data should be drawn.\n     * @param edge  the axis location (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot \n     *                   (<code>null</code> permitted).\n     * \n     * @return The axis state (never <code>null</code>).\n     */\n    public abstract AxisState draw(Graphics2D g2, \n                                   double cursor,\n                                   Rectangle2D plotArea, \n                                   Rectangle2D dataArea,\n                                   RectangleEdge edge,\n                                   PlotRenderingInfo plotState);\n\n    /**\n     * Calculates the positions of the ticks for the axis, storing the results\n     * in the tick list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the edge on which the axis is located.\n     * \n     * @return The list of ticks.\n     */\n    public abstract List refreshTicks(Graphics2D g2, \n                                      AxisState state,\n                                      Rectangle2D dataArea,\n                                      RectangleEdge edge);\n\n    /**\n     * Registers an object for notification of changes to the axis.\n     *\n     * @param listener  the object that is being registered.\n     * \n     * @see #removeChangeListener(AxisChangeListener)\n     */\n    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }", "draw": "    public abstract AxisState draw(Graphics2D g2, \n                                   double cursor,\n                                   Rectangle2D plotArea, \n                                   Rectangle2D dataArea,\n                                   RectangleEdge edge,\n                                   PlotRenderingInfo plotState);\n\n    /**\n     * Calculates the positions of the ticks for the axis, storing the results\n     * in the tick list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the edge on which the axis is located.\n     * \n     * @return The list of ticks.\n     */\n    public abstract List refreshTicks(Graphics2D g2, \n                                      AxisState state,\n                                      Rectangle2D dataArea,\n                                      RectangleEdge edge);\n\n    /**\n     * Registers an object for notification of changes to the axis.\n     *\n     * @param listener  the object that is being registered.\n     * \n     * @see #removeChangeListener(AxisChangeListener)\n     */\n    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }", "refreshTicks": "    public abstract List refreshTicks(Graphics2D g2, \n                                      AxisState state,\n                                      Rectangle2D dataArea,\n                                      RectangleEdge edge);\n\n    /**\n     * Registers an object for notification of changes to the axis.\n     *\n     * @param listener  the object that is being registered.\n     * \n     * @see #removeChangeListener(AxisChangeListener)\n     */\n    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }", "addChangeListener": "    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }", "removeChangeListener": "    public void removeChangeListener(AxisChangeListener listener) {\n        this.listenerList.remove(AxisChangeListener.class, listener);\n    }", "hasListener": "    public boolean hasListener(EventListener listener) {\n        List list = Arrays.asList(this.listenerList.getListenerList());\n        return list.contains(listener);\n    }", "notifyListeners": "    protected void notifyListeners(AxisChangeEvent event) {\n\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == AxisChangeListener.class) {\n                ((AxisChangeListener) listeners[i + 1]).axisChanged(event);\n            }\n        }\n\n    }", "getLabelEnclosure": "    protected Rectangle2D getLabelEnclosure(Graphics2D g2, RectangleEdge edge) {\n\n        Rectangle2D result = new Rectangle2D.Double();\n        String axisLabel = getLabel();\n        if (axisLabel != null && !axisLabel.equals(\"\")) {\n            FontMetrics fm = g2.getFontMetrics(getLabelFont());\n            Rectangle2D bounds = TextUtilities.getTextBounds(axisLabel, g2, fm);\n            RectangleInsets insets = getLabelInsets();\n            bounds = insets.createOutsetRectangle(bounds);\n            double angle = getLabelAngle();\n            if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n                angle = angle - Math.PI / 2.0;\n            }\n            double x = bounds.getCenterX();\n            double y = bounds.getCenterY();\n            AffineTransform transformer \n                = AffineTransform.getRotateInstance(angle, x, y);\n            Shape labelBounds = transformer.createTransformedShape(bounds);\n            result = labelBounds.getBounds2D();\n        }\n\n        return result;\n\n    }", "drawLabel": "    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }", "drawAxisLine": "    protected void drawAxisLine(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        \n        Line2D axisLine = null;\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        g2.setPaint(this.axisLinePaint);\n        g2.setStroke(this.axisLineStroke);\n        g2.draw(axisLine);\n        \n    }", "clone": "    public Object clone() throws CloneNotSupportedException {\n        Axis clone = (Axis) super.clone();\n        // It's up to the plot which clones up to restore the correct references\n        clone.plot = null;        \n        clone.listenerList = new EventListenerList();\n        return clone;\n    }", "equals": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Axis)) {\n            return false;\n        }\n        Axis that = (Axis) obj;\n        if (this.visible != that.visible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.label, that.label)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelInsets, that.labelInsets)) {\n            return false;\n        }\n        if (this.labelAngle != that.labelAngle) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelToolTip, that.labelToolTip)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelURL, that.labelURL)) {\n            return false;\n        }\n        if (this.axisLineVisible != that.axisLineVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisLineStroke, that.axisLineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.axisLinePaint, that.axisLinePaint)) {\n            return false;\n        }\n        if (this.tickLabelsVisible != that.tickLabelsVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickLabelFont, that.tickLabelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.tickLabelPaint, that.tickLabelPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.tickLabelInsets, that.tickLabelInsets\n        )) {\n            return false;\n        }\n        if (this.tickMarksVisible != that.tickMarksVisible) {\n            return false;\n        }\n        if (this.tickMarkInsideLength != that.tickMarkInsideLength) {\n            return false;\n        }                  \n        if (this.tickMarkOutsideLength != that.tickMarkOutsideLength) {\n            return false;\n        }                  \n        if (!PaintUtilities.equal(this.tickMarkPaint, that.tickMarkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickMarkStroke, that.tickMarkStroke)) {\n            return false;\n        }\n        if (this.fixedDimension != that.fixedDimension) {\n            return false;\n        }\n        return true;\n    }", "writeObject": "    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.tickLabelPaint, stream);\n        SerialUtilities.writeStroke(this.axisLineStroke, stream);\n        SerialUtilities.writePaint(this.axisLinePaint, stream);\n        SerialUtilities.writeStroke(this.tickMarkStroke, stream);\n        SerialUtilities.writePaint(this.tickMarkPaint, stream);\n    }", "readObject": "    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.tickLabelPaint = SerialUtilities.readPaint(stream);\n        this.axisLineStroke = SerialUtilities.readStroke(stream);\n        this.axisLinePaint = SerialUtilities.readPaint(stream);\n        this.tickMarkStroke = SerialUtilities.readStroke(stream);\n        this.tickMarkPaint = SerialUtilities.readPaint(stream);\n        this.listenerList = new EventListenerList();\n    }"}