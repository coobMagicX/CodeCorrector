{"getFraction": "    public static Fraction getFraction(String str) {\n        if (str == null) {\n            throw new IllegalArgumentException(\"The string must not be null\");\n        }\n        // parse double format\n        int pos = str.indexOf('.');\n        if (pos >= 0) {\n            return getFraction(Double.parseDouble(str));\n        }\n\n        // parse X Y/Z format\n        pos = str.indexOf(' ');\n        if (pos > 0) {\n            int whole = Integer.parseInt(str.substring(0, pos));\n            str = str.substring(pos + 1);\n            pos = str.indexOf('/');\n            if (pos < 0) {\n                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n            } else {\n                int numer = Integer.parseInt(str.substring(0, pos));\n                int denom = Integer.parseInt(str.substring(pos + 1));\n                return getFraction(whole, numer, denom);\n            }\n        }\n\n        // parse Y/Z format\n        pos = str.indexOf('/');\n        if (pos < 0) {\n            // simple whole number\n            return getFraction(Integer.parseInt(str), 1);\n        } else {\n            int numer = Integer.parseInt(str.substring(0, pos));\n            int denom = Integer.parseInt(str.substring(pos + 1));\n            return getFraction(numer, denom);\n        }\n    }", "getReducedFraction": "    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }", "getNumerator": "    public int getNumerator() {\n        return numerator;\n    }", "getDenominator": "    public int getDenominator() {\n        return denominator;\n    }", "getProperNumerator": "    public int getProperNumerator() {\n        return Math.abs(numerator % denominator);\n    }", "getProperWhole": "    public int getProperWhole() {\n        return numerator / denominator;\n    }", "intValue": "    public int intValue() {\n        return numerator / denominator;\n    }", "longValue": "    public long longValue() {\n        return (long) numerator / denominator;\n    }", "floatValue": "    public float floatValue() {\n        return ((float) numerator) / ((float) denominator);\n    }", "doubleValue": "    public double doubleValue() {\n        return ((double) numerator) / ((double) denominator);\n    }", "reduce": "    public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }", "invert": "    public Fraction invert() {\n        if (numerator == 0) {\n            throw new ArithmeticException(\"Unable to invert zero.\");\n        }\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: can't negate numerator\");\n        }\n        if (numerator<0) {\n            return new Fraction(-denominator, -numerator);\n        } else {\n            return new Fraction(denominator, numerator);\n        }\n    }", "negate": "    public Fraction negate() {\n        // the positive range is one smaller than the negative range of an int.\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: too large to negate\");\n        }\n        return new Fraction(-numerator, denominator);\n    }", "abs": "    public Fraction abs() {\n        if (numerator >= 0) {\n            return this;\n        }\n        return negate();\n    }", "pow": "    public Fraction pow(int power) {\n        if (power == 1) {\n            return this;\n        } else if (power == 0) {\n            return ONE;\n        } else if (power < 0) {\n            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n                return this.invert().pow(2).pow(-(power/2));\n            }\n            return this.invert().pow(-power);\n        } else {\n            Fraction f = this.multiplyBy(this);\n            if ((power % 2) == 0) { // if even...\n                return f.pow(power/2);\n            } else { // if odd...\n                return f.pow(power/2).multiplyBy(this);\n            }\n        }\n    }", "greatestCommonDivisor": "    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }", "mulAndCheck": "    private static int mulAndCheck(int x, int y) {\n        long m = ((long)x)*((long)y);\n        if (m < Integer.MIN_VALUE ||\n            m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }", "mulPosAndCheck": "    private static int mulPosAndCheck(int x, int y) {\n        /* assert x>=0 && y>=0; */\n        long m = ((long)x)*((long)y);\n        if (m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mulPos\");\n        }\n        return (int)m;\n    }", "addAndCheck": "    private static int addAndCheck(int x, int y) {\n        long s = (long)x+(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }", "subAndCheck": "    private static int subAndCheck(int x, int y) {\n        long s = (long)x-(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }", "add": "    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }", "subtract": "    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }", "addSub": "    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            int uvp = mulAndCheck(numerator, fraction.denominator);\n            int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }", "multiplyBy": "    public Fraction multiplyBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don't overflow unless the result *must* overflow.\n        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n        return getReducedFraction\n            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n    }", "divideBy": "    public Fraction divideBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n        }\n        return multiplyBy(fraction.invert());\n    }", "equals": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof Fraction == false) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        return (getNumerator() == other.getNumerator() &&\n                getDenominator() == other.getDenominator());\n    }", "compareTo": "    public int compareTo(Fraction other) {\n        if (this==other) {\n            return 0;\n        }\n        if (numerator == other.numerator && denominator == other.denominator) {\n            return 0;\n        }\n\n        // otherwise see which is less\n        long first = (long) numerator * (long) other.denominator;\n        long second = (long) other.numerator * (long) denominator;\n        if (first == second) {\n            return 0;\n        } else if (first < second) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }", "toString": "    public String toString() {\n        if (toString == null) {\n            toString = new StringBuilder(32)\n                .append(getNumerator())\n                .append('/')\n                .append(getDenominator()).toString();\n        }\n        return toString;\n    }", "toProperString": "    public String toProperString() {\n        if (toProperString == null) {\n            if (numerator == 0) {\n                toProperString = \"0\";\n            } else if (numerator == denominator) {\n                toProperString = \"1\";\n            } else if (numerator == -1 * denominator) {\n                toProperString = \"-1\";\n            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n                // note that we do the magnitude comparison test above with\n                // NEGATIVE (not positive) numbers, since negative numbers\n                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n                // is handled incorrectly.\n                int properNumerator = getProperNumerator();\n                if (properNumerator == 0) {\n                    toProperString = Integer.toString(getProperWhole());\n                } else {\n                    toProperString = new StringBuilder(32)\n                        .append(getProperWhole()).append(' ')\n                        .append(properNumerator).append('/')\n                        .append(getDenominator()).toString();\n                }\n            } else {\n                toProperString = new StringBuilder(32)\n                    .append(getNumerator()).append('/')\n                    .append(getDenominator()).toString();\n            }\n        }\n        return toProperString;\n    }"}