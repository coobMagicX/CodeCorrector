{"process": "  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }", "getFilterForMode": "  private Predicate<Var> getFilterForMode() {\n    switch (mode) {\n      case ALL:\n        return Predicates.<Var>alwaysTrue();\n      case LOCALS_ONLY:\n        return new IdentifyLocals();\n      case CONSTANTS_ONLY:\n        return new IdentifyConstants();\n      default:\n        throw new IllegalStateException();\n    }\n  }", "apply": "    public boolean apply(Var var) {\n      return var.scope.isLocal();\n    }", "afterExitScope": "    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      collectAliasCandidates(t, referenceMap);\n      doInlinesForScope(t, referenceMap);\n    }", "collectAliasCandidates": "    private void collectAliasCandidates(NodeTraversal t,\n        ReferenceMap referenceMap) {\n      if (mode != Mode.CONSTANTS_ONLY) {\n        for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n          Var v = it.next();\n          ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n          // NOTE(nicksantos): Don't handle variables that are never used.\n          // The tests are much easier to write if you don't, and there's\n          // another pass that handles unused variables much more elegantly.\n          if (referenceInfo != null && referenceInfo.references.size() >= 2 &&\n              referenceInfo.isWellDefined() &&\n              referenceInfo.isAssignedOnceInLifetime()) {\n            Reference init = referenceInfo.getInitializingReference();\n            Node value = init.getAssignedValue();\n            if (value != null && value.isName()) {\n              aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n            }\n          }\n        }\n      }\n    }", "doInlinesForScope": "    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {\n\n      boolean maybeModifiedArguments =\n          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        // referenceInfo will be null if we're in constants-only mode\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n          // Never try to inline exported variables or variables that\n          // were not collected or variables that have already been inlined.\n          continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n          Reference init = referenceInfo.getInitializingReferenceForConstants();\n          Node value = init.getAssignedValue();\n          inlineDeclaredConstant(v, value, referenceInfo.references);\n          staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n          // If we're in constants-only mode, don't run more aggressive\n          // inlining heuristics. See InlineConstantsTest.\n          continue;\n        } else {\n          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);\n        }\n      }\n    }", "maybeEscapedOrModifiedArguments": "    private boolean maybeEscapedOrModifiedArguments(\n        Scope scope, ReferenceMap referenceMap) {\n      if (scope.isLocal()) {\n        Var arguments = scope.getArgumentsVar();\n        ReferenceCollection refs = referenceMap.getReferences(arguments);\n        if (refs != null && !refs.references.isEmpty()) {\n          for (Reference ref : refs.references) {\n            Node refNode = ref.getNode();\n            Node refParent = ref.getParent();\n            // Any reference that is not a read of the arguments property\n            // consider a escape of the arguments object.\n            if (!(NodeUtil.isGet(refParent)\n                && refNode == ref.getParent().getFirstChild()\n                && !isLValue(refParent))) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }", "isLValue": "    private boolean isLValue(Node n) {\n      Node parent = n.getParent();\n      return (parent.isInc()\n          || parent.isDec()\n          || (NodeUtil.isAssignmentOp(parent)\n          && parent.getFirstChild() == n));\n    }", "inlineNonConstants": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (refCount == firstRefAfterInit) {\n        // The variable likely only read once, try some more\n        // complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(\n            firstRefAfterInit - 1);\n        if (canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2) {\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference is the initialization, remove the assignment and\n          // the variable declaration.\n          Node value = init.getAssignedValue();\n          Preconditions.checkNotNull(value);\n          inlineWellDefinedVariable(v, value, referenceInfo.references);\n          staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n          // Inlining the variable based solely on well-defined and assigned\n          // once is *NOT* correct. We relax the correctness requirement if\n          // the variable is declared constant.\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias)) {\n              Reference aliasInit;\n              aliasInit = candidate.refInfo.getInitializingReference();\n              Node value = aliasInit.getAssignedValue();\n              Preconditions.checkNotNull(value);\n              inlineWellDefinedVariable(candidate.alias,\n                  value,\n                  candidate.refInfo.references);\n              staleVars.add(candidate.alias);\n            }\n          }\n        }\n      }\n    }", "blacklistVarReferencesInTree": "    private void blacklistVarReferencesInTree(Node root, Scope scope) {\n      for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {\n        blacklistVarReferencesInTree(c, scope);\n      }\n\n      if (root.isName()) {\n        staleVars.add(scope.getVar(root.getString()));\n      }\n    }", "isVarInlineForbidden": "    private boolean isVarInlineForbidden(Var var) {\n      // A variable may not be inlined if:\n      // 1) The variable is exported,\n      // 2) A reference to the variable has been inlined. We're downstream\n      //    of the mechanism that creates variable references, so we don't\n      //    have a good way to update the reference. Just punt on it.\n      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n      return var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }", "inline": "    private void inline(Var v, Reference decl, Reference init, Reference ref) {\n      Node value = init.getAssignedValue();\n      Preconditions.checkState(value != null);\n      // Check for function declarations before the value is moved in the AST.\n      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);\n      compiler.reportChangeToEnclosingScope(ref.getNode());\n      inlineValue(v, ref, value.detachFromParent());\n      if (decl != init) {\n        Node expressRoot = init.getGrandparent();\n        Preconditions.checkState(expressRoot.isExprResult());\n        NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n      }\n      // Function declarations have already been removed.\n      if (!isFunctionDeclaration) {\n        compiler.reportChangeToEnclosingScope(decl.getNode());\n        removeDeclaration(decl);\n      }\n    }", "inlineWellDefinedVariable": "    private void inlineWellDefinedVariable(Var v, Node value,\n        List<Reference> refSet) {\n      Reference decl = refSet.get(0);\n      for (int i = 1; i < refSet.size(); i++) {\n        inlineValue(v, refSet.get(i), value.cloneTree());\n      }\n      removeDeclaration(decl);\n    }", "inlineDeclaredConstant": "    private void inlineDeclaredConstant(Var v, Node value,\n        List<Reference> refSet) {\n      // Replace the references with the constant value\n      Reference decl = null;\n\n      for (Reference r : refSet) {\n        if (r.getNode() == v.getNameNode()) {\n          decl = r;\n        } else {\n          inlineValue(v, r, value.cloneTree());\n        }\n      }\n\n      removeDeclaration(decl);\n    }", "removeDeclaration": "    private void removeDeclaration(Reference decl) {\n      Node varNode = decl.getParent();\n      Node grandparent = decl.getGrandparent();\n\n      compiler.reportChangeToEnclosingScope(decl.getNode());\n      varNode.removeChild(decl.getNode());\n      // Remove var node if empty\n      if (!varNode.hasChildren()) {\n        Preconditions.checkState(varNode.isVar());\n        NodeUtil.removeChild(grandparent, varNode);\n      }\n    }", "inlineValue": "    private void inlineValue(Var v, Reference ref, Node value) {\n      compiler.reportChangeToEnclosingScope(ref.getNode());\n      if (ref.isSimpleAssignmentToName()) {\n        // This is the initial assignment.\n        ref.getGrandparent().replaceChild(ref.getParent(), value);\n      } else {\n        ref.getParent().replaceChild(ref.getNode(), value);\n      }\n      blacklistVarReferencesInTree(value, v.scope);\n    }", "isInlineableDeclaredConstant": "    private boolean isInlineableDeclaredConstant(Var var,\n        ReferenceCollection refInfo) {\n      if (!identifyConstants.apply(var)) {\n        return false;\n      }\n\n      if (!refInfo.isAssignedOnceInLifetime()) {\n        return false;\n      }\n\n      Reference init = refInfo.getInitializingReferenceForConstants();\n      if (init == null) {\n        return false;\n      }\n\n      Node value = init.getAssignedValue();\n      if (value == null) {\n        // This constant is either externally defined or initialized indirectly\n        // (e.g. in an function expression used to hide\n        // temporary variables), so the constant is ineligible for inlining.\n        return false;\n      }\n\n      // Is the constant's value immutable?\n      if (!NodeUtil.isImmutableValue(value)) {\n        return false;\n      }\n\n      // Determine if we should really inline a String or not.\n      return !value.isString() ||\n          isStringWorthInlining(var, refInfo.references);\n    }", "isStringWorthInlining": "    private boolean isStringWorthInlining(Var var, List<Reference> refs) {\n      if (!inlineAllStrings && !var.isDefine()) {\n        int len = var.getInitialValue().getString().length() + \"''\".length();\n\n        // if not inlined: var xx=\"value\"; .. xx .. xx ..\n        // The 4 bytes per reference is just a heuristic:\n        // 2 bytes per var name plus maybe 2 bytes if we don't inline, e.g.\n        // in the case of \"foo \" + CONST + \" bar\"\n        int noInlineBytes = \"var xx=;\".length() + len +\n                            4 * (refs.size() - 1);\n\n        // if inlined:\n        // I'm going to assume that half of the quotes will be eliminated\n        // thanks to constant folding, therefore I subtract 1 (2/2=1) from\n        // the string length.\n        int inlineBytes = (len - 1) * (refs.size() - 1);\n\n        // Not inlining if doing so uses more bytes, or this constant is being\n        // defined.\n        return noInlineBytes >= inlineBytes;\n      }\n\n      return true;\n    }", "canInline": "    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n\n      // If the value is read more than once, skip it.\n      // VAR declarations and EXPR_RESULT don't need the value, but other\n      // ASSIGN expressions parents do.\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n\n      // Be very conservative and do no cross control structures or\n      // scope boundaries\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n\n      // Do not inline into a call node. This would change\n      // the context in which it was being called. For example,\n      //   var a = b.c;\n      //   a();\n      // should not be inlined, because it calls a in the context of b\n      // rather than the context of the window.\n      //   var a = b.c;\n      //   f(a)\n      // is OK.\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      if (value.isGetProp()\n          && reference.getParent().isCall()\n          && reference.getParent().getFirstChild() == reference.getNode()) {\n        return false;\n      }\n\n      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (reference.getParent().isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n          // Bug 2388531: Don't inline subclass definitions into class defining\n          // calls as this confused class removing logic.\n          SubclassRelationship relationship =\n              convention.getClassesDefinedByCall(callNode);\n          if (relationship != null) {\n            return false;\n          }\n\n          // issue 668: Don't inline singleton getter methods\n          // calls as this confused class removing logic.\n          if (convention.getSingletonGetterClassName(callNode) != null) {\n            return false;\n          }\n        }\n      }\n\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }", "canMoveAggressively": "    private boolean canMoveAggressively(Node value) {\n      // Function expressions and other mutable objects can move within\n      // the same basic block.\n      return NodeUtil.isLiteralValue(value, true)\n          || value.isFunction();\n    }", "canMoveModerately": "    private boolean canMoveModerately(\n        Reference initialization,\n        Reference reference) {\n      // Check if declaration can be inlined without passing\n      // any side-effect causing nodes.\n      Iterator<Node> it;\n      if (initialization.getParent().isVar()) {\n        it = NodeIterators.LocalVarMotion.forVar(\n            initialization.getNode(),     // NAME\n            initialization.getParent(),       // VAR\n            initialization.getGrandparent()); // VAR container\n      } else if (initialization.getParent().isAssign()) {\n        Preconditions.checkState(\n            initialization.getGrandparent().isExprResult());\n        it = NodeIterators.LocalVarMotion.forAssign(\n            initialization.getNode(),     // NAME\n            initialization.getParent(),       // ASSIGN\n            initialization.getGrandparent(),  // EXPR_RESULT\n            initialization.getGrandparent().getParent()); // EXPR container\n      } else {\n        throw new IllegalStateException(\"Unexpected initialization parent \" +\n            initialization.getParent().toStringTree());\n      }\n      Node targetName = reference.getNode();\n      while (it.hasNext()) {\n        Node curNode = it.next();\n        if (curNode == targetName) {\n          return true;\n        }\n      }\n\n      return false;\n    }", "isValidDeclaration": "    private boolean isValidDeclaration(Reference declaration) {\n      return (declaration.getParent().isVar()\n          && !declaration.getGrandparent().isFor())\n          || NodeUtil.isFunctionDeclaration(declaration.getParent());\n    }", "isValidInitialization": "    private boolean isValidInitialization(Reference initialization) {\n      if (initialization == null) {\n        return false;\n      } else if (initialization.isDeclaration()) {\n        // The reference is a FUNCTION declaration or normal VAR declaration\n        // with a value.\n        if (!NodeUtil.isFunctionDeclaration(initialization.getParent())\n            && initialization.getNode().getFirstChild() == null) {\n          return false;\n        }\n      } else {\n        Node parent = initialization.getParent();\n        Preconditions.checkState(\n            parent.isAssign()\n            && parent.getFirstChild() == initialization.getNode());\n      }\n\n      Node n = initialization.getAssignedValue();\n      if (n.isFunction()) {\n        return compiler.getCodingConvention().isInlinableFunction(n);\n      }\n\n      return true;\n    }", "isValidReference": "    private boolean isValidReference(Reference reference) {\n      return !reference.isDeclaration() && !reference.isLvalue();\n    }", "isImmutableAndWellDefinedVariable": "    private boolean isImmutableAndWellDefinedVariable(Var v,\n        ReferenceCollection refInfo) {\n      List<Reference> refSet = refInfo.references;\n      int startingReadRef = 1;\n      Reference refDecl = refSet.get(0);\n      if (!isValidDeclaration(refDecl)) {\n        return false;\n      }\n\n      boolean isNeverAssigned = refInfo.isNeverAssigned();\n      // For values that are never assigned, only the references need to be\n      // checked.\n      if (!isNeverAssigned) {\n        Reference refInit = refInfo.getInitializingReference();\n        if (!isValidInitialization(refInit)) {\n          return false;\n        }\n\n        if (refDecl != refInit) {\n          Preconditions.checkState(refInit == refSet.get(1));\n          startingReadRef = 2;\n        }\n\n        if (!refInfo.isWellDefined()) {\n          return false;\n        }\n\n        Node value = refInit.getAssignedValue();\n        Preconditions.checkNotNull(value);\n\n        boolean isImmutableValueWorthInlining =\n            NodeUtil.isImmutableValue(value) &&\n            (!value.isString() ||\n                isStringWorthInlining(v, refInfo.references));\n        boolean isInlinableThisAlias =\n            value.isThis() &&\n            !refInfo.isEscaped();\n        if (!isImmutableValueWorthInlining && !isInlinableThisAlias) {\n          return false;\n        }\n      }\n\n      for (int i = startingReadRef; i < refSet.size(); i++) {\n        Reference ref = refSet.get(i);\n        if (!isValidReference(ref)) {\n          return false;\n        }\n      }\n\n      return true;\n    }"}