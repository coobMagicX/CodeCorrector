{"getLineOffset": "  public int getLineOffset(int lineno) {\n    if (lineOffsets == null) {\n      findLineOffsets();\n    }\n    if (lineno < 1 || lineno > lineOffsets.length) {\n      throw new IllegalArgumentException(\n          \"Expected line number between 1 and \" + lineOffsets.length +\n          \"\\nActual: \" + lineno);\n    }\n    return lineOffsets[lineno - 1];\n  }", "getNumLines": "  int getNumLines() {\n    if (lineOffsets == null) {\n      findLineOffsets();\n    }\n    return lineOffsets.length;\n  }", "findLineOffsets": "  private void findLineOffsets() {\n    try {\n      String[] sourceLines = getCode().split(\"\\n\");\n      lineOffsets = new int[sourceLines.length];\n      for (int ii = 1; ii < sourceLines.length; ++ii) {\n        lineOffsets[ii] =\n            lineOffsets[ii - 1] + sourceLines[ii - 1].length() + 1;\n      }\n    } catch (IOException e) {\n      lineOffsets = new int[1];\n      lineOffsets[0] = 0;\n    }\n  }", "getCode": "    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n        cachedCode = Files.toString(file, this.getCharset());\n        super.setCode(cachedCode);\n      }\n      return cachedCode;\n    }", "getCodeReader": "    public Reader getCodeReader() throws IOException {\n      if (hasSourceInMemory()) {\n        return super.getCodeReader();\n      } else {\n        // If we haven't pulled the code into memory yet, don't.\n        return new FileReader(file);\n      }\n    }", "getCodeNoCache": "  String getCodeNoCache() {\n    return code;\n  }", "setCode": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }", "getOriginalPath": "  public String getOriginalPath() {\n    return originalPath != null ? originalPath : fileName;\n  }", "setOriginalPath": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }", "clearCachedSource": "    public void clearCachedSource() {\n      super.setCode(null);\n    }", "hasSourceInMemory": "  boolean hasSourceInMemory() {\n    return code != null;\n  }", "getName": "  public String getName() {\n    return fileName;\n  }", "isExtern": "  public boolean isExtern() {\n    return isExternFile;\n  }", "setIsExtern": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }", "getLine": "  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "getRegion": "  public Region getRegion(int lineNumber) {\n    String js = \"\";\n    try {\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n    int pos = 0;\n    int startLine = Math.max(1,\n        lineNumber - (SOURCE_EXCERPT_REGION_LENGTH + 1) / 2 + 1);\n    for (int n = 1; n < startLine; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        break;\n      }\n      pos = nextpos + 1;\n    }\n    int end = pos;\n    int endLine = startLine;\n    for (int n = 0; n < SOURCE_EXCERPT_REGION_LENGTH; n++, endLine++) {\n      end = js.indexOf('\\n', end);\n      if (end == -1) {\n        break;\n      }\n      end++;\n    }\n    if (lineNumber >= endLine) {\n      return null;\n    }\n    if (end == -1) {\n      int last = js.length() - 1;\n      if (js.charAt(last) == '\\n') {\n        return\n            new SimpleRegion(startLine, endLine, js.substring(pos, last));\n      } else {\n        return new SimpleRegion(startLine, endLine, js.substring(pos));\n      }\n    } else {\n      return new SimpleRegion(startLine, endLine, js.substring(pos, end));\n    }\n  }", "toString": "  public String toString() {\n    return fileName;\n  }", "fromFile": "  public static SourceFile fromFile(File file) {\n    return new OnDisk(file);\n  }", "fromCode": "  public static SourceFile fromCode(String fileName,\n      String originalPath, String code) {\n    return new Preloaded(fileName, originalPath, code);\n  }", "fromInputStream": "  public static SourceFile fromInputStream(String fileName,\n      String originalPath, InputStream s) throws IOException {\n    return fromCode(fileName, originalPath,\n        CharStreams.toString(new InputStreamReader(s, Charsets.UTF_8)));\n  }", "fromReader": "  public static SourceFile fromReader(String fileName, Reader r)\n      throws IOException {\n    return fromCode(fileName, CharStreams.toString(r));\n  }", "fromGenerator": "  public static SourceFile fromGenerator(String fileName,\n      Generator generator) {\n    return new Generated(fileName, generator);\n  }", "setCharset": "    public void setCharset(Charset c) {\n      inputCharset = c.name();\n    }", "getCharset": "    public Charset getCharset() {\n      return Charset.forName(inputCharset);\n    }"}