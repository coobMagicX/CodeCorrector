{"process": "  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }", "apply": "    public boolean apply(Var var) {\n      return var.scope.isLocal();\n    }", "isLValue": "    private boolean isLValue(Node n) {\n      Node parent = n.getParent();\n      return (parent.isInc()\n          || parent.isDec()\n          || (NodeUtil.isAssignmentOp(parent)\n          && parent.getFirstChild() == n));\n    }", "blacklistVarReferencesInTree": "    private void blacklistVarReferencesInTree(Node root, Scope scope) {\n      for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {\n        blacklistVarReferencesInTree(c, scope);\n      }\n\n      if (root.isName()) {\n        staleVars.add(scope.getVar(root.getString()));\n      }\n    }", "inline": "    private void inline(Var v, Reference declaration,\n                        Reference init, Reference reference) {\n      Node value = init.getAssignedValue();\n      Preconditions.checkState(value != null);\n      // Check for function declarations before the value is moved in the AST.\n      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);\n\n      inlineValue(v, reference, value.detachFromParent());\n      if (declaration != init) {\n        Node expressRoot = init.getGrandparent();\n        Preconditions.checkState(expressRoot.isExprResult());\n        NodeUtil.removeChild(expressRoot.getParent(), expressRoot);\n      }\n\n      // Function declarations have already been removed.\n      if (!isFunctionDeclaration) {\n        removeDeclaration(declaration);\n      } else {\n        compiler.reportCodeChange();\n      }\n    }", "removeDeclaration": "    private void removeDeclaration(Reference declaration) {\n      Node varNode = declaration.getParent();\n      Node grandparent = declaration.getGrandparent();\n\n      varNode.removeChild(declaration.getNode());\n\n      // Remove var node if empty\n      if (!varNode.hasChildren()) {\n        Preconditions.checkState(varNode.isVar());\n        NodeUtil.removeChild(grandparent, varNode);\n      }\n\n      compiler.reportCodeChange();\n    }", "inlineValue": "    private void inlineValue(Var v, Reference ref, Node value) {\n      if (ref.isSimpleAssignmentToName()) {\n        // This is the initial assignment.\n        ref.getGrandparent().replaceChild(ref.getParent(), value);\n      } else {\n        ref.getParent().replaceChild(ref.getNode(), value);\n      }\n\n      blacklistVarReferencesInTree(value, v.scope);\n      compiler.reportCodeChange();\n    }", "canMoveAggressively": "    private boolean canMoveAggressively(Node value) {\n      // Function expressions and other mutable objects can move within\n      // the same basic block.\n      return NodeUtil.isLiteralValue(value, true)\n          || value.isFunction();\n    }", "canMoveModerately": "    private boolean canMoveModerately(\n        Reference initialization,\n        Reference reference) {\n      // Check if declaration can be inlined without passing\n      // any side-effect causing nodes.\n      Iterator<Node> it;\n      if (initialization.getParent().isVar()) {\n        it = NodeIterators.LocalVarMotion.forVar(\n            initialization.getNode(),     // NAME\n            initialization.getParent(),       // VAR\n            initialization.getGrandparent()); // VAR container\n      } else if (initialization.getParent().isAssign()) {\n        Preconditions.checkState(\n            initialization.getGrandparent().isExprResult());\n        it = NodeIterators.LocalVarMotion.forAssign(\n            initialization.getNode(),     // NAME\n            initialization.getParent(),       // ASSIGN\n            initialization.getGrandparent(),  // EXPR_RESULT\n            initialization.getGrandparent().getParent()); // EXPR container\n      } else {\n        throw new IllegalStateException(\"Unexpected initialization parent \" +\n            initialization.getParent().toStringTree());\n      }\n      Node targetName = reference.getNode();\n      while (it.hasNext()) {\n        Node curNode = it.next();\n        if (curNode == targetName) {\n          return true;\n        }\n      }\n\n      return false;\n    }", "isValidDeclaration": "    private boolean isValidDeclaration(Reference declaration) {\n      return (declaration.getParent().isVar()\n          && !declaration.getGrandparent().isFor())\n          || NodeUtil.isFunctionDeclaration(declaration.getParent());\n    }", "isValidInitialization": "    private boolean isValidInitialization(Reference initialization) {\n      if (initialization == null) {\n        return false;\n      } else if (initialization.isDeclaration()) {\n        // The reference is a FUNCTION declaration or normal VAR declaration\n        // with a value.\n        return NodeUtil.isFunctionDeclaration(initialization.getParent())\n            || initialization.getNode().getFirstChild() != null;\n      } else {\n        Node parent = initialization.getParent();\n        Preconditions.checkState(\n            parent.isAssign()\n            && parent.getFirstChild() == initialization.getNode());\n        return true;\n      }\n    }", "isValidReference": "    private boolean isValidReference(Reference reference) {\n      return !reference.isDeclaration() && !reference.isLvalue();\n    }"}