{"getExportedVariableNames": "  Set<String> getExportedVariableNames() {\n    return exportedVariables;\n  }", "process": "  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }", "visit": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n        Node left = n.getFirstChild();\n        if (left.getType() == Token.GETPROP) {\n          Node name = left.getFirstChild();\n          if (name.getType() == Token.NAME &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.getType() == Token.STRING) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, Node.newNumber(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hosited functions will explode if the're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionExpression(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.NEW:\n        trySimplifyNewDate(t, n, parent);\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().getType() == Token.NAME &&\n            parent.getType() != Token.CALL &&\n            parent.getType() != Token.ASSIGN &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }", "getEnclosingDeclNameNode": "  private Node getEnclosingDeclNameNode(NodeTraversal t) {\n    Node scopeRoot = t.getScopeRoot();\n    if (NodeUtil.isFunctionDeclaration(scopeRoot)) {\n      // function x() {...}\n      return scopeRoot.getFirstChild();\n    } else {\n      Node parent = scopeRoot.getParent();\n      if (parent != null) {\n        if (parent.getType() == Token.ASSIGN ||\n            parent.getLastChild() == scopeRoot &&\n            parent.getFirstChild().isQualifiedName()) {\n          // x.y.z = function() {...};\n          return parent.getFirstChild();\n        } else if (parent.getType() == Token.NAME) {\n          // var x = function() {...};\n          return parent;\n        }\n      }\n    }\n\n    return null;\n  }", "processSetCssNameMapping": "  private void processSetCssNameMapping(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyArgument(t, left, arg, Token.OBJECTLIT)) {\n      // Translate OBJECTLIT into SubstitutionMap. All keys and\n      // values must be strings, or an error will be thrown.\n      final Map<String, String> cssNames = Maps.newHashMap();\n      JSError error = null;\n      for (Node key = arg.getFirstChild(); key != null;\n          key = key.getNext().getNext()) {\n        Node value = key.getNext();\n        if (key.getType() != Token.STRING\n            || value == null\n            || value.getType() != Token.STRING) {\n          error = t.makeError(n,\n              NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR);\n        }\n        if (error != null) {\n          compiler.report(error);\n          break;\n        }\n        cssNames.put(key.getString(), value.getString());\n      }\n\n      // If there were no errors, create a CssRenamingMap from cssNames, update\n      // the compiler to use it and remove the call to goog.setCssNameMapping().\n      if (error == null) {\n        CssRenamingMap cssRenamingMap = new CssRenamingMap() {\n          public String get(String value) {\n            if (cssNames.containsKey(value)) {\n              return cssNames.get(value);\n            } else {\n              return value;\n            }\n          }\n        };\n        compiler.setCssRenamingMap(cssRenamingMap);\n        parent.getParent().removeChild(parent);\n        compiler.reportCodeChange();\n      }\n    }\n  }", "updateMinimumModule": "    private void updateMinimumModule(JSModule newModule) {\n      if (minimumModule == null) {\n        minimumModule = newModule;\n      } else if (moduleGraph != null) {\n        minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n            minimumModule, newModule);\n      } else {\n        // If there is no module graph, then there must be exactly one\n        // module in the program.\n        Preconditions.checkState(newModule == minimumModule,\n                                 \"Missing module graph\");\n      }\n    }", "replace": "    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }", "createDeclarationNode": "    private Node createDeclarationNode() {\n      if (namespace.indexOf('.') == -1) {\n        return makeVarDeclNode(namespace, firstNode);\n      } else {\n        return makeAssignmentExprNode(namespace, firstNode);\n      }\n    }", "makeVarDeclNode": "    private Node makeVarDeclNode(String namespace, Node sourceNode) {\n      Node name = Node.newString(Token.NAME, namespace);\n      name.addChildToFront(createNamespaceLiteral());\n\n      Node decl = new Node(Token.VAR, name);\n      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n\n      // TODO(nicksantos): ew ew ew. Create a mutator package.\n      if (compiler.getCodingConvention().isConstant(namespace)) {\n        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n\n      Preconditions.checkState(isNamespacePlaceholder(decl));\n      decl.copyInformationFromForTree(sourceNode);\n      return decl;\n    }", "createNamespaceLiteral": "    private Node createNamespaceLiteral() {\n      Node objlit = new Node(Token.OBJECTLIT);\n      objlit.setJSType(\n          compiler.getTypeRegistry().createAnonymousObjectType());\n      return objlit;\n    }", "makeAssignmentExprNode": "    private Node makeAssignmentExprNode(String namespace, Node node) {\n      Node decl = new Node(Token.EXPR_RESULT,\n          new Node(Token.ASSIGN,\n              NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n              createNamespaceLiteral()));\n      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n      Preconditions.checkState(isNamespacePlaceholder(decl));\n      decl.copyInformationFromForTree(node);\n      return decl;\n    }", "isNamespacePlaceholder": "  private static boolean isNamespacePlaceholder(Node n) {\n    if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n      return false;\n    }\n\n    Node value = null;\n    if (n.getType() == Token.EXPR_RESULT) {\n      Node assign = n.getFirstChild();\n      value = assign.getLastChild();\n    } else if (n.getType() == Token.VAR) {\n      Node name = n.getFirstChild();\n      value = name.getFirstChild();\n    }\n\n    return value != null\n      && value.getType() == Token.OBJECTLIT\n      && !value.hasChildren();\n  }"}