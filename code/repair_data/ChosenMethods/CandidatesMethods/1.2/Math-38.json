{"doOptimize": "    protected RealPointValuePair doOptimize() {\n        final double[] lowerBound = getLowerBound();\n        final double[] upperBound = getUpperBound();\n\n        // Validity checks.\n        setup(lowerBound, upperBound);\n\n        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n        currentBest = new ArrayRealVector(getStartPoint());\n\n        final double value = bobyqa(lowerBound, upperBound);\n\n        return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);\n    }", "bobyqa": "    private double bobyqa(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n\n        // Return if there is insufficient space between the bounds. Modify the\n        // initial X if necessary in order to avoid conflicts between the bounds\n        // and the construction of the first quadratic model. The lower and upper\n        // bounds on moves from the updated X are set now, in the ISL and ISU\n        // partitions of W, in order to provide useful and exact information about\n        // components of X that become within distance RHOBEG from their bounds.\n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    // Computing MAX\n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    // Computing MIN\n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n        // Make the call of BOBYQB.\n\n        return bobyqb(lowerBound, upperBound);\n    } // bobyqa", "bobyqb": "    private double bobyqb(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int np = n + 1;\n        final int nptm = npt - np;\n        final int nh = n * np / 2;\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(npt);\n        final ArrayRealVector work3 = new ArrayRealVector(npt);\n\n        double cauchy = Double.NaN;\n        double alpha = Double.NaN;\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        // Set some constants.\n        // Parameter adjustments\n\n        // Function Body\n\n        // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n        // BMAT and ZMAT for the first iteration, with the corresponding values of\n        // of NF and KOPT, which are the number of calls of CALFUN so far and the\n        // index of the interpolation point at the trust region centre. Then the\n        // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n        // less than NPT. GOPT will be updated if KOPT is different from KBASE.\n\n        trustRegionCenterInterpolationPointIndex = 0;\n\n        prelim(lowerBound, upperBound);\n        double xoptsq = ZERO;\n        for (int i = 0; i < n; i++) {\n            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n            // Computing 2nd power\n            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n            xoptsq += deltaOne * deltaOne;\n        }\n        double fsave = fAtInterpolationPoints.getEntry(0);\n        final int kbase = 0;\n\n        // Complete the settings that are required for the iterative procedure.\n\n        int ntrits = 0;\n        int itest = 0;\n        int knew = 0;\n        int nfsav = getEvaluations();\n        double rho = initialTrustRegionRadius;\n        double delta = rho;\n        double diffa = ZERO;\n        double diffb = ZERO;\n        double diffc = ZERO;\n        double f = ZERO;\n        double beta = ZERO;\n        double adelt = ZERO;\n        double denom = ZERO;\n        double ratio = ZERO;\n        double dnorm = ZERO;\n        double scaden = ZERO;\n        double biglsq = ZERO;\n        double distsq = ZERO;\n\n        // Update GOPT if necessary before the first iteration and after each\n        // call of RESCUE that makes a call of CALFUN.\n\n        int state = 20;\n        for(;;) switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}\n    } // bobyqb", "altmov": "    private double[] altmov(\n            int knew,\n            double adelt\n    ) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        final ArrayRealVector glag = new ArrayRealVector(n);\n        final ArrayRealVector hcol = new ArrayRealVector(npt);\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(n);\n\n        for (int k = 0; k < npt; k++) {\n            hcol.setEntry(k, ZERO);\n        }\n        for (int j = 0, max = npt - n - 1; j < max; j++) {\n            final double tmp = zMatrix.getEntry(knew, j);\n            for (int k = 0; k < npt; k++) {\n                hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));\n            }\n        }\n        final double alpha = hcol.getEntry(knew);\n        final double ha = HALF * alpha;\n\n        // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n\n        for (int i = 0; i < n; i++) {\n            glag.setEntry(i, bMatrix.getEntry(knew, i));\n        }\n        for (int k = 0; k < npt; k++) {\n            double tmp = ZERO;\n            for (int j = 0; j < n; j++) {\n                tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n            }\n            tmp *= hcol.getEntry(k);\n            for (int i = 0; i < n; i++) {\n                glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));\n            }\n        }\n\n        // Search for a large denominator along the straight lines through XOPT\n        // and another interpolation point. SLBD and SUBD will be lower and upper\n        // bounds on the step along each of these lines in turn. PREDSQ will be\n        // set to the square of the predicted denominator for each line. PRESAV\n        // will be set to the largest admissible value of PREDSQ that occurs.\n\n        double presav = ZERO;\n        double step = Double.NaN;\n        int ksav = 0;\n        int ibdsav = 0;\n        double stpsav = 0;\n        for (int k = 0; k < npt; k++) {\n            if (k == trustRegionCenterInterpolationPointIndex) {\n                continue;\n            }\n            double dderiv = ZERO;\n            double distsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                dderiv += glag.getEntry(i) * tmp;\n                distsq += tmp * tmp;\n            }\n            double subd = adelt / Math.sqrt(distsq);\n            double slbd = -subd;\n            int ilbd = 0;\n            int iubd = 0;\n            final double sumin = Math.min(ONE, subd);\n\n            // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n\n            for (int i = 0; i < n; i++) {\n                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);\n                if (tmp > ZERO) {\n                    if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = -i - 1;\n                    }\n                    if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        // Computing MAX\n                        subd = Math.max(sumin,\n                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = i + 1;\n                    }\n                } else if (tmp < ZERO) {\n                    if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;\n                        ilbd = i + 1;\n                    }\n                    if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {\n                        // Computing MAX\n                        subd = Math.max(sumin,\n                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);\n                        iubd = -i - 1;\n                    }\n                }\n            }\n\n            // Seek a large modulus of the KNEW-th Lagrange function when the index\n            // of the other interpolation point on the line through XOPT is KNEW.\n\n            step = slbd;\n            int isbd = ilbd;\n            double vlag = Double.NaN;\n            if (k == knew) {\n                final double diff = dderiv - ONE;\n                vlag = slbd * (dderiv - slbd * diff);\n                final double d1 = subd * (dderiv - subd * diff);\n                if (Math.abs(d1) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = d1;\n                    isbd = iubd;\n                }\n                final double d2 = HALF * dderiv;\n                final double d3 = d2 - diff * slbd;\n                final double d4 = d2 - diff * subd;\n                if (d3 * d4 < ZERO) {\n                    final double d5 = d2 * d2 / diff;\n                    if (Math.abs(d5) > Math.abs(vlag)) {\n                        step = d2 / diff;\n                        vlag = d5;\n                        isbd = 0;\n                    }\n                }\n\n                // Search along each of the other lines through XOPT and another point.\n\n            } else {\n                vlag = slbd * (ONE - slbd);\n                final double tmp = subd * (ONE - subd);\n                if (Math.abs(tmp) > Math.abs(vlag)) {\n                    step = subd;\n                    vlag = tmp;\n                    isbd = iubd;\n                }\n                if (subd > HALF) {\n                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n                        step = HALF;\n                        vlag = ONE_OVER_FOUR;\n                        isbd = 0;\n                    }\n                }\n                vlag *= dderiv;\n            }\n\n            // Calculate PREDSQ for the current line search and maintain PRESAV.\n\n            final double tmp = step * (ONE - step) * distsq;\n            final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);\n            if (predsq > presav) {\n                presav = predsq;\n                ksav = k;\n                stpsav = step;\n                ibdsav = isbd;\n            }\n        }\n\n        // Construct XNEW in a way that satisfies the bound constraints exactly.\n\n        for (int i = 0; i < n; i++) {\n            final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));\n            newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                      Math.min(upperDifference.getEntry(i), tmp)));\n        }\n        if (ibdsav < 0) {\n            newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));\n        }\n        if (ibdsav > 0) {\n            newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));\n        }\n\n        // Prepare for the iterative method that assembles the constrained Cauchy\n        // step in W. The sum of squares of the fixed components of W is formed in\n        // WFIXSQ, and the free components of W are set to BIGSTP.\n\n        final double bigstp = adelt + adelt;\n        int iflag = 0;\n        double cauchy = Double.NaN;\n        double csave = ZERO;\n        while (true) {\n            double wfixsq = ZERO;\n            double ggfree = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                work1.setEntry(i, ZERO);\n                if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO ||\n                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO) {\n                    work1.setEntry(i, bigstp);\n                    // Computing 2nd power\n                    ggfree += glagValue * glagValue;\n                }\n            }\n            if (ggfree == ZERO) {\n                return new double[] { alpha, ZERO };\n            }\n\n            // Investigate whether more components of W can be fixed.\n            final double tmp1 = adelt * adelt - wfixsq;\n            if (tmp1 > ZERO) {\n                step = Math.sqrt(tmp1 / ggfree);\n                ggfree = ZERO;\n                for (int i = 0; i < n; i++) {\n                    if (work1.getEntry(i) == bigstp) {\n                        final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);\n                        if (tmp2 <= lowerDifference.getEntry(i)) {\n                            work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            // Computing 2nd power\n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else if (tmp2 >= upperDifference.getEntry(i)) {\n                            work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                            // Computing 2nd power\n                            final double d1 = work1.getEntry(i);\n                            wfixsq += d1 * d1;\n                        } else {\n                            // Computing 2nd power\n                            final double d1 = glag.getEntry(i);\n                            ggfree += d1 * d1;\n                        }\n                    }\n                }\n            }\n\n            // Set the remaining free components of W and all components of XALT,\n            // except that W may be scaled later.\n\n            double gw = ZERO;\n            for (int i = 0; i < n; i++) {\n                final double glagValue = glag.getEntry(i);\n                if (work1.getEntry(i) == bigstp) {\n                    work1.setEntry(i, -step * glagValue);\n                    final double min = Math.min(upperDifference.getEntry(i),\n                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));\n                } else if (work1.getEntry(i) == ZERO) {\n                    alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));\n                } else if (glagValue > ZERO) {\n                    alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));\n                } else {\n                    alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                gw += glagValue * work1.getEntry(i);\n            }\n\n            // Set CURV to the curvature of the KNEW-th Lagrange function along W.\n            // Scale W by a factor less than one if that can reduce the modulus of\n            // the Lagrange function at XOPT+W. Set CAUCHY to the final value of\n            // the square of this function.\n\n            double curv = ZERO;\n            for (int k = 0; k < npt; k++) {\n                double tmp = ZERO;\n                for (int j = 0; j < n; j++) {\n                    tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);\n                }\n                curv += hcol.getEntry(k) * tmp * tmp;\n            }\n            if (iflag == 1) {\n                curv = -curv;\n            }\n            if (curv > -gw &&\n                curv < -gw * (ONE + Math.sqrt(TWO))) {\n                final double scale = -gw / curv;\n                for (int i = 0; i < n; i++) {\n                    final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);\n                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),\n                                              Math.min(upperDifference.getEntry(i), tmp)));\n                }\n                // Computing 2nd power\n                final double d1 = HALF * gw * scale;\n                cauchy = d1 * d1;\n            } else {\n                // Computing 2nd power\n                final double d1 = gw + HALF * curv;\n                cauchy = d1 * d1;\n            }\n\n            // If IFLAG is zero, then XALT is calculated as before after reversing\n            // the sign of GLAG. Thus two XALT vectors become available. The one that\n            // is chosen is the one that gives the larger value of CAUCHY.\n\n            if (iflag == 0) {\n                for (int i = 0; i < n; i++) {\n                    glag.setEntry(i, -glag.getEntry(i));\n                    work2.setEntry(i, alternativeNewPoint.getEntry(i));\n                }\n                csave = cauchy;\n                iflag = 1;\n            } else {\n                break;\n            }\n        }\n        if (csave > cauchy) {\n            for (int i = 0; i < n; i++) {\n                alternativeNewPoint.setEntry(i, work2.getEntry(i));\n            }\n            cauchy = csave;\n        }\n\n        return new double[] { alpha, cauchy };\n    } // altmov", "prelim": "    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n                    throw new PathIsExploredException(); // XXX\n                }\n                final int iptMinus1 = ipt;\n                final int jptMinus1 = jpt;\n                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n            }\n\n            // Calculate the next value of F. The least function value so far and\n            // its index are required.\n\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n                                                 upperBound[j]));\n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                }\n                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n            final double f = isMinimize ? objectiveValue : -objectiveValue;\n            final int numEval = getEvaluations(); // nfm + 1\n            fAtInterpolationPoints.setEntry(nfm, f);\n\n            if (numEval == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n\n            // Set the nonzero initial elements of BMAT and the quadratic model in the\n            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n            // order that the function value at the first of them contributes to the\n            // off-diagonal second derivative terms of the initial quadratic model.\n\n            if (numEval <= 2 * n + 1) {\n                if (numEval >= 2 &&\n                    numEval <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    if (npt < numEval + n) {\n                        final double oneOverStepA = ONE / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                        throw new PathIsExploredException(); // XXX\n                    }\n                } else if (numEval >= n + 2) {\n                    final int ih = nfx * (nfx + 1) / 2 - 1;\n                    final double tmp = (f - fbeg) / stepb;\n                    final double diff = stepb - stepa;\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n                            fAtInterpolationPoints.setEntry(nfm - n, f);\n                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n                                trustRegionCenterInterpolationPointIndex = nfm - n;\n                            }\n                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n                        }\n                    }\n                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                    bMatrix.setEntry(nfm - n, nfxm,\n                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    zMatrix.setEntry(nfm - n, nfxm,\n                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n                }\n\n                // Set the off-diagonal second derivatives of the Lagrange functions and\n                // the initial quadratic model.\n\n            } else {\n                zMatrix.setEntry(0, nfxm, recip);\n                zMatrix.setEntry(nfm, nfxm, recip);\n                zMatrix.setEntry(ipt, nfxm, -recip);\n                zMatrix.setEntry(jpt, nfxm, -recip);\n\n                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n                throw new PathIsExploredException(); // XXX\n            }\n        } while (getEvaluations() < npt);\n    } // prelim", "trsbox": "    private double[] trsbox(\n            double delta,\n            ArrayRealVector gnew,\n            ArrayRealVector xbdi,\n            ArrayRealVector s,\n            ArrayRealVector hs,\n            ArrayRealVector hred\n    ) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        // Local variables\n        double ds;\n        int iu;\n        double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;\n        int iact = -1;\n        int nact = 0;\n        double angt = 0, qred;\n        int isav;\n        double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n        int iterc;\n        double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;\n        int itcsav = 0;\n        double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;\n        int itermax = 0;\n\n        // Set some constants.\n\n        // Function Body\n\n        // The sign of GOPT(I) gives the sign of the change to the I-th variable\n        // that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether\n        // or not to fix the I-th variable at one of its bounds initially, with\n        // NACT being set to the number of fixed variables. D and GNEW are also\n        // set for the first iteration. DELSQ is the upper bound on the sum of\n        // squares of the free variables. QRED is the reduction in Q so far.\n\n        iterc = 0;\n        nact = 0;\n        for (int i = 0; i < n; i++) {\n            xbdi.setEntry(i, ZERO);\n            if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i)) {\n                if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) {\n                    xbdi.setEntry(i, MINUS_ONE);\n                }\n            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i)) {\n                if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n                    xbdi.setEntry(i, ONE);\n                }\n            }\n            if (xbdi.getEntry(i) != ZERO) {\n                ++nact;\n            }\n            trialStepPoint.setEntry(i, ZERO);\n            gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));\n        }\n        delsq = delta * delta;\n        qred = ZERO;\n        crvmin = MINUS_ONE;\n\n        // Set the next search direction of the conjugate gradient method. It is\n        // the steepest descent direction initially and when the iterations are\n        // restarted because a variable has just been fixed by a bound, and of\n        // course the components of the fixed variables are zero. ITERMAX is an\n        // upper bound on the indices of the conjugate gradient iterations.\n\n        int state = 20;\n        for(;;) {\n            switch (state) {\n        case 20: {\n            printState(20); // XXX\n            beta = ZERO;\n        }\n        case 30: {\n            printState(30); // XXX\n            stepsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) != ZERO) {\n                    s.setEntry(i, ZERO);\n                } else if (beta == ZERO) {\n                    s.setEntry(i, -gnew.getEntry(i));\n                } else {\n                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));\n                }\n                // Computing 2nd power\n                final double d1 = s.getEntry(i);\n                stepsq += d1 * d1;\n            }\n            if (stepsq == ZERO) {\n                state = 190; break;\n            }\n            if (beta == ZERO) {\n                gredsq = stepsq;\n                itermax = iterc + n - nact;\n            }\n            if (gredsq * delsq <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n\n            // Multiply the search direction by the second derivative matrix of Q and\n            // calculate some scalars for the choice of steplength. Then set BLEN to\n            // the length of the the step to the trust region boundary and STPLEN to\n            // the steplength, ignoring the simple bounds.\n\n            state = 210; break;\n        }\n        case 50: {\n            printState(50); // XXX\n            resid = delsq;\n            ds = ZERO;\n            shs = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    final double d1 = trialStepPoint.getEntry(i);\n                    resid -= d1 * d1;\n                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                }\n            }\n            if (resid <= ZERO) {\n                state = 90; break;\n            }\n            temp = Math.sqrt(stepsq * resid + ds * ds);\n            if (ds < ZERO) {\n                blen = (temp - ds) / stepsq;\n            } else {\n                blen = resid / (temp + ds);\n            }\n            stplen = blen;\n            if (shs > ZERO) {\n                // Computing MIN\n                stplen = Math.min(blen, gredsq / shs);\n            }\n\n            // Reduce STPLEN if necessary in order to preserve the simple bounds,\n            // letting IACT be the index of the new constrained variable.\n\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (s.getEntry(i) != ZERO) {\n                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);\n                    if (s.getEntry(i) > ZERO) {\n                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    } else {\n                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);\n                    }\n                    if (temp < stplen) {\n                        stplen = temp;\n                        iact = i;\n                    }\n                }\n            }\n\n            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n\n            sdec = ZERO;\n            if (stplen > ZERO) {\n                ++iterc;\n                temp = shs / stepsq;\n                if (iact == -1 && temp > ZERO) {\n                    crvmin = Math.min(crvmin,temp);\n                    if (crvmin == MINUS_ONE) {\n                        crvmin = temp;\n                    }\n                }\n                ggsav = gredsq;\n                gredsq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));\n                    if (xbdi.getEntry(i) == ZERO) {\n                        // Computing 2nd power\n                        final double d1 = gnew.getEntry(i);\n                        gredsq += d1 * d1;\n                    }\n                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));\n                }\n                // Computing MAX\n                final double d1 = stplen * (ggsav - HALF * stplen * shs);\n                sdec = Math.max(d1, ZERO);\n                qred += sdec;\n            }\n\n            // Restart the conjugate gradient method if it has hit a new bound.\n\n            if (iact >= 0) {\n                ++nact;\n                xbdi.setEntry(iact, ONE);\n                if (s.getEntry(iact) < ZERO) {\n                    xbdi.setEntry(iact, MINUS_ONE);\n                }\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(iact);\n                delsq -= d1 * d1;\n                if (delsq <= ZERO) {\n                    state = 190; break;\n                }\n                state = 20; break;\n            }\n\n            // If STPLEN is less than BLEN, then either apply another conjugate\n            // gradient iteration or RETURN.\n\n            if (stplen < blen) {\n                if (iterc == itermax) {\n                    state = 190; break;\n                }\n                if (sdec <= qred * .01) {\n                    state = 190; break;\n                }\n                beta = gredsq / ggsav;\n                state = 30; break;\n            }\n        }\n        case 90: {\n            printState(90); // XXX\n            crvmin = ZERO;\n\n            // Prepare for the alternative iteration by calculating some scalars\n            // and by multiplying the reduced D by the second derivative matrix of\n            // Q, where S holds the reduced D in the call of GGMULT.\n\n        }\n        case 100: {\n            printState(100); // XXX\n            if (nact >= n - 1) {\n                state = 190; break;\n            }\n            dredsq = ZERO;\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    dredsq += d1 * d1;\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                    s.setEntry(i, trialStepPoint.getEntry(i));\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            itcsav = iterc;\n            state = 210; break;\n            // Let the search direction S be a linear combination of the reduced D\n            // and the reduced G that is orthogonal to the reduced D.\n        }\n        case 120: {\n            printState(120); // XXX\n            ++iterc;\n            temp = gredsq * dredsq - dredg * dredg;\n            if (temp <= qred * 1e-4 * qred) {\n                state = 190; break;\n            }\n            temp = Math.sqrt(temp);\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);\n                } else {\n                    s.setEntry(i, ZERO);\n                }\n            }\n            sredg = -temp;\n\n            // By considering the simple bounds on the variables, calculate an upper\n            // bound on the tangent of half the angle of the alternative iteration,\n            // namely ANGBD, except that, if already a free variable has reached a\n            // bound, there is a branch back to label 100 after fixing that variable.\n\n            angbd = ONE;\n            iact = -1;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);\n                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);\n                    if (tempa <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, MINUS_ONE);\n                        state = 100; break;\n                    } else if (tempb <= ZERO) {\n                        ++nact;\n                        xbdi.setEntry(i, ONE);\n                        state = 100; break;\n                    }\n                    // Computing 2nd power\n                    double d1 = trialStepPoint.getEntry(i);\n                    // Computing 2nd power\n                    double d2 = s.getEntry(i);\n                    ssq = d1 * d1 + d2 * d2;\n                    // Computing 2nd power\n                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) - s.getEntry(i);\n                        if (angbd * temp > tempa) {\n                            angbd = tempa / temp;\n                            iact = i;\n                            xsav = MINUS_ONE;\n                        }\n                    }\n                    // Computing 2nd power\n                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);\n                    temp = ssq - d1 * d1;\n                    if (temp > ZERO) {\n                        temp = Math.sqrt(temp) + s.getEntry(i);\n                        if (angbd * temp > tempb) {\n                            angbd = tempb / temp;\n                            iact = i;\n                            xsav = ONE;\n                        }\n                    }\n                }\n            }\n\n            // Calculate HHD and some curvatures for the alternative iteration.\n\n            state = 210; break;\n        }\n        case 150: {\n            printState(150); // XXX\n            shs = ZERO;\n            dhs = ZERO;\n            dhd = ZERO;\n            for (int i = 0; i < n; i++) {\n                if (xbdi.getEntry(i) == ZERO) {\n                    shs += s.getEntry(i) * hs.getEntry(i);\n                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);\n                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);\n                }\n            }\n\n            // Seek the greatest reduction in Q for a range of equally spaced values\n            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n            // the alternative iteration.\n\n            redmax = ZERO;\n            isav = -1;\n            redsav = ZERO;\n            iu = (int) (angbd * 17. + 3.1);\n            for (int i = 0; i < iu; i++) {\n                angt = angbd * i / iu;\n                sth = (angt + angt) / (ONE + angt * angt);\n                temp = shs + angt * (angt * dhd - dhs - dhs);\n                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);\n                if (rednew > redmax) {\n                    redmax = rednew;\n                    isav = i;\n                    rdprev = redsav;\n                } else if (i == isav + 1) {\n                    rdnext = rednew;\n                }\n                redsav = rednew;\n            }\n\n            // Return if the reduction is zero. Otherwise, set the sine and cosine\n            // of the angle of the alternative iteration, and calculate SDEC.\n\n            if (isav < 0) {\n                state = 190; break;\n            }\n            if (isav < iu) {\n                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n                angt = angbd * (isav + HALF * temp) / iu;\n            }\n            cth = (ONE - angt * angt) / (ONE + angt * angt);\n            sth = (angt + angt) / (ONE + angt * angt);\n            temp = shs + angt * (angt * dhd - dhs - dhs);\n            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);\n            if (sdec <= ZERO) {\n                state = 190; break;\n            }\n\n            // Update GNEW, D and HRED. If the angle of the alternative iteration\n            // is restricted by a bound on a free variable, that variable is fixed\n            // at the bound.\n\n            dredg = ZERO;\n            gredsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));\n                if (xbdi.getEntry(i) == ZERO) {\n                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));\n                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);\n                    // Computing 2nd power\n                    final double d1 = gnew.getEntry(i);\n                    gredsq += d1 * d1;\n                }\n                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));\n            }\n            qred += sdec;\n            if (iact >= 0 && isav == iu) {\n                ++nact;\n                xbdi.setEntry(iact, xsav);\n                state = 100; break;\n            }\n\n            // If SDEC is sufficiently small, then RETURN after setting XNEW to\n            // XOPT+D, giving careful attention to the bounds.\n\n            if (sdec > qred * .01) {\n                state = 120; break;\n            }\n        }\n        case 190: {\n            printState(190); // XXX\n            dsq = ZERO;\n            for (int i = 0; i < n; i++) {\n                // Computing MAX\n                // Computing MIN\n                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),\n                                            upperDifference.getEntry(i));\n                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));\n                if (xbdi.getEntry(i) == MINUS_ONE) {\n                    newPoint.setEntry(i, lowerDifference.getEntry(i));\n                }\n                if (xbdi.getEntry(i) == ONE) {\n                    newPoint.setEntry(i, upperDifference.getEntry(i));\n                }\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(i);\n                dsq += d1 * d1;\n            }\n            return new double[] { dsq, crvmin };\n            // The following instructions multiply the current S-vector by the second\n            // derivative matrix of the quadratic model, putting the product in HS.\n            // They are reached from three different parts of the software above and\n            // they can be regarded as an external subroutine.\n        }\n        case 210: {\n            printState(210); // XXX\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                hs.setEntry(j, ZERO);\n                for (int i = 0; i <= j; i++) {\n                    if (i < j) {\n                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));\n                    }\n                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));\n                    ih++;\n                }\n            }\n            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);\n            for (int k = 0; k < npt; k++) {\n                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n            if (crvmin != ZERO) {\n                state = 50; break;\n            }\n            if (iterc > itcsav) {\n                state = 150; break;\n            }\n            for (int i = 0; i < n; i++) {\n                hred.setEntry(i, hs.getEntry(i));\n            }\n            state = 120; break;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"trsbox\");\n        }}\n        }\n    } // trsbox", "update": "    private void update(\n            double beta,\n            double denom,\n            int knew\n    ) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int nptm = npt - n - 1;\n\n        // XXX Should probably be split into two arrays.\n        final ArrayRealVector work = new ArrayRealVector(npt + n);\n\n        double ztest = ZERO;\n        for (int k = 0; k < npt; k++) {\n            for (int j = 0; j < nptm; j++) {\n                // Computing MAX\n                ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));\n            }\n        }\n        ztest *= 1e-20;\n\n        // Apply the rotations that put zeros in the KNEW-th row of ZMAT.\n\n        for (int j = 1; j < nptm; j++) {\n            final double d1 = zMatrix.getEntry(knew, j);\n            if (Math.abs(d1) > ztest) {\n                // Computing 2nd power\n                final double d2 = zMatrix.getEntry(knew, 0);\n                // Computing 2nd power\n                final double d3 = zMatrix.getEntry(knew, j);\n                final double d4 = Math.sqrt(d2 * d2 + d3 * d3);\n                final double d5 = zMatrix.getEntry(knew, 0) / d4;\n                final double d6 = zMatrix.getEntry(knew, j) / d4;\n                for (int i = 0; i < npt; i++) {\n                    final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);\n                    zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));\n                    zMatrix.setEntry(i, 0, d7);\n                }\n            }\n            zMatrix.setEntry(knew, j, ZERO);\n        }\n\n        // Put the first NPT components of the KNEW-th column of HLAG into W,\n        // and calculate the parameters of the updating formula.\n\n        for (int i = 0; i < npt; i++) {\n            work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));\n        }\n        final double alpha = work.getEntry(knew);\n        final double tau = lagrangeValuesAtNewPoint.getEntry(knew);\n        lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);\n\n        // Complete the updating of ZMAT.\n\n        final double sqrtDenom = Math.sqrt(denom);\n        final double d1 = tau / sqrtDenom;\n        final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;\n        for (int i = 0; i < npt; i++) {\n            zMatrix.setEntry(i, 0,\n                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));\n        }\n\n        // Finally, update the matrix BMAT.\n\n        for (int j = 0; j < n; j++) {\n            final int jp = npt + j;\n            work.setEntry(jp, bMatrix.getEntry(knew, j));\n            final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;\n            final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;\n            for (int i = 0; i <= jp; i++) {\n                bMatrix.setEntry(i, j,\n                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));\n                if (i >= npt) {\n                    bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));\n                }\n            }\n        }\n    } // update", "setup": "    private void setup(double[] lowerBound,\n                       double[] upperBound) {\n        printMethod(); // XXX\n\n        double[] init = getStartPoint();\n        final int dimension = init.length;\n\n        // Check problem dimension.\n        if (dimension < MINIMUM_PROBLEM_DIMENSION) {\n            throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);\n        }\n        // Check number of interpolation points.\n        final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\n        if (numberOfInterpolationPoints < nPointsInterval[0] ||\n            numberOfInterpolationPoints > nPointsInterval[1]) {\n            throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n                                          numberOfInterpolationPoints,\n                                          nPointsInterval[0],\n                                          nPointsInterval[1]);\n        }\n\n        // Initialize bound differences.\n        boundDifference = new double[dimension];\n\n        double requiredMinDiff = 2 * initialTrustRegionRadius;\n        double minDiff = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < dimension; i++) {\n            boundDifference[i] = upperBound[i] - lowerBound[i];\n            minDiff = Math.min(minDiff, boundDifference[i]);\n        }\n        if (minDiff < requiredMinDiff) {\n            initialTrustRegionRadius = minDiff / 3.0;\n        }\n\n        // Initialize the data structures used by the \"bobyqa\" method.\n        bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n                                           dimension);\n        zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                           numberOfInterpolationPoints - dimension - 1);\n        interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                                       dimension);\n        originShift = new ArrayRealVector(dimension);\n        fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\n        trustRegionCenterOffset = new ArrayRealVector(dimension);\n        gradientAtTrustRegionCenter = new ArrayRealVector(dimension);\n        lowerDifference = new ArrayRealVector(dimension);\n        upperDifference = new ArrayRealVector(dimension);\n        modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\n        newPoint = new ArrayRealVector(dimension);\n        alternativeNewPoint = new ArrayRealVector(dimension);\n        trialStepPoint = new ArrayRealVector(dimension);\n        lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\n        modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n    }", "fillNewArray": "    private static double[] fillNewArray(int n,\n                                         double value) {\n        double[] ds = new double[n];\n        Arrays.fill(ds, value);\n        return ds;\n    }", "caller": "    private static String caller(int n) {\n        final Throwable t = new Throwable();\n        final StackTraceElement[] elements = t.getStackTrace();\n        final StackTraceElement e = elements[n];\n        return e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";\n    }", "printState": "    private static void printState(int s) {\n        //        System.out.println(caller(2) + \": state \" + s);\n    }", "printMethod": "    private static void printMethod() {\n        //        System.out.println(caller(2));\n    }"}