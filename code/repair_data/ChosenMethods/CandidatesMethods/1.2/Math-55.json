{"getX": "  public double getX() {\n    return x;\n  }", "getY": "  public double getY() {\n    return y;\n  }", "getZ": "  public double getZ() {\n    return z;\n  }", "add": "  public Vector3D add(double factor, Vector3D v) {\n    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n  }", "subtract": "  public Vector3D subtract(double factor, Vector3D v) {\n    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n  }", "normalize": "  public Vector3D normalize() {\n    double s = getNorm();\n    if (s == 0) {\n      throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return scalarMultiply(1 / s);\n  }", "orthogonal": "  public Vector3D orthogonal() {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if ((x >= -threshold) && (x <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n      return new Vector3D(0, inverse * z, -inverse * y);\n    } else if ((y >= -threshold) && (y <= threshold)) {\n      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n      return new Vector3D(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new Vector3D(inverse * y, -inverse * x, 0);\n\n  }", "angle": "  public static double angle(Vector3D v1, Vector3D v2) {\n\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    double dot = dotProduct(v1, v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n      // the vectors are almost aligned, compute using the sine\n      Vector3D v3 = crossProduct(v1, v2);\n      if (dot >= 0) {\n        return FastMath.asin(v3.getNorm() / normProduct);\n      }\n      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n\n  }", "negate": "  public Vector3D negate() {\n    return new Vector3D(-x, -y, -z);\n  }", "scalarMultiply": "  public Vector3D scalarMultiply(double a) {\n    return new Vector3D(a * x, a * y, a * z);\n  }", "equals": "  public boolean equals(Object other) {\n\n    if (this == other) {\n      return true;\n    }\n\n    if (other instanceof Vector3D) {\n      final Vector3D rhs = (Vector3D)other;\n      if (rhs.isNaN()) {\n          return this.isNaN();\n      }\n\n      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n    }\n    return false;\n  }", "crossProduct": "  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n\n      // we reduce cancellation errors by preconditioning,\n      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n      // v3 without loss of precision. See Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n\n\n      // compute cross product from v3 and v2 instead of v1 and v2\n      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n\n  }", "distance1": "  public static double distance1(Vector3D v1, Vector3D v2) {\n    final double dx = FastMath.abs(v2.x - v1.x);\n    final double dy = FastMath.abs(v2.y - v1.y);\n    final double dz = FastMath.abs(v2.z - v1.z);\n    return dx + dy + dz;\n  }", "distance": "  public static double distance(Vector3D v1, Vector3D v2) {\n    final double dx = v2.x - v1.x;\n    final double dy = v2.y - v1.y;\n    final double dz = v2.z - v1.z;\n    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n  }"}