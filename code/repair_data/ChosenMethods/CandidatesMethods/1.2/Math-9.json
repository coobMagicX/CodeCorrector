{"reset": "    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }", "revert": "    public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n        return reverted;\n    }", "getDirection": "    public Vector3D getDirection() {\n        return direction;\n    }", "contains": "    public boolean contains(final Vector3D p) {\n        return distance(p) < 1.0e-10;\n    }", "distance": "    public double distance(final Line line) {\n\n        final Vector3D normal = Vector3D.crossProduct(direction, line.direction);\n        final double n = normal.getNorm();\n        if (n < Precision.SAFE_MIN) {\n            // lines are parallel\n            return distance(line.zero);\n        }\n\n        // signed separation of the two parallel planes that contains the lines\n        final double offset = line.zero.subtract(zero).dotProduct(normal) / n;\n\n        return FastMath.abs(offset);\n\n    }", "intersection": "    public Vector3D intersection(final Line line) {\n        final Vector3D closest = closestPoint(line);\n        return line.contains(closest) ? closest : null;\n    }", "wholeLine": "    public SubLine wholeLine() {\n        return new SubLine(this, new IntervalsSet());\n    }"}