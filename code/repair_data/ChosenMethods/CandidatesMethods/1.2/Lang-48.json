{"reflectionEquals": "    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,\n            String[] excludeFields) {\n        if (lhs == rhs) {\n            return true;\n        }\n        if (lhs == null || rhs == null) {\n            return false;\n        }\n        // Find the leaf class since there may be transients in the leaf \n        // class or in classes between the leaf and root.\n        // If we are not testing transients or a subclass has no ivars, \n        // then a subclass can test equals to a superclass.\n        Class lhsClass = lhs.getClass();\n        Class rhsClass = rhs.getClass();\n        Class testClass;\n        if (lhsClass.isInstance(rhs)) {\n            testClass = lhsClass;\n            if (!rhsClass.isInstance(lhs)) {\n                // rhsClass is a subclass of lhsClass\n                testClass = rhsClass;\n            }\n        } else if (rhsClass.isInstance(lhs)) {\n            testClass = rhsClass;\n            if (!lhsClass.isInstance(rhs)) {\n                // lhsClass is a subclass of rhsClass\n                testClass = lhsClass;\n            }\n        } else {\n            // The two classes are not related.\n            return false;\n        }\n        EqualsBuilder equalsBuilder = new EqualsBuilder();\n        try {\n            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                testClass = testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n            }\n        } catch (IllegalArgumentException e) {\n            // In this case, we tried to test a subclass vs. a superclass and\n            // the subclass has ivars or the ivars are transient and \n            // we are testing transients.\n            // If a subclass has ivars that we are trying to test them, we get an\n            // exception and we know that the objects are not equal.\n            return false;\n        }\n        return equalsBuilder.isEquals();\n    }", "reflectionAppend": "    private static void reflectionAppend(\n        Object lhs,\n        Object rhs,\n        Class clazz,\n        EqualsBuilder builder,\n        boolean useTransients,\n        String[] excludeFields) {\n        Field[] fields = clazz.getDeclaredFields();\n        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n            Field f = fields[i];\n            if (!excludedFieldList.contains(f.getName())\n                && (f.getName().indexOf('$') == -1)\n                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                && (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    //this can't happen. Would get a Security exception instead\n                    //throw a runtime exception in case the impossible happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    }", "appendSuper": "    public EqualsBuilder appendSuper(boolean superEquals) {\n        if (isEquals == false) {\n            return this;\n        }\n        isEquals = superEquals;\n        return this;\n    }", "append": "    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n        if (isEquals == false) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null || rhs == null) {\n            this.setEquals(false);\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            this.setEquals(false);\n            return this;\n        }\n        for (int i = 0; i < lhs.length && isEquals; ++i) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }", "isEquals": "    public boolean isEquals() {\n        return this.isEquals;\n    }", "setEquals": "    protected void setEquals(boolean isEquals) {\n        this.isEquals = isEquals;\n    }"}