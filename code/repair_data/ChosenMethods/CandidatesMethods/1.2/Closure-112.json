{"inferArguments": "  private void inferArguments(Scope functionScope) {\n    Node functionNode = functionScope.getRootNode();\n    Node astParameters = functionNode.getFirstChild().getNext();\n    Node iifeArgumentNode = null;\n\n    if (NodeUtil.isCallOrNewTarget(functionNode)) {\n      iifeArgumentNode = functionNode.getNext();\n    }\n\n    FunctionType functionType =\n        JSType.toMaybeFunctionType(functionNode.getJSType());\n    if (functionType != null) {\n      Node parameterTypes = functionType.getParametersNode();\n      if (parameterTypes != null) {\n        Node parameterTypeNode = parameterTypes.getFirstChild();\n        for (Node astParameter : astParameters.children()) {\n          Var var = functionScope.getVar(astParameter.getString());\n          Preconditions.checkNotNull(var);\n          if (var.isTypeInferred() &&\n              var.getType() == unknownType) {\n            JSType newType = null;\n\n            if (iifeArgumentNode != null) {\n              newType = iifeArgumentNode.getJSType();\n            } else if (parameterTypeNode != null) {\n              newType = parameterTypeNode.getJSType();\n            }\n\n            if (newType != null) {\n              var.setType(newType);\n              astParameter.setJSType(newType);\n            }\n          }\n\n          if (parameterTypeNode != null) {\n            parameterTypeNode = parameterTypeNode.getNext();\n          }\n          if (iifeArgumentNode != null) {\n            iifeArgumentNode = iifeArgumentNode.getNext();\n          }\n        }\n      }\n    }\n  }", "createInitialEstimateLattice": "  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }", "createEntryLattice": "  FlowScope createEntryLattice() {\n    return functionScope;\n  }", "branchedFlowThrough": "  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably too expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.isVar()) {\n              item = item.getFirstChild();\n            }\n            if (item.isName()) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getTemplateTypeMap().getTemplateType(\n                      registry.getObjectIndexKey());\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.isCase()) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.isAnd() ||\n                condition.isOr()) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.isAnd() ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }", "traverse": "  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n\n      case Token.CAST:\n        scope = traverseChildren(n, scope);\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.hasType()) {\n          n.setJSType(info.getType().evaluate(syntacticScope, registry));\n        }\n        break;\n    }\n\n    return scope;\n  }", "traverseReturn": "  private FlowScope traverseReturn(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node retValue = n.getFirstChild();\n    if (retValue != null) {\n      JSType type = functionScope.getRootNode().getJSType();\n      if (type != null) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        if (fnType != null) {\n          inferPropertyTypesToMatchConstraint(\n              retValue.getJSType(), fnType.getReturnType());\n        }\n      }\n    }\n    return scope;\n  }", "traverseAssign": "  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }", "updateScopeForTypeChange": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }", "ensurePropertyDefined": "  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor = obj.isThis() &&\n        getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        // In general, we don't want to define a property on a struct object,\n        // b/c TypeCheck will later check for improper property creation on\n        // structs. There are two exceptions.\n        // 1) If it's a property created inside the constructor, on the newly\n        //    created instance, allow it.\n        // 2) If it's a prototype property, allow it. For example:\n        //    Foo.prototype.bar = baz;\n        //    where Foo.prototype is a struct and the assignment happens at the\n        //    top level and the constructor Foo is defined in the same file.\n        boolean staticPropCreation = false;\n        Node maybeAssignStm = getprop.getParent().getParent();\n        if (syntacticScope.isGlobal() &&\n            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n          String propCreationFilename = maybeAssignStm.getSourceFileName();\n          Node ctor = objectType.getOwnerFunction().getSource();\n          if (ctor != null &&\n              ctor.getSourceFileName().equals(propCreationFilename)) {\n            staticPropCreation = true;\n          }\n        }\n        if (!propCreationInConstructor && !staticPropCreation) {\n          return; // Early return to avoid creating the property below.\n        }\n      }\n\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(propName, rightType, getprop);\n          }\n        } else if (propCreationInConstructor) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        } else {\n          registry.registerPropertyOnType(propName, objectType);\n        }\n      }\n    }\n  }", "ensurePropertyDeclared": "  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }", "ensurePropertyDeclaredHelper": "  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }", "traverseName": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped and assigned in an inner scope, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable = isInferred &&\n            isUnflowable(syntacticScope.getVar(varName));\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable. That variable is assigned more than once,\n        // and we can't know which type we're getting.\n        //\n        // var t = null; function f() { (t); } doStuff(); t = {};\n        //\n        // Notice that this heuristic isn't perfect. For example, you might\n        // have:\n        //\n        // function f() { (t); } f(); var t = 3;\n        //\n        // In this case, we would infer the first reference to t as\n        // type {number}, even though it's undefined.\n        boolean nonLocalInferredSlot = false;\n        if (isInferred && syntacticScope.isLocal()) {\n          Var maybeOuterVar = syntacticScope.getParent().getVar(varName);\n          if (var == maybeOuterVar &&\n              !maybeOuterVar.isMarkedAssignedExactlyOnce()) {\n            nonLocalInferredSlot = true;\n          }\n        }\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = unknownType;\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }", "isAddedAsNumber": "  private boolean isAddedAsNumber(JSType type) {\n    return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE,\n        NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE));\n  }", "tightenTypesAfterAssertions": "  private FlowScope tightenTypesAfterAssertions(FlowScope scope,\n      Node callNode) {\n    Node left = callNode.getFirstChild();\n    Node firstParam = left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec =\n        assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec == null || firstParam == null) {\n      return scope;\n    }\n    Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode == null) {\n      return scope;\n    }\n    JSType assertedType = assertionFunctionSpec.getAssertedType(\n        callNode, registry);\n    String assertedNodeName = assertedNode.getQualifiedName();\n\n    JSType narrowed;\n    // Handle assertions that enforce expressions evaluate to true.\n    if (assertedType == null) {\n      // Handle arbitrary expressions within the assert.\n      scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n          assertedNode, scope, true);\n      // Build the result of the assertExpression\n      narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined();\n    } else {\n      // Handle assertions that enforce expressions are of a certain type.\n      JSType type = getJSType(assertedNode);\n      narrowed = type.getGreatestSubtype(assertedType);\n      if (assertedNodeName != null && type.differsFrom(narrowed)) {\n        scope = narrowScope(scope, assertedNode, narrowed);\n      }\n    }\n\n    callNode.setJSType(narrowed);\n    return scope;\n  }", "narrowScope": "  private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n    if (node.isThis()) {\n      // \"this\" references don't need to be modeled in the control flow graph.\n      return scope;\n    }\n\n    scope = scope.createChildFlowScope();\n    if (node.isGetProp()) {\n      scope.inferQualifiedSlot(\n          node, node.getQualifiedName(), getJSType(node), narrowed);\n    } else {\n      redeclareSimpleVar(scope, node, narrowed);\n    }\n    return scope;\n  }", "backwardsInferenceFromCallSite": "  private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n    boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n    if (updatedFnType) {\n      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n    }\n    updateTypeOfParameters(n, fnType);\n    updateBind(n);\n  }", "updateBind": "  private void updateBind(Node n) {\n    CodingConvention.Bind bind =\n        compiler.getCodingConvention().describeFunctionBind(n, true);\n    if (bind == null) {\n      return;\n    }\n\n    FunctionType callTargetFn = getJSType(bind.target)\n        .restrictByNotNullOrUndefined().toMaybeFunctionType();\n    if (callTargetFn == null) {\n      return;\n    }\n\n    n.setJSType(\n        callTargetFn.getBindReturnType(\n            // getBindReturnType expects the 'this' argument to be included.\n            bind.getBoundParameterCount() + 1));\n  }", "inferTemplateTypesFromParameters": "  private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n      FunctionType fnType, Node call) {\n    if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {\n      return Collections.emptyMap();\n    }\n\n    Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap();\n\n    Node callTarget = call.getFirstChild();\n    if (NodeUtil.isGet(callTarget)) {\n      Node obj = callTarget.getFirstChild();\n      maybeResolveTemplatedType(\n          fnType.getTypeOfThis(),\n          getJSType(obj),\n          resolvedTypes);\n    }\n\n    if (call.hasMoreThanOneChild()) {\n      maybeResolveTemplateTypeFromNodes(\n          fnType.getParameters(),\n          call.getChildAtIndex(1).siblings(),\n          resolvedTypes);\n    }\n    return resolvedTypes;\n  }", "maybeResolveTemplateTypeFromNodes": "  private void maybeResolveTemplateTypeFromNodes(\n      Iterator<Node> declParams,\n      Iterator<Node> callParams,\n      Map<TemplateType, JSType> resolvedTypes) {\n    while (declParams.hasNext() && callParams.hasNext()) {\n      Node declParam = declParams.next();\n      maybeResolveTemplatedType(\n          getJSType(declParam),\n          getJSType(callParams.next()),\n          resolvedTypes);\n      if (declParam.isVarArgs()) {\n        while (callParams.hasNext()) {\n          maybeResolveTemplatedType(\n              getJSType(declParam),\n              getJSType(callParams.next()),\n              resolvedTypes);\n        }\n      }\n    }\n  }", "resolvedTemplateType": "  private static void resolvedTemplateType(\n      Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n    JSType previous = map.get(template);\n    if (!resolved.isUnknownType()) {\n      if (previous == null) {\n        map.put(template, resolved);\n      } else {\n        JSType join = previous.getLeastSupertype(resolved);\n        map.put(template, join);\n      }\n    }\n  }", "caseTemplateType": "    public JSType caseTemplateType(TemplateType type) {\n      madeChanges = true;\n      JSType replacement = replacements.get(type);\n      return replacement != null ?\n          replacement : registry.getNativeType(UNKNOWN_TYPE);\n    }", "inferTemplatedTypesForCall": "  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types\n    Map<TemplateType, JSType> inferred = \n        inferTemplateTypesFromParameters(fnType, n);\n\n\n    // Replace all template types. If we couldn't find a replacement, we\n    // replace it with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild();\n\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return replacer.madeChanges;\n  }", "traverseNew": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node constructor = n.getFirstChild();\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = unknownType;\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          backwardsInferenceFromCallSite(n, ct);\n\n          // If necessary, create a TemplatizedType wrapper around the instance\n          // type, based on the types of the constructor parameters.\n          ObjectType instanceType = ct.getInstanceType();\n          Map<TemplateType, JSType> inferredTypes =\n              inferTemplateTypesFromParameters(ct, n);\n          if (inferredTypes.isEmpty()) {\n            type = instanceType;\n          } else {\n            type = registry.createTemplatizedType(instanceType, inferredTypes);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }", "traverseAnd": "  private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n    return traverseShortCircuitingBinOp(n, scope, true);\n  }", "traverseChildren": "  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }", "inferPropertyTypesToMatchConstraint": "  private static void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    type.matchConstraint(constraint);\n  }", "dereferencePointer": "  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }", "traverseShortCircuitingBinOp": "  private BooleanOutcomePair traverseShortCircuitingBinOp(\n      Node n, FlowScope scope, boolean condition) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n\n    // type the left node\n    BooleanOutcomePair leftLiterals =\n        traverseWithinShortCircuitingBinOp(left,\n            scope.createChildFlowScope());\n    JSType leftType = left.getJSType();\n\n    // reverse abstract interpret the left node to produce the correct\n    // scope in which to verify the right node\n    FlowScope rightScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            left, leftLiterals.getOutcomeFlowScope(left.getType(), condition),\n            condition);\n\n    // type the right node\n    BooleanOutcomePair rightLiterals =\n        traverseWithinShortCircuitingBinOp(\n            right, rightScope.createChildFlowScope());\n    JSType rightType = right.getJSType();\n\n    JSType type;\n    BooleanOutcomePair literals;\n    if (leftType != null && rightType != null) {\n      leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition);\n      if (leftLiterals.toBooleanOutcomes ==\n          BooleanLiteralSet.get(!condition)) {\n        // Use the restricted left type, since the right side never gets\n        // evaluated.\n        type = leftType;\n        literals = leftLiterals;\n      } else {\n        // Use the join of the restricted left type knowing the outcome of the\n        // ToBoolean predicate and of the right type.\n        type = leftType.getLeastSupertype(rightType);\n        literals =\n            getBooleanOutcomePair(leftLiterals, rightLiterals, condition);\n      }\n\n      // Exclude the boolean type if the literal set is empty because a boolean\n      // can never actually be returned.\n      if (literals.booleanValues == BooleanLiteralSet.EMPTY &&\n          getNativeType(BOOLEAN_TYPE).isSubtype(type)) {\n        // Exclusion only make sense for a union type.\n        if (type.isUnionType()) {\n          type = type.toMaybeUnionType().getRestrictedUnion(\n              getNativeType(BOOLEAN_TYPE));\n        }\n      }\n    } else {\n      type = null;\n      literals = new BooleanOutcomePair(\n          BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH,\n          leftLiterals.getJoinedFlowScope(),\n          rightLiterals.getJoinedFlowScope());\n    }\n    n.setJSType(type);\n\n    return literals;\n  }", "traverseWithinShortCircuitingBinOp": "  private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n,\n      FlowScope scope) {\n    switch (n.getType()) {\n      case Token.AND:\n        return traverseAnd(n, scope);\n\n      case Token.OR:\n        return traverseOr(n, scope);\n\n      default:\n        scope = traverse(n, scope);\n        return newBooleanOutcomePair(n.getJSType(), scope);\n    }\n  }", "getBooleanOutcomePair": "  BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left,\n      BooleanOutcomePair right, boolean condition) {\n    return new BooleanOutcomePair(\n        getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes,\n                           condition),\n        getBooleanOutcomes(left.booleanValues, right.booleanValues, condition),\n        left.getJoinedFlowScope(), right.getJoinedFlowScope());\n  }", "getBooleanOutcomes": "  static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left,\n      BooleanLiteralSet right, boolean condition) {\n    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));\n  }", "getJoinedFlowScope": "    FlowScope getJoinedFlowScope() {\n      if (joinedScope == null) {\n        if (leftScope == rightScope) {\n          joinedScope = rightScope;\n        } else {\n          joinedScope = join(leftScope, rightScope);\n        }\n      }\n      return joinedScope;\n    }", "newBooleanOutcomePair": "  private BooleanOutcomePair newBooleanOutcomePair(\n      JSType jsType, FlowScope flowScope) {\n    if (jsType == null) {\n      return new BooleanOutcomePair(\n          BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope);\n    }\n    return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(),\n        registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ?\n            BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY,\n        flowScope, flowScope);\n  }", "isUnflowable": "  private boolean isUnflowable(Var v) {\n    return v != null && v.isLocal() && v.isMarkedEscaped() &&\n        // It's OK to flow a variable in the scope where it's escaped.\n        v.getScope() == syntacticScope;\n  }", "getJSType": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return unknownType;\n    } else {\n      return jsType;\n    }\n  }", "getNativeType": "  private JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }"}