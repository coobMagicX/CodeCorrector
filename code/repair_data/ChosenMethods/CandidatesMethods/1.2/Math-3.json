{"scale": "    public static double[] scale(double val, final double[] arr) {\n        double[] newArr = new double[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            newArr[i] = arr[i] * val;\n        }\n        return newArr;\n    }", "scaleInPlace": "    public static void scaleInPlace(double val, final double[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] *= val;\n        }\n    }", "ebeAdd": "    public static double[] ebeAdd(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] += b[i];\n        }\n        return result;\n    }", "ebeSubtract": "    public static double[] ebeSubtract(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] -= b[i];\n        }\n        return result;\n    }", "ebeMultiply": "    public static double[] ebeMultiply(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }", "ebeDivide": "    public static double[] ebeDivide(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] /= b[i];\n        }\n        return result;\n    }", "distance1": "    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }", "distance": "    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }", "distanceInf": "    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }", "isMonotonic": "    public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n        return checkOrder(val, dir, strict, false);\n    }", "checkRectangular": "    public static void checkRectangular(final long[][] in)\n        throws NullArgumentException, DimensionMismatchException {\n        MathUtils.checkNotNull(in);\n        for (int i = 1; i < in.length; i++) {\n            if (in[i].length != in[0].length) {\n                throw new DimensionMismatchException(\n                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                        in[i].length, in[0].length);\n            }\n        }\n    }", "checkPositive": "    public static void checkPositive(final double[] in)\n        throws NotStrictlyPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] <= 0) {\n                throw new NotStrictlyPositiveException(in[i]);\n            }\n        }\n    }", "checkNonNegative": "    public static void checkNonNegative(final long[][] in)\n        throws NotPositiveException {\n        for (int i = 0; i < in.length; i ++) {\n            for (int j = 0; j < in[i].length; j++) {\n                if (in[i][j] < 0) {\n                    throw new NotPositiveException(in[i][j]);\n                }\n            }\n        }\n    }", "safeNorm": "    public static double safeNorm(double[] v) {\n        double rdwarf = 3.834e-20;\n        double rgiant = 1.304e+19;\n        double s1 = 0;\n        double s2 = 0;\n        double s3 = 0;\n        double x1max = 0;\n        double x3max = 0;\n        double floatn = v.length;\n        double agiant = rgiant / floatn;\n        for (int i = 0; i < v.length; i++) {\n            double xabs = Math.abs(v[i]);\n            if (xabs < rdwarf || xabs > agiant) {\n                if (xabs > rdwarf) {\n                    if (xabs > x1max) {\n                        double r = x1max / xabs;\n                        s1= 1 + s1 * r * r;\n                        x1max = xabs;\n                    } else {\n                        double r = xabs / x1max;\n                        s1 += r * r;\n                    }\n                } else {\n                    if (xabs > x3max) {\n                        double r = x3max / xabs;\n                        s3= 1 + s3 * r * r;\n                        x3max = xabs;\n                    } else {\n                        if (xabs != 0) {\n                            double r = xabs / x3max;\n                            s3 += r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 += xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 != 0) {\n            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 == 0) {\n                norm = x3max * Math.sqrt(s3);\n            } else {\n                if (s2 >= x3max) {\n                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }", "sortInPlace": "    public static void sortInPlace(double[] x,\n                                   final OrderDirection dir,\n                                   double[] ... yList)\n        throws NullArgumentException,\n               DimensionMismatchException {\n\n        // Consistency checks.\n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        final int yListLen = yList.length;\n        final int len = x.length;\n\n        for (int j = 0; j < yListLen; j++) {\n            final double[] y = yList[j];\n            if (y == null) {\n                throw new NullArgumentException();\n            }\n            if (y.length != len) {\n                throw new DimensionMismatchException(y.length, len);\n            }\n        }\n\n        // Associate each abscissa \"x[i]\" with its index \"i\".\n        final List<Pair<Double, Integer>> list\n            = new ArrayList<Pair<Double, Integer>>(len);\n        for (int i = 0; i < len; i++) {\n            list.add(new Pair<Double, Integer>(x[i], i));\n        }\n\n        // Create comparators for increasing and decreasing orders.\n        final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n            new Comparator<Pair<Double, Integer>>() {\n            public int compare(Pair<Double, Integer> o1,\n                               Pair<Double, Integer> o2) {\n                return o1.getKey().compareTo(o2.getKey());\n            }\n        } : new Comparator<Pair<Double,Integer>>() {\n            public int compare(Pair<Double, Integer> o1,\n                               Pair<Double, Integer> o2) {\n                return o2.getKey().compareTo(o1.getKey());\n            }\n        };\n\n        // Sort.\n        Collections.sort(list, comp);\n\n        // Modify the original array so that its elements are in\n        // the prescribed order.\n        // Retrieve indices of original locations.\n        final int[] indices = new int[len];\n        for (int i = 0; i < len; i++) {\n            final Pair<Double, Integer> e = list.get(i);\n            x[i] = e.getKey();\n            indices[i] = e.getValue();\n        }\n\n        // In each of the associated arrays, move the\n        // elements to their new location.\n        for (int j = 0; j < yListLen; j++) {\n            // Input array will be modified in place.\n            final double[] yInPlace = yList[j];\n            final double[] yOrig = yInPlace.clone();\n\n            for (int i = 0; i < len; i++) {\n                yInPlace[i] = yOrig[indices[i]];\n            }\n        }\n    }", "linearCombination": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3,\n                                           final double a4, final double b4) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // split a4 and b4 as two 26 bits numbers\n        final double ca4        = SPLIT_FACTOR * a4;\n        final double a4High     = ca4 - (ca4 - a4);\n        final double a4Low      = a4 - a4High;\n        final double cb4        = SPLIT_FACTOR * b4;\n        final double b4High     = cb4 - (cb4 - b4);\n        final double b4Low      = b4 - b4High;\n\n        // accurate multiplication a4 * b4\n        final double prod4High  = a4 * b4;\n        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n        final double s1234High  = s123High + prod4High;\n        final double s1234Prime = s1234High - prod4High;\n        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n\n        // final rounding, s1234 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n        }\n\n        return result;\n    }", "equals": "    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "equalsIncludingNaN": "    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "normalizeArray": "     public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }", "buildArray": "    public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n         final T[][] array;\n         if (columns < 0) {\n             T[] dummyRow = buildArray(field, 0);\n             array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         } else {\n             array = (T[][]) Array.newInstance(field.getRuntimeClass(),\n                                               new int[] {\n                                                   rows, columns\n                                               });\n             for (int i = 0; i < rows; ++i) {\n                 Arrays.fill(array[i], field.getZero());\n             }\n         }\n         return array;\n     }", "convolve": "     public static double[] convolve(double[] x, double[] h)\n         throws NullArgumentException,\n                NoDataException {\n         MathUtils.checkNotNull(x);\n         MathUtils.checkNotNull(h);\n\n         final int xLen = x.length;\n         final int hLen = h.length;\n\n         if (xLen == 0 || hLen == 0) {\n             throw new NoDataException();\n         }\n\n         // initialize the output array\n         final int totalLength = xLen + hLen - 1;\n         final double[] y = new double[totalLength];\n\n         // straightforward implementation of the convolution sum\n         for (int n = 0; n < totalLength; n++) {\n             double yn = 0;\n             int k = FastMath.max(0, n + 1 - xLen);\n             int j = n - k;\n             while (k < hLen && j >= 0) {\n                 yn += x[j--] * h[k++];\n             }\n             y[n] = yn;\n         }\n\n         return y;\n     }"}