{"isLenient": "    public boolean isLenient() {\n        return false;\n    }", "get": "    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }", "add": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "addWrapField": "    public long addWrapField(long instant, int months) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n    }", "getDifferenceAsLong": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -getDifference(subtrahendInstant, minuendInstant);\n        }\n\n        int minuendYear = iChronology.getYear(minuendInstant);\n        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n\n        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n\n        // Before adjusting for remainder, account for special case of add\n        // where the day-of-month is forced to the nearest sane value.\n        int minuendDom = iChronology.getDayOfMonth\n            (minuendInstant, minuendYear, minuendMonth);\n        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n            // Last day of the minuend month...\n            int subtrahendDom = iChronology.getDayOfMonth\n                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n            if (subtrahendDom > minuendDom) {\n                // ...and day of subtrahend month is larger.\n                // Note: This works fine, but it ideally shouldn't invoke other\n                // fields from within a field.\n                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n            }\n        }\n\n        // Inlined remainder method to avoid duplicate calls.\n        long minuendRem = minuendInstant\n            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n        long subtrahendRem = subtrahendInstant\n            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n\n        return difference;\n    }", "set": "    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }", "getRangeDurationField": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }", "isLeap": "    public boolean isLeap(long instant) {\n        int thisYear = iChronology.getYear(instant);\n        if (iChronology.isLeapYear(thisYear)) {\n            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n        }\n        return false;\n    }", "getLeapAmount": "    public int getLeapAmount(long instant) {\n        return isLeap(instant) ? 1 : 0;\n    }", "getLeapDurationField": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }", "getMinimumValue": "    public int getMinimumValue() {\n        return MIN;\n    }", "getMaximumValue": "    public int getMaximumValue() {\n        return iMax;\n    }", "remainder": "    public long remainder(long instant) {\n        return instant - roundFloor(instant);\n    }"}