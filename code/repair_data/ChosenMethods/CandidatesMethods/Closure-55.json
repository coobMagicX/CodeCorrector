{"process": "  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }", "isReduceableFunctionExpression": "  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n  }", "apply": "    void apply() {\n      parent.replaceChild(oldChild, newChild);\n      compiler.reportCodeChange();\n    }", "estimateSavings": "    int estimateSavings() {\n      return InlineCostEstimator.getCost(oldChild) -\n          InlineCostEstimator.getCost(newChild);\n    }", "visit": "    public void visit(NodeTraversal traversal, Node node, Node parent) {\n    }", "reduce": "    public Node reduce(Node node) {\n      if (!isReduceableFunctionExpression(node)) {\n        return node;\n      }\n\n      Node propName = getSetPropertyName(node);\n      if (propName != null) {\n        if (propName.getType() != Token.STRING) {\n          throw new IllegalStateException(\n              \"Expected STRING, got \" + Token.name(propName.getType()));\n        }\n\n        return buildCallNode(FACTORY_METHOD_NAME, propName,\n                             node.getLineno(), node.getCharno());\n      } else {\n        return node;\n      }\n    }", "buildCallNode": "    protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       int lineno, int charno) {\n      Node call = new Node(Token.CALL, lineno, charno);\n      call.putBooleanProp(Node.FREE_CALL, true);\n      call.addChildToBack(Node.newString(Token.NAME, methodName));\n      if (argumentNode != null) {\n        call.addChildToBack(argumentNode.cloneTree());\n      }\n      return call;\n    }", "maybeGetSingleReturnRValue": "    protected final Node maybeGetSingleReturnRValue(Node functionNode) {\n      Node body = functionNode.getLastChild();\n      if (!body.hasOneChild()) {\n        return null;\n      }\n\n      Node statement = body.getFirstChild();\n      if (statement.getType() == Token.RETURN) {\n        return statement.getFirstChild();\n      }\n      return null;\n    }", "isIdentityFunction": "    private boolean isIdentityFunction(Node functionNode) {\n      Node argList = functionNode.getFirstChild().getNext();\n      Node paramNode = argList.getFirstChild();\n      if (paramNode == null) {\n        return false;\n      }\n\n      Node value = maybeGetSingleReturnRValue(functionNode);\n      if (value != null &&\n          NodeUtil.isName(value) &&\n          value.getString().equals(paramNode.getString())) {\n        return true;\n      }\n      return false;\n    }", "getValueNode": "    private Node getValueNode(Node functionNode) {\n      Node value = maybeGetSingleReturnRValue(functionNode);\n      if (value != null &&\n          NodeUtil.isImmutableValue(value)) {\n        return value;\n      }\n      return null;\n    }", "getGetPropertyName": "    private Node getGetPropertyName(Node functionNode) {\n      Node value = maybeGetSingleReturnRValue(functionNode);\n      if (value != null &&\n          NodeUtil.isGetProp(value) &&\n          NodeUtil.isThis(value.getFirstChild())) {\n        return value.getLastChild();\n      }\n      return null;\n    }", "getSetPropertyName": "    private Node getSetPropertyName(Node functionNode) {\n      Node body = functionNode.getLastChild();\n      if (!body.hasOneChild()) {\n        return null;\n      }\n\n      Node argList = functionNode.getFirstChild().getNext();\n      Node paramNode = argList.getFirstChild();\n      if (paramNode == null) {\n        return null;\n      }\n\n      Node statement = body.getFirstChild();\n      if (!NodeUtil.isExprAssign(statement)) {\n        return null;\n      }\n\n      Node assign = statement.getFirstChild();\n      Node lhs = assign.getFirstChild();\n      if (NodeUtil.isGetProp(lhs) && NodeUtil.isThis(lhs.getFirstChild())) {\n        Node rhs = assign.getLastChild();\n        if (NodeUtil.isName(rhs) &&\n            rhs.getString().equals(paramNode.getString())) {\n          Node propertyName = lhs.getLastChild();\n          return propertyName;\n        }\n      }\n      return null;\n    }"}