{"setErrorManager": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }", "createMessageFormatter": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }", "initOptions": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }", "init": "  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }", "initModules": "  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }", "initBasedOnOptions": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }", "makeCompilerInput": "  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }", "checkFirstModule": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }", "createFillFileName": "  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }", "fillEmptyModules": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }", "rebuildInputsFromModules": "  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }", "getAllInputsFromModules": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }", "initInputsByIdMap": "  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }", "compile": "  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }", "compileModules": "  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }", "disableThreads": "  public void disableThreads() {\n    useThreads = false;\n  }", "runInCompilerThread": "  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }", "runCallableWithLargeStack": "  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }", "runCallable": "  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the JS Compiler overflows the stack when running on some\n    // large or complex JS code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }", "compileInternal": "  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }", "parse": "  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }", "getPassConfig": "  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }", "createPassConfigInternal": "  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }", "setPassConfig": "  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }", "precheck": "  boolean precheck() {\n    return true;\n  }", "check": "  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }", "externExports": "  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }", "process": "  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }", "maybeSanityCheck": "  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }", "runSanityCheck": "  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }", "removeTryCatchFinally": "  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }", "stripCode": "  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }", "runCustomPasses": "  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }", "endPass": "  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }", "newTracer": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }", "stopTracer": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }", "getResult": "  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }", "getMessages": "  public JSError[] getMessages() {\n    return getErrors();\n  }", "getErrors": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }", "getWarnings": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }", "getRoot": "  public Node getRoot() {\n    return externAndJsRoot;\n  }", "nextUniqueNameId": "  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }", "resetUniqueNameId": "  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }", "getUniqueNameIdSupplier": "  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }", "areNodesEqualForInlining": "  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }", "getInput": "  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }", "removeExternInput": "  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }", "newExternInput": "  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }", "putCompilerInput": "  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }", "addIncrementalSourceAst": "  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }", "replaceIncrementalSourceAst": "  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }", "addNewSourceAst": "  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }", "getModuleGraph": "  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }", "getDegenerateModuleGraph": "  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }", "getTypeRegistry": "  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }", "getTypedScopeCreator": "  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }", "ensureDefaultPassConfig": "  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }", "buildKnownSymbolTable": "  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }", "getTopScope": "  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }", "getReverseAbstractInterpreter": "  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }", "getTypeValidator": "  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }", "parseInputs": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      hoistNoCompileFiles();\n\n      if (staleInputs) {\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }", "hoistExterns": "  private void hoistExterns(Node externsRoot) {\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        // If we're doing scanning dependency info anyway, use that\n        // information to skip sources that obviously aren't externs.\n        if (!input.getProvides().isEmpty() || !input.getRequires().isEmpty()) {\n          continue;\n        }\n      }\n\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST on a parse error.\n      if (n == null) {\n        continue;\n      }\n\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.isExterns()) {\n        // If the input file is explicitly marked as an externs file, then\n        // assume the programmer made a mistake and throw it into\n        // the externs pile anyways.\n        externsRoot.addChildToBack(n);\n        input.setIsExtern(true);\n\n        input.getModule().remove(input);\n\n        externs.add(input);\n        staleInputs = true;\n      }\n    }\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n  }", "hoistNoCompileFiles": "  private void hoistNoCompileFiles() {\n    boolean staleInputs = false;\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n\n      // Inputs can have a null AST on a parse error.\n      if (n == null) {\n        continue;\n      }\n\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.isNoCompile()) {\n        input.getModule().remove(input);\n        staleInputs = true;\n      }\n    }\n\n    if (staleInputs) {\n      repartitionInputs();\n    }\n  }", "repartitionInputs": "  private void repartitionInputs() {\n    fillEmptyModules(modules);\n    rebuildInputsFromModules();\n  }", "processAMDAndCommonJSModules": "  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }", "parseSyntheticCode": "  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }", "newCompilerOptions": "  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }", "initCompilerOptionsIfTesting": "  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }", "parseTestCode": "  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }", "getDefaultErrorReporter": "  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }", "toSource": "  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }", "toSourceArray": "  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }", "reset": "    void reset() {\n      sb.setLength(0);\n    }", "append": "    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }", "toString": "    public String toString() {\n      return sb.toString();\n    }", "getLength": "    public int getLength() {\n      return sb.length();\n    }", "getLineIndex": "    int getLineIndex() {\n      return lineCount;\n    }", "getColumnIndex": "    int getColumnIndex() {\n      return colCount;\n    }", "endsWith": "    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }", "optimize": "  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }", "setCssRenamingMap": "  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }", "getCssRenamingMap": "  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }", "processDefines": "  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }", "isInliningForbidden": "  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }", "computeCFG": "  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }", "normalize": "  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }", "prepareAst": "  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }", "recordFunctionInformation": "  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }", "addChangeHandler": "  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }", "removeChangeHandler": "  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }", "reportCodeChange": "  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }", "getCodingConvention": "  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }", "isIdeMode": "  public boolean isIdeMode() {\n    return options.ideMode;\n  }", "acceptEcmaScript5": "  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }", "languageMode": "  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }", "acceptConstKeyword": "  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }", "getParserConfig": "  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }", "isTypeCheckingEnabled": "  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }", "getDiagnosticGroups": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }", "report": "  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }", "getErrorLevel": "  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }", "throwInternalError": "  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }", "getErrorCount": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }", "getWarningCount": "  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }", "hasHaltingErrors": "  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }", "hasErrors": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }", "addToDebugLog": "  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }", "getSourceFileByName": "  SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of JavaScript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }", "getSourceLine": "  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }", "getSourceRegion": "  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }", "getNodeForCodeInsertion": "  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }", "getSourceMap": "  public SourceMap getSourceMap() {\n    return sourceMap;\n  }", "getVariableMap": "  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }", "getPropertyMap": "  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }", "getOptions": "  CompilerOptions getOptions() {\n    return options;\n  }", "getFunctionalInformationMap": "  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }", "setLoggingLevel": "  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }", "getAstDotGraph": "  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }", "getErrorManager": "  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }", "getInputsInOrder": "  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }", "getInputsById": "  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }", "getExternsInOrder": "  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }", "getState": "  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }", "setState": "  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }", "getInputsForTesting": "  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }", "getExternsForTesting": "  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }", "hasRegExpGlobalReferences": "  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }", "setHasRegExpGlobalReferences": "  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }", "updateGlobalVarReferences": "  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }", "getGlobalVarReferences": "  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }", "getSynthesizedExternsInput": "  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }", "getProgress": "  public double getProgress() {\n    return progress;\n  }", "setProgress": "  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }", "replaceScript": "  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }", "addNewScript": "  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }", "processNewScript": "  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }", "runHotSwap": "  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }", "runHotSwapPass": "  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }", "getCleanupPassConfig": "  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }", "removeSyntheticVarsInput": "  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }", "ensureLibraryInjected": "  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }", "loadLibraryCode": "  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }", "getReleaseVersion": "  public static String getReleaseVersion() {\n    ResourceBundle config = ResourceBundle.getBundle(CONFIG_RESOURCE);\n    return config.getString(\"compiler.version\");\n  }", "getReleaseDate": "  public static String getReleaseDate() {\n    ResourceBundle config = ResourceBundle.getBundle(CONFIG_RESOURCE);\n    return config.getString(\"compiler.date\");\n  }"}