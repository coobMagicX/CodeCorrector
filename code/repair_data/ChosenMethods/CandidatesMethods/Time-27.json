{"toFormatter": "    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }", "clear": "    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }", "append": "    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }", "printZeroRarelyFirst": "    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }", "printZeroIfSupported": "    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }", "appendPrefix": "    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }", "appendField": "    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }", "appendSuffix": "    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }", "appendSeparator": "    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }", "appendSeparatorIfFieldsAfter": "    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }", "appendSeparatorIfFieldsBefore": "    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }", "clearPrefix": "    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }", "append0": "    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }", "createComposite": "    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }", "parse": "        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }", "scan": "        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }", "countFieldsToPrint": "        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }", "getFieldValue": "        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }", "setFieldValue": "        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }", "getFieldType": "        int getFieldType() {\n            return iFieldType;\n        }", "finish": "        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }", "decompose": "        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }", "addArrayToList": "        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }"}