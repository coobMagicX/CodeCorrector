{"getDeserializer": "    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)\n    {\n        if (nodeClass == ObjectNode.class) {\n            return ObjectDeserializer.getInstance();\n        }\n        if (nodeClass == ArrayNode.class) {\n            return ArrayDeserializer.getInstance();\n        }\n        // For others, generic one works fine\n        return instance;\n    }", "deserialize": "        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }", "deserializeWithType": "    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer)\n        throws IOException\n    {\n        /* Output can be as JSON Object, Array or scalar: no way to know\n         * a priori. So:\n         */\n        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n    }", "_reportProblem": "    protected void _reportProblem(JsonParser p, String msg) throws JsonMappingException {\n        throw new JsonMappingException(msg, p.getTokenLocation());\n    }", "_handleDuplicateField": "    protected void _handleDuplicateField(JsonParser p, DeserializationContext ctxt,\n            JsonNodeFactory nodeFactory,\n            String fieldName, ObjectNode objectNode,\n            JsonNode oldValue, JsonNode newValue)\n        throws JsonProcessingException\n    {\n        // [Issue#237]: Report an error if asked to do so:\n        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY)) {\n            _reportProblem(p, \"Duplicate field '\"+fieldName+\"' for ObjectNode: not allowed when FAIL_ON_READING_DUP_TREE_KEY enabled\");\n        }\n    }", "deserializeObject": "    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ObjectNode node = nodeFactory.objectNode();\n        String key;\n        if (p.isExpectedStartObjectToken()) {\n            key = p.nextFieldName();\n        } else {\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.END_OBJECT) {\n                return node;\n            }\n            if (t != JsonToken.FIELD_NAME) {\n                throw ctxt.mappingException(handledType(), p.getCurrentToken());\n            }\n            key = p.getCurrentName();\n        }\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken t = p.nextToken();\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = nodeFactory.nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, nodeFactory);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, nodeFactory,\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }", "deserializeArray": "    protected final ArrayNode deserializeArray(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        ArrayNode node = nodeFactory.arrayNode();\n        while (true) {\n            JsonToken t = p.nextToken();\n            if (t == null) {\n                throw ctxt.mappingException(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                node.add(deserializeObject(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                node.add(deserializeArray(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_END_ARRAY:\n                return node;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                node.add(_fromEmbedded(p, ctxt, nodeFactory));\n            case JsonTokenId.ID_STRING:\n                node.add(nodeFactory.textNode(p.getText()));\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                node.add(_fromInt(p, ctxt, nodeFactory));\n                break;\n            case JsonTokenId.ID_TRUE:\n                node.add(nodeFactory.booleanNode(true));\n                break;\n            case JsonTokenId.ID_FALSE:\n                node.add(nodeFactory.booleanNode(false));\n                break;\n            case JsonTokenId.ID_NULL:\n                node.add(nodeFactory.nullNode());\n                break;\n            default:\n                node.add(deserializeAny(p, ctxt, nodeFactory));\n                break;\n            }\n        }\n    }", "deserializeAny": "    protected final JsonNode deserializeAny(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        switch (p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_END_OBJECT: // for empty JSON Objects we may point to this\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_START_ARRAY:\n            return deserializeArray(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_FIELD_NAME:\n            return deserializeObject(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return _fromEmbedded(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_STRING:\n            return nodeFactory.textNode(p.getText());\n        case JsonTokenId.ID_NUMBER_INT:\n            return _fromInt(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            return _fromFloat(p, ctxt, nodeFactory);\n        case JsonTokenId.ID_TRUE:\n            return nodeFactory.booleanNode(true);\n        case JsonTokenId.ID_FALSE:\n            return nodeFactory.booleanNode(false);\n        case JsonTokenId.ID_NULL:\n            return nodeFactory.nullNode();\n            \n            // These states can not be mapped; input stream is\n            // off by an event or two\n\n        //case END_OBJECT:\n        //case END_ARRAY:\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }"}