{"unwrappingDeserializer": "    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer transformer)\n    {\n        // bit kludgy but we don't want to accidentally change type; sub-classes\n        // MUST override this method to support unwrapped properties...\n        if (getClass() != BeanDeserializer.class) {\n            return this;\n        }\n        // 25-Mar-2017, tatu: Not clean at all, but for [databind#383] we do need\n        //   to keep track of accidental recursion...\n        if (_currentlyTransforming == transformer) {\n            return this;\n        }\n        _currentlyTransforming = transformer;\n        try {\n            return new BeanDeserializer(this, transformer);\n        } finally { _currentlyTransforming = null; }\n    }", "withObjectIdReader": "    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n        return new BeanDeserializer(this, oir);\n    }", "withIgnorableProperties": "    public BeanDeserializer withIgnorableProperties(Set<String> ignorableProps) {\n        return new BeanDeserializer(this, ignorableProps);\n    }", "withBeanProperties": "    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BeanDeserializer(this, props);\n    }", "asArrayDeserializer": "    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayDeserializer(this, props);\n    }", "deserialize": "    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean) throws IOException\n    {\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }", "_deserializeOther": "    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n            JsonToken t) throws IOException\n    {\n        // and then others, generally requiring use of @JsonCreator\n        if (t != null) {\n            switch (t) {\n            case VALUE_STRING:\n                return deserializeFromString(p, ctxt);\n            case VALUE_NUMBER_INT:\n                return deserializeFromNumber(p, ctxt);\n            case VALUE_NUMBER_FLOAT:\n                return deserializeFromDouble(p, ctxt);\n            case VALUE_EMBEDDED_OBJECT:\n                return deserializeFromEmbedded(p, ctxt);\n            case VALUE_TRUE:\n            case VALUE_FALSE:\n                return deserializeFromBoolean(p, ctxt);\n            case VALUE_NULL:\n                return deserializeFromNull(p, ctxt);\n            case START_ARRAY:\n                // these only work if there's a (delegating) creator...\n                return deserializeFromArray(p, ctxt);\n            case FIELD_NAME:\n            case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n                if (_vanillaProcessing) {\n                    return vanillaDeserialize(p, ctxt, t);\n                }\n                if (_objectIdReader != null) {\n                    return deserializeWithObjectId(p, ctxt);\n                }\n                return deserializeFromObject(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }", "_missingToken": "    protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {\n        throw ctxt.endOfInputException(handledType());\n    }", "vanillaDeserialize": "    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n    {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }", "deserializeFromObject": "    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [databind#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if ((_objectIdReader != null) && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }", "_deserializeUsingPropertyBased": "    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n        TokenBuffer unknown = null;\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n        JsonToken t = p.getCurrentToken();\n        List<BeanReferring> referrings = null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                Object value;\n                if ((activeView != null) && !creatorProp.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                value = _deserializeWithErrorWrapping(p, ctxt, creatorProp);\n                if (buffer.assignParameter(creatorProp, value)) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    if (bean == null) {\n                        return ctxt.handleInstantiationProblem(handledType(), null,\n                                _creatorReturnedNullException());\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                } catch (UnresolvedForwardReference reference) {\n                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                    //    handling of forward references here. Not exactly sure why existing\n                    //    facilities did not cover, but this does appear to solve the problem\n                    BeanReferring referring = handleUnresolvedReference(ctxt,\n                            prop, buffer, reference);\n                    if (referrings == null) {\n                        referrings = new ArrayList<BeanReferring>();\n                    }\n                    referrings.add(referring);\n                }\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean =  creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            bean = null; // never gets here\n        }\n        if (referrings != null) {\n            for (BeanReferring referring : referrings) {\n               referring.setBean(bean);\n            }\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }", "handleUnresolvedReference": "    private BeanReferring handleUnresolvedReference(DeserializationContext ctxt,\n            SettableBeanProperty prop, PropertyValueBuffer buffer,\n            UnresolvedForwardReference reference)\n        throws JsonMappingException\n    {\n        BeanReferring referring = new BeanReferring(ctxt, reference,\n                prop.getType(), buffer, prop);\n        reference.getRoid().appendReferring(referring);\n        return referring;\n    }", "_deserializeWithErrorWrapping": "    protected final Object _deserializeWithErrorWrapping(JsonParser p,\n            DeserializationContext ctxt, SettableBeanProperty prop)\n        throws IOException\n    {\n        try {\n            return prop.deserialize(p, ctxt);\n        } catch (Exception e) {\n            wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);\n            // never gets here, unless caller declines to throw an exception\n            return null;\n        }\n    }", "deserializeFromNull": "    protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic\n        //   \"empty\" POJOs deserialized from XML, where empty XML tag synthesizes a\n        //   `VALUE_NULL` token.\n        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tb = new TokenBuffer(p, ctxt);\n            tb.writeEndObject();\n            JsonParser p2 = tb.asParser(p);\n            p2.nextToken(); // to point to END_OBJECT\n            // note: don't have ObjectId to consider at this point, so:\n            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)\n                    : deserializeFromObject(p2, ctxt);\n            p2.close();\n            return ob;\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }", "deserializeWithView": "    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException\n    {\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                // TODO: 06-Jan-2015, tatu: try streamlining call sequences here as well\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    if (!prop.visibleInView(activeView)) {\n                        p.skipChildren();\n                        continue;\n                    }\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }", "deserializeWithUnwrapped": "    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    _anySetter.deserializeAndSet(b2.asParserOnFirstToken(), ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }", "deserializeUsingPropertyBasedWithUnwrapped": "    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n        \n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n                        p.nextToken();\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName,\n                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }", "deserializeWithExternalTypeId": "    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n            Object bean)\n        throws IOException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }", "deserializeUsingPropertyBasedWithExternalTypeId": "    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                            // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                            //   it's too complicated, so bail out\n                            return ctxt.reportBadDefinition(_beanType, String.format(\n                                    \"Cannot create polymorphic instances with external type ids (%s -> %s)\",\n                                    _beanType, bean.getClass()));\n                        }\n                        return ext.complete(p, ctxt, bean);\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName,\n                        _anySetter.deserialize(p, ctxt));\n            }\n        }\n        tokens.writeEndObject();\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }", "_creatorReturnedNullException": "    protected Exception _creatorReturnedNullException() {\n        if (_nullFromCreator == null) {\n            _nullFromCreator = new NullPointerException(\"JSON Creator returned null\");\n        }\n        return _nullFromCreator;\n    }", "setBean": "        public void setBean(Object bean) {\n            _bean = bean;\n        }", "handleResolvedForwardReference": "        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n        {\n            if (_bean == null) {\n                _context.reportInputMismatch(_prop,\n\"Cannot resolve ObjectId forward reference using property '%s' (of type %s): Bean not yet resolved\",\n_prop.getName(), _prop.getDeclaringClass().getName());\n        }\n            _prop.set(_bean, value);\n        }"}