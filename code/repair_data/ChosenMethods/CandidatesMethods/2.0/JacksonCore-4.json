{"buf": "    private char[] buf(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }", "size": "    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }", "append": "    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }", "getCurrentSegment": "    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }", "emptyAndGetCurrentSegment": "    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }", "getCurrentSegmentSize": "    public int getCurrentSegmentSize() { return _currentSize; }", "setCurrentLength": "    public void setCurrentLength(int len) { _currentSize = len; }", "finishCurrentSegment": "    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        // Let's grow segments by 50%\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }", "expandCurrentSegment": "    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }", "unshare": "    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }", "expand": "    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        // Let's grow segments by 50% minimum\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }", "carr": "    private char[] carr(int len) { return new char[len]; }"}