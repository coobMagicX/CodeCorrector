{"unknownType": "    public static JavaType unknownType() {\n        return defaultInstance()._unknownType();\n    }", "constructSpecializedType": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }", "findTypeParameters": "    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n        // First: find full inheritance chain\n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        // Caller is supposed to ensure this never happens, so:\n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        // Ok and then go to the ultimate super-type:\n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { // got bindings, need to resolve\n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        // which ought to be generic (if not, it's raw type)\n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }", "moreSpecificType": "    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n    {\n        if (type1 == null) {\n            return type2;\n        }\n        if (type2 == null) {\n            return type1;\n        }\n        Class<?> raw1 = type1.getRawClass();\n        Class<?> raw2 = type2.getRawClass();\n        if (raw1 == raw2) {\n            return type1;\n        }\n        // TODO: maybe try sub-classing, to retain generic types?\n        if (raw1.isAssignableFrom(raw2)) {\n            return type2;\n        }\n        return type1;\n    }", "constructType": "    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }", "_constructType": "    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }", "constructArrayType": "    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }", "constructCollectionType": "    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }", "constructCollectionLikeType": "    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }", "constructMapType": "    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }", "constructMapLikeType": "    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }", "constructSimpleType": "    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        // Quick sanity check: must match numbers of types with expected...\n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } ", "uncheckedSimpleType": "    public JavaType uncheckedSimpleType(Class<?> cls) {\n        return new SimpleType(cls);\n    }", "constructParametrizedType": "    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        JavaType resultType;\n        \n        // Need to check kind of class we are dealing with...\n        if (parametrized.isArray()) {\n            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }", "constructParametricType": "    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }", "constructRawCollectionType": "    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }", "constructRawCollectionLikeType": "    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }", "constructRawMapType": "    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }", "constructRawMapLikeType": "    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }", "_fromParamType": "    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n    {\n        /* First: what is the actual base type? One odd thing\n         * is that 'getRawType' returns Type, not Class<?> as\n         * one might expect. But let's assume it is always of\n         * type Class: if not, need to add more code to resolve\n         * it to Class.\n         */\n        Class<?> rawType = (Class<?>) type.getRawType();\n        Type[] args = type.getActualTypeArguments();\n        int paramCount = (args == null) ? 0 : args.length;\n\n        JavaType[] pt;\n        \n        if (paramCount == 0) {\n            pt = NO_TYPES;\n        } else {\n            pt = new JavaType[paramCount];\n            for (int i = 0; i < paramCount; ++i) {\n                pt[i] = _constructType(args[i], context);\n            }\n        }\n\n        // Ok: Map or Collection?\n        if (Map.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n            if (mapParams.length != 2) {\n                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n            }\n            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n        }\n        if (Collection.class.isAssignableFrom(rawType)) {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n            if (collectionParams.length != 1) {\n                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n            }\n            return CollectionType.construct(rawType, collectionParams[0]);\n        }\n        if (paramCount == 0) { // no generics\n            return new SimpleType(rawType);\n        }\n        return constructSimpleType(rawType, pt);\n    }", "_fromArrayType": "    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n    {\n        JavaType compType = _constructType(type.getGenericComponentType(), context);\n        return ArrayType.construct(compType, null, null);\n    }", "_fromVariable": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n        Type[] bounds = type.getBounds();\n\n        // With type variables we must use bound information.\n        // Theoretically this gets tricky, as there may be multiple\n        // bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional;\n        // but here we are lucky in that implicit \"Object\" is\n        // added as bounds if so.\n        // Either way let's just use the first bound, for now, and\n        // worry about better match later on if there is need.\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        context._addPlaceholder(name);\n        return _constructType(bounds[0], context);\n    }", "_mapType": "    private JavaType _mapType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }", "_collectionType": "    private JavaType _collectionType(Class<?> rawClass)\n    {\n        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return CollectionType.construct(rawClass, _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 1) {\n            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return CollectionType.construct(rawClass, typeParams[0]);\n    }    ", "_resolveVariableViaSubTypes": "    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n    {\n        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n        if (leafType != null && leafType.isGeneric()) {\n            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n                TypeVariable<?> tv = typeVariables[i];\n                if (variableName.equals(tv.getName())) {\n                    // further resolution needed?\n                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n                    if (type instanceof TypeVariable<?>) {\n                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n                    }\n                    // no we're good for the variable (but it may have parameterization of its own)\n                    return _constructType(type, bindings);\n                }\n            }\n        }\n        return _unknownType();\n    }", "_unknownType": "    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }", "_findSuperTypeChain": "    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n    {\n        // If super-type is a class (not interface), bit simpler\n        if (supertype.isInterface()) {\n            return _findSuperInterfaceChain(subtype, supertype);\n        }\n        return _findSuperClassChain(subtype, supertype);\n    }"}