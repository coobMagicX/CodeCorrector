{"version": "    public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Public API, Feature configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling specified parser features:\n     * check {@link Feature} for list of available features.", "enable": "    public abstract JsonGenerator enable(Feature f);\n\n    /**\n     * Method for disabling specified  features\n     * (check {@link Feature} for list of features)", "disable": "    public abstract JsonGenerator disable(Feature f);\n\n    /**\n     * Method for enabling or disabling specified feature:\n     * check {@link Feature} for list of available features.", "configure": "    public final JsonGenerator configure(Feature f, boolean state) {\n        if (state) enable(f); else disable(f);\n        return this;\n    }", "canWriteObjectId": "    public boolean canWriteObjectId() { return false; }", "writeStartObject": "    public void writeStartObject(Object forValue) throws IOException\n    {\n        writeStartObject();\n        setCurrentValue(forValue);\n    }", "writeEndObject": "    public abstract void writeEndObject() throws IOException;\n\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to {@link #writeFieldName(String)}, main difference", "writeEmbeddedObject": "    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                this);\n    }", "writeObjectId": "    public void writeObjectId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n    }", "writeObjectRef": "    public void writeObjectRef(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n    }", "writeObject": "    public abstract void writeObject(Object pojo) throws IOException;\n\n    /**\n     * Method for writing given JSON tree (expressed as a tree\n     * where given JsonNode is the root) using this generator.\n     * This will generally just call\n     * {@link #writeObject} with given node, but is added", "writeObjectFieldStart": "    public final void writeObjectFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartObject();\n    }", "writeObjectField": "    public final void writeObjectField(String fieldName, Object pojo) throws IOException {\n        writeFieldName(fieldName);\n        writeObject(pojo);\n    }", "flush": "    public abstract void flush() throws IOException;\n\n    /**\n     * Method that can be called to determine whether this generator\n     * is closed or not. If it is closed, no more output can be done.\n     */\n    public abstract boolean isClosed();\n\n    /*\n    /**********************************************************\n    /* Closeable implementation\n    /**********************************************************\n     */\n\n    /**\n     * Method called to close this generator, so that no more content\n     * can be written.\n     *<p>\n     * Whether the underlying target (stream, writer) gets closed depends\n     * on whether this generator either manages the target (i.e. is the\n     * only one with access to the target -- case if caller passes a\n     * reference to the resource such as File, but not stream); or\n     * has feature {@link Feature#AUTO_CLOSE_TARGET} enabled.", "close": "    public abstract void close() throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used for constructing and throwing\n     * {@link JsonGenerationException} with given base message.", "_writeSimpleObject": "    protected void _writeSimpleObject(Object value)  throws IOException\n    {\n        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n         *    types even without codec. This can improve interoperability,\n         *    and specifically help with TokenBuffer.\n         */\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        if (value instanceof String) {\n            writeString((String) value);\n            return;\n        }\n        if (value instanceof Number) {\n            Number n = (Number) value;\n            if (n instanceof Integer) {\n                writeNumber(n.intValue());\n                return;\n            } else if (n instanceof Long) {\n                writeNumber(n.longValue());\n                return;\n            } else if (n instanceof Double) {\n                writeNumber(n.doubleValue());\n                return;\n            } else if (n instanceof Float) {\n                writeNumber(n.floatValue());\n                return;\n            } else if (n instanceof Short) {\n                writeNumber(n.shortValue());\n                return;\n            } else if (n instanceof Byte) {\n                writeNumber(n.byteValue());\n                return;\n            } else if (n instanceof BigInteger) {\n                writeNumber((BigInteger) n);\n                return;\n            } else if (n instanceof BigDecimal) {\n                writeNumber((BigDecimal) n);\n                return;\n\n            // then Atomic types\n            } else if (n instanceof AtomicInteger) {\n                writeNumber(((AtomicInteger) n).get());\n                return;\n            } else if (n instanceof AtomicLong) {\n                writeNumber(((AtomicLong) n).get());\n                return;\n            }\n        } else if (value instanceof byte[]) {\n            writeBinary((byte[]) value);\n            return;\n        } else if (value instanceof Boolean) {\n            writeBoolean((Boolean) value);\n            return;\n        } else if (value instanceof AtomicBoolean) {\n            writeBoolean(((AtomicBoolean) value).get());\n            return;\n        }\n        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n                +value.getClass().getName()+\")\");\n    }    "}