{"getFactoryConfig": "    public DeserializerFactoryConfig getFactoryConfig() {\n        return _factoryConfig;\n    }", "withConfig": "    protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config);\n    \n    /*\n    /********************************************************\n    /* Configuration handling: fluent factories\n    /********************************************************\n     */\n\n    /**\n     * Convenience method for creating a new factory instance with additional deserializer\n     * provider.\n     */\n    @Override\n    public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }", "withAdditionalDeserializers": "    public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalDeserializers(additional));\n    }", "withAdditionalKeyDeserializers": "    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n        return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional));\n    }", "withDeserializerModifier": "    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n        return withConfig(_factoryConfig.withDeserializerModifier(modifier));\n    }", "withAbstractTypeResolver": "    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n        return withConfig(_factoryConfig.withAbstractTypeResolver(resolver));\n    }", "mapAbstractType": "    public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException\n    {\n        // first, general mappings\n        while (true) {\n            JavaType next = _mapAbstractType2(config, type);\n            if (next == null) {\n                return type;\n            }\n            // Should not have to worry about cycles; but better verify since they will invariably occur... :-)\n            // (also: guard against invalid resolution to a non-related type)\n            Class<?> prevCls = type.getRawClass();\n            Class<?> nextCls = next.getRawClass();\n            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\");\n            }\n            type = next;\n        }\n    }", "_mapAbstractType2": "    private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n        throws JsonMappingException\n    {\n        Class<?> currClass = type.getRawClass();\n        if (_factoryConfig.hasAbstractTypeResolvers()) {\n            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n                JavaType concrete = resolver.findTypeMapping(config, type);\n                if (concrete != null && concrete.getRawClass() != currClass) {\n                    return concrete;\n                }\n            }\n        }\n        return null;\n    }", "findValueInstantiator": "    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        // [JACKSON-633] Check @JsonValueInstantiator before anything else\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            /* Second: see if some of standard Jackson/JDK types might provide value\n             * instantiators.\n             */\n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n        \n        // finally: anyone want to modify ValueInstantiator?\n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                // let's do sanity check; easier to spot buggy handlers\n                if (instantiator == null) {\n\t\t    ctxt.reportMappingException(\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        // Sanity check: does the chosen instantatior have incomplete creators?\n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }", "_findStdValueInstantiator": "    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        if (beanDesc.getBeanClass() == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        return null;\n    }", "_constructDefaultValueInstantiator": "    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        CreatorCollector creators =  new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        // need to construct suitable visibility checker:\n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n        vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n\n        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n         *  (which has creator parameters sprinkled around) with actual creator\n         *  declarations (which are needed to access creator annotation, amongst other things).\n         *  Easiest to combine that info first, then pass it to remaining processing.\n         */\n        /* 15-Mar-2015, tatu: Alas, this won't help with constructors that only have implicit\n         *   names. Those will need to be resolved later on.\n         */\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n\n        /* Important: first add factory methods; then constructors, so\n         * latter can override former!\n         */\n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        // constructors only usable on concrete types:\n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(config);\n    }", "_findCreatorsFromProperties": "    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { // since emptyMap is immutable need to create a 'real' one\n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }", "_addDeserializerConstructors": "    protected void _addDeserializerConstructors\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        // First things first: the \"default constructor\" (zero-arg\n        // constructor; whether implicit or explicit) is NOT included\n        // in list of constructors, so needs to be handled separately.\n        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n        if (defaultCtor != null) {\n            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                creators.setDefaultCreator(defaultCtor);\n            }\n        }\n\n        // may need to keep track for [#725]\n        List<AnnotatedConstructor> implicitCtors = null;\n        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n            final int argCount = ctor.getParameterCount();\n\n            // some single-arg factory methods (String, number) are auto-detected\n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n\n                if (useProps) {\n                    SettableBeanProperty[] properties = new SettableBeanProperty[1];\n                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n                    AnnotatedParameter arg = ctor.getParameter(0);\n                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                            intr.findInjectableValueId(arg));\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                } else {\n                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                            ctor, isCreator,\n                            vchecker.isCreatorVisible(ctor));\n                    // one more thing: sever link to creator property, to avoid possible later\n                    // problems with \"unresolved\" constructor property\n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                }\n                // regardless, fully handled\n                continue;\n            }\n\n            // 2 or more args; all params must have names or be injectable\n            // 14-Mar-2015, tatu (2.6): Or, as per [#725], implicit names will also\n            //   do, with some constraints. But that will require bit post processing...\n\n            AnnotatedParameter nonAnnotatedParam = null;\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int explicitNameCount = 0;\n            int implicitWithCreatorCount = 0;\n            int injectCount = 0;\n\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    continue;\n                }\n                // One more thing: implicit names are ok iff ctor has creator annotation\n                if (isCreator && (name != null && !name.isEmpty())) {\n                    ++implicitWithCreatorCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n\n            final int namedCount = explicitNameCount + implicitWithCreatorCount;\n            // Ok: if named or injectable, we have more work to do\n            if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) {\n                // simple case; everything covered:\n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    // Secondary: all but one injectable, one un-annotated (un-named)\n                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                    continue;\n                }\n                // otherwise, epic fail?\n                // 16-Mar-2015, tatu: due to [#725], need to be more permissive. For now let's\n                //    only report problem if there's no implicit name\n                PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr);\n                if (impl == null || impl.isEmpty()) {\n                    // Let's consider non-static inner class as a special case...\n                    int ix = nonAnnotatedParam.getIndex();\n                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n                        throw new IllegalArgumentException(\"Non-static inner classes like \"\n                                +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\");\n                    }\n                    throw new IllegalArgumentException(\"Argument #\"+ix\n                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n            // [#725]: as a fallback, all-implicit names may work as well\n            if (!creators.hasDefaultCreator()) {\n                if (implicitCtors == null) {\n                    implicitCtors = new LinkedList<AnnotatedConstructor>();\n                }\n                implicitCtors.add(ctor);\n            }\n        }\n        // last option, as per [#725]: consider implicit-names-only, visible constructor,\n        // if just one found\n        if ((implicitCtors != null) && !creators.hasDelegatingCreator()\n                && !creators.hasPropertyBasedCreator()) {\n            _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,\n                    creators, implicitCtors);\n        }\n    }", "_checkImplicitlyNamedConstructors": "    protected void _checkImplicitlyNamedConstructors(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            List<AnnotatedConstructor> implicitCtors) throws JsonMappingException\n    {\n        AnnotatedConstructor found = null;\n        SettableBeanProperty[] foundProps = null;\n\n        // Further checks: (a) must have names for all parameters, (b) only one visible\n        // Also, since earlier matching of properties and creators relied on existence of\n        // `@JsonCreator` (or equivalent) annotation, we need to do bit more re-inspection...\n\n        main_loop:\n        for (AnnotatedConstructor ctor : implicitCtors) {\n            if (!vchecker.isCreatorVisible(ctor)) {\n                continue;\n            }\n            // as per earlier notes, only end up here if no properties associated with creator\n            final int argCount = ctor.getParameterCount();\n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = ctor.getParameter(i);\n                final PropertyName name = _findParamName(param, intr);\n\n                // must have name (implicit fine)\n                if (name == null || name.isEmpty()) {\n                    continue main_loop;\n                }\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, param.getIndex(),\n                        param, /*injectId*/ null);\n            }\n            if (found != null) { // only one allowed\n                found = null;\n                break;\n            }\n            found = ctor;\n            foundProps = properties;\n        }\n        // found one and only one visible? Ship it!\n        if (found != null) {\n            creators.addPropertyCreator(found, /*isCreator*/ false, foundProps);\n            BasicBeanDescription bbd = (BasicBeanDescription) beanDesc;\n            // Also: add properties, to keep error messages complete wrt known properties...\n            for (SettableBeanProperty prop : foundProps) {\n                PropertyName pn = prop.getFullName();\n                if (!bbd.hasProperty(pn)) {\n                    BeanPropertyDefinition newDef = SimpleBeanPropertyDefinition.construct(\n                            ctxt.getConfig(), prop.getMember(), pn);\n                    bbd.addProperty(newDef);\n                }\n            }\n        }\n    }", "_checkIfCreatorPropertyBased": "    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n\n        if (mode == JsonCreator.Mode.PROPERTIES) {\n            return true;\n        }\n        if (mode == JsonCreator.Mode.DELEGATING) {\n            return false;\n        }\n        // If explicit name, or inject id, property-based\n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        // in absence of everything else, default to delegating\n        return false;\n    }", "_handleSingleArgumentConstructor": "    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n        throws JsonMappingException\n    {\n        // otherwise either 'simple' number, String, or general delegate:\n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        // Delegating Creator ok iff it has @JsonCreator (etc)\n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null);\n            return true;\n        }\n        return false;\n    }", "_addDeserializerFactoryMethods": "    protected void _addDeserializerFactoryMethods\n        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n         AnnotationIntrospector intr, CreatorCollector creators,\n         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n            final int argCount = factory.getParameterCount();\n            // zero-arg methods must be annotated; if so, are \"default creators\" [JACKSON-850]\n            if (argCount == 0) {\n                if (isCreator) {\n                    creators.setDefaultCreator(factory);\n                }\n                continue;\n            }\n\n            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n            // some single-arg factory methods (String, number) are auto-detected\n            if (argCount == 1) {\n                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n                if (!useProps) { // not property based but delegating\n                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                            factory, isCreator);\n                    // 23-Sep-2016, tatu: [databind#1383]: Need to also sever link to avoid possible\n                    //    later problems with \"unresolved\" constructor property\n                    if (argDef != null) {\n                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                    }\n                    continue;\n                }\n                // fall through if there's name\n            } else {\n                // more than 2 args, must have @JsonCreator\n                if (!isCreator) {\n                    continue;\n                }\n            }\n            // 1 or more args; all params must have name annotations\n            AnnotatedParameter nonAnnotatedParam = null;            \n            SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n            int implicitNameCount = 0;\n            int explicitNameCount = 0;\n            int injectCount = 0;\n            \n            for (int i = 0; i < argCount; ++i) {\n                final AnnotatedParameter param = factory.getParameter(i);\n                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                Object injectId = intr.findInjectableValueId(param);\n                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n\n                if (propDef != null && propDef.isExplicitlyNamed()) {\n                    ++explicitNameCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                if (injectId != null) {\n                    ++injectCount;\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                    continue;\n                }\n                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++implicitNameCount;\n                    continue;\n                }\n                // One more thing: implicit names are ok iff ctor has creator annotation\n                if (isCreator) {\n                    if (name != null && !name.isEmpty()) {\n                        ++implicitNameCount;\n                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                        continue;\n                    }\n                }\n                /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n                 *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n                 *  let's add one more work around\n                 */\n                /*\n                PropertyName name2 = _findExplicitParamName(param, intr);\n                if (name2 != null && !name2.isEmpty()) {\n                    // Hmmh. Ok, fine. So what are we to do with it... ?\n                    // For now... skip. May need to revisit this, should this become problematic\n                    continue main_loop;\n                }\n                */\n                if (nonAnnotatedParam == null) {\n                    nonAnnotatedParam = param;\n                }\n            }\n            final int namedCount = explicitNameCount + implicitNameCount;\n            \n            // Ok: if named or injectable, we have more work to do\n            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                // simple case; everything covered:\n                if ((namedCount + injectCount) == argCount) {\n                    creators.addPropertyCreator(factory, isCreator, properties);\n                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n                    creators.addDelegatingCreator(factory, isCreator, properties);\n                } else { // otherwise, epic fail\n                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                }\n            }\n        }\n    }", "_handleSingleArgumentFactory": "    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n            AnnotationIntrospector intr, CreatorCollector creators,\n            AnnotatedMethod factory, boolean isCreator)\n        throws JsonMappingException\n    {\n        Class<?> type = factory.getRawParameterType(0);\n        \n        if (type == String.class || type == CharSequence.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addStringCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addIntCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addLongCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addDoubleCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || vchecker.isCreatorVisible(factory)) {\n                creators.addBooleanCreator(factory, isCreator);\n            }\n            return true;\n        }\n        if (isCreator) {\n            creators.addDelegatingCreator(factory, isCreator, null);\n            return true;\n        }\n        return false;\n    }", "_findParamName": "    protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            // 14-Apr-2014, tatu: Need to also consider possible implicit name\n            //  (for JDK8, or via paranamer)\n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }", "_findImplicitParamName": "    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        String str = intr.findImplicitPropertyName(param);\n        if (str != null && !str.isEmpty()) {\n            return PropertyName.construct(str);\n        }\n        return null;\n    }", "_findExplicitParamName": "    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            return intr.findNameForDeserialization(param);\n        }\n        return null;\n    }", "createArrayDeserializer": "    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n            ArrayType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType elemType = type.getContentType();\n        \n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (elemTypeDeser == null) {\n            elemTypeDeser = findTypeDeserializer(config, elemType);\n        }\n        // 23-Nov-2010, tatu: Custom array deserializer?\n        JsonDeserializer<?>  deser = _findCustomArrayDeserializer(type,\n                config, beanDesc, elemTypeDeser, contentDeser);\n        if (deser == null) {\n            if (contentDeser == null) {\n                Class<?> raw = elemType.getRawClass();\n                if (elemType.isPrimitive()) {\n                    return PrimitiveArrayDeserializers.forType(raw);\n                } else if (raw == String.class) {\n                    return StringArrayDeserializer.instance;\n                }\n            }\n            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n        }\n        // and then new with 2.2: ability to post-process it too (Issue#120)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }", "createCollectionDeserializer": "    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n            CollectionType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type,\n                config, beanDesc, contentTypeDeser, contentDeser);\n        if (deser == null) {\n            Class<?> collectionClass = type.getRawClass();\n            if (contentDeser == null) { // not defined by annotation\n                // One special type: EnumSet:\n                if (EnumSet.class.isAssignableFrom(collectionClass)) {\n                    deser = new EnumSetDeserializer(contentType, null);\n                }\n            }\n        }\n\n        /* One twist: if we are being asked to instantiate an interface or\n         * abstract Collection, we need to either find something that implements\n         * the thing, or give up.\n         *\n         * Note that we do NOT try to guess based on secondary interfaces\n         * here; that would probably not work correctly since casts would\n         * fail later on (as the primary type is not the interface we'd\n         * be implementing)\n         */\n        if (deser == null) {\n            if (type.isInterface() || type.isAbstract()) {\n                CollectionType implType = _mapAbstractCollectionType(type, config);\n                if (implType == null) {\n                    // [databind#292]: Actually, may be fine, but only if polymorphich deser enabled\n                    if (type.getTypeHandler() == null) {\n                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                    }\n                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                } else {\n                    type = implType;\n                    // But if so, also need to re-check creators...\n                    beanDesc = config.introspectForCreation(type);\n                }\n            }\n            if (deser == null) {\n                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                if (!inst.canCreateUsingDefault()) {\n                    // [databind#161]: No default constructor for ArrayBlockingQueue...\n                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);\n                    }\n                }\n                // Can use more optimal deserializer if content type is String, so:\n                if (contentType.getRawClass() == String.class) {\n                    // no value type deserializer because Strings are one of natural/native types:\n                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n                } else {\n                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n                }\n            }\n        }\n        // allow post-processing it too\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }", "_mapAbstractCollectionType": "    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)\n    {\n        Class<?> collectionClass = type.getRawClass();\n        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n        if (collectionClass == null) {\n            return null;\n        }\n        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n    }", "createCollectionLikeDeserializer": "    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n            CollectionLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n        if (deser != null) {\n            // and then new with 2.2: ability to post-process it too (Issue#120)\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }", "createMapDeserializer": "    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n            MapType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n\n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        // Then optional type info; either attached to type, or resolved separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                keyDes, contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            // Value handling is identical for all, but EnumMap requires special handling for keys\n            Class<?> mapClass = type.getRawClass();\n            if (EnumMap.class.isAssignableFrom(mapClass)) {\n                Class<?> kt = keyType.getRawClass();\n                if (kt == null || !kt.isEnum()) {\n                    throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                }\n                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n            }\n\n            // Otherwise, generic handler works ok.\n    \n            /* But there is one more twist: if we are being asked to instantiate\n             * an interface or abstract Map, we need to either find something\n             * that implements the thing, or give up.\n             *\n             * Note that we do NOT try to guess based on secondary interfaces\n             * here; that would probably not work correctly since casts would\n             * fail later on (as the primary type is not the interface we'd\n             * be implementing)\n             */\n            if (deser == null) {\n                if (type.isInterface() || type.isAbstract()) {\n                    @SuppressWarnings(\"rawtypes\")\n                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n                    if (fallback != null) {\n                        mapClass = fallback;\n                        type = (MapType) config.constructSpecializedType(type, mapClass);\n                        // But if so, also need to re-check creators...\n                        beanDesc = config.introspectForCreation(type);\n                    } else {\n                        // [databind#292]: Actually, may be fine, but only if polymorphic deser enabled\n                        if (type.getTypeHandler() == null) {\n                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n                        }\n                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                    }\n                }\n                if (deser == null) {\n                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n                    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n                    //   most often it ought to be `Map` or `EnumMap`, but due to abstract\n                    //   mapping it will more likely be concrete type like `HashMap`.\n                    //   So, for time being, just pass `Map.class`\n                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,\n                            beanDesc.getClassInfo());\n                    Set<String> ignored = (ignorals == null) ? null\n                            : ignorals.findIgnoredForDeserialization();\n                    md.setIgnorableProperties(ignored);\n                    deser = md;\n                }\n            }\n        }\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }", "createMapLikeDeserializer": "    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n            MapLikeType type, final BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType keyType = type.getKeyType();\n        JavaType contentType = type.getContentType();\n        final DeserializationConfig config = ctxt.getConfig();\n        \n        // First: is there annotation-specified deserializer for values?\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n        \n        // Ok: need a key deserializer (null indicates 'default' here)\n        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n        /* !!! 24-Jan-2012, tatu: NOTE: impls MUST use resolve() to find key deserializer!\n        if (keyDes == null) {\n            keyDes = p.findKeyDeserializer(config, keyType, property);\n        }\n        */\n        // Then optional type info (1.5); either attached to type, or resolve separately:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        // but if not, may still be possible to find:\n        if (contentTypeDeser == null) {\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config,\n                beanDesc, keyDes, contentTypeDeser, contentDeser);\n        if (deser != null) {\n            // and then new with 2.2: ability to post-process it too (Issue#120)\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }", "createEnumDeserializer": "    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final Class<?> enumClass = type.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n\n        if (deser == null) {\n            ValueInstantiator valueInstantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            SettableBeanProperty[] creatorProps = (valueInstantiator == null) ? null\n                    : valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            // May have @JsonCreator for static factory method:\n            for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n                if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                    if (factory.getParameterCount() == 0) { // [databind#960]\n                        deser = EnumDeserializer.deserializerForNoArgsCreator(config, enumClass, factory);\n                        break;\n                    }\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory, valueInstantiator, creatorProps);\n                        break;\n                    }\n                }\n            }\n           \n            // Need to consider @JsonValue if one found\n            if (deser == null) {\n                deser = new EnumDeserializer(constructEnumResolver(enumClass,\n                        config, beanDesc.findJsonValueMethod()));\n            }\n        }\n\n        // and then post-process it too\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser);\n            }\n        }\n        return deser;\n    }", "createTreeDeserializer": "    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n            JavaType nodeType, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        @SuppressWarnings(\"unchecked\")\n        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n        // 23-Nov-2010, tatu: Custom deserializer?\n        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config,\n                beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        return JsonNodeDeserializer.getDeserializer(nodeClass);\n    }", "createReferenceDeserializer": "    public JsonDeserializer<?> createReferenceDeserializer(DeserializationContext ctxt,\n            ReferenceType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        JavaType contentType = type.getContentType();\n        // Very first thing: is deserializer hard-coded for elements?\n        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n        final DeserializationConfig config = ctxt.getConfig();\n        // Then optional type info: if type has been resolved, we may already know type deserializer:\n        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n        if (contentTypeDeser == null) { // or if not, may be able to find:\n            contentTypeDeser = findTypeDeserializer(config, contentType);\n        }\n        JsonDeserializer<?> deser = _findCustomReferenceDeserializer(type, config, beanDesc,\n                contentTypeDeser, contentDeser);\n\n        if (deser == null) {\n            // Just one referential type as of JDK 1.7 / Java 7: AtomicReference (Java 8 adds Optional)\n            if (AtomicReference.class.isAssignableFrom(type.getRawClass())) {\n                return new AtomicReferenceDeserializer(type, contentTypeDeser, contentDeser);\n            }\n        }\n        if (deser != null) {\n            // and then post-process\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyReferenceDeserializer(config, type, beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }", "findTypeDeserializer": "    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        /* Ok: if there is no explicit type info handler, we may want to\n         * use a default. If so, config object knows what to use.\n         */\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }", "findOptionalStdDeserializer": "    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n    }", "createKeyDeserializer": "    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                return _createEnumKeyDeserializer(ctxt, type);\n            }\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }", "_createEnumKeyDeserializer": "    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        Class<?> enumClass = type.getRawClass();\n\n        BeanDescription beanDesc = config.introspect(type);\n        // 24-Sep-2015, bim: a key deserializer is the preferred thing.\n        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n        if (des != null) {\n            return des;\n        } else {\n            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.\n            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);\n            if (custom != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);\n            }\n            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n            if (valueDesForKey != null) {\n                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);\n            }\n        }\n        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n        // May have @JsonCreator for static factory method:\n        final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n            if (ai.hasCreatorAnnotation(factory)) {\n                int argCount = factory.getParameterCount();\n                if (argCount == 1) {\n                    Class<?> returnType = factory.getRawReturnType();\n                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                    if (returnType.isAssignableFrom(enumClass)) {\n                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n                        if (factory.getRawParameterType(0) != String.class) {\n                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n                        }\n                        if (config.canOverrideAccessModifiers()) {\n                            ClassUtil.checkAndFixAccess(factory.getMember(),\n                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                        }\n                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n                    }\n                }\n                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n                        +enumClass.getName()+\")\");\n            }\n        }\n        // Also, need to consider @JsonValue, if one found\n        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n    }", "findPropertyTypeDeserializer": "    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config,\n            JavaType baseType, AnnotatedMember annotated)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n        // Defaulting: if no annotations on member, check value class\n        if (b == null) {\n            return findTypeDeserializer(config, baseType);\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, annotated, baseType);\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    }", "findPropertyContentTypeDeserializer": "    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config,\n            JavaType containerType, AnnotatedMember propertyEntity)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n        JavaType contentType = containerType.getContentType();\n        // Defaulting: if no annotations on member, check class\n        if (b == null) {\n            return findTypeDeserializer(config, contentType);\n        }\n        // but if annotations found, may need to resolve subtypes:\n        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                config, propertyEntity, contentType);\n        return b.buildTypeDeserializer(config, contentType, subtypes);\n    }", "findDefaultDeserializer": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        // Object (\"untyped\"), String equivalents:\n        if (rawType == CLASS_OBJECT) {\n            // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.\n            DeserializationConfig config = ctxt.getConfig();\n            JavaType lt, mt;\n            \n            if (_factoryConfig.hasAbstractTypeResolvers()) {\n                lt = _findRemappedType(config, List.class);\n                mt = _findRemappedType(config, Map.class);\n            } else {\n                lt = mt = null;\n            }\n            return new UntypedObjectDeserializer(lt, mt);\n        }\n        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n            return StringDeserializer.instance;\n        }\n        if (rawType == CLASS_ITERABLE) {\n            // [databind#199]: Can and should 'upgrade' to a Collection type:\n            TypeFactory tf = ctxt.getTypeFactory();\n            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n            // Should we re-introspect beanDesc? For now let's not...\n            return createCollectionDeserializer(ctxt, ct, beanDesc);\n        }\n        if (rawType == CLASS_MAP_ENTRY) {\n            // 28-Apr-2015, tatu: TypeFactory does it all for us already so\n            JavaType kt = type.containedType(0);\n            if (kt == null) {\n                kt = TypeFactory.unknownType();\n            }\n            JavaType vt = type.containedType(1);\n            if (vt == null) {\n                vt = TypeFactory.unknownType();\n            }\n            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n            if (vts == null) {\n                vts = findTypeDeserializer(ctxt.getConfig(), vt);\n            }\n            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n        }\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n            }\n            if (deser != null) {\n                return deser;\n            }\n        }\n        // and a few Jackson types as well:\n        if (rawType == TokenBuffer.class) {\n            return new TokenBufferDeserializer();\n        }\n        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n        return JdkDeserializers.find(rawType, clsName);\n    }", "_findRemappedType": "    protected JavaType _findRemappedType(DeserializationConfig config, Class<?> rawType) throws JsonMappingException {\n        JavaType type = mapAbstractType(config, config.constructType(rawType));\n        return (type == null || type.hasRawClass(rawType)) ? null : type;\n    }", "_findCustomTreeNodeDeserializer": "    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomReferenceDeserializer": "    protected JsonDeserializer<?> _findCustomReferenceDeserializer(ReferenceType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer contentTypeDeserializer, JsonDeserializer<?> contentDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findReferenceDeserializer(type, config, beanDesc,\n                    contentTypeDeserializer, contentDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomBeanDeserializer": "    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return (JsonDeserializer<Object>) deser;\n            }\n        }\n        return null;\n    }", "_findCustomArrayDeserializer": "    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n                    beanDesc, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomCollectionDeserializer": "    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomCollectionLikeDeserializer": "    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n                    elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomEnumDeserializer": "    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n            DeserializationConfig config, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomMapDeserializer": "    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "_findCustomMapLikeDeserializer": "    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n            DeserializationConfig config, BeanDescription beanDesc,\n            KeyDeserializer keyDeserializer,\n            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n        throws JsonMappingException\n    {\n        for (Deserializers d  : _factoryConfig.deserializers()) {\n            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n            if (deser != null) {\n                return deser;\n            }\n        }\n        return null;\n    }", "findDeserializerFromAnnotation": "    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.deserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }", "findKeyDeserializerFromAnnotation": "    protected KeyDeserializer findKeyDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n            throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            Object deserDef = intr.findKeyDeserializer(ann);\n            if (deserDef != null) {\n                return ctxt.keyDeserializerInstance(ann, deserDef);\n            }\n        }\n        return null;\n    }", "resolveMemberAndTypeAnnotations": "    protected JavaType resolveMemberAndTypeAnnotations(DeserializationContext ctxt,\n            AnnotatedMember member, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        // First things first: see if we can find annotations on declared\n        // type\n\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            if (keyType != null) {\n                Object kdDef = intr.findKeyDeserializer(member);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);\n                if (kd != null) {\n                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }\n        }\n\n        if (type.hasContentType()) { // that is, is either container- or reference-type\n            Object cdDef = intr.findContentDeserializer(member);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n            if (cd != null) {\n                type = type.withContentValueHandler(cd);\n            }\n            TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n                    ctxt.getConfig(), type, (AnnotatedMember) member);            \t\n            if (contentTypeDeser != null) {\n                type = type.withContentTypeHandler(contentTypeDeser);\n            }\n        }\n        TypeDeserializer valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n                    type, (AnnotatedMember) member);\n        if (valueTypeDeser != null) {\n            type = type.withTypeHandler(valueTypeDeser);\n        }\n\n        // Second part: find actual type-override annotations on member, if any\n\n        // 18-Jun-2016, tatu: Should we re-do checks for annotations on refined\n        //   subtypes as well? Code pre-2.8 did not do this, but if we get bug\n        //   reports may need to consider\n        type = intr.refineDeserializationType(ctxt.getConfig(), member, type);\n        return type;\n    }", "modifyTypeByAnnotation": "    protected JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        // First, deserializers for key/value types?\n        /*\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n            //  (not 100% why or how, but this does seem to get called more than once, which\n            //   is not good: for now, let's just avoid errors)\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n           // ... as well as deserializer for contents:\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        */\n        // then: type refinement(s)?\n        return intr.refineDeserializationType(ctxt.getConfig(), a, type);\n    }", "resolveType": "    protected JavaType resolveType(DeserializationContext ctxt,\n            BeanDescription beanDesc, JavaType type, AnnotatedMember member)\n        throws JsonMappingException\n    {\n        return resolveMemberAndTypeAnnotations(ctxt, member, type);\n    }", "_findJsonValueFor": "    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)\n    {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }"}