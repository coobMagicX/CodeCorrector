{"connect": "    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }", "encodeUrl": "    static URL encodeUrl(URL u) {\n        try {\n            //  odd way to encode urls, but it works!\n            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)\n            urlS = urlS.replaceAll(\" \", \"%20\");\n            final URI uri = new URI(urlS);\n            return new URL(uri.toASCIIString());\n        } catch (Exception e) {\n            return u;\n        }\n    }", "encodeMimeName": "    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }", "url": "        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }", "proxy": "        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }", "timeout": "        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }", "maxBodySize": "        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }", "followRedirects": "        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }", "referrer": "    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }", "method": "        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }", "ignoreHttpErrors": "        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }", "ignoreContentType": "        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }", "data": "        public Collection<Connection.KeyVal> data() {\n            return data;\n        }", "sslSocketFactory": "        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }", "requestBody": "        public String requestBody() {\n            return body;\n        }", "header": "        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            addHeader(name, value);\n            return (T) this;\n        }", "headers": "        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }", "cookie": "        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }", "cookies": "        public Map<String, String> cookies() {\n            return cookies;\n        }", "parser": "        public Parser parser() {\n            return parser;\n        }", "get": "    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }", "post": "    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }", "execute": "        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            Validate.notNull(req.url(), \"URL must be specified to connect\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(encodeUrl(redir));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    res.bodyStream = null;\n                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\")) {\n                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n                    } else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\")) {\n                        res.bodyStream = new InflaterInputStream(res.bodyStream, new Inflater(true));\n                    }\n                    res.bodyStream = ConstrainableInputStream\n                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout())\n                    ;\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e){\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n                throw e;\n            }\n\n            res.executed = true;\n            return res;\n        }", "request": "    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }", "response": "    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }", "postDataCharset": "        public String postDataCharset() {\n            return postDataCharset;\n        }", "fixHeaderEncoding": "        private static String fixHeaderEncoding(String val) {\n            try {\n                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n                if (!looksLikeUtf8(bytes))\n                    return val;\n                return new String(bytes, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                // shouldn't happen as these both always exist\n                return val;\n            }\n        }", "looksLikeUtf8": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }", "hasHeaderWithValue": "        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }", "removeHeader": "        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }", "multiHeaders": "        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }", "getHeadersCaseInsensitive": "        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }", "hasCookie": "        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }", "removeCookie": "        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }", "statusCode": "        public int statusCode() {\n            return statusCode;\n        }", "charset": "        public Response charset(String charset) {\n            this.charset = charset;\n            return this;\n        }", "contentType": "        public String contentType() {\n            return contentType;\n        }", "parse": "        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                bodyStream = new ByteArrayInputStream(byteData.array());\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            inputStreamRead = true;\n            safeClose();\n            return doc;\n        }", "body": "        public String body() {\n            prepareByteData();\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body;\n            if (charset == null)\n                body = Charset.forName(DataUtil.defaultCharset).decode(byteData).toString();\n            else\n                body = Charset.forName(charset).decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }", "bodyAsBytes": "        public byte[] bodyAsBytes() {\n            prepareByteData();\n            return byteData.array();\n        }", "bodyStream": "        public BufferedInputStream bodyStream() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            inputStreamRead = true;\n            return ConstrainableInputStream.wrap(bodyStream, DataUtil.bufferSize, req.maxBodySize());\n        }", "createConnection": "        private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n            final HttpURLConnection conn = (HttpURLConnection) (\n                req.proxy() == null ?\n                req.url().openConnection() :\n                req.url().openConnection(req.proxy())\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            if (req.cookies().size() > 0)\n                conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }", "safeClose": "        private void safeClose() {\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n        }", "setupFromConnection": "        private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException {\n            this.conn = conn;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders);\n\n            // if from a redirect, map previous response cookies into this response\n            if (previousResponse != null) {\n                for (Map.Entry<String, String> prevCookie : previousResponse.cookies().entrySet()) {\n                    if (!hasCookie(prevCookie.getKey()))\n                        cookie(prevCookie.getKey(), prevCookie.getValue());\n                }\n                previousResponse.safeClose();\n            }\n        }", "processResponseHeaders": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                }\n                for (String value : values) {\n                    addHeader(name, value);\n                }\n            }\n        }", "setOutputContentType": "        private static String setOutputContentType(final Connection.Request req) {\n            String bound = null;\n            if (req.hasHeader(CONTENT_TYPE)) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset\n\n                // if user has set content type to multipart/form-data, auto add boundary.\n                if(req.header(CONTENT_TYPE).contains(MULTIPART_FORM_DATA) &&\n                        !req.header(CONTENT_TYPE).contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }", "writePost": "        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n\n            if (bound != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(bound);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    if (keyVal.hasInputStream()) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        w.write(keyVal.contentType() != null ? keyVal.contentType() : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(bound);\n                w.write(\"--\");\n            } else if (req.requestBody() != null) {\n                // data will be in query string, we're sending a plaintext body\n                w.write(req.requestBody());\n            }\n            else {\n                // regular form data (application/x-www-form-urlencoded)\n                boolean first = true;\n                for (Connection.KeyVal keyVal : data) {\n                    if (!first)\n                        w.append('&');\n                    else\n                        first = false;\n\n                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                    w.write('=');\n                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                }\n            }\n            w.close();\n        }", "getRequestCookieString": "        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = StringUtil.borrowBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                // todo: spec says only ascii, no escaping / encoding defined. validate on set? or escape somehow here?\n            }\n            return StringUtil.releaseBuilder(sb);\n        }", "serialiseRequestUrl": "        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            URL in = req.url();\n            StringBuilder url = StringUtil.borrowBuilder();\n            boolean first = true;\n            // reconstitute the query, ready for appends\n            url\n                .append(in.getProtocol())\n                .append(\"://\")\n                .append(in.getAuthority()) // includes host, port\n                .append(in.getPath())\n                .append(\"?\");\n            if (in.getQuery() != null) {\n                url.append(in.getQuery());\n                first = false;\n            }\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                if (!first)\n                    url.append('&');\n                else\n                    first = false;\n                url\n                    .append(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset))\n                    .append('=')\n                    .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n            }\n            req.url(new URL(StringUtil.releaseBuilder(url)));\n            req.data().clear(); // moved into url as get params\n        }", "needsMultipart": "    private static boolean needsMultipart(Connection.Request req) {\n        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }", "create": "        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }", "key": "        public String key() {\n            return key;\n        }", "value": "        public String value() {\n            return value;\n        }", "inputStream": "        public InputStream inputStream() {\n            return stream;\n        }", "hasInputStream": "        public boolean hasInputStream() {\n            return stream != null;\n        }", "toString": "        public String toString() {\n            return key + \"=\" + value;\n        }"}