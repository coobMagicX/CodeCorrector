{"getNextZipEntry": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n        }\n        byte[] lfh = new byte[LFH_LEN];\n        try {\n            readFully(lfh);\n        } catch (EOFException e) {\n            return null;\n        }\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.CFH_SIG)) {\n            hitCentralDirectory = true;\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(lfh, off);\n        off += SHORT;\n        current.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                            & ZipFile.NIBLET_MASK);\n\n        final int generalPurposeFlag = ZipShort.getValue(lfh, off);\n        final boolean hasEFS = \n            (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0;\n        final ZipEncoding entryEncoding =\n            hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        hasDataDescriptor = (generalPurposeFlag & 8) != 0;\n\n        off += SHORT;\n\n        current.setMethod(ZipShort.getValue(lfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n        current.setTime(time);\n        off += WORD;\n\n        if (!hasDataDescriptor) {\n            current.setCrc(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            current.setCompressedSize(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            current.setSize(ZipLong.getValue(lfh, off));\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(lfh, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(lfh, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.setName(entryEncoding.decode(fileName));\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.setExtra(extraData);\n\n        if (!hasEFS && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current, fileName, null);\n        }\n        return current;\n    }", "getNextEntry": "    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }", "read": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0 && inf.finished()) {\n                return -1;\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }", "close": "    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n        }\n    }", "skip": "    public long skip(long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            byte[] b = new byte[1024];\n            while (skipped != value) {\n                long rem = value - skipped;\n                int x = read(b, 0, (int) (b.length > rem ? rem : b.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }", "matches": "    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG); // empty zip\n    }", "checksig": "    private static boolean checksig(byte[] signature, byte[] expected){\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;        \n    }", "closeEntry": "    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n        // Ensure all entry bytes are read\n        skip(Long.MAX_VALUE);\n        int inB;\n        if (current.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            inB = inf.getTotalIn();\n        } else {\n            inB = readBytesOfEntry;\n        }\n        int diff = 0;\n\n        // Pushback any required bytes\n        if ((diff = bytesReadFromStream - inB) != 0) {\n            ((PushbackInputStream) in).unread(buf,\n                                              lengthOfLastRead - diff, diff);\n        }\n\n        if (hasDataDescriptor) {\n            readFully(new byte[4 * WORD]);\n        }\n\n        inf.reset();\n        readBytesOfEntry = offsetInBuffer = bytesReadFromStream =\n            lengthOfLastRead = 0;\n        crc.reset();\n        current = null;\n    }", "fill": "    private void fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if ((lengthOfLastRead = in.read(buf)) > 0) {\n            inf.setInput(buf, 0, lengthOfLastRead);\n        }\n    }", "readFully": "    private void readFully(byte[] b) throws IOException {\n        int count = 0, x = 0;\n        while (count != b.length) {\n            count += x = in.read(b, count, b.length - count);\n            if (x == -1) {\n                throw new EOFException();\n            }\n        }\n    }"}