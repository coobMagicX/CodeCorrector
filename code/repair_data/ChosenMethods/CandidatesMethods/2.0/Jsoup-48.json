{"connect": "    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }", "encodeMimeName": "    private static String encodeMimeName(String val) {\n        if (val == null)\n            return null;\n        return val.replaceAll(\"\\\"\", \"%22\");\n    }", "url": "        public T url(URL url) {\n            Validate.notNull(url, \"URL must not be null\");\n            this.url = url;\n            return (T) this;\n        }", "timeout": "        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }", "referrer": "    public Connection referrer(String referrer) {\n        Validate.notNull(referrer, \"Referrer must not be null\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }", "method": "        public T method(Method method) {\n            Validate.notNull(method, \"Method must not be null\");\n            this.method = method;\n            return (T) this;\n        }", "data": "        public Collection<Connection.KeyVal> data() {\n            return data;\n        }", "header": "        public T header(String name, String value) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Validate.notNull(value, \"Header value must not be null\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            headers.put(name, value);\n            return (T) this;\n        }", "cookie": "        public T cookie(String name, String value) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            Validate.notNull(value, \"Cookie value must not be null\");\n            cookies.put(name, value);\n            return (T) this;\n        }", "cookies": "        public Map<String, String> cookies() {\n            return cookies;\n        }", "parser": "        public Parser parser() {\n            return parser;\n        }", "get": "    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        return res.parse();\n    }", "post": "    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        return res.parse();\n    }", "execute": "        static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n            Validate.notNull(req, \"Request must not be null\");\n            String protocol = req.url().getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (!req.method().hasBody() && req.data().size() > 0) {\n                serialiseRequestUrl(req); // appends query string\n            } else if (req.method().hasBody()) {\n                mimeBoundary = setOutputContentType(req);\n            }\n            HttpURLConnection conn = createConnection(req);\n            Response res;\n            try {\n                conn.connect();\n                if (conn.getDoOutput())\n                    writePost(req, conn.getOutputStream(), mimeBoundary);\n\n                int status = conn.getResponseCode();\n                res = new Response(previousResponse);\n                res.setupFromConnection(conn, previousResponse);\n                res.req = req;\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                    req.data().clear();\n\n                    String location = res.header(LOCATION);\n                    if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n\n                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                        req.cookie(cookie.getKey(), cookie.getValue());\n                    }\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n                        req.parser(Parser.xmlParser());\n                    }\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream bodyStream = null;\n                    InputStream dataStream = null;\n                    try {\n                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                                new BufferedInputStream(dataStream);\n\n                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                    } finally {\n                        if (bodyStream != null) bodyStream.close();\n                        if (dataStream != null) dataStream.close();\n                    }\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } finally {\n                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                // connection errors will not be released quickly enough and can cause a too many open files error.\n                conn.disconnect();\n            }\n\n            res.executed = true;\n            return res;\n        }", "request": "    public Connection request(Connection.Request request) {\n        req = request;\n        return this;\n    }", "response": "    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }", "hasHeader": "        public boolean hasHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            return getHeaderCaseInsensitive(name) != null;\n        }", "hasHeaderWithValue": "        public boolean hasHeaderWithValue(String name, String value) {\n            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n        }", "removeHeader": "        public T removeHeader(String name) {\n            Validate.notEmpty(name, \"Header name must not be empty\");\n            Map.Entry<String, String> entry = scanHeaders(name); // remove is case insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }", "headers": "        public Map<String, String> headers() {\n            return headers;\n        }", "getHeaderCaseInsensitive": "        private String getHeaderCaseInsensitive(String name) {\n            Validate.notNull(name, \"Header name must not be null\");\n            // quick evals for common case of title case, lower case, then scan for mixed\n            String value = headers.get(name);\n            if (value == null)\n                value = headers.get(name.toLowerCase());\n            if (value == null) {\n                Map.Entry<String, String> entry = scanHeaders(name);\n                if (entry != null)\n                    value = entry.getValue();\n            }\n            return value;\n        }", "scanHeaders": "        private Map.Entry<String, String> scanHeaders(String name) {\n            String lc = name.toLowerCase();\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(lc))\n                    return entry;\n            }\n            return null;\n        }", "hasCookie": "        public boolean hasCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            return cookies.containsKey(name);\n        }", "removeCookie": "        public T removeCookie(String name) {\n            Validate.notEmpty(name, \"Cookie name must not be empty\");\n            cookies.remove(name);\n            return (T) this;\n        }", "charset": "        public String charset() {\n            return charset;\n        }", "parse": "        public Document parse() throws IOException {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n            byteData.rewind();\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            return doc;\n        }", "body": "        public String body() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body;\n            if (charset == null)\n                body = Charset.forName(DataUtil.defaultCharset).decode(byteData).toString();\n            else\n                body = Charset.forName(charset).decode(byteData).toString();\n            byteData.rewind();\n            return body;\n        }", "getInsecureVerifier": "        private static HostnameVerifier getInsecureVerifier() {\n            return new HostnameVerifier() {\n                public boolean verify(String urlHostName, SSLSession session) {\n                    return true;\n                }\n            };\n        }", "createHeaderMap": "        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                if (headers.containsKey(key))\n                    headers.get(key).add(val);\n                else {\n                    final ArrayList<String> vals = new ArrayList<String>();\n                    vals.add(val);\n                    headers.put(key, vals);\n                }\n            }\n            return headers;\n        }", "processResponseHeaders": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    if (!values.isEmpty())\n                        header(name, values.get(0));\n                }\n            }\n        }", "getRequestCookieString": "        private static String getRequestCookieString(Connection.Request req) {\n            StringBuilder sb = new StringBuilder();\n            boolean first = true;\n            for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                if (!first)\n                    sb.append(\"; \");\n                else\n                    first = false;\n                sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                // todo: spec says only ascii, no escaping / encoding defined. validate on set? or escape somehow here?\n            }\n            return sb.toString();\n        }", "create": "        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal().key(key).value(filename).inputStream(stream);\n        }", "key": "        public String key() {\n            return key;\n        }", "value": "        public String value() {\n            return value;\n        }", "toString": "        public String toString() {\n            return key + \"=\" + value;\n        }"}