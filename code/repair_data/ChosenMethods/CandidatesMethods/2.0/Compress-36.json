{"close": "    public void close() throws IOException {\n        if (file != null) {\n            try {\n                file.close();\n            } finally {\n                file = null;\n                if (password != null) {\n                    Arrays.fill(password, (byte) 0);\n                }\n                password = null;\n            }\n        }\n    }", "getNextEntry": "    public SevenZArchiveEntry getNextEntry() throws IOException {\n        if (currentEntryIndex >= archive.files.length - 1) {\n            return null;\n        }\n        ++currentEntryIndex;\n        final SevenZArchiveEntry entry = archive.files[currentEntryIndex];\n        buildDecodingStream();\n        return entry;\n    }", "getEntries": "    public Iterable<SevenZArchiveEntry> getEntries() {\n        return Arrays.asList(archive.files);\n    }", "readStreamsInfo": "    private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        int nid = header.readUnsignedByte();\n        \n        if (nid == NID.kPackInfo) {\n            readPackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid == NID.kUnpackInfo) {\n            readUnpackInfo(header, archive);\n            nid = header.readUnsignedByte();\n        } else {\n            // archive without unpack/coders info\n            archive.folders = new Folder[0];\n        }\n        \n        if (nid == NID.kSubStreamsInfo) {\n            readSubStreamsInfo(header, archive);\n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated StreamsInfo\");\n        }\n    }", "readSubStreamsInfo": "    private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\n        for (final Folder folder : archive.folders) {\n            folder.numUnpackSubStreams = 1;\n        }\n        int totalUnpackStreams = archive.folders.length;\n        \n        int nid = header.readUnsignedByte();\n        if (nid == NID.kNumUnpackStream) {\n            totalUnpackStreams = 0;\n            for (final Folder folder : archive.folders) {\n                final long numStreams = readUint64(header);\n                folder.numUnpackSubStreams = (int)numStreams;\n                totalUnpackStreams += numStreams;\n            }\n            nid = header.readUnsignedByte();\n        }\n        \n        final SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\n        subStreamsInfo.unpackSizes = new long[totalUnpackStreams];\n        subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\n        subStreamsInfo.crcs = new long[totalUnpackStreams];\n        \n        int nextUnpackStream = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams == 0) {\n                continue;\n            }\n            long sum = 0;\n            if (nid == NID.kSize) {\n                for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {\n                    final long size = readUint64(header);\n                    subStreamsInfo.unpackSizes[nextUnpackStream++] = size;\n                    sum += size;\n                }\n            }\n            subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n        }\n        if (nid == NID.kSize) {\n            nid = header.readUnsignedByte();\n        }\n        \n        int numDigests = 0;\n        for (final Folder folder : archive.folders) {\n            if (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\n                numDigests += folder.numUnpackSubStreams;\n            }\n        }\n        \n        if (nid == NID.kCRC) {\n            final BitSet hasMissingCrc = readAllOrBits(header, numDigests);\n            final long[] missingCrcs = new long[numDigests];\n            for (int i = 0; i < numDigests; i++) {\n                if (hasMissingCrc.get(i)) {\n                    missingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n                }\n            }\n            int nextCrc = 0;\n            int nextMissingCrc = 0;\n            for (final Folder folder: archive.folders) {\n                if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\n                    subStreamsInfo.hasCrc.set(nextCrc, true);\n                    subStreamsInfo.crcs[nextCrc] = folder.crc;\n                    ++nextCrc;\n                } else {\n                    for (int i = 0; i < folder.numUnpackSubStreams; i++) {\n                        subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\n                        subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n                        ++nextCrc;\n                        ++nextMissingCrc;\n                    }\n                }\n            }\n            \n            nid = header.readUnsignedByte();\n        }\n        \n        if (nid != NID.kEnd) {\n            throw new IOException(\"Badly terminated SubStreamsInfo\");\n        }\n        \n        archive.subStreamsInfo = subStreamsInfo;\n    }", "calculateStreamMap": "    private void calculateStreamMap(final Archive archive) throws IOException {\n        final StreamMap streamMap = new StreamMap();\n        \n        int nextFolderPackStreamIndex = 0;\n        final int numFolders = archive.folders != null ? archive.folders.length : 0;\n        streamMap.folderFirstPackStreamIndex = new int[numFolders];\n        for (int i = 0; i < numFolders; i++) {\n            streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;\n            nextFolderPackStreamIndex += archive.folders[i].packedStreams.length;\n        }\n        \n        long nextPackStreamOffset = 0;\n        final int numPackSizes = archive.packSizes != null ? archive.packSizes.length : 0;\n        streamMap.packStreamOffsets = new long[numPackSizes];\n        for (int i = 0; i < numPackSizes; i++) {\n            streamMap.packStreamOffsets[i] = nextPackStreamOffset;\n            nextPackStreamOffset += archive.packSizes[i]; \n        }\n        \n        streamMap.folderFirstFileIndex = new int[numFolders];\n        streamMap.fileFolderIndex = new int[archive.files.length];\n        int nextFolderIndex = 0;\n        int nextFolderUnpackStreamIndex = 0;\n        for (int i = 0; i < archive.files.length; i++) {\n            if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {\n                streamMap.fileFolderIndex[i] = -1;\n                continue;\n            }\n            if (nextFolderUnpackStreamIndex == 0) {\n                for (; nextFolderIndex < archive.folders.length; ++nextFolderIndex) {\n                    streamMap.folderFirstFileIndex[nextFolderIndex] = i;\n                    if (archive.folders[nextFolderIndex].numUnpackSubStreams > 0) {\n                        break;\n                    }\n                }\n                if (nextFolderIndex >= archive.folders.length) {\n                    throw new IOException(\"Too few folders in archive\");\n                }\n            }\n            streamMap.fileFolderIndex[i] = nextFolderIndex;\n            if (!archive.files[i].hasStream()) {\n                continue;\n            }\n            ++nextFolderUnpackStreamIndex;\n            if (nextFolderUnpackStreamIndex >= archive.folders[nextFolderIndex].numUnpackSubStreams) {\n                ++nextFolderIndex;\n                nextFolderUnpackStreamIndex = 0;\n            }\n        }\n        \n        archive.streamMap = streamMap;\n    }", "buildDecodingStream": "    private void buildDecodingStream() throws IOException {\n        final int folderIndex = archive.streamMap.fileFolderIndex[currentEntryIndex];\n        if (folderIndex < 0) {\n            deferredBlockStreams.clear();\n            // TODO: previously it'd return an empty stream?\n            // new BoundedInputStream(new ByteArrayInputStream(new byte[0]), 0);\n            return;\n        }\n        final SevenZArchiveEntry file = archive.files[currentEntryIndex];\n        if (currentFolderIndex == folderIndex) {\n            // (COMPRESS-320).\n            // The current entry is within the same (potentially opened) folder. The\n            // previous stream has to be fully decoded before we can start reading\n            // but don't do it eagerly -- if the user skips over the entire folder nothing\n            // is effectively decompressed.\n\n            file.setContentMethods(archive.files[currentEntryIndex - 1].getContentMethods());\n        } else {\n            // We're opening a new folder. Discard any queued streams/ folder stream.\n            currentFolderIndex = folderIndex;\n            deferredBlockStreams.clear();\n            if (currentFolderInputStream != null) {\n                currentFolderInputStream.close();\n                currentFolderInputStream = null;\n            }\n            \n            final Folder folder = archive.folders[folderIndex];\n            final int firstPackStreamIndex = archive.streamMap.folderFirstPackStreamIndex[folderIndex];\n            final long folderOffset = SIGNATURE_HEADER_SIZE + archive.packPos +\n                    archive.streamMap.packStreamOffsets[firstPackStreamIndex];\n            currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);\n        }\n\n        InputStream fileStream = new BoundedInputStream(currentFolderInputStream, file.getSize());\n        if (file.getHasCrc()) {\n            fileStream = new CRC32VerifyingInputStream(fileStream, file.getSize(), file.getCrcValue());\n        }\n        \n        deferredBlockStreams.add(fileStream);\n    }", "read": "    public int read(final byte[] b, final int off, final int len) throws IOException {\n        return getCurrentStream().read(b, off, len);\n    }", "getCurrentStream": "    private InputStream getCurrentStream() throws IOException {\n        if (deferredBlockStreams.isEmpty()) {\n            throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n        }\n        \n        while (deferredBlockStreams.size() > 1) {\n            // In solid compression mode we need to decompress all leading folder'\n            // streams to get access to an entry. We defer this until really needed\n            // so that entire blocks can be skipped without wasting time for decompression.\n            final InputStream stream = deferredBlockStreams.remove(0);\n            IOUtils.skip(stream, Long.MAX_VALUE);\n            stream.close();\n        }\n\n        return deferredBlockStreams.get(0);\n    }", "matches": "    public static boolean matches(final byte[] signature, final int length) {\n        if (length < sevenZSignature.length) {\n            return false;\n        }\n\n        for (int i = 0; i < sevenZSignature.length; i++) {\n            if (signature[i] != sevenZSignature[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "skipBytesFully": "    private static long skipBytesFully(final DataInput input, long bytesToSkip) throws IOException {\n        if (bytesToSkip < 1) {\n            return 0;\n        }\n        long skipped = 0;\n        while (bytesToSkip > Integer.MAX_VALUE) {\n            final long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        while (bytesToSkip > 0) {\n            final int skippedNow = input.skipBytes((int) bytesToSkip);\n            if (skippedNow == 0) {\n                return skipped;\n            }\n            skipped += skippedNow;\n            bytesToSkip -= skippedNow;\n        }\n        return skipped;\n    }"}