{"withConfig": "    public DeserializerFactory withConfig(DeserializerFactoryConfig config)\n    {\n        if (_factoryConfig == config) {\n            return this;\n        }\n        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n         *    and we pretty much have to here either choose between losing subtype instance\n         *    when registering additional deserializers, or losing deserializers.\n         *    Instead, let's actually just throw an error if this method is called when subtype\n         *    has not properly overridden this method; this to indicate problem as soon as possible.\n         */\n        if (getClass() != BeanDeserializerFactory.class) {\n            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n                    +\"additional deserializer definitions\");\n        }\n        return new BeanDeserializerFactory(config);\n    }", "createBeanDeserializer": "    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        /* Or, for abstract types, may have alternate means for resolution\n         * (defaulting, materialization)\n         */\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        checkIllegalTypes(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }", "createBuilderBasedDeserializer": "    public JsonDeserializer<Object> createBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,\n    \t\tClass<?> builderClass)\n        throws JsonMappingException\n    {\n        // First: need a BeanDescription for builder class\n        JavaType builderType = ctxt.constructType(builderClass);\n        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);\n        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);\n    }", "findStdDeserializer": "    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // note: we do NOT check for custom deserializers here, caller has already\n        // done that\n        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n        // Also: better ensure these are post-processable?\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n                }\n            }\n        }\n        return deser;\n    }", "buildBeanDeserializer": "    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        /* 19-Mar-2012, tatu: This check used to be done earlier; but we have to defer\n         *   it a bit to collect information on ObjectIdReader, for example.\n         */\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }", "buildBuilderBasedDeserializer": "    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n    \t// Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                \"build\" : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }", "addObjectIdReader": "    protected void addObjectIdReader(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return;\n        }\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n        JavaType idType;\n        SettableBeanProperty idProp;\n        ObjectIdGenerator<?> gen;\n\n        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            PropertyName propName = objectIdInfo.getPropertyName();\n            idProp = builder.findProperty(propName);\n            if (idProp == null) {\n                throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                        +beanDesc.getBeanClass().getName()+\": can not find property with name '\"+propName+\"'\");\n            }\n            idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n        } else {\n            JavaType type = ctxt.constructType(implClass);\n            idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            idProp = null;\n            gen = ctxt.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        }\n        // also: unlike with value deserializers, let's just resolve one we need here\n        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n        builder.setObjectIdReader(ObjectIdReader.construct(idType,\n                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n    }", "constructBeanDeserializerBuilder": "    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt,\n            BeanDescription beanDesc) {\n        return new BeanDeserializerBuilder(beanDesc, ctxt.getConfig());\n    }", "addBeanProps": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }", "filterBeanProps": "    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder,\n            List<BeanPropertyDefinition> propDefsIn,\n            Set<String> ignored)\n        throws JsonMappingException\n    {\n        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n                Math.max(4, propDefsIn.size()));\n        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n        // These are all valid setters, but we do need to introspect bit more\n        for (BeanPropertyDefinition property : propDefsIn) {\n            String name = property.getName();\n            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n                continue;\n            }\n            if (!property.hasConstructorParameter()) { // never skip constructor params\n                Class<?> rawPropertyType = null;\n                if (property.hasSetter()) {\n                    rawPropertyType = property.getSetter().getRawParameterType(0);\n                } else if (property.hasField()) {\n                    rawPropertyType = property.getField().getRawType();\n                }\n\n                // Some types are declared as ignorable as well\n                if ((rawPropertyType != null)\n                        && isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes)) {\n                    // important: make ignorable, to avoid errors if value is actually seen\n                    builder.addIgnorable(name);\n                    continue;\n                }\n            }\n            result.add(property);\n        }\n        return result;\n    }", "addReferenceProperties": "    protected void addReferenceProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        // and then back references, not necessarily found as regular properties\n        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n        if (refs != null) {\n            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                String name = en.getKey();\n                AnnotatedMember m = en.getValue();\n                JavaType type;\n                if (m instanceof AnnotatedMethod) {\n                    type = ((AnnotatedMethod) m).getParameterType(0);\n                } else {\n                    type = m.getType();\n                    // 30-Mar-2017, tatu: Unfortunately it is not yet possible to make back-refs\n                    //    work through constructors; but let's at least indicate the issue for now\n                    if (m instanceof AnnotatedParameter) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Can not bind back references as Creator parameters: type %s (reference '%s', parameter index #%d)\",\nbeanDesc.getBeanClass().getName(), name, ((AnnotatedParameter) m).getIndex());\n                    }\n                }\n                SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(\n                        ctxt.getConfig(), m, PropertyName.construct(name));\n                builder.addBackReferenceProperty(name, constructSettableProperty(ctxt,\n                        beanDesc, propDef, type));\n            }\n        }\n    }", "addInjectables": "    protected void addInjectables(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n        if (raw != null) {\n            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                AnnotatedMember m = entry.getValue();\n                builder.addInjectable(PropertyName.construct(m.getName()),\n                        m.getType(),\n                        beanDesc.getClassAnnotations(), m, entry.getKey());\n            }\n        }\n    }", "constructAnySetter": "    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt,\n            BeanDescription beanDesc, AnnotatedMember mutator)\n        throws JsonMappingException\n    {\n        //find the java type based on the annotated setter method or setter field \n        JavaType type = null;\n        if (mutator instanceof AnnotatedMethod) {\n            // we know it's a 2-arg method, second arg is the value\n            type = ((AnnotatedMethod) mutator).getParameterType(1);\n        } else if (mutator instanceof AnnotatedField) {\n            // get the type from the content type of the map object\n            type = ((AnnotatedField) mutator).getType().getContentType();\n        }\n        // First: various annotations on type itself, as well as type-overrides\n        // on accessor need to be resolved\n        type = resolveMemberAndTypeAnnotations(ctxt, mutator, type);\n        BeanProperty.Std prop = new BeanProperty.Std(PropertyName.construct(mutator.getName()),\n                type, null, beanDesc.getClassAnnotations(), mutator,\n                PropertyMetadata.STD_OPTIONAL);\n        // and then possible direct deserializer override on accessor\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            // As per [databind#462] need to ensure we contextualize deserializer before passing it on\n            deser = (JsonDeserializer<Object>) ctxt.handlePrimaryContextualization(deser, prop, type);\n        }\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        return new SettableAnyProperty(prop, mutator, type, deser, typeDeser);\n    }", "constructSettableProperty": "    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        // 08-Sep-2016, tatu: issues like [databind#1342] suggest something fishy\n        //   going on; add sanity checks to try to pin down actual problem...\n        //   Possibly passing creator parameter?\n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        // Does the Method specify the deserializer to use? If so, let's use it.\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            // 08-Sep-2016, tatu: wonder if we should verify it is `AnnotatedField` to be safe?\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }", "constructSetterlessProperty": "    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef)\n        throws JsonMappingException\n    {\n        final AnnotatedMethod getter = propDef.getGetter();\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, getter, getter.getType());\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), getter);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, getter);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }", "isPotentialBeanType": "    protected boolean isPotentialBeanType(Class<?> type)\n    {\n        String typeStr = ClassUtil.canBeABeanType(type);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        if (ClassUtil.isProxyType(type)) {\n            throw new IllegalArgumentException(\"Can not deserialize Proxy class \"+type.getName()+\" as a Bean\");\n        }\n        /* also: can't deserialize some local classes: static are ok; in-method not;\n         * other non-static inner classes are ok\n         */\n        typeStr = ClassUtil.isLocalType(type, true);\n        if (typeStr != null) {\n            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n        }\n        return true;\n    }", "isIgnorableType": "    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc,\n            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n    {\n        Boolean status = ignoredTypes.get(type);\n        if (status != null) {\n            return status.booleanValue();\n        }\n        // 21-Apr-2016, tatu: For 2.8, can specify config overrides\n        ConfigOverride override = config.findConfigOverride(type);\n        if (override != null) {\n            status = override.getIsIgnoredType();\n        }\n        if (status == null) {\n            BeanDescription desc = config.introspectClassAnnotations(type);\n            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n            // We default to 'false', i.e. not ignorable\n            if (status == null) {\n                status = Boolean.FALSE;\n            }\n        }\n        ignoredTypes.put(type, status);\n        return status.booleanValue();\n    }"}