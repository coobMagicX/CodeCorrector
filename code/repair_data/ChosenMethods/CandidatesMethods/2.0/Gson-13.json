{"setLenient": "  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }", "isLenient": "  public final boolean isLenient() {\n    return lenient;\n  }", "beginArray": "  public void beginArray() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      pathIndices[stackSize - 1] = 0;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n    }\n  }", "beginObject": "  public void beginObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n    }\n  }", "endObject": "  public void endObject() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_END_OBJECT) {\n      stackSize--;\n      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n      pathIndices[stackSize - 1]++;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n    }\n  }", "peek": "  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }", "doPeek": "  int doPeek() throws IOException {\n    int peekStack = stack[stackSize - 1];\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\n      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n      // Look for a comma before the next element.\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case ']':\n        return peeked = PEEKED_END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n      // Look for a comma before the next element.\n      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n        int c = nextNonWhitespace(true);\n        switch (c) {\n        case '}':\n          return peeked = PEEKED_END_OBJECT;\n        case ';':\n          checkLenient(); // fall-through\n        case ',':\n          break;\n        default:\n          throw syntaxError(\"Unterminated object\");\n        }\n      }\n      int c = nextNonWhitespace(true);\n      switch (c) {\n      case '\"':\n        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n      case '\\'':\n        checkLenient();\n        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n      case '}':\n        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n          return peeked = PEEKED_END_OBJECT;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      default:\n        checkLenient();\n        pos--; // Don't consume the first character in an unquoted string.\n        if (isLiteral((char) c)) {\n          return peeked = PEEKED_UNQUOTED_NAME;\n        } else {\n          throw syntaxError(\"Expected name\");\n        }\n      }", "peekKeyword": "  private int peekKeyword() throws IOException {\n    // Figure out which keyword we're matching against by its first character.\n    char c = buffer[pos];\n    String keyword;\n    String keywordUpper;\n    int peeking;\n    if (c == 't' || c == 'T') {\n      keyword = \"true\";\n      keywordUpper = \"TRUE\";\n      peeking = PEEKED_TRUE;\n    } else if (c == 'f' || c == 'F') {\n      keyword = \"false\";\n      keywordUpper = \"FALSE\";\n      peeking = PEEKED_FALSE;\n    } else if (c == 'n' || c == 'N') {\n      keyword = \"null\";\n      keywordUpper = \"NULL\";\n      peeking = PEEKED_NULL;\n    } else {\n      return PEEKED_NONE;\n    }\n\n    // Confirm that chars [1..length) match the keyword.\n    int length = keyword.length();\n    for (int i = 1; i < length; i++) {\n      if (pos + i >= limit && !fillBuffer(i + 1)) {\n        return PEEKED_NONE;\n      }\n      c = buffer[pos + i];\n      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n        return PEEKED_NONE;\n      }\n    }\n\n    if ((pos + length < limit || fillBuffer(length + 1))\n        && isLiteral(buffer[pos + length])) {\n      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n    }\n\n    // We've found the keyword followed either by EOF or by a non-literal character.\n    pos += length;\n    return peeked = peeking;\n  }", "peekNumber": "  private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n      if (p + i == l) {\n        if (i == buffer.length) {\n          // Though this looks like a well-formed number, it's too long to continue reading. Give up\n          // and let the application handle this as an unquoted literal.\n          return PEEKED_NONE;\n        }\n        if (!fillBuffer(i + 1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      char c = buffer[p + i];\n      switch (c) {\n      case '-':\n        if (last == NUMBER_CHAR_NONE) {\n          negative = true;\n          last = NUMBER_CHAR_SIGN;\n          continue;\n        } else if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '+':\n        if (last == NUMBER_CHAR_EXP_E) {\n          last = NUMBER_CHAR_EXP_SIGN;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case 'e':\n      case 'E':\n        if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n          last = NUMBER_CHAR_EXP_E;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      case '.':\n        if (last == NUMBER_CHAR_DIGIT) {\n          last = NUMBER_CHAR_DECIMAL;\n          continue;\n        }\n        return PEEKED_NONE;\n\n      default:\n        if (c < '0' || c > '9') {\n          if (!isLiteral(c)) {\n            break charactersOfNumber;\n          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }", "isLiteral": "  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ':':\n    case ',':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      return false;\n    default:\n      return true;\n    }\n  }", "nextString": "  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }", "nextBoolean": "  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }", "nextNull": "  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek() + locationString());\n    }\n  }", "nextDouble": "  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\n          \"JSON forbids NaN and infinities: \" + result + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }", "nextLong": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }", "nextQuotedValue": "  private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }", "nextUnquotedValue": "  private String nextUnquotedValue() throws IOException {\n    StringBuilder builder = null;\n    int i = 0;\n\n    findNonLiteralCharacter:\n    while (true) {\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          break findNonLiteralCharacter;\n        }\n      }\n\n      // Attempt to load the entire literal into the buffer at once.\n      if (i < buffer.length) {\n        if (fillBuffer(i + 1)) {\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      // use a StringBuilder when the value is too long. This is too long to be a number!\n      if (builder == null) {\n        builder = new StringBuilder();\n      }\n      builder.append(buffer, pos, i);\n      pos += i;\n      i = 0;\n      if (!fillBuffer(1)) {\n        break;\n      }\n    }\n\n    String result;\n    if (builder == null) {\n      result = new String(buffer, pos, i);\n    } else {\n      builder.append(buffer, pos, i);\n      result = builder.toString();\n    }\n    pos += i;\n    return result;\n  }", "skipQuotedValue": "  private void skipQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    do {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      while (p < l) {\n        int c = buffer[p++];\n        if (c == quote) {\n          pos = p;\n          return;\n        } else if (c == '\\\\') {\n          pos = p;\n          readEscapeCharacter();\n          p = pos;\n          l = limit;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n      pos = p;\n    } while (fillBuffer(1));\n    throw syntaxError(\"Unterminated string\");\n  }", "skipUnquotedValue": "  private void skipUnquotedValue() throws IOException {\n    do {\n      int i = 0;\n      for (; pos + i < limit; i++) {\n        switch (buffer[pos + i]) {\n        case '/':\n        case '\\\\':\n        case ';':\n        case '#':\n        case '=':\n          checkLenient(); // fall-through\n        case '{':\n        case '}':\n        case '[':\n        case ']':\n        case ':':\n        case ',':\n        case ' ':\n        case '\\t':\n        case '\\f':\n        case '\\r':\n        case '\\n':\n          pos += i;\n          return;\n        }\n      }\n      pos += i;\n    } while (fillBuffer(1));\n  }", "nextInt": "  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }", "close": "  public void close() throws IOException {\n    peeked = PEEKED_NONE;\n    stack[0] = JsonScope.CLOSED;\n    stackSize = 1;\n    in.close();\n  }", "skipValue": "  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }", "push": "  private void push(int newTop) {\n    if (stackSize == stack.length) {\n      int[] newStack = new int[stackSize * 2];\n      int[] newPathIndices = new int[stackSize * 2];\n      String[] newPathNames = new String[stackSize * 2];\n      System.arraycopy(stack, 0, newStack, 0, stackSize);\n      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n      stack = newStack;\n      pathIndices = newPathIndices;\n      pathNames = newPathNames;\n    }\n    stack[stackSize++] = newTop;\n  }", "fillBuffer": "  private boolean fillBuffer(int minimum) throws IOException {\n    char[] buffer = this.buffer;\n    lineStart -= pos;\n    if (limit != pos) {\n      limit -= pos;\n      System.arraycopy(buffer, pos, buffer, 0, limit);\n    } else {\n      limit = 0;\n    }\n\n    pos = 0;\n    int total;\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n      limit += total;\n\n      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n      if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\n        pos++;\n        lineStart++;\n        minimum++;\n      }\n\n      if (limit >= minimum) {\n        return true;\n      }\n    }\n    return false;\n  }", "nextNonWhitespace": "  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n    /*\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n     * and 'limit' fields respectively. Using locals rather than fields saves\n     * a few field reads for each whitespace character in a pretty-printed\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n     * before any (potentially indirect) call to fillBuffer() and reread both\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\n     */\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    while (true) {\n      if (p == l) {\n        pos = p;\n        if (!fillBuffer(1)) {\n          break;\n        }\n        p = pos;\n        l = limit;\n      }\n\n      int c = buffer[p++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = p;\n        continue;\n      } else if (c == ' ' || c == '\\r' || c == '\\t') {\n        continue;\n      }\n\n      if (c == '/') {\n        pos = p;\n        if (p == l) {\n          pos--; // push back '/' so it's still in the buffer when this method returns\n          boolean charsLoaded = fillBuffer(2);\n          pos++; // consume the '/' again\n          if (!charsLoaded) {\n            return c;\n          }\n        }\n\n        checkLenient();\n        char peek = buffer[pos];\n        switch (peek) {\n        case '*':\n          // skip a /* c-style comment */\n          pos++;\n          if (!skipTo(\"*/\")) {\n            throw syntaxError(\"Unterminated comment\");\n          }\n          p = pos + 2;\n          l = limit;\n          continue;\n\n        case '/':\n          // skip a // end-of-line comment\n          pos++;\n          skipToEndOfLine();\n          p = pos;\n          l = limit;\n          continue;\n\n        default:\n          return c;\n        }\n      } else if (c == '#') {\n        pos = p;\n        /*\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n         * specify this behaviour, but it's required to parse\n         * existing documents. See http://b/2571423.\n         */\n        checkLenient();\n        skipToEndOfLine();\n        p = pos;\n        l = limit;\n      } else {\n        pos = p;\n        return c;\n      }\n    }\n    if (throwOnEof) {\n      throw new EOFException(\"End of input\" + locationString());\n    } else {\n      return -1;\n    }\n  }", "checkLenient": "  private void checkLenient() throws IOException {\n    if (!lenient) {\n      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n    }\n  }", "skipToEndOfLine": "  private void skipToEndOfLine() throws IOException {\n    while (pos < limit || fillBuffer(1)) {\n      char c = buffer[pos++];\n      if (c == '\\n') {\n        lineNumber++;\n        lineStart = pos;\n        break;\n      } else if (c == '\\r') {\n        break;\n      }\n    }\n  }", "skipTo": "  private boolean skipTo(String toFind) throws IOException {\n    outer:\n    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n      if (buffer[pos] == '\\n') {\n        lineNumber++;\n        lineStart = pos + 1;\n        continue;\n      }\n      for (int c = 0; c < toFind.length(); c++) {\n        if (buffer[pos + c] != toFind.charAt(c)) {\n          continue outer;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "toString": "  @Override public String toString() {\n    return getClass().getSimpleName() + locationString();\n  }", "locationString": "  private String locationString() {\n    int line = lineNumber + 1;\n    int column = pos - lineStart + 1;\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\n  }", "getPath": "  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }", "readEscapeCharacter": "  private char readEscapeCharacter() throws IOException {\n    if (pos == limit && !fillBuffer(1)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n\n    char escaped = buffer[pos++];\n    switch (escaped) {\n    case 'u':\n      if (pos + 4 > limit && !fillBuffer(4)) {\n        throw syntaxError(\"Unterminated escape sequence\");\n      }\n      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n      char result = 0;\n      for (int i = pos, end = i + 4; i < end; i++) {\n        char c = buffer[i];\n        result <<= 4;\n        if (c >= '0' && c <= '9') {\n          result += (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n          result += (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n          result += (c - 'A' + 10);\n        } else {\n          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n        }\n      }\n      pos += 4;\n      return result;\n\n    case 't':\n      return '\\t';\n\n    case 'b':\n      return '\\b';\n\n    case 'n':\n      return '\\n';\n\n    case 'r':\n      return '\\r';\n\n    case 'f':\n      return '\\f';\n\n    case '\\n':\n      lineNumber++;\n      lineStart = pos;\n      // fall-through\n\n    case '\\'':\n    case '\"':\n    case '\\\\':\n    case '/':\t\n    \treturn escaped;\n    default:\n    \t// throw error when none of the above cases are matched\n    \tthrow syntaxError(\"Invalid escape sequence\");\n    }\n  }", "consumeNonExecutePrefix": "  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace(true);\n    pos--;\n\n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n\n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n\n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }"}