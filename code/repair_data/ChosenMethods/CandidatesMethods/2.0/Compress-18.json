{"setAddPaxHeadersForNonAsciiNames": "    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }", "getBytesWritten": "    public long getBytesWritten() {\n        return ((CountingOutputStream) out).getBytesWritten();\n    }", "finish": "    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n\n        if (haveUnclosedEntry) {\n            throw new IOException(\"This archives contains unclosed entries.\");\n        }\n        writeEOFRecord();\n        writeEOFRecord();\n        buffer.flushBlock();\n        finished = true;\n    }", "close": "    public void close() throws IOException {\n        if(!finished) {\n            finish();\n        }\n\n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }", "putArchiveEntry": "    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        final ByteBuffer encodedName = encoding.encode(entryName);\n        final int nameLen = encodedName.limit() - encodedName.position();\n        boolean paxHeaderContainsPath = false;\n        if (nameLen >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(\"path\", entryName);\n                paxHeaderContainsPath = true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                longLinkEntry.setSize(nameLen + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), nameLen);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entryName\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(entry.getLinkName())) {\n            paxHeaders.put(\"linkpath\", entry.getLinkName());\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, encoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }", "closeArchiveEntry": "    public void closeArchiveEntry() throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        if (!haveUnclosedEntry){\n            throw new IOException(\"No current entry to close\");\n        }\n        if (assemLen > 0) {\n            for (int i = assemLen; i < assemBuf.length; ++i) {\n                assemBuf[i] = 0;\n            }\n\n            buffer.writeRecord(assemBuf);\n\n            currBytes += assemLen;\n            assemLen = 0;\n        }\n\n        if (currBytes < currSize) {\n            throw new IOException(\"entry '\" + currName + \"' closed at '\"\n                                  + currBytes\n                                  + \"' before the '\" + currSize\n                                  + \"' bytes specified in the header were written\");\n        }\n        haveUnclosedEntry = false;\n    }", "write": "    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }", "writePaxHeaders": "    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }", "stripTo7Bits": "    private String stripTo7Bits(String name) {\n        final int length = name.length();\n        StringBuffer result = new StringBuffer(length);\n        for (int i = 0; i < length; i++) {\n            char stripped = (char) (name.charAt(i) & 0x7F);\n            if (stripped != 0) { // would be read as Trailing null\n                result.append(stripped);\n            }\n        }\n        return result.toString();\n    }", "writeEOFRecord": "    private void writeEOFRecord() throws IOException {\n        for (int i = 0; i < recordBuf.length; ++i) {\n            recordBuf[i] = 0;\n        }\n\n        buffer.writeRecord(recordBuf);\n    }", "flush": "    public void flush() throws IOException {\n        out.flush();\n    }", "createArchiveEntry": "    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)\n            throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new TarArchiveEntry(inputFile, entryName);\n    }", "addPaxHeadersForBigNumbers": "    private void addPaxHeadersForBigNumbers(Map<String, String> paxHeaders,\n                                            TarArchiveEntry entry) {\n        addPaxHeaderForBigNumber(paxHeaders, \"size\", entry.getSize(),\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"gid\", entry.getGroupId(),\n                                 TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"mtime\",\n                                 entry.getModTime().getTime() / 1000,\n                                 TarConstants.MAXSIZE);\n        addPaxHeaderForBigNumber(paxHeaders, \"uid\", entry.getUserId(),\n                                 TarConstants.MAXID);\n        // star extensions by J\\u00f6rg Schilling\n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devmajor\",\n                                 entry.getDevMajor(), TarConstants.MAXID);\n        addPaxHeaderForBigNumber(paxHeaders, \"SCHILY.devminor\",\n                                 entry.getDevMinor(), TarConstants.MAXID);\n        // there is no PAX header for file mode\n        failForBigNumber(\"mode\", entry.getMode(), TarConstants.MAXID);\n    }", "addPaxHeaderForBigNumber": "    private void addPaxHeaderForBigNumber(Map<String, String> paxHeaders,\n                                          String header, long value,\n                                          long maxValue) {\n        if (value < 0 || value > maxValue) {\n            paxHeaders.put(header, String.valueOf(value));\n        }\n    }"}