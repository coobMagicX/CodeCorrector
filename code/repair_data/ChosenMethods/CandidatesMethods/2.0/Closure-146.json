{"getNativeType": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }", "forgiveUnknownNames": "  void forgiveUnknownNames() {}", "isNoType": "  public boolean isNoType() {\n    return false;\n  }", "isNoObjectType": "  public boolean isNoObjectType() {\n    return false;\n  }", "isEmptyType": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType();\n  }", "isNumberObjectType": "  public boolean isNumberObjectType() {\n    return false;\n  }", "isNumberValueType": "  public boolean isNumberValueType() {\n    return false;\n  }", "isFunctionPrototypeType": "  public boolean isFunctionPrototypeType() {\n    return false;\n  }", "isStringObjectType": "  public boolean isStringObjectType() {\n    return false;\n  }", "isTheObjectType": "  boolean isTheObjectType() {\n    return false;\n  }", "isStringValueType": "  public boolean isStringValueType() {\n    return false;\n  }", "isArrayType": "  public boolean isArrayType() {\n    return false;\n  }", "isBooleanObjectType": "  public boolean isBooleanObjectType() {\n    return false;\n  }", "isBooleanValueType": "  public boolean isBooleanValueType() {\n    return false;\n  }", "isRegexpType": "  public boolean isRegexpType() {\n    return false;\n  }", "isDateType": "  public boolean isDateType() {\n    return false;\n  }", "isNullType": "  public boolean isNullType() {\n    return false;\n  }", "isVoidType": "  public boolean isVoidType() {\n    return false;\n  }", "isAllType": "  public boolean isAllType() {\n    return false;\n  }", "isUnknownType": "  public boolean isUnknownType() {\n    return false;\n  }", "isCheckedUnknownType": "  public boolean isCheckedUnknownType() {\n    return false;\n  }", "isUnionType": "  public boolean isUnionType() {\n    return false;\n  }", "isFunctionType": "  public boolean isFunctionType() {\n    return false;\n  }", "isEnumElementType": "  public boolean isEnumElementType() {\n    return false;\n  }", "isEnumType": "  public boolean isEnumType() {\n    return false;\n  }", "isNamedType": "  boolean isNamedType() {\n    return false;\n  }", "isRecordType": "  public boolean isRecordType() {\n    return false;\n  }", "isTemplateType": "  public boolean isTemplateType() {\n    return false;\n  }", "isNominalType": "  public boolean isNominalType() {\n    return false;\n  }", "isInstanceType": "  public boolean isInstanceType() {\n    return false;\n  }", "equals": "  public boolean equals(Object jsType) {\n    return (jsType instanceof JSType) ?\n        isEquivalentTo((JSType) jsType) : false;\n  }", "findPropertyType": "  public JSType findPropertyType(String propertyName) {\n    ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());\n    if (autoboxObjType != null) {\n      return autoboxObjType.findPropertyType(propertyName);\n    }\n\n    return null;\n  }", "toObjectType": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }", "dereference": "  public final ObjectType dereference() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return ObjectType.cast(autobox == null ? restricted : autobox);\n  }", "canTestForEqualityWith": "  public final boolean canTestForEqualityWith(JSType that) {\n    return this.testForEquality(that).equals(UNKNOWN);\n  }", "testForEquality": "  public TernaryValue testForEquality(JSType that) {\n    if (that.isAllType() || that.isNoType() || that.isUnknownType()) {\n      return UNKNOWN;\n    }\n    if (that.isEnumElementType()) {\n      return that.testForEquality(this);\n    }\n    if (that instanceof UnionType) {\n      UnionType union = (UnionType) that;\n      TernaryValue result = null;\n      for (JSType t : union.alternates) {\n        TernaryValue test = this.testForEquality(t);\n        if (result == null) {\n          result = test;\n        } else if (!result.equals(test)) {\n          return UNKNOWN;\n        }\n      }\n    }\n    return null;\n  }", "getLeastSupertype": "  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n    if (thatType.isEmptyType() || thatType.isAllType()) {\n      // Defer to the implementations of the end lattice elements when\n      // possible.\n      return thatType.getLeastSupertype(thisType);\n    }\n\n    return thisType.registry.createUnionType(thisType, thatType);\n  }", "getGreatestSubtype": "  static JSType getGreatestSubtype(JSType thisType, JSType thatType) {\n    if (thatType.isEmptyType() || thatType.isAllType()) {\n      // Defer to the implementations of the end lattice elements when\n      // possible.\n      return thatType.getGreatestSubtype(thisType);\n    } else if (thisType.isUnknownType() || thatType.isUnknownType()) {\n      // The greatest subtype with any unknown type is the universal\n      // unknown type, unless the two types are equal.\n      return thisType.isEquivalentTo(thatType) ? thisType :\n          thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    } else if (thisType.isSubtype(thatType)) {\n      return thisType;\n    } else if (thatType.isSubtype(thisType)) {\n      return thatType;\n    } else if (thisType.isUnionType()) {\n      return ((UnionType) thisType).meet(thatType);\n    } else if (thatType.isUnionType()) {\n      return ((UnionType) thatType).meet(thisType);\n    } else if (thisType.isObject() && thatType.isObject()) {\n      return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return thisType.getNativeType(JSTypeNative.NO_TYPE);\n  }", "getRestrictedTypeGivenToBooleanOutcome": "  public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n      return this;\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }", "getPossibleToBooleanOutcomes": "  public abstract BooleanLiteralSet getPossibleToBooleanOutcomes();\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types if equality", "getTypesUnderEquality": "  public TypePair getTypesUnderEquality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderEquality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case FALSE:\n        return new TypePair(null, null);\n\n      case TRUE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }", "getTypesUnderInequality": "  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        return new TypePair(null, null);\n\n      case FALSE:\n      case UNKNOWN:\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }", "getTypesUnderShallowEquality": "  public TypePair getTypesUnderShallowEquality(JSType that) {\n    JSType commonType = getGreatestSubtype(that);\n    return new TypePair(commonType, commonType);\n  }", "getTypesUnderShallowInequality": "  public TypePair getTypesUnderShallowInequality(JSType that) {\n    // union types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderShallowInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // Other types.\n    // There are only two types whose shallow inequality is deterministically\n    // true -- null and undefined. We can just enumerate them.\n    if (this.isNullType() && that.isNullType() ||\n        this.isVoidType() && that.isVoidType()) {\n      return new TypePair(null, null);\n    } else {\n      return new TypePair(this, that);\n    }\n  }", "isSubtype": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).referencedType);\n    }\n    return false;\n  }", "visit": "  public abstract <T> T visit(Visitor<T> visitor);\n\n  /**\n   * Force this type to resolve, even if the registry is in a lazy\n   * resolving mode.\n   * @see #resolve\n   */\n  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n    ResolveMode oldResolveMode = registry.getResolveMode();\n    registry.setResolveMode(ResolveMode.IMMEDIATE);\n    JSType result = resolve(t, scope);\n    registry.setResolveMode(oldResolveMode);\n    return result;\n  }", "resolve": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "setResolvedTypeInternal": "  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }"}