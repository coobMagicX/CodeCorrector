{"rawClass": "    public static Class<?> rawClass(Type t) {\n        if (t instanceof Class<?>) {\n            return (Class<?>) t;\n        }\n        // Shouldbe able to optimize bit more in future...\n        return defaultInstance().constructType(t).getRawClass();\n    }", "constructSpecializedType": "    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        if (baseType.getRawClass() == subclass) {\n            return baseType;\n        }\n        // Currently only SimpleType instances can become something else\n        if (baseType instanceof SimpleType) {\n            // and only if subclass is an array, Collection or Map\n            if (subclass.isArray()\n                || Map.class.isAssignableFrom(subclass)\n                || Collection.class.isAssignableFrom(subclass)) {\n                // need to assert type compatibility...\n                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n                }\n                // this _should_ work, right?\n                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n                // one more thing: handlers to copy?\n                Object h = baseType.getValueHandler();\n                if (h != null) {\n                    subtype = subtype.withValueHandler(h);\n                }\n                h = baseType.getTypeHandler();\n                if (h != null) {\n                    subtype = subtype.withTypeHandler(h);\n                }\n                return subtype;\n            }\n        }\n        // otherwise regular narrowing should work just fine\n        return baseType.narrowBy(subclass);\n    }", "constructFromCanonical": "    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n    {\n        return _parser.parse(canonical);\n    }", "findTypeParameters": "    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n    {\n        // First: find full inheritance chain\n        HierarchicType subType = _findSuperTypeChain(clz, expType);\n        // Caller is supposed to ensure this never happens, so:\n        if (subType == null) {\n            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n        }\n        // Ok and then go to the ultimate super-type:\n        HierarchicType superType = subType;\n        while (superType.getSuperType() != null) {\n            superType = superType.getSuperType();\n            Class<?> raw = superType.getRawClass();\n            TypeBindings newBindings = new TypeBindings(this, raw);\n            if (superType.isGeneric()) { // got bindings, need to resolve\n                ParameterizedType pt = superType.asGeneric();\n                Type[] actualTypes = pt.getActualTypeArguments();\n                TypeVariable<?>[] vars = raw.getTypeParameters();\n                int len = actualTypes.length;\n                for (int i = 0; i < len; ++i) {\n                    String name = vars[i].getName();\n                    JavaType type = _constructType(actualTypes[i], bindings);\n                    newBindings.addBinding(name, type);\n                }\n            }\n            bindings = newBindings;\n        }\n\n        // which ought to be generic (if not, it's raw type)\n        if (!superType.isGeneric()) {\n            return null;\n        }\n        return bindings.typesAsArray();\n    }", "constructType": "    public JavaType constructType(Type type, JavaType context) {\n        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n        return _constructType(type, b);\n    }", "_constructType": "    protected JavaType _constructType(Type type, TypeBindings context)\n    {\n        JavaType resultType;\n\n        // simple class?\n        if (type instanceof Class<?>) {\n            resultType = _fromClass((Class<?>) type, context);\n        }\n        // But if not, need to start resolving.\n        else if (type instanceof ParameterizedType) {\n            resultType = _fromParamType((ParameterizedType) type, context);\n        }\n        else if (type instanceof JavaType) { // [Issue#116]\n            return (JavaType) type;\n        }\n        else if (type instanceof GenericArrayType) {\n            resultType = _fromArrayType((GenericArrayType) type, context);\n        }\n        else if (type instanceof TypeVariable<?>) {\n            resultType = _fromVariable((TypeVariable<?>) type, context);\n        }\n        else if (type instanceof WildcardType) {\n            resultType = _fromWildcard((WildcardType) type, context);\n        } else {\n            // sanity check\n            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n        }\n        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n         * for now only call for simple types (i.e. not for arrays, map or collections).\n         * Can be changed in future it necessary\n         */\n        if (_modifiers != null && !resultType.isContainerType()) {\n            for (TypeModifier mod : _modifiers) {\n                resultType = mod.modifyType(resultType, type, context, this);\n            }\n        }\n        return resultType;\n    }", "constructArrayType": "    public ArrayType constructArrayType(JavaType elementType) {\n        return ArrayType.construct(elementType, null, null);\n    }", "constructCollectionType": "    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n        return CollectionType.construct(collectionClass, elementType);\n    }", "constructCollectionLikeType": "    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n        return CollectionLikeType.construct(collectionClass, elementType);\n    }", "constructMapType": "    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }", "constructMapLikeType": "    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n    }", "constructSimpleType": "    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n            JavaType[] parameterTypes)\n    {\n        // Quick sanity check: must match numbers of types with expected...\n        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n        if (typeVars.length != parameterTypes.length) {\n            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n                    +\" parameters, was given \"+parameterTypes.length);\n        }\n        String[] names = new String[typeVars.length];\n        for (int i = 0, len = typeVars.length; i < len; ++i) {\n            names[i] = typeVars[i].getName();\n        }\n        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n    } ", "constructReferenceType": "    public JavaType constructReferenceType(Class<?> rawType, JavaType refType)\n    {\n        return new ReferenceType(rawType, refType, null, null, false);\n    }", "constructParametrizedType": "    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n            JavaType... parameterTypes)\n    {\n        JavaType resultType;\n        \n        // Need to check kind of class we are dealing with...\n        if (parametrized.isArray()) {\n            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructArrayType(parameterTypes[0]);\n        }\n        else if (Map.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 2) {\n                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n        }\n        else if (Collection.class.isAssignableFrom(parametrized)) {\n            if (parameterTypes.length != 1) {\n                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n            }\n            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n        } else {\n            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n        }\n        return resultType;\n    }", "constructParametricType": "    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n    }", "constructRawCollectionType": "    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n        return CollectionType.construct(collectionClass, unknownType());\n    }", "constructRawCollectionLikeType": "    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n        return CollectionLikeType.construct(collectionClass, unknownType());\n    }", "constructRawMapType": "    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n        return MapType.construct(mapClass, unknownType(), unknownType());\n    }", "constructRawMapLikeType": "    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n    }", "_fromClass": "    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n    {\n        // Very first thing: small set of core types we know well:\n        if (clz == String.class) return CORE_TYPE_STRING;\n        if (clz == Boolean.TYPE) return CORE_TYPE_BOOL;\n        if (clz == Integer.TYPE) return CORE_TYPE_INT;\n        if (clz == Long.TYPE) return CORE_TYPE_LONG;\n        \n        // Barring that, we may have recently constructed an instance:\n        ClassKey key = new ClassKey(clz);\n        JavaType result = _typeCache.get(key); // ok, cache object is synced\n        if (result != null) {\n            return result;\n        }\n\n        // If context was needed, weed do:\n        /*\n        if (context == null) {\n            context = new TypeBindings(this, cls);\n        }\n        */\n\n        // First: do we have an array type?\n        if (clz.isArray()) {\n            result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n            /* Also: although enums can also be fully resolved, there's little\n             * point in doing so (T extends Enum<T>) etc.\n             */\n        } else if (clz.isEnum()) {\n            result = new SimpleType(clz);\n            /* Maps and Collections aren't quite as hot; problem is, due\n             * to type erasure we often do not know typing and can only assume\n             * base Object.\n             */\n        } else if (Map.class.isAssignableFrom(clz)) {\n            result = _mapType(clz);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n            result =  _collectionType(clz);\n        } else {\n            // 28-Apr-2015, tatu: New class of types, referential...\n            if (AtomicReference.class.isAssignableFrom(clz)) {\n                \n                JavaType[] pts = findTypeParameters(clz, AtomicReference.class);\n                JavaType rt = (pts == null || pts.length != 1) ? unknownType() : pts[0];\n                result = constructReferenceType(clz, rt);\n            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n            } else if (Map.Entry.class.isAssignableFrom(clz)) {\n                JavaType[] pts = findTypeParameters(clz, Map.Entry.class);\n                JavaType kt, vt;\n                if (pts == null || pts.length != 2) {\n                    kt = vt = unknownType();\n                } else {\n                    kt = pts[0];\n                    vt = pts[1];\n                }\n                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n            } else {\n                result = new SimpleType(clz);\n            }\n        }\n        _typeCache.put(key, result); // cache object syncs\n        return result;\n    }", "_fromParameterizedClass": "    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n    {\n        if (clz.isArray()) { // ignore generics (should never have any)\n            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n        }\n        if (clz.isEnum()) { // ditto for enums\n            return new SimpleType(clz);\n        }\n        if (Map.class.isAssignableFrom(clz)) {\n            // First: if we do have param types, use them\n            JavaType keyType, contentType;\n            if (paramTypes.size() > 0) {\n                keyType = paramTypes.get(0);\n                contentType = (paramTypes.size() >= 2) ?\n                        paramTypes.get(1) : _unknownType();\n                return MapType.construct(clz, keyType, contentType);\n            }\n            return _mapType(clz);\n        }\n        if (Collection.class.isAssignableFrom(clz)) {\n            if (paramTypes.size() >= 1) {\n                return CollectionType.construct(clz, paramTypes.get(0));\n            }\n            return _collectionType(clz);\n        }\n        if (paramTypes.size() == 0) {\n            return new SimpleType(clz);\n        }\n        // Hmmh. Does this actually occur?\n        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n        return constructSimpleType(clz, clz, pt);\n    }", "_mapType": "    private JavaType _mapType(Class<?> rawClass)\n    {\n        // 28-May-2015, tatu: Properties are special, as per [databind#810]\n        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n        // ok to have no types (\"raw\")\n        if (typeParams == null) {\n            return MapType.construct(rawClass, _unknownType(), _unknownType());\n        }\n        // but exactly 2 types if any found\n        if (typeParams.length != 2) {\n            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n        }\n        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n    }", "_unknownType": "    protected JavaType _unknownType() {\n        return new SimpleType(Object.class);\n    }", "_findSuperClassChain": "    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n    {\n        HierarchicType current = new HierarchicType(currentType);\n        Class<?> raw = current.getRawClass();\n        if (raw == target) {\n            return current;\n        }\n        // Otherwise, keep on going down the rat hole...\n        Type parent = raw.getGenericSuperclass();\n        if (parent != null) {\n            HierarchicType sup = _findSuperClassChain(parent, target);\n            if (sup != null) {\n                sup.setSubType(current);\n                current.setSuperType(sup);\n                return current;\n            }\n        }\n        return null;\n    }", "_hashMapSuperInterfaceChain": "    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n    {\n        if (_cachedHashMapType == null) {\n            HierarchicType base = current.deepCloneWithoutSubtype();\n            _doFindSuperInterfaceChain(base, Map.class);\n            _cachedHashMapType = base.getSuperType();\n        }\n        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n        current.setSuperType(t);\n        t.setSubType(current);\n        return current;\n    }"}