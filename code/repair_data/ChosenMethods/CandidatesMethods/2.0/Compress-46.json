{"getLocalFileDataLength": "    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0) +\n                (bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n                (bit2_createTimePresent && createTime != null ? 4 : 0)\n        );\n    }", "getCentralDirectoryLength": "    public ZipShort getCentralDirectoryLength() {\n        return new ZipShort(1 +\n                (bit0_modifyTimePresent ? 4 : 0)\n        );\n    }", "getLocalFileDataData": "    public byte[] getLocalFileDataData() {\n        final byte[] data = new byte[getLocalFileDataLength().getValue()];\n        int pos = 0;\n        data[pos++] = 0;\n        if (bit0_modifyTimePresent) {\n            data[0] |= MODIFY_TIME_BIT;\n            System.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit1_accessTimePresent && accessTime != null) {\n            data[0] |= ACCESS_TIME_BIT;\n            System.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\n            pos += 4;\n        }\n        if (bit2_createTimePresent && createTime != null) {\n            data[0] |= CREATE_TIME_BIT;\n            System.arraycopy(createTime.getBytes(), 0, data, pos, 4);\n            pos += 4; // NOSONAR - assignment as documentation\n        }\n        return data;\n    }", "getCentralDirectoryData": "    public byte[] getCentralDirectoryData() {\n        final byte[] centralData = new byte[getCentralDirectoryLength().getValue()];\n        final byte[] localData = getLocalFileDataData();\n\n        // Truncate out create & access time (last 8 bytes) from\n        // the copy of the local data we obtained:\n        System.arraycopy(localData, 0, centralData, 0, centralData.length);\n        return centralData;\n    }", "parseFromLocalFileData": "    public void parseFromLocalFileData(\n            final byte[] data, int offset, final int length\n    ) throws ZipException {\n        reset();\n        final int len = offset + length;\n        setFlags(data[offset++]);\n        if (bit0_modifyTimePresent) {\n            modifyTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n\n        // Notice the extra length check in case we are parsing the shorter\n        // central data field (for both access and create timestamps).\n        if (bit1_accessTimePresent && offset + 4 <= len) {\n            accessTime = new ZipLong(data, offset);\n            offset += 4;\n        }\n        if (bit2_createTimePresent && offset + 4 <= len) {\n            createTime = new ZipLong(data, offset);\n            offset += 4; // NOSONAR - assignment as documentation\n        }\n    }", "parseFromCentralDirectoryData": "    public void parseFromCentralDirectoryData(\n            final byte[] buffer, final int offset, final int length\n    ) throws ZipException {\n        reset();\n        parseFromLocalFileData(buffer, offset, length);\n    }", "reset": "    private void reset() {\n        setFlags((byte) 0);\n        this.modifyTime = null;\n        this.accessTime = null;\n        this.createTime = null;\n    }", "setFlags": "    public void setFlags(final byte flags) {\n        this.flags = flags;\n        this.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\n        this.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\n        this.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n    }", "getFlags": "    public byte getFlags() { return flags; }", "zipLongToDate": "    private static Date zipLongToDate(ZipLong unixTime) {\n        return unixTime != null ? new Date(unixTime.getIntValue() * 1000L) : null;\n    }", "dateToZipLong": "    private static ZipLong dateToZipLong(final Date d) {\n        if (d == null) { return null; }\n\n        return unixTimeToZipLong(d.getTime() / 1000);\n    }", "unixTimeToZipLong": "    private static ZipLong unixTimeToZipLong(long l) {\n        final long TWO_TO_32 = 0x100000000L;\n        if (l >= TWO_TO_32) {\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }", "clone": "    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }", "equals": "    public boolean equals(final Object o) {\n        if (o instanceof X5455_ExtendedTimestamp) {\n            final X5455_ExtendedTimestamp xf = (X5455_ExtendedTimestamp) o;\n\n            // The ZipLong==ZipLong clauses handle the cases where both are null.\n            // and only last 3 bits of flags matter.\n            return ((flags & 0x07) == (xf.flags & 0x07)) &&\n                    (modifyTime == xf.modifyTime || (modifyTime != null && modifyTime.equals(xf.modifyTime))) &&\n                    (accessTime == xf.accessTime || (accessTime != null && accessTime.equals(xf.accessTime))) &&\n                    (createTime == xf.createTime || (createTime != null && createTime.equals(xf.createTime)));\n        }\n        return false;\n    }"}