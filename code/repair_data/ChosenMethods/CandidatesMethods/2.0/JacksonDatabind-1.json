{"rename": "    public BeanPropertyWriter rename(NameTransformer transformer) {\n        String newName = transformer.transform(_name.getValue());\n        if (newName.equals(_name.toString())) {\n            return this;\n        }\n        return new BeanPropertyWriter(this, new SerializedString(newName));\n    }", "assignSerializer": "    public void assignSerializer(JsonSerializer<Object> ser)\n    {\n        // may need to disable check in future?\n        if (_serializer != null && _serializer != ser) {\n            throw new IllegalStateException(\"Can not override serializer\");\n        }\n        _serializer = ser;\n    }", "assignNullSerializer": "    public void assignNullSerializer(JsonSerializer<Object> nullSer)\n    {\n        // may need to disable check in future?\n        if (_nullSerializer != null && _nullSerializer != nullSer) {\n            throw new IllegalStateException(\"Can not override null serializer\");\n        }\n        _nullSerializer = nullSer;\n    }", "getName": "    public String getName() {\n        return _name.getValue();\n    }", "getType": "    public JavaType getType() {\n        return _declaredType;\n    }", "getWrapperName": "    public PropertyName getWrapperName() {\n        return _wrapperName;\n    }", "getAnnotation": "    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n        return _member.getAnnotation(acls);\n    }", "getContextAnnotation": "    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n        return _contextAnnotations.get(acls);\n    }", "getMember": "    public AnnotatedMember getMember() {\n        return _member;\n    }", "depositSchemaProperty": "    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n        throws JsonMappingException\n    {\n        JavaType propType = getSerializationType();\n        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n        JsonNode schemaNode;\n        // Maybe it already has annotated/statically configured serializer?\n        JsonSerializer<Object> ser = getSerializer();\n        if (ser == null) { // nope\n            Class<?> serType = getRawSerializationType();\n            if (serType == null) {\n                serType = getPropertyType();\n            }\n            ser = provider.findValueSerializer(serType, this);\n        }\n        boolean isOptional = !isRequired();\n        if (ser instanceof SchemaAware) {\n            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n        } else {  \n            schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); \n        }\n        propertiesNode.put(getName(), schemaNode);\n    }", "getInternalSetting": "    public Object getInternalSetting(Object key)\n    {\n        if (_internalSettings == null) {\n            return null;\n        }\n        return _internalSettings.get(key);\n    }", "getSerializedName": "    public SerializedString getSerializedName() { return _name; }", "hasSerializer": "    public boolean hasSerializer() { return _serializer != null; }", "hasNullSerializer": "    public boolean hasNullSerializer() { return _nullSerializer != null; }", "getSerializer": "    public JsonSerializer<Object> getSerializer() {\n        return _serializer;\n    }", "getSerializationType": "    public JavaType getSerializationType() {\n        return _cfgSerializationType;\n    }", "getRawSerializationType": "    public Class<?> getRawSerializationType() {\n        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n    }", "getPropertyType": "    public Class<?> getPropertyType() \n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getReturnType();\n        }\n        return _field.getType();\n    }", "getGenericPropertyType": "    public Type getGenericPropertyType()\n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.getGenericReturnType();\n        }\n        return _field.getGenericType();\n    }", "getViews": "    public Class<?>[] getViews() { return _includeInViews; }", "serializeAsField": "    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        // Null handling is bit different, check that first\n        if (value == null) {\n            if (_nullSerializer != null) {\n                jgen.writeFieldName(_name);\n                _nullSerializer.serialize(null, jgen, prov);\n            }\n            return;\n        }\n        // then find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) {\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) {\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        jgen.writeFieldName(_name);\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }", "serializeAsColumn": "    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            _handleSelfReference(bean, ser);\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }", "serializeAsPlaceholder": "    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        if (_nullSerializer != null) {\n            _nullSerializer.serialize(null, jgen, prov);\n        } else {\n            jgen.writeNull();\n        }\n    }", "_findAndAddDynamic": "    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n            Class<?> type, SerializerProvider provider) throws JsonMappingException\n    {\n        PropertySerializerMap.SerializerAndMapResult result;\n        if (_nonTrivialBaseType != null) {\n            JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n            result = map.findAndAddSerializer(t, provider, this);\n        } else {\n            result = map.findAndAddSerializer(type, provider, this);\n        }\n        // did we get a new map of serializers? If so, start using it\n        if (map != result.map) {\n            _dynamicSerializers = result.map;\n        }\n        return result.serializer;\n    }", "get": "    public final Object get(Object bean) throws Exception\n    {\n        if (_accessorMethod != null) {\n            return _accessorMethod.invoke(bean);\n        }\n        return _field.get(bean);\n    }", "_handleSelfReference": "    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n        throws JsonMappingException\n    {\n        /* 05-Feb-2012, tatu: Usually a problem, but NOT if we are handling\n         *    object id; this may be the case for BeanSerializers at least.\n         */\n        if (ser.usesObjectId()) {\n            return;\n        }\n        throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n    }"}