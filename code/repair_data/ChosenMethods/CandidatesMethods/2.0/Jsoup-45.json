{"parse": "    Document parse(String input, String baseUri, ParseErrorList errors) {\n        state = HtmlTreeBuilderState.Initial;\n        baseUriSetFromDoc = false;\n        return super.parse(input, baseUri, errors);\n    }", "process": "    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }", "transition": "    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }", "state": "    HtmlTreeBuilderState state() {\n        return state;\n    }", "getDocument": "    Document getDocument() {\n        return doc;\n    }", "getBaseUri": "    String getBaseUri() {\n        return baseUri;\n    }", "error": "    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }", "insert": "    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }", "insertNode": "    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }", "pop": "    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }", "push": "    void push(Element element) {\n        stack.add(element);\n    }", "getStack": "    ArrayList<Element> getStack() {\n        return stack;\n    }", "onStack": "    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }", "isElementInQueue": "    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n        for (int pos = queue.size() -1; pos >= 0; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }", "getFromStack": "    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }", "removeFromStack": "    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }", "popStackToClose": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (StringUtil.in(next.nodeName(), elNames))\n                break;\n        }\n    }", "popStackToBefore": "    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }", "clearStackToTableContext": "    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }", "clearStackToTableBodyContext": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }", "clearStackToTableRowContext": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }", "clearStackToContext": "    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }", "aboveOnStack": "    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }", "insertOnStackAfter": "    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }", "replaceOnStack": "    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }", "resetInsertionMode": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }", "inTableScope": "    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }", "inSelectScope": "    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }", "setHeadElement": "    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }", "getHeadElement": "    Element getHeadElement() {\n        return headElement;\n    }", "getFormElement": "    FormElement getFormElement() {\n        return formElement;\n    }", "setFormElement": "    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }", "getPendingTableCharacters": "    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }", "lastFormattingElement": "    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }", "removeLastFormattingElement": "    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }", "pushActiveFormattingElements": "    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }", "isSameFormattingElement": "    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }", "reconstructFormattingElements": "    void reconstructFormattingElements() {\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }", "clearFormattingElementsToLastMarker": "    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }", "removeFromActiveFormattingElements": "    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }", "isInActiveFormattingElements": "    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }", "getActiveFormattingElement": "    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }", "replaceActiveFormattingElement": "    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }", "insertMarkerToFormattingElements": "    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }", "toString": "    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }"}