{"getOrCreateFunctionState": "  FunctionState getOrCreateFunctionState(String fnName) {\n    FunctionState fs = fns.get(fnName);\n    if (fs == null) {\n      fs = new FunctionState();\n      fns.put(fnName, fs);\n    }\n    return fs;\n  }", "enableSpecialization": "  public void enableSpecialization(SpecializeModule.SpecializationState\n      specializationState) {\n    this.specializationState = specializationState;\n  }", "process": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions(fnNames);\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "visit": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n      if (n.getType() == Token.NAME) {\n        checkNameUsage(t, n, parent);\n      }\n    }", "findNamedFunctions": "    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n      if (!NodeUtil.isStatement(n)) {\n        // There aren't any interesting functions here.\n        return;\n      }\n\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   var fooFn = function(x) { return ... }\n        case Token.VAR:\n          Preconditions.checkState(n.hasOneChild());\n          Node nameNode = n.getFirstChild();\n          if (nameNode.getType() == Token.NAME && nameNode.hasChildren()\n              && nameNode.getFirstChild().getType() == Token.FUNCTION) {\n            maybeAddFunction(new FunctionVar(n), t.getModule());\n          }\n          break;\n\n        // Named functions\n        // function Foo(x) { return ... }\n        case Token.FUNCTION:\n          Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n              || parent.getType() == Token.LABEL);\n          if (!NodeUtil.isFunctionExpression(n)) {\n            Function fn = new NamedFunction(n);\n            maybeAddFunction(fn, t.getModule());\n          }\n          break;\n      }\n    }", "findFunctionExpressions": "    public void findFunctionExpressions(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   (function(){})();\n        case Token.CALL:\n          Node fnNode = null;\n          if (n.getFirstChild().getType() == Token.FUNCTION) {\n            fnNode = n.getFirstChild();\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Node fnIdentifingNode = n.getFirstChild().getFirstChild();\n            if (fnIdentifingNode.getType() == Token.FUNCTION) {\n              fnNode = fnIdentifingNode;\n            }\n          }\n\n          // If a interesting function was discovered, add it.\n          if (fnNode != null) {\n            Function fn = new FunctionExpression(fnNode, callsSeen++);\n            maybeAddFunction(fn, t.getModule());\n            anonFns.put(fnNode, fn.getName());\n          }\n          break;\n      }\n    }", "maybeAddFunction": "  private void maybeAddFunction(Function fn, JSModule module) {\n    String name = fn.getName();\n    FunctionState fs = getOrCreateFunctionState(name);\n\n    // TODO(johnlenz): Maybe \"smarten\" FunctionState by adding this logic\n    // to it?\n\n    // If the function has multiple definitions, don't inline it.\n    if (fs.hasExistingFunctionDefinition()) {\n      fs.setInline(false);\n    } else {\n      // verify the function hasn't already been marked as \"don't inline\"\n      if (fs.canInline()) {\n        // store it for use when inlining.\n        fs.setFn(fn);\n        if (injector.isDirectCallNodeReplacementPossible(\n            fn.getFunctionNode())) {\n          fs.inlineDirectly(true);\n        }\n\n        // verify the function meets all the requirements.\n        // TODO(johnlenz): Minimum requirement checks are about 5% of the\n        // runtime cost of this pass.\n        if (!isCandidateFunction(fn)) {\n          // It doesn't meet the requirements.\n          fs.setInline(false);\n        }\n\n        // Set the module and gather names that need temporaries.\n        if (fs.canInline()) {\n          fs.setModule(module);\n\n          Node fnNode = fn.getFunctionNode();\n          Set<String> namesToAlias =\n              FunctionArgumentInjector.findModifiedParameters(fnNode);\n          if (!namesToAlias.isEmpty()) {\n            fs.inlineDirectly(false);\n            fs.setNamesToAlias(namesToAlias);\n          }\n\n          Node block = NodeUtil.getFunctionBody(fnNode);\n          if (NodeUtil.referencesThis(block)) {\n            fs.setReferencesThis(true);\n          }\n\n          if (NodeUtil.containsFunction(block)) {\n            fs.setHasInnerFunctions(true);\n            // If there are inner functions, we can inline into global scope\n            // if there are no local vars or named functions.\n            // TODO(johnlenz): this can be improved by looking at the possible\n            // values for locals.  If there are simple values, or constants\n            // we could still inline.\n            if (hasLocalNames(fnNode)) {\n              fs.setInline(false);\n            }\n          }\n        }\n\n        // Check if block inlining is allowed.\n        if (fs.canInline() && !fs.canInlineDirectly()) {\n          if (!blockFunctionInliningEnabled) {\n            fs.setInline(false);\n          }\n        }\n      }\n    }\n  }", "hasLocalNames": "  private boolean hasLocalNames(Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n    return NodeUtil.getFnParameters(fnNode).hasChildren()\n        || NodeUtil.has(\n             block,\n             new NodeUtil.MatchDeclaration(),\n             new NodeUtil.MatchShallowStatement());\n  }", "getContainingFunction": "  private static Node getContainingFunction(NodeTraversal t) {\n    return (t.inGlobalScope()) ? null : t.getScopeRoot();\n  }", "isCandidateFunction": "  private boolean isCandidateFunction(Function fn) {\n    // Don't inline exported functions.\n    String fnName = fn.getName();\n    if (compiler.getCodingConvention().isExported(fnName)) {\n      // TODO(johnlenz): Should we allow internal references to be inlined?\n      // An exported name can be replaced externally, any inlined instance\n      // would not reflect this change.\n      // To allow inlining we need to be able to distinguish between exports\n      // that are used in a read-only fashion and those that can be replaced\n      // by external definitions.\n      return false;\n    }\n\n    // Don't inline this special function\n    if (RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(fnName)) {\n      return false;\n    }\n\n    // Don't inline if we are specializing and the function can't be fixed up\n    if (specializationState != null &&\n        !specializationState.canFixupFunction(fn.getFunctionNode())) {\n      return false;\n    }\n\n    Node fnNode = fn.getFunctionNode();\n    return injector.doesFunctionMeetMinimumRequirements(fnName, fnNode);\n  }", "isCandidateUsage": "  static boolean isCandidateUsage(Node name) {\n    Node parent = name.getParent();\n    Preconditions.checkState(name.getType() == Token.NAME);\n    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {\n      // This is a declaration.  Duplicate declarations are handle during\n      // function candidate gathering.\n      return true;\n    }\n\n    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {\n      // This is a normal reference to the function.\n      return true;\n    }\n\n    // Check for a \".call\" to the named function:\n    //   CALL\n    //     GETPROP/GETELEM\n    //       NAME\n    //       STRING == \"call\"\n    //     This-Value\n    //     Function-parameter-1\n    //     ...\n    if (NodeUtil.isGet(parent)\n         && name == parent.getFirstChild()\n         && name.getNext().getType() == Token.STRING\n         && name.getNext().getString().equals(\"call\")) {\n      Node gramps = name.getAncestor(2);\n      if (gramps.getType() == Token.CALL\n          && gramps.getFirstChild() == parent) {\n        // Yep, a \".call\".\n        return true;\n      }\n    }\n    return false;\n  }", "visitCallSite": "    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n      Preconditions.checkState(fs.hasExistingFunctionDefinition());\n      if (fs.canInline()) {\n        Reference ref = fs.getReference(callNode);\n        // There are two cases ref can be null: if the call site was introduce\n        // because it was part of a function that was inlined during this pass\n        // or if the call site was trimmed from the list of references because\n        // the function couldn't be inlined at this location.\n        if (ref != null) {\n          if (specializationState != null) {\n            Node containingFunction = getContainingFunction(t);\n\n            if (containingFunction != null) {\n              // Report that the function was specialized so that\n              // {@link SpecializeModule} can fix it up.\n              specializationState.reportSpecializedFunction(containingFunction);\n            }\n          }\n\n          inlineFunction(t, callNode, fs, ref.mode);\n          // Keep track of references that have been inlined so that\n          // we can verify that none have been missed.\n          ref.inlined = true;\n        }\n      }\n    }", "maybeAddReference": "    void maybeAddReference(NodeTraversal t, FunctionState fs,\n        Node callNode, JSModule module) {\n      if (!fs.canInline()) {\n        return;\n      }\n\n      boolean referenceAdded = false;\n      InliningMode mode = fs.canInlineDirectly()\n           ? InliningMode.DIRECT : InliningMode.BLOCK;\n      referenceAdded = maybeAddReferenceUsingMode(\n          t, fs, callNode, module, mode);\n      if (!referenceAdded &&\n          mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n        // This reference can not be directly inlined, see if\n        // block replacement inlining is possible.\n        mode = InliningMode.BLOCK;\n        referenceAdded = maybeAddReferenceUsingMode(\n            t, fs, callNode, module, mode);\n      }\n\n      if (!referenceAdded) {\n        // Don't try to remove a function if we can't inline all\n        // the references.\n        fs.setRemove(false);\n      }\n    }", "maybeAddReferenceUsingMode": "    private boolean maybeAddReferenceUsingMode(\n        NodeTraversal t, FunctionState fs, Node callNode,\n        JSModule module, InliningMode mode) {\n\n      if (specializationState != null) {\n        // If we're specializing, make sure we can fixup\n        // the containing function before inlining\n        Node containingFunction = getContainingFunction(t);\n        if (containingFunction != null && !specializationState.canFixupFunction(\n            containingFunction)) {\n            return false;\n        }\n      }\n\n      CanInlineResult result = injector.canInlineReferenceToFunction(\n          t, callNode, fs.getFn().getFunctionNode(),\n          fs.getNamesToAlias(), mode, fs.getReferencesThis(),\n          fs.hasInnerFunctions());\n      if (result != CanInlineResult.NO) {\n        // Yeah!\n        boolean decompose =\n          (result == CanInlineResult.AFTER_DECOMPOSITION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n      }\n\n      return false;\n    }", "checkNameUsage": "    private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n\n      if (isCandidateUsage(n)) {\n        return;\n      }\n\n      // Other refs to a function name remove its candidacy for inlining\n      String name = n.getString();\n      FunctionState fs = fns.get(name);\n      if (fs == null) {\n        return;\n      }\n\n      // Unlike normal call/new parameters, references passed to\n      // JSCompiler_ObjectPropertyString are not aliases of a value, but\n      // a reference to the name itself, as such the value of the name is\n      // unknown and can not be inlined.\n      if (parent.getType() == Token.NEW) {\n        Node target = parent.getFirstChild();\n        if (target.getType() == Token.NAME && target.getString().equals(\n            ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING)) {\n          // This method is going to be replaced so don't inline it anywhere.\n          fs.setInline(false);\n        }\n      }\n\n      // If the name is being assigned to it can not be inlined.\n      if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) {\n        // e.g. bar = something; <== we can't inline \"bar\"\n        // so mark the function as uninlinable.\n        // TODO(johnlenz): Should we just remove it from fns here?\n        fs.setInline(false);\n      } else {\n        // e.g. var fn = bar; <== we can't inline \"bar\"\n        // As this reference can't be inlined mark the function as\n        // unremovable.\n        fs.setRemove(false);\n      }\n    }", "inlineFunction": "    private void inlineFunction(\n        NodeTraversal t, Node callNode, FunctionState fs, InliningMode mode) {\n      Function fn = fs.getFn();\n      String fnName = fn.getName();\n      Node fnNode = fs.getSafeFnNode();\n\n      Node newCode = injector.inline(t, callNode, fnName, fnNode, mode);\n      t.getCompiler().reportCodeChange();\n      t.getCompiler().addToDebugLog(\"Inlined function: \" + fn.getName());\n    }", "trimCanidatesNotMeetingMinimumRequirements": "  private void trimCanidatesNotMeetingMinimumRequirements() {\n   Iterator<Entry<String, FunctionState>> i;\n   for (i = fns.entrySet().iterator(); i.hasNext();) {\n     FunctionState fs = i.next().getValue();\n     if (!fs.hasExistingFunctionDefinition() || !fs.canInline()) {\n       i.remove();\n     }\n   }\n  }", "trimCanidatesUsingOnCost": "  void trimCanidatesUsingOnCost() {\n    Iterator<Entry<String, FunctionState>> i;\n    for (i = fns.entrySet().iterator(); i.hasNext();) {\n      FunctionState fs = i.next().getValue();\n      if (fs.hasReferences()) {\n        // Only inline function if it decreases the code size.\n        boolean lowersCost = mimimizeCost(fs);\n        if (!lowersCost) {\n          // It shouldn't be inlined; remove it from the list.\n          i.remove();\n        }\n      } else if (!fs.canRemove()) {\n        // Don't bother tracking functions without references that can't be\n        // removed.\n        i.remove();\n      }\n    }\n  }", "mimimizeCost": "  private boolean mimimizeCost(FunctionState fs) {\n    if (!inliningLowersCost(fs)) {\n      // Try again without Block inlining references\n      if (fs.hasBlockInliningReferences()) {\n        fs.setRemove(false);\n        fs.removeBlockInliningReferences();\n        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }", "inliningLowersCost": "  private boolean inliningLowersCost(FunctionState fs) {\n    return injector.inliningLowersCost(\n        fs.getModule(),\n        fs.getFn().getFunctionNode(),\n        fs.getReferences(),\n        fs.getNamesToAlias(),\n        fs.canRemove(),\n        fs.getReferencesThis());\n  }", "resolveInlineConflicts": "  private void resolveInlineConflicts() {\n    for (FunctionState fs : fns.values()) {\n      resolveInlineConflictsForFunction(fs);\n    }\n  }", "resolveInlineConflictsForFunction": "  private void resolveInlineConflictsForFunction(FunctionState fs) {\n    // Functions that aren't referenced don't cause conflicts.\n    if (!fs.hasReferences()) {\n      return;\n    }\n\n    Node fnNode = fs.getFn().getFunctionNode();\n    Set<String> names = findCalledFunctions(fnNode);\n    if (!names.isEmpty()) {\n      // Prevent the removal of the referenced functions.\n      for (String name : names) {\n        FunctionState fsCalled = fns.get(name);\n        if (fsCalled != null && fsCalled.canRemove()) {\n          fsCalled.setRemove(false);\n          // For functions that can no longer be removed, check if they should\n          // still be inlined.\n          if (!mimimizeCost(fsCalled)) {\n            // It can't be inlined remove it from the list.\n            fsCalled.setInline(false);\n          }\n        }\n      }\n\n      // Make a copy of the Node, so it isn't changed by other inlines.\n      fs.setSafeFnNode(fs.getFn().getFunctionNode().cloneTree());\n    }\n  }", "findCalledFunctions": "  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.getType() == Token.CALL) {\n      Node child = node.getFirstChild();\n      if (child.getType() == Token.NAME) {\n        changed.add(child.getString());\n      }\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }", "decomposeExpressions": "  private void decomposeExpressions(Set<String> fnNames) {\n    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n        compiler, compiler.getUniqueNameIdSupplier(), fnNames);\n\n    for (FunctionState fs : fns.values()) {\n      if (fs.canInline()) {\n        for (Reference ref : fs.getReferences()) {\n          if (ref.requiresDecomposition) {\n            decomposer.maybeDecomposeExpression(ref.callNode);\n          }\n        }\n      }\n    }\n  }", "removeInlinedFunctions": "  void removeInlinedFunctions() {\n    for (FunctionState fs : fns.values()) {\n      if (fs.canRemove()) {\n        Function fn = fs.getFn();\n        Preconditions.checkState(fs.canInline());\n        Preconditions.checkState(fn != null);\n        verifyAllReferencesInlined(fs);\n\n        if (specializationState != null) {\n          specializationState.reportRemovedFunction(\n              fn.getFunctionNode(), fn.getDeclaringBlock());\n        }\n\n        fn.remove();\n        compiler.reportCodeChange();\n      }\n    }\n  }", "verifyAllReferencesInlined": "  void verifyAllReferencesInlined(FunctionState fs) {\n    for (Reference ref : fs.getReferences()) {\n      if (!ref.inlined) {\n        throw new IllegalStateException(\"Call site missed.\\n call: \"\n            + ref.callNode.toStringTree() + \"\\n parent:  \"\n            + ref.callNode.getParent().toStringTree());\n      }\n    }\n  }", "hasExistingFunctionDefinition": "    boolean hasExistingFunctionDefinition() {\n      return (fn != null);\n    }", "setReferencesThis": "    public void setReferencesThis(boolean referencesThis) {\n      this.referencesThis = referencesThis;\n    }", "getReferencesThis": "    public boolean getReferencesThis() {\n      return this.referencesThis;\n    }", "setHasInnerFunctions": "    public void setHasInnerFunctions(boolean hasInnerFunctions) {\n      this.hasInnerFunctions = hasInnerFunctions;\n    }", "hasInnerFunctions": "    public boolean hasInnerFunctions() {\n      return hasInnerFunctions;\n    }", "removeBlockInliningReferences": "    void removeBlockInliningReferences() {\n      Iterator<Entry<Node, Reference>> i;\n      for (i = getReferencesInternal().entrySet().iterator(); i.hasNext();) {\n        Entry<Node, Reference> entry = i.next();\n        if (entry.getValue().mode == InliningMode.BLOCK) {\n          i.remove();\n        }\n      }\n    }", "hasBlockInliningReferences": "    public boolean hasBlockInliningReferences() {\n      for (Reference r : getReferencesInternal().values()) {\n        if (r.mode == InliningMode.BLOCK) {\n          return true;\n        }\n      }\n      return false;\n    }", "setFn": "    public void setFn(Function fn) {\n      Preconditions.checkState(this.fn == null);\n      this.fn = fn;\n    }", "getSafeFnNode": "    public Node getSafeFnNode() {\n      return (safeFnNode != null) ? safeFnNode : fn.getFunctionNode();\n    }", "setSafeFnNode": "    public void setSafeFnNode(Node safeFnNode) {\n      this.safeFnNode = safeFnNode;\n    }", "canInline": "    public boolean canInline() {\n      return inline;\n    }", "setInline": "    public void setInline(boolean inline) {\n      this.inline = inline;\n      if (inline == false) {\n        // No need to keep references to function that can't be inlined.\n        references = null;\n        // Don't remove functions that we aren't inlining.\n        remove = false;\n      }\n    }", "canRemove": "    public boolean canRemove() {\n      return remove;\n    }", "setRemove": "    public void setRemove(boolean remove) {\n      this.remove = remove;\n    }", "canInlineDirectly": "    public boolean canInlineDirectly() {\n      return inlineDirectly;\n    }", "inlineDirectly": "    public void inlineDirectly(boolean directReplacement) {\n      this.inlineDirectly = directReplacement;\n    }", "hasReferences": "    public boolean hasReferences() {\n      return (references != null && !references.isEmpty());\n    }", "getReferencesInternal": "    private Map<Node, Reference> getReferencesInternal() {\n      if (references == null) {\n        return Collections.emptyMap();\n      }\n      return references;\n    }", "addReference": "    public void addReference(Reference ref) {\n      if (references == null) {\n        references = Maps.newHashMap();\n      }\n      references.put(ref.callNode, ref);\n    }", "getReferences": "    public Collection<Reference> getReferences() {\n      return getReferencesInternal().values();\n    }", "getReference": "    public Reference getReference(Node n) {\n      return getReferencesInternal().get(n);\n    }", "getNamesToAlias": "    public Set<String> getNamesToAlias() {\n      if (namesToAlias == null) {\n        return Collections.emptySet();\n      }\n      return Collections.unmodifiableSet(namesToAlias);\n    }", "setNamesToAlias": "    public void setNamesToAlias(Set<String> names) {\n      namesToAlias = names;\n    }", "setModule": "    public void setModule(JSModule module) {\n      this.module = module;\n    }", "getName": "    public String getName() {\n      return fakeName;\n    }", "getFunctionNode": "    public Node getFunctionNode() {\n      return fn;\n    }", "remove": "    public void remove() {\n      // Nothing to do. The function is removed with the call.\n    }", "getDeclaringBlock": "    public Node getDeclaringBlock() {\n      return null;\n    }"}