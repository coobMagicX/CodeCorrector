{"process": "    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }", "transition": "    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }", "state": "    HtmlTreeBuilderState state() {\n        return state;\n    }", "getDocument": "    Document getDocument() {\n        return doc;\n    }", "getBaseUri": "    String getBaseUri() {\n        return baseUri;\n    }", "error": "    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }", "insert": "    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        String tagName = currentElement().tagName();\n        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n            node = new DataNode(characterToken.getData());\n        else\n            node = new TextNode(characterToken.getData());\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }", "pop": "    Element pop() {\n        int size = stack.size();\n        return stack.remove(size-1);\n    }", "push": "    void push(Element element) {\n        stack.add(element);\n    }", "getStack": "    ArrayList<Element> getStack() {\n        return stack;\n    }", "onStack": "    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }", "getFromStack": "    Element getFromStack(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }", "removeFromStack": "    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                return true;\n            }\n        }\n        return false;\n    }", "popStackToClose": "    void popStackToClose(String... elNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (inSorted(next.nodeName(), elNames))\n                break;\n        }\n    }", "popStackToBefore": "    void popStackToBefore(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                stack.remove(pos);\n            }\n        }\n    }", "clearStackToTableContext": "    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }", "clearStackToTableBodyContext": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }", "clearStackToTableRowContext": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }", "clearStackToContext": "    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                stack.remove(pos);\n        }\n    }", "aboveOnStack": "    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }", "insertOnStackAfter": "    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }", "replaceOnStack": "    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }", "getHeadElement": "    Element getHeadElement() {\n        return headElement;\n    }", "getFormElement": "    FormElement getFormElement() {\n        return formElement;\n    }", "getPendingTableCharacters": "    List<String> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }", "getActiveFormattingElement": "    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }", "toString": "    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }"}