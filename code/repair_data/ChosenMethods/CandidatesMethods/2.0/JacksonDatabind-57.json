{"version": "    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "_new": "    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n            FormatSchema schema, InjectableValues injectableValues,\n            DataFormatReaders dataFormatReaders) {\n        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n                 schema,  injectableValues, dataFormatReaders);\n    }", "_newIterator": "    protected <T> MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt,\n            JsonDeserializer<?> deser, boolean parserManaged)\n    {\n        return new MappingIterator<T>(_valueType, p, ctxt,\n                deser, parserManaged, _valueToUpdate);\n    }", "_initForReading": "    protected JsonToken _initForReading(JsonParser p) throws IOException\n    {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = p.getCurrentToken();\n        if (t == null) { // and then we must get something...\n            t = p.nextToken();\n            if (t == null) {\n                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }", "_initForMultiRead": "    protected void _initForMultiRead(JsonParser p) throws IOException {\n        if (_schema != null) {\n            p.setSchema(_schema);\n        }\n        _config.initialize(p); // since 2.5\n    }", "with": "    public ObjectReader with(ContextAttributes attrs) {\n        return _with(_config.with(attrs));\n    }", "withFeatures": "    public ObjectReader withFeatures(FormatFeature... features) {\n        return _with(_config.withFeatures(features));\n    }    ", "without": "    public ObjectReader without(FormatFeature feature) {\n        return _with(_config.without(feature)); \n    }", "withoutFeatures": "    public ObjectReader withoutFeatures(FormatFeature... features) {\n        return _with(_config.withoutFeatures(features));\n    }", "withRootName": "    public ObjectReader withRootName(PropertyName rootName) {\n        return _with(_config.withRootName(rootName));\n    }", "withoutRootName": "    public ObjectReader withoutRootName() {\n        return _with(_config.withRootName(PropertyName.NO_NAME));\n    }", "forType": "    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    ", "withType": "    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n    }    ", "withValueToUpdate": "    public ObjectReader withValueToUpdate(Object value)\n    {\n        if (value == _valueToUpdate) return this;\n        if (value == null) {\n            throw new IllegalArgumentException(\"cat not update null value\");\n        }\n        JavaType t;\n        \n        /* no real benefit from pre-fetching, as updating readers are much\n         * less likely to be reused, and value type may also be forced\n         * with a later chained call...\n         */\n        if (_valueType == null) {\n            t = _config.constructType(value.getClass());\n        } else {\n            t = _valueType;\n        }\n        return _new(this, _config, t, _rootDeserializer, value,\n                _schema, _injectableValues, _dataFormatReaders);\n    }", "withView": "    public ObjectReader withView(Class<?> activeView) {\n        return _with(_config.withView(activeView));\n    }", "withHandler": "    public ObjectReader withHandler(DeserializationProblemHandler h) {\n        return _with(_config.withHandler(h));\n    }", "withFormatDetection": "    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                _schema, _injectableValues, readers);\n    }", "withAttributes": "    public ObjectReader withAttributes(Map<?,?> attrs) {\n        return _with(_config.withAttributes(attrs));\n    }", "withAttribute": "    public ObjectReader withAttribute(Object key, Object value) {\n        return _with( _config.withAttribute(key, value));\n    }", "withoutAttribute": "    public ObjectReader withoutAttribute(Object key) {\n        return _with(_config.withoutAttribute(key));\n    }", "_with": "    protected ObjectReader _with(DeserializationConfig newConfig) {\n        if (newConfig == _config) {\n            return this;\n        }\n        ObjectReader r = _new(this, newConfig);\n        if (_dataFormatReaders != null) {\n            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n        }\n        return r;\n    }", "getConfig": "    public DeserializationConfig getConfig() {\n        return _config;\n    }", "getFactory": "    public JsonFactory getFactory() {\n        return _parserFactory;\n    }", "getTypeFactory": "    public TypeFactory getTypeFactory() {\n        return _config.getTypeFactory();\n    }", "getAttributes": "    public ContextAttributes getAttributes() {\n        return _config.getAttributes();\n    }", "getInjectableValues": "    public InjectableValues getInjectableValues() {\n        return _injectableValues;\n    }", "readValues": "    public <T> MappingIterator<T> readValues(URL src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), true);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }", "createArrayNode": "    public JsonNode createArrayNode() {\n        return _config.getNodeFactory().arrayNode();\n    }", "createObjectNode": "    public JsonNode createObjectNode() {\n        return _config.getNodeFactory().objectNode();\n    }", "treeAsTokens": "    public JsonParser treeAsTokens(TreeNode n) {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }", "readTree": "    public JsonNode readTree(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n\n        return _bindAndCloseAsTree(_considerFilter(_parserFactory.createParser(json), false));\n    }", "writeTree": "    public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n        throw new UnsupportedOperationException();\n    }", "treeToValue": "    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n    {\n        try {\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }    ", "writeValue": "    public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n    }", "_bind": "    protected Object _bind(JsonParser p, Object valueToUpdate) throws IOException\n    {\n        /* First: may need to read the next token, to initialize state (either\n         * before first read from parser, or after previous token has been cleared)\n         */\n        Object result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL) {\n            if (valueToUpdate == null) {\n                DeserializationContext ctxt = createDeserializationContext(p);\n                result = _findRootDeserializer(ctxt).getNullValue(ctxt);\n            } else {\n                result = valueToUpdate;\n            }\n        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = valueToUpdate;\n        } else { // pointing to event other than null\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = _unwrapAndDeserialize(p, ctxt, _valueType, deser);\n            } else {\n                if (valueToUpdate == null) {\n                    result = deser.deserialize(p, ctxt);\n                } else {\n                    deser.deserialize(p, ctxt, valueToUpdate);\n                    result = valueToUpdate;\n                }\n            }\n        }\n        // Need to consume the token too\n        p.clearCurrentToken();\n        return result;\n    }", "_considerFilter": "    protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {\n        // 26-Mar-2016, tatu: Need to allow multiple-matches at least if we have\n        //    have a multiple-value read (that is, \"readValues()\").\n        return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))\n                ? p : new FilteringParserDelegate(p, _filter, false, multiValue);\n    }", "_bindAndCloseAsTree": "    protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException {\n        try {\n            return _bindAsTree(p);\n        } finally {\n            try {\n                p.close();\n            } catch (IOException ioe) { }\n        }\n    }", "_bindAsTree": "    protected JsonNode _bindAsTree(JsonParser p) throws IOException\n    {\n        JsonNode result;\n        JsonToken t = _initForReading(p);\n        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n            result = NullNode.instance;\n        } else {\n            DeserializationContext ctxt = createDeserializationContext(p);\n            JsonDeserializer<Object> deser = _findTreeDeserializer(ctxt);\n            if (_unwrapRoot) {\n                result = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);\n            } else {\n                result = (JsonNode) deser.deserialize(p, ctxt);\n            }\n        }\n        // Need to consume the token too\n        p.clearCurrentToken();\n        return result;\n    }", "_bindAndReadValues": "    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException\n    {\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }", "_detectBindAndClose": "    protected Object _detectBindAndClose(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndClose(p);\n    }", "_detectBindAndReadValues": "    protected <T> MappingIterator<T> _detectBindAndReadValues(DataFormatReaders.Match match, boolean forceClosing)\n        throws IOException, JsonProcessingException\n    {\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        // One more thing: we Own the input stream now; and while it's \n        // not super clean way to do it, we must ensure closure so:\n        if (forceClosing) {\n            p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        }\n        // important: use matching ObjectReader (may not be 'this')\n        return match.getReader()._bindAndReadValues(p);\n    }", "_detectBindAndCloseAsTree": "    protected JsonNode _detectBindAndCloseAsTree(InputStream in) throws IOException\n    {\n        DataFormatReaders.Match match = _dataFormatReaders.findFormat(in);\n        if (!match.hasMatch()) {\n            _reportUnkownFormat(_dataFormatReaders, match);\n        }\n        JsonParser p = match.createParserWithMatch();\n        p.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n        return match.getReader()._bindAndCloseAsTree(p);\n    }", "_reportUnkownFormat": "    protected void _reportUnkownFormat(DataFormatReaders detector, DataFormatReaders.Match match) throws JsonProcessingException\n    {\n        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:\n        throw new JsonParseException(null, \"Can not detect format from input, does not look like any of detectable formats \"\n                +detector.toString());\n    }", "_verifySchemaType": "    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_parserFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_parserFactory.getFormatName());\n            }\n        }\n    }", "createDeserializationContext": "    protected DefaultDeserializationContext createDeserializationContext(JsonParser p) {\n        return _context.createInstance(_config, p, _injectableValues);\n    }", "_reportUndetectableSource": "    protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n    {\n        // 17-Aug-2015, tatu: Unfortunately, no parser/generator available so:\n        throw new JsonParseException(null, \"Can not use source of type \"\n                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\");\n    }", "_inputStream": "    protected InputStream _inputStream(File f) throws IOException {\n        return new FileInputStream(f);\n    }", "_findRootDeserializer": "    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        if (_rootDeserializer != null) {\n            return _rootDeserializer;\n        }\n\n        // Sanity check: must have actual type...\n        JavaType t = _valueType;\n        if (t == null) {\n            throw JsonMappingException.from(ctxt, \"No value type configured for ObjectReader\");\n        }\n        \n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(t);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(t);\n        if (deser == null) { // can this happen?\n            throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type \"+t);\n        }\n        _rootDeserializers.put(t, deser);\n        return deser;\n    }", "_findTreeDeserializer": "    protected JsonDeserializer<Object> _findTreeDeserializer(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _rootDeserializers.get(JSON_NODE_TYPE);\n        if (deser == null) {\n            // Nope: need to ask provider to resolve it\n            deser = ctxt.findRootValueDeserializer(JSON_NODE_TYPE);\n            if (deser == null) { // can this happen?\n                throw JsonMappingException.from(ctxt,\n                        \"Can not find a deserializer for type \"+JSON_NODE_TYPE);\n            }\n            _rootDeserializers.put(JSON_NODE_TYPE, deser);\n        }\n        return deser;\n    }", "_prefetchRootDeserializer": "    protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType)\n    {\n        if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n            return null;\n        }\n        // already cached?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser == null) {\n            try {\n                // If not, need to resolve; for which we need a temporary context as well:\n                DeserializationContext ctxt = createDeserializationContext(null);\n                deser = ctxt.findRootValueDeserializer(valueType);\n                if (deser != null) {\n                    _rootDeserializers.put(valueType, deser);\n                }\n                return deser;\n            } catch (JsonProcessingException e) {\n                // need to swallow?\n            }\n        }\n        return deser;\n    }", "at": "    public ObjectReader at(final JsonPointer pointer) {\n        return new ObjectReader(this, new JsonPointerBasedFilter(pointer));\n    }"}