{"forInterface": "  static FunctionType forInterface(\n      JSTypeRegistry registry, String name, Node source) {\n    return new FunctionType(registry, name, source);\n  }", "isInstanceType": "  public boolean isInstanceType() {\n    // The universal constructor is its own instance, bizarrely.\n    return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n  }", "isConstructor": "  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }", "isInterface": "  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }", "isOrdinaryFunction": "  public boolean isOrdinaryFunction() {\n    return kind == Kind.ORDINARY;\n  }", "isFunctionType": "  public boolean isFunctionType() {\n    return true;\n  }", "canBeCalled": "  public boolean canBeCalled() {\n    return true;\n  }", "getParameters": "  public Iterable<Node> getParameters() {\n    Node n = getParametersNode();\n    if (n != null) {\n      return n.children();\n    } else {\n      return Collections.emptySet();\n    }\n  }", "getParametersNode": "  public Node getParametersNode() {\n    return call.parameters;\n  }", "getMinArguments": "  public int getMinArguments() {\n    // NOTE(nicksantos): There are some native functions that have optional\n    // parameters before required parameters. This algorithm finds the position\n    // of the last required parameter.\n    int i = 0;\n    int min = 0;\n    for (Node n : getParameters()) {\n      i++;\n      if (!n.isOptionalArg() && !n.isVarArgs()) {\n        min = i;\n      }\n    }\n    return min;\n  }", "getMaxArguments": "  public int getMaxArguments() {\n    Node params = getParametersNode();\n    if (params != null) {\n      Node lastParam = params.getLastChild();\n      if (lastParam == null || !lastParam.isVarArgs()) {\n        return params.getChildCount();\n      }\n    }\n\n    return Integer.MAX_VALUE;\n  }", "getReturnType": "  public JSType getReturnType() {\n    return call.returnType;\n  }", "isReturnTypeInferred": "  public boolean isReturnTypeInferred() {\n    return call.returnTypeInferred;\n  }", "getInternalArrowType": "  ArrowType getInternalArrowType() {\n    return call;\n  }", "getPrototype": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }", "setPrototypeBasedOn": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }", "setPrototype": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n    }\n    return true;\n  }", "getAllImplementedInterfaces": "  public Iterable<ObjectType> getAllImplementedInterfaces() {\n    // Store them in a linked hash set, so that the compile job is\n    // deterministic.\n    Set<ObjectType> interfaces = Sets.newLinkedHashSet();\n\n    for (ObjectType type : getImplementedInterfaces()) {\n      addRelatedInterfaces(type, interfaces);\n    }\n    return interfaces;\n  }", "addRelatedInterfaces": "  private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) {\n    FunctionType constructor = instance.getConstructor();\n    if (constructor != null) {\n      if (!constructor.isInterface()) {\n        return;\n      }\n\n      set.add(instance);\n\n      if (constructor.getSuperClassConstructor() != null) {\n        addRelatedInterfaces(\n            constructor.getSuperClassConstructor().getInstanceType(), set);\n      }\n    }\n  }", "getImplementedInterfaces": "  public Iterable<ObjectType> getImplementedInterfaces() {\n    FunctionType superCtor = isConstructor() ?\n        getSuperClassConstructor() : null;\n    if (superCtor == null) {\n      return implementedInterfaces;\n    } else {\n      return Iterables.concat(\n          implementedInterfaces, superCtor.getImplementedInterfaces());\n    }\n  }", "setImplementedInterfaces": "  public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {\n    // Records this type for each implemented interface.\n    for (ObjectType type : implementedInterfaces) {\n      registry.registerTypeImplementingInterface(this, type);\n    }\n    this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);\n  }", "hasProperty": "  public boolean hasProperty(String name) {\n    return super.hasProperty(name) || \"prototype\".equals(name);\n  }", "hasOwnProperty": "  public boolean hasOwnProperty(String name) {\n    return super.hasOwnProperty(name) || \"prototype\".equals(name);\n  }", "getPropertyType": "  public JSType getPropertyType(String name) {\n    if (\"prototype\".equals(name)) {\n      return getPrototype();\n    } else {\n      if (!hasOwnProperty(name)) {\n        if (\"call\".equals(name)) {\n          // Define the \"call\" function lazily.\n          Node params = getParametersNode();\n          if (params == null) {\n            // If there's no params array, don't do any type-checking\n            // in this CALL function.\n            defineDeclaredProperty(name,\n                new FunctionBuilder(registry)\n                    .withReturnType(getReturnType())\n                    .build(),\n                false);\n          } else {\n            params = params.cloneTree();\n            Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n            thisTypeNode.setJSType(\n                registry.createOptionalNullableType(getTypeOfThis()));\n            params.addChildToFront(thisTypeNode);\n            thisTypeNode.setOptionalArg(true);\n\n            defineDeclaredProperty(name,\n                new FunctionBuilder(registry)\n                    .withParamsNode(params)\n                    .withReturnType(getReturnType())\n                    .build(),\n                false);\n          }\n        } else if (\"apply\".equals(name)) {\n          // Define the \"apply\" function lazily.\n          FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n\n          // Ecma-262 says that apply's second argument must be an Array\n          // or an arguments object. We don't model the arguments object,\n          // so let's just be forgiving for now.\n          // TODO(nicksantos): Model the Arguments object.\n          builder.addOptionalParams(\n              registry.createNullableType(getTypeOfThis()),\n              registry.createNullableType(\n                  registry.getNativeType(JSTypeNative.OBJECT_TYPE)));\n\n          defineDeclaredProperty(name,\n              new FunctionBuilder(registry)\n                  .withParams(builder)\n                  .withReturnType(getReturnType())\n                  .build(),\n              false);\n        }\n      }\n\n      return super.getPropertyType(name);\n    }\n  }", "defineProperty": "  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.isEquivalentTo(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }", "isPropertyTypeInferred": "  public boolean isPropertyTypeInferred(String property) {\n    return \"prototype\".equals(property) ||\n        super.isPropertyTypeInferred(property);\n  }", "getLeastSupertype": "  public JSType getLeastSupertype(JSType that) {\n    return supAndInfHelper(that, true);\n  }", "getGreatestSubtype": "  public JSType getGreatestSubtype(JSType that) {\n    return supAndInfHelper(that, false);\n  }", "supAndInfHelper": "  private JSType supAndInfHelper(JSType that, boolean leastSuper) {\n    // NOTE(nicksantos): When we remove the unknown type, the function types\n    // form a lattice with the universal constructor at the top of the lattice,\n    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.\n    //\n    // When we introduce the unknown type, it's much more difficult to make\n    // heads or tails of the partial ordering of types, because there's no\n    // clear hierarchy between the different components (parameter types and\n    // return types) in the ArrowType.\n    //\n    // Rather than make the situation more complicated by introducing new\n    // types (like unions of functions), we just fallback on the simpler\n    // approach of getting things right at the top and the bottom of the\n    // lattice.\n    if (isFunctionType() && that.isFunctionType()) {\n      if (isEquivalentTo(that)) {\n        return this;\n      }\n\n      FunctionType other = null;\n      if (that instanceof FunctionType) {\n        other = (FunctionType) that;\n      }\n\n      // If these are ordinary functions, then merge them.\n      // Don't do this if any of the params/return\n      // values are unknown, because then there will be cycles in\n      // their local lattice and they will merge in weird ways.\n      if (other != null &&\n          isOrdinaryFunction() && that.isOrdinaryFunction() &&\n          !this.call.hasUnknownParamsOrReturn() &&\n          !other.call.hasUnknownParamsOrReturn()) {\n\n        // Check for the degenerate case, but double check\n        // that there's not a cycle.\n        boolean isSubtypeOfThat = this.isSubtype(that);\n        boolean isSubtypeOfThis = that.isSubtype(this);\n        if (isSubtypeOfThat && !isSubtypeOfThis) {\n          return leastSuper ? that : this;\n        } else if (isSubtypeOfThis && !isSubtypeOfThat) {\n          return leastSuper ? this : that;\n        }\n\n        // Merge the two functions component-wise.\n        FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper);\n        if (merged != null) {\n          return merged;\n        }\n      }\n\n      // The function instance type is a special case\n      // that lives above the rest of the lattice.\n      JSType functionInstance = registry.getNativeType(\n          JSTypeNative.FUNCTION_INSTANCE_TYPE);\n      if (functionInstance.isEquivalentTo(that)) {\n        return leastSuper ? that : this;\n      } else if (functionInstance.isEquivalentTo(this)) {\n        return leastSuper ? this : that;\n      }\n\n      // In theory, we should be using the GREATEST_FUNCTION_TYPE as the\n      // greatest function. In practice, we don't because it's way too\n      // broad. The greatest function takes var_args None parameters, which\n      // means that all parameters register a type warning.\n      //\n      // Instead, we use the U2U ctor type, which has unknown type args.\n      FunctionType greatestFn =\n          registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n      FunctionType leastFn =\n          registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);\n      return leastSuper ? greatestFn : leastFn;\n    }\n\n    return leastSuper ?\n        super.getLeastSupertype(that) :\n        super.getGreatestSubtype(that);\n  }", "tryMergeFunctionPiecewise": "  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call)) {\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }", "getSuperClassConstructor": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }", "hasUnknownSupertype": "  public boolean hasUnknownSupertype() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    Preconditions.checkArgument(!this.isUnknownType());\n    // Potential infinite loop if our type system messes up or someone defines\n    // a bad type. Otherwise the loop should always end.\n    FunctionType ctor = this;\n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }", "getTopMostDefiningType": "  public JSType getTopMostDefiningType(String propertyName) {\n    Preconditions.checkState(isConstructor() || isInterface());\n    Preconditions.checkArgument(getPrototype().hasProperty(propertyName));\n    FunctionType ctor = this;\n    JSType topInstanceType;\n    do {\n      topInstanceType = ctor.getInstanceType();\n      ctor = ctor.getSuperClassConstructor();\n    } while (ctor != null && ctor.getPrototype().hasProperty(propertyName));\n    return topInstanceType;\n  }", "isEquivalentTo": "  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }", "hasEqualCallType": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.isEquivalentTo(otherType.call);\n  }", "toString": "  public String toString() {\n    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n      return \"Function\";\n    }\n\n    StringBuilder b = new StringBuilder(32);\n    b.append(\"function (\");\n    int paramNum = call.parameters.getChildCount();\n    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();\n    if (hasKnownTypeOfThis) {\n      b.append(\"this:\");\n      b.append(typeOfThis.toString());\n    }\n    if (paramNum > 0) {\n      if (hasKnownTypeOfThis) {\n        b.append(\", \");\n      }\n      Node p = call.parameters.getFirstChild();\n      if (p.isVarArgs()) {\n        appendVarArgsString(b, p.getJSType());\n      } else {\n        b.append(p.getJSType().toString());\n      }\n      p = p.getNext();\n      while (p != null) {\n        b.append(\", \");\n        if (p.isVarArgs()) {\n          appendVarArgsString(b, p.getJSType());\n        } else {\n          b.append(p.getJSType().toString());\n        }\n        p = p.getNext();\n      }\n    }\n    b.append(\"): \");\n    b.append(call.returnType);\n    return b.toString();\n  }", "appendVarArgsString": "  private void appendVarArgsString(StringBuilder builder, JSType paramType) {\n    if (paramType.isUnionType()) {\n      // Remove the optionalness from the var arg.\n      paramType = ((UnionType) paramType).getRestrictedUnion(\n          registry.getNativeType(JSTypeNative.VOID_TYPE));\n    }\n    builder.append(\"...[\").append(paramType.toString()).append(\"]\");\n  }", "isSubtype": "  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      return (this.isConstructor() || other.isConstructor() ||\n              other.typeOfThis.isSubtype(this.typeOfThis) ||\n              this.typeOfThis.isSubtype(other.typeOfThis)) &&\n          this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }", "visit": "  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseFunctionType(this);\n  }", "getInstanceType": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }", "setInstanceType": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }", "hasInstanceType": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }", "getTypeOfThis": "  public ObjectType getTypeOfThis() {\n    return typeOfThis.isNoObjectType() ?\n        registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis;\n  }", "getSource": "  public Node getSource() {\n    return source;\n  }", "setSource": "  public void setSource(Node source) {\n    this.source = source;\n  }", "addSubType": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }", "getSubTypes": "  public List<FunctionType> getSubTypes() {\n    return subTypes;\n  }", "getTemplateTypeName": "  public String getTemplateTypeName() {\n    return templateTypeName;\n  }", "resolveInternal": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "toDebugHashCodeString": "  public String toDebugHashCodeString() {\n    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n      return super.toDebugHashCodeString();\n    }\n\n    StringBuilder b = new StringBuilder(32);\n    b.append(\"function (\");\n    int paramNum = call.parameters.getChildCount();\n    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();\n    if (hasKnownTypeOfThis) {\n      b.append(\"this:\");\n      b.append(getDebugHashCodeStringOf(typeOfThis));\n    }\n    if (paramNum > 0) {\n      if (hasKnownTypeOfThis) {\n        b.append(\", \");\n      }\n      Node p = call.parameters.getFirstChild();\n      b.append(getDebugHashCodeStringOf(p.getJSType()));\n      p = p.getNext();\n      while (p != null) {\n        b.append(\", \");\n        b.append(getDebugHashCodeStringOf(p.getJSType()));\n        p = p.getNext();\n      }\n    }\n    b.append(\")\");\n    b.append(\": \");\n    b.append(getDebugHashCodeStringOf(call.returnType));\n    return b.toString();\n  }", "getDebugHashCodeStringOf": "  private String getDebugHashCodeStringOf(JSType type) {\n    if (type == this) {\n      return \"me\";\n    } else {\n      return type.toDebugHashCodeString();\n    }\n  }"}