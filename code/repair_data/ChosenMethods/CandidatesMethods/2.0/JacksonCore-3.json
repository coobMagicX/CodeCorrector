{"getCodec": "    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }", "setCodec": "    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }", "getInputSource": "    public Object getInputSource() {\n        return _inputStream;\n    }", "_closeInput": "    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }", "getValueAsString": "    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }", "getBinaryValue": "    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }", "readBinaryValue": "    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }", "_readBinary": "    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer)\n        throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }", "_nextTokenNotInObject": "    private final JsonToken _nextTokenNotInObject(int i)\n        throws IOException, JsonParseException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }", "nextIntValue": "    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }", "_verifyNoLeadingZeroes": "    private final int _verifyNoLeadingZeroes()\n        throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }", "findName": "    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n        throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }", "_finishString": "    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }", "_finishString2": "    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }", "_skipString": "    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }", "_handleInvalidNumberStart": "    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }", "_skipWSOrEnd": "    private final int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                _reportInvalidChar(i);\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }", "_skipLine": "    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }", "_decodeCharForError": "    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = (int) firstByte;\n        if (c < 0) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }", "_reportInvalidToken": "    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }", "_reportInvalidChar": "    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }", "_reportInvalidInitial": "    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }", "_reportInvalidOther": "    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }"}