{"builder": "    public static Builder builder(JavaType beanType) {\n        return new Builder(beanType);\n    }", "start": "    public ExternalTypeHandler start() {\n        return new ExternalTypeHandler(this);\n    }", "handleTypePropertyValue": "    public boolean handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean)\n        throws IOException\n    {\n        Object ob = _nameToPropertyIndex.get(propName);\n        if (ob == null) {\n            return false;\n        }\n        final String typeId = p.getText();\n        // 28-Nov-2016, tatu: For [databind#291], need separate handling\n        if (ob instanceof List<?>) {\n            boolean result = false;\n            for (Integer index : (List<Integer>) ob) {\n                if (_handleTypePropertyValue(p, ctxt, propName, bean,\n                        typeId, index.intValue())) {\n                    result = true;\n                }\n            }\n            return result;\n        }\n        return _handleTypePropertyValue(p, ctxt, propName, bean,\n                typeId, ((Integer) ob).intValue());\n    }", "_handleTypePropertyValue": "    private final boolean _handleTypePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean, String typeId, int index)\n        throws IOException\n    {\n        ExtTypedProperty prop = _properties[index];\n        if (!prop.hasTypePropertyName(propName)) { // when could/should this ever happen?\n            return false;\n        }\n        // note: can NOT skip child values (should always be String anyway)\n        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n        // Minor optimization: deserialize properties as soon as we have all we need:\n        if (canDeserialize) {\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            // clear stored data, to avoid deserializing+setting twice:\n            _tokens[index] = null;\n        } else {\n            _typeIds[index] = typeId;\n        }\n        return true;\n    }", "handlePropertyValue": "    public boolean handlePropertyValue(JsonParser p, DeserializationContext ctxt,\n            String propName, Object bean) throws IOException\n    {\n        Object ob = _nameToPropertyIndex.get(propName);\n        if (ob == null) {\n            return false;\n        }\n        // 28-Nov-2016, tatu: For [databind#291], need separate handling\n        if (ob instanceof List<?>) {\n            Iterator<Integer> it = ((List<Integer>) ob).iterator();\n            Integer index = it.next();\n\n            ExtTypedProperty prop = _properties[index];\n            // For now, let's assume it's same type (either type id OR value)\n            // for all mappings, so we'll only check first one\n            if (prop.hasTypePropertyName(propName)) {\n                String typeId = p.getText();\n                p.skipChildren();\n                _typeIds[index] = typeId;\n                while (it.hasNext()) {\n                    _typeIds[it.next()] = typeId;\n                }\n            } else {\n                @SuppressWarnings(\"resource\")\n                TokenBuffer tokens = new TokenBuffer(p, ctxt);\n                tokens.copyCurrentStructure(p);\n                _tokens[index] = tokens;\n                while (it.hasNext()) {\n                    _tokens[it.next()] = tokens;\n                }\n            }\n            return true;\n        }\n\n        // Otherwise only maps to a single value, in which case we can\n        // handle things in bit more optimal way...\n        int index = ((Integer) ob).intValue();\n        ExtTypedProperty prop = _properties[index];\n        boolean canDeserialize;\n        if (prop.hasTypePropertyName(propName)) {\n            _typeIds[index] = p.getText();\n            p.skipChildren();\n            canDeserialize = (bean != null) && (_tokens[index] != null);\n        } else {\n            @SuppressWarnings(\"resource\")\n            TokenBuffer tokens = new TokenBuffer(p, ctxt);\n            tokens.copyCurrentStructure(p);\n            _tokens[index] = tokens;\n            canDeserialize = (bean != null) && (_typeIds[index] != null);\n        }\n        // Minor optimization: let's deserialize properties as soon as\n        // we have all pertinent information:\n        if (canDeserialize) {\n            String typeId = _typeIds[index];\n            // clear stored data, to avoid deserializing+setting twice:\n            _typeIds[index] = null;\n            _deserializeAndSet(p, ctxt, bean, index, typeId);\n            _tokens[index] = null;\n        }\n        return true;\n    }", "complete": "    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    buffer.assignParameter(typeProp, typeId);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }", "_deserialize": "    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n            int index, String typeId) throws IOException\n    {\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        return _properties[index].getProperty().deserialize(mp, ctxt);\n    }", "_deserializeAndSet": "    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, int index, String typeId) throws IOException\n    {\n        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n         * style to ensure we can handle all kinds of JSON constructs.\n         */\n        JsonParser p2 = _tokens[index].asParser(p);\n        JsonToken t = p2.nextToken();\n        // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n        if (t == JsonToken.VALUE_NULL) {\n            _properties[index].getProperty().set(bean, null);\n            return;\n        }\n        TokenBuffer merged = new TokenBuffer(p, ctxt);\n        merged.writeStartArray();\n        merged.writeString(typeId);\n\n        merged.copyCurrentStructure(p2);\n        merged.writeEndArray();\n        // needs to point to START_OBJECT (or whatever first token is)\n        JsonParser mp = merged.asParser(p);\n        mp.nextToken();\n        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);\n    }", "_addPropertyIndex": "        private void _addPropertyIndex(String name, Integer index) {\n            Object ob = _nameToPropertyIndex.get(name);\n            if (ob == null) {\n                _nameToPropertyIndex.put(name, index);\n            } else if (ob instanceof List<?>) {\n                @SuppressWarnings(\"unchecked\")\n                List<Object> list = (List<Object>) ob;\n                list.add(index);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(ob);\n                list.add(index);\n                _nameToPropertyIndex.put(name, list);\n            }\n        }", "build": "        public ExternalTypeHandler build(BeanPropertyMap otherProps) {\n            // 21-Jun-2016, tatu: as per [databind#999], may need to link type id property also\n            final int len = _properties.size();\n            ExtTypedProperty[] extProps = new ExtTypedProperty[len];\n            for (int i = 0; i < len; ++i) {\n                ExtTypedProperty extProp = _properties.get(i);\n                String typePropId = extProp.getTypePropertyName();\n                SettableBeanProperty typeProp = otherProps.find(typePropId);\n                if (typeProp != null) {\n                    extProp.linkTypeProperty(typeProp);\n                }\n                extProps[i] = extProp;\n            }\n            return new ExternalTypeHandler(_beanType, extProps, _nameToPropertyIndex,\n                    null, null);\n        }", "linkTypeProperty": "        public void linkTypeProperty(SettableBeanProperty p) {\n            _typeProperty = p;\n        }", "hasTypePropertyName": "        public boolean hasTypePropertyName(String n) {\n            return n.equals(_typePropertyName);\n        }", "hasDefaultType": "        public boolean hasDefaultType() {\n            return _typeDeserializer.getDefaultImpl() != null;\n        }", "getDefaultTypeId": "        public String getDefaultTypeId() {\n            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n            if (defaultType == null) {\n                return null;\n            }\n            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n        }", "getTypePropertyName": "        public String getTypePropertyName() { return _typePropertyName; }", "getProperty": "        public SettableBeanProperty getProperty() {\n            return _property;\n        }", "getTypeProperty": "        public SettableBeanProperty getTypeProperty() {\n            return _typeProperty;\n        }"}