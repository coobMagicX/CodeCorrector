{"setContentCompression": "    public void setContentCompression(SevenZMethod method) {\n        this.contentCompression = method;\n    }", "close": "        public void close() throws IOException {\n            // the file will be closed by the containing class's close method\n        }", "createArchiveEntry": "    public SevenZArchiveEntry createArchiveEntry(final File inputFile,\n            final String entryName) throws IOException {\n        final SevenZArchiveEntry entry = new SevenZArchiveEntry();\n        entry.setDirectory(inputFile.isDirectory());\n        entry.setName(entryName);\n        entry.setLastModifiedDate(new Date(inputFile.lastModified()));\n        return entry;\n    }", "putArchiveEntry": "    public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\n        final SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\n        files.add(entry);\n    }", "closeArchiveEntry": "    public void closeArchiveEntry() throws IOException {\n        if (currentOutputStream != null) {\n            currentOutputStream.flush();\n            currentOutputStream.close();\n        }\n\n        final SevenZArchiveEntry entry = files.get(files.size() - 1);\n        if (fileBytesWritten > 0) {\n            entry.setHasStream(true);\n            ++numNonEmptyStreams;\n            entry.setSize(currentOutputStream.getBytesWritten());\n            entry.setCompressedSize(fileBytesWritten);\n            entry.setCrcValue(crc32.getValue());\n            entry.setCompressedCrcValue(compressedCrc32.getValue());\n            entry.setHasCrc(true);\n        } else {\n            entry.setHasStream(false);\n            entry.setSize(0);\n            entry.setCompressedSize(0);\n            entry.setHasCrc(false);\n        }\n        currentOutputStream = null;\n        crc32.reset();\n        compressedCrc32.reset();\n        fileBytesWritten = 0;\n    }", "write": "        public void write(final byte[] b, final int off, final int len)\n            throws IOException {\n            file.write(b, off, len);\n            compressedCrc32.update(b, off, len);\n            fileBytesWritten += len;\n        }", "finish": "    public void finish() throws IOException {\n        if (finished) {\n            throw new IOException(\"This archive has already been finished\");\n        }\n        finished = true;\n        \n        final long headerPosition = file.getFilePointer();\n        \n        final ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\n        final DataOutputStream header = new DataOutputStream(headerBaos);\n        \n        writeHeader(header);\n        header.flush();\n        final byte[] headerBytes = headerBaos.toByteArray();\n        file.write(headerBytes);\n        \n        final CRC32 crc32 = new CRC32();\n        \n        // signature header\n        file.seek(0);\n        file.write(SevenZFile.sevenZSignature);\n        // version\n        file.write(0);\n        file.write(2);\n        \n        // start header\n        final ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\n        final DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\n        startHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\n        startHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\n        crc32.reset();\n        crc32.update(headerBytes);\n        startHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\n        startHeaderStream.flush();\n        final byte[] startHeaderBytes = startHeaderBaos.toByteArray();\n        crc32.reset();\n        crc32.update(startHeaderBytes);\n        file.writeInt(Integer.reverseBytes((int) crc32.getValue()));\n        file.write(startHeaderBytes);\n    }", "getCurrentOutputStream": "    private OutputStream getCurrentOutputStream() throws IOException {\n        if (currentOutputStream == null) {\n            currentOutputStream = setupFileOutputStream();\n        }\n        return currentOutputStream;\n    }", "setupFileOutputStream": "    private CountingOutputStream setupFileOutputStream() throws IOException {\n        OutputStream out = new OutputStreamWrapper();\n        return new CountingOutputStream(Coders\n                                        .addEncoder(out,\n                                                    contentCompression,\n                                                    null)) {\n            @Override\n            public void write(final int b) throws IOException {\n                super.write(b);\n                crc32.update(b);\n            }\n    \n            @Override\n            public void write(final byte[] b) throws IOException {\n                super.write(b);\n                crc32.update(b);\n            }\n    \n            @Override\n            public void write(final byte[] b, final int off, final int len)\n                throws IOException {\n                super.write(b, off, len);\n                crc32.update(b, off, len);\n            }\n        };\n    }", "writeHeader": "    private void writeHeader(final DataOutput header) throws IOException {\n        header.write(NID.kHeader);\n        \n        header.write(NID.kMainStreamsInfo);\n        writeStreamsInfo(header);\n        writeFilesInfo(header);\n        header.write(NID.kEnd);\n    }", "writeStreamsInfo": "    private void writeStreamsInfo(final DataOutput header) throws IOException {\n        if (numNonEmptyStreams > 0) {\n            writePackInfo(header);\n            writeUnpackInfo(header);\n        }\n        \n        writeSubStreamsInfo(header);\n        \n        header.write(NID.kEnd);\n    }", "writePackInfo": "    private void writePackInfo(final DataOutput header) throws IOException {\n        header.write(NID.kPackInfo);\n        \n        writeUint64(header, 0);\n        writeUint64(header, 0xffffFFFFL & numNonEmptyStreams);\n        \n        header.write(NID.kSize);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                writeUint64(header, entry.getCompressedSize());\n            }\n        }\n        \n        header.write(NID.kCRC);\n        header.write(1);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue()));\n            }\n        }\n        \n        header.write(NID.kEnd);\n    }", "writeUnpackInfo": "    private void writeUnpackInfo(final DataOutput header) throws IOException {\n        header.write(NID.kUnpackInfo);\n        \n        header.write(NID.kFolder);\n        writeUint64(header, numNonEmptyStreams);\n        header.write(0);\n        for (int i = 0; i < numNonEmptyStreams; i++) {\n            writeFolder(header);\n        }\n        \n        header.write(NID.kCodersUnpackSize);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                writeUint64(header, entry.getSize());\n            }\n        }\n        \n        header.write(NID.kCRC);\n        header.write(1);\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.hasStream()) {\n                header.writeInt(Integer.reverseBytes((int) entry.getCrcValue()));\n            }\n        }\n        \n        header.write(NID.kEnd);\n    }", "writeFolder": "    private void writeFolder(final DataOutput header) throws IOException {\n        // one coder\n        writeUint64(header, 1);\n        byte[] id = contentCompression.getId();\n        byte[] properties = contentCompression.getProperties();\n\n        int codecFlags = id.length;\n        if (properties.length > 0) {\n            codecFlags |= 0x20;\n        }\n        header.write(codecFlags);\n        header.write(id);\n\n        if (properties.length > 0) {\n            header.write(properties.length);\n            header.write(properties);\n        }\n    }", "writeSubStreamsInfo": "    private void writeSubStreamsInfo(final DataOutput header) throws IOException {\n        header.write(NID.kSubStreamsInfo);\n//        \n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//        \n        header.write(NID.kEnd);\n    }", "writeFilesInfo": "    private void writeFilesInfo(final DataOutput header) throws IOException {\n        header.write(NID.kFilesInfo);\n        \n        writeUint64(header, files.size());\n\n        writeFileEmptyStreams(header);\n        writeFileEmptyFiles(header);\n        writeFileAntiItems(header);\n        writeFileNames(header);\n        writeFileCTimes(header);\n        writeFileATimes(header);\n        writeFileMTimes(header);\n        writeFileWindowsAttributes(header);\n        header.write(0);\n    }", "writeFileEmptyStreams": "    private void writeFileEmptyStreams(final DataOutput header) throws IOException {\n        boolean hasEmptyStreams = false;\n        for (final SevenZArchiveEntry entry : files) {\n            if (!entry.hasStream()) {\n                hasEmptyStreams = true;\n                break;\n            }\n        }\n        if (hasEmptyStreams) {\n            header.write(NID.kEmptyStream);\n            final BitSet emptyStreams = new BitSet(files.size());\n            for (int i = 0; i < files.size(); i++) {\n                emptyStreams.set(i, !files.get(i).hasStream());\n            }\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, emptyStreams, files.size());\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeFileEmptyFiles": "    private void writeFileEmptyFiles(final DataOutput header) throws IOException {\n        boolean hasEmptyFiles = false;\n        int emptyStreamCounter = 0;\n        final BitSet emptyFiles = new BitSet(0);\n        for (int i = 0; i < files.size(); i++) {\n            if (!files.get(i).hasStream()) {\n                boolean isDir = files.get(i).isDirectory();\n                emptyFiles.set(emptyStreamCounter++, !isDir);\n                hasEmptyFiles |= !isDir;\n            }\n        }\n        if (hasEmptyFiles) {\n            header.write(NID.kEmptyFile);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, emptyFiles, emptyStreamCounter);\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeFileAntiItems": "    private void writeFileAntiItems(final DataOutput header) throws IOException {\n        boolean hasAntiItems = false;\n        final BitSet antiItems = new BitSet(0);\n        int antiItemCounter = 0;\n        for (int i = 0; i < files.size(); i++) {\n            if (!files.get(i).hasStream()) {\n                boolean isAnti = files.get(i).isAntiItem();\n                antiItems.set(antiItemCounter++, isAnti);\n                hasAntiItems |= isAnti;\n            }\n        }\n        if (hasAntiItems) {\n            header.write(NID.kAnti);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            writeBits(out, antiItems, antiItemCounter);\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeFileNames": "    private void writeFileNames(final DataOutput header) throws IOException {\n        header.write(NID.kName);\n        \n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final DataOutputStream out = new DataOutputStream(baos);\n        out.write(0);\n        for (final SevenZArchiveEntry entry : files) {\n            out.write(entry.getName().getBytes(\"UTF-16LE\"));\n            out.writeShort(0);\n        }\n        out.flush();\n        final byte[] contents = baos.toByteArray();\n        writeUint64(header, contents.length);\n        header.write(contents);\n    }", "writeFileCTimes": "    private void writeFileCTimes(final DataOutput header) throws IOException {\n        int numCreationDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasCreationDate()) {\n                ++numCreationDates;\n            }\n        }\n        if (numCreationDates > 0) {\n            header.write(NID.kCTime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numCreationDates != files.size()) {\n                out.write(0);\n                final BitSet cTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    cTimes.set(i, files.get(i).getHasCreationDate());\n                }\n                writeBits(out, cTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasCreationDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeFileATimes": "    private void writeFileATimes(final DataOutput header) throws IOException {\n        int numAccessDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasAccessDate()) {\n                ++numAccessDates;\n            }\n        }\n        if (numAccessDates > 0) {\n            header.write(NID.kATime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numAccessDates != files.size()) {\n                out.write(0);\n                final BitSet aTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    aTimes.set(i, files.get(i).getHasAccessDate());\n                }\n                writeBits(out, aTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasAccessDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeFileMTimes": "    private void writeFileMTimes(final DataOutput header) throws IOException {\n        int numLastModifiedDates = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasLastModifiedDate()) {\n                ++numLastModifiedDates;\n            }\n        }\n        if (numLastModifiedDates > 0) {\n            header.write(NID.kMTime);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numLastModifiedDates != files.size()) {\n                out.write(0);\n                final BitSet mTimes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    mTimes.set(i, files.get(i).getHasLastModifiedDate());\n                }\n                writeBits(out, mTimes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasLastModifiedDate()) {\n                    out.writeLong(Long.reverseBytes(\n                            SevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeFileWindowsAttributes": "    private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\n        int numWindowsAttributes = 0;\n        for (final SevenZArchiveEntry entry : files) {\n            if (entry.getHasWindowsAttributes()) {\n                ++numWindowsAttributes;\n            }\n        }\n        if (numWindowsAttributes > 0) {\n            header.write(NID.kWinAttributes);\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final DataOutputStream out = new DataOutputStream(baos);\n            if (numWindowsAttributes != files.size()) {\n                out.write(0);\n                final BitSet attributes = new BitSet(files.size());\n                for (int i = 0; i < files.size(); i++) {\n                    attributes.set(i, files.get(i).getHasWindowsAttributes());\n                }\n                writeBits(out, attributes, files.size());\n            } else {\n                out.write(1);\n            }\n            out.write(0);\n            for (final SevenZArchiveEntry entry : files) {\n                if (entry.getHasWindowsAttributes()) {\n                    out.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n                }\n            }\n            out.flush();\n            final byte[] contents = baos.toByteArray();\n            writeUint64(header, contents.length);\n            header.write(contents);\n        }\n    }", "writeUint64": "    private void writeUint64(final DataOutput header, long value) throws IOException {\n        int firstByte = 0;\n        int mask = 0x80;\n        int i;\n        for (i = 0; i < 8; i++) {\n            if (value < ((1L << ( 7  * (i + 1))))) {\n                firstByte |= (value >>> (8 * i));\n                break;\n            }\n            firstByte |= mask;\n            mask >>>= 1;\n        }\n        header.write(firstByte);\n        for (; i > 0; i--) {\n            header.write((int) (0xff & value));\n            value >>>= 8;\n        }\n    }", "writeBits": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            --shift;\n            if (shift == 0) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (length > 0 && shift > 0) {\n            header.write(cache);\n        }\n    }", "flush": "        public void flush() throws IOException {\n            // no reason to flush a RandomAccessFile\n        }"}