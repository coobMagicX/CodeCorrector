{"version": "    public Version version() {\n        return PackageVersion.VERSION;\n    }", "getCodec": "    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }", "setCodec": "    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }", "setXMLTextElementName": "    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }", "requiresCustomCodec": "    public boolean requiresCustomCodec() {\n        return true;\n    }", "enable": "    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }", "disable": "    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }", "configure": "    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }", "getFormatFeatures": "    public int getFormatFeatures() {\n        return _formatFeatures;\n    }", "overrideFormatFeatures": "    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }", "getStaxReader": "    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }", "addVirtualWrapping": "    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n         *   problems with Lists-in-Lists properties\n         */\n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }", "getCurrentName": "    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }", "overrideCurrentName": "    public void overrideCurrentName(String name)\n    {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }", "close": "    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }", "getParsingContext": "    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }", "getTokenLocation": "    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }", "getCurrentLocation": "    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }", "isExpectedStartArrayToken": "    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            // 06-Jan-2015, tatu: Actually, could also be empty Object buffered; if so, convert...\n            if (_nextToken == JsonToken.END_OBJECT) {\n                _nextToken = JsonToken.END_ARRAY;\n            } else {\n                _nextToken = null;\n            }\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }", "nextToken": "    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n            switch (token) {\n            case XmlTokenStream.XML_END_ELEMENT:\n                // Simple, except that if this is a leaf, need to suppress end:\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    if (_parsingContext.inArray()) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_NULL);\n                }\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If there was a chance of leaf node, no more...\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText();\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // One more refinement (pronunced like \"hack\") is that if\n                    // we had an empty String (or all white space), and we are\n                    // deserializing an array, we better hide the empty text.\n                    // Also: must skip following END_ELEMENT\n                    _xmlTokens.skipEndElement();\n                    if (_parsingContext.inArray()) {\n                        if (_isEmpty(_currText)) {\n                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                            //    expose as empty Object, not null (or, worse, as used to\n                            //    be done, by swallowing the token)\n                            _nextToken = JsonToken.END_OBJECT;\n                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                            return (_currToken = JsonToken.START_OBJECT);\n                        }\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // [dataformat-xml#177]: empty text may also need to be skipped\n                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n                    // loop over again\n                    if (_parsingContext.inObject()) {\n                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                            token = _xmlTokens.next();\n                            continue;\n                        }\n                    }\n                }\n                // If not a leaf (or otherwise ignorable), need to transform into property...\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n        }\n    }", "nextTextValue": "    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }", "_updateState": "    private void _updateState(JsonToken t)\n    {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }", "getText": "    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }", "getValueAsString": "    public String getValueAsString(String defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            // the interesting case; may be able to convert certain kinds of\n            // elements (specifically, ones with attributes, CDATA only content)\n            // into VALUE_STRING\n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    // need to convert token, as well as \"undo\" START_OBJECT\n                    // note: Should NOT update context, because we will still be getting\n                    // matching END_OBJECT, which will undo contexts properly\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    /* One more thing: must explicitly skip the END_OBJECT that\n                     * would follow.\n                     */\n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }", "getTextCharacters": "    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }", "getTextLength": "    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }", "getTextOffset": "    public int getTextOffset() throws IOException {\n        return 0;\n    }", "hasTextCharacters": "    public boolean hasTextCharacters()\n    {\n        return false;\n    }", "getEmbeddedObject": "    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }", "getBinaryValue": "    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }", "getBigIntegerValue": "    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "getDecimalValue": "    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "getDoubleValue": "    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getFloatValue": "    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getIntValue": "    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getLongValue": "    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }", "getNumberType": "    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "getNumberValue": "    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }", "_getByteArrayBuilder": "    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }", "_isEmpty": "    protected boolean _isEmpty(String str)\n    {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }"}