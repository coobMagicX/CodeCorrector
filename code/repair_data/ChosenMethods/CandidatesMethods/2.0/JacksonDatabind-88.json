{"getMechanism": "    public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.CLASS; }", "registerSubtype": "    public void registerSubtype(Class<?> type, String name) {\n        // not used with class name - based resolvers\n    }", "idFromValue": "    public String idFromValue(Object value) {\n        return _idFrom(value, value.getClass(), _typeFactory);\n    }", "idFromValueAndType": "    public String idFromValueAndType(Object value, Class<?> type) {\n        return _idFrom(value, type, _typeFactory);\n    }", "typeFromId": "    public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n        return _typeFromId(id, context);\n    }", "_typeFromId": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n        }\n        return tf.constructSpecializedType(_baseType, cls);\n    }", "_idFrom": "    protected final String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory)\n    {\n        // Need to ensure that \"enum subtypes\" work too\n        if (Enum.class.isAssignableFrom(cls)) {\n            if (!cls.isEnum()) { // means that it's sub-class of base enum, so:\n                cls = cls.getSuperclass();\n            }\n        }\n        String str = cls.getName();\n        if (str.startsWith(\"java.util\")) {\n            // 25-Jan-2009, tatu: There are some internal classes that we can not access as is.\n            //     We need better mechanism; for now this has to do...\n\n            // Enum sets and maps are problematic since we MUST know type of\n            // contained enums, to be able to deserialize.\n            // In addition, EnumSet is not a concrete type either\n            if (value instanceof EnumSet<?>) { // Regular- and JumboEnumSet...\n                Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value);\n                // not optimal: but EnumSet is not a customizable type so this is sort of ok\n               str = typeFactory.constructCollectionType(EnumSet.class, enumClass).toCanonical();\n            } else if (value instanceof EnumMap<?,?>) {\n                Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?,?>) value);\n                Class<?> valueClass = Object.class;\n                // not optimal: but EnumMap is not a customizable type so this is sort of ok\n                str = typeFactory.constructMapType(EnumMap.class, enumClass, valueClass).toCanonical();\n            } else {\n                String end = str.substring(9);\n                if ((end.startsWith(\".Arrays$\") || end.startsWith(\".Collections$\"))\n                       && str.indexOf(\"List\") >= 0) {\n                    /* 17-Feb-2010, tatus: Another such case: result of\n                     *    Arrays.asList() is named like so in Sun JDK...\n                     *   Let's just plain old ArrayList in its place\n                     * NOTE: chances are there are plenty of similar cases\n                     * for other wrappers... (immutable, singleton, synced etc)\n                     */\n                    str = \"java.util.ArrayList\";\n                }\n            }\n        } else if (str.indexOf('$') >= 0) {\n            /* Other special handling may be needed for inner classes, [JACKSON-584].\n             * The best way to handle would be to find 'hidden' constructor; pass parent\n             * value etc (which is actually done for non-anonymous static classes!),\n             * but that is just not possible due to various things. So, we will instead\n             * try to generalize type into something we will be more likely to be able\n             * construct.\n             */\n            Class<?> outer = ClassUtil.getOuterClass(cls);\n            if (outer != null) {\n                /* one more check: let's actually not worry if the declared\n                 * static type is non-static as well; if so, deserializer does\n                 * have a chance at figuring it all out.\n                 */\n                Class<?> staticType = _baseType.getRawClass();\n                if (ClassUtil.getOuterClass(staticType) == null) {\n                    // Is this always correct? Seems like it should be...\n                    cls = _baseType.getRawClass();\n                    str = cls.getName();\n                }\n            }\n        }\n        return str;\n    }", "getDescForKnownTypeIds": "    public String getDescForKnownTypeIds() {\n        return \"class name used as type id\";\n    }"}