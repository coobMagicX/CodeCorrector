{"compile": "    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }", "valueOf": "    public static JsonPointer valueOf(String input) { return compile(input); }", "matches": "    public boolean matches() { return _nextSegment == null; }", "getMatchingProperty": "    public String getMatchingProperty() { return _matchingPropertyName; }", "getMatchingIndex": "    public int getMatchingIndex() { return _matchingElementIndex; }", "mayMatchProperty": "    public boolean mayMatchProperty() { return _matchingPropertyName != null; }", "mayMatchElement": "    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }", "matchProperty": "    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }", "matchElement": "    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }", "tail": "    public JsonPointer tail() {\n        return _nextSegment;\n    }", "toString": "    @Override public String toString() { return _asString; }", "hashCode": "    @Override public int hashCode() { return _asString.hashCode(); }", "equals": "    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }", "_parseIndex": "    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }", "_parseTail": "    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }", "_parseQuotedTail": "    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }", "_appendEscape": "    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }"}