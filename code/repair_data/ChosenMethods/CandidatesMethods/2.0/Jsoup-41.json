{"nodeName": "    public String nodeName() {\n        return tag.getName();\n    }", "tag": "    public Tag tag() {\n        return tag;\n    }", "isBlock": "    public boolean isBlock() {\n        return tag.isBlock();\n    }", "id": "    public String id() {\n        String id = attr(\"id\");\n        return id == null ? \"\" : id;\n    }", "attr": "    public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }", "dataset": "    public Map<String, String> dataset() {\n        return attributes.dataset();\n    }", "parent": "    public final Element parent() {\n        return (Element) parentNode;\n    }", "parents": "    public Elements parents() {\n        Elements parents = new Elements();\n        accumulateParents(this, parents);\n        return parents;\n    }", "child": "    public Element child(int index) {\n        return children().get(index);\n    }", "children": "    public Elements children() {\n        // create on the fly rather than maintaining two lists. if gets slow, memoize, and mark dirty on change\n        List<Element> elements = new ArrayList<Element>(childNodes.size());\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return new Elements(elements);\n    }", "textNodes": "    public List<TextNode> textNodes() {\n        List<TextNode> textNodes = new ArrayList<TextNode>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }", "dataNodes": "    public List<DataNode> dataNodes() {\n        List<DataNode> dataNodes = new ArrayList<DataNode>();\n        for (Node node : childNodes) {\n            if (node instanceof DataNode)\n                dataNodes.add((DataNode) node);\n        }\n        return Collections.unmodifiableList(dataNodes);\n    }", "select": "    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }", "appendElement": "    public Element appendElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        appendChild(child);\n        return child;\n    }", "prependElement": "    public Element prependElement(String tagName) {\n        Element child = new Element(Tag.valueOf(tagName), baseUri());\n        prependChild(child);\n        return child;\n    }", "append": "    public Element append(String html) {\n        Validate.notNull(html);\n\n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }", "prepend": "    public Element prepend(String html) {\n        Validate.notNull(html);\n        \n        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n        return this;\n    }", "before": "    public Element before(Node node) {\n        return (Element) super.before(node);\n    }", "after": "    public Element after(Node node) {\n        return (Element) super.after(node);\n    }", "empty": "    public Element empty() {\n        childNodes.clear();\n        return this;\n    }", "wrap": "    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }", "cssSelector": "    public String cssSelector() {\n        if (id().length() > 0)\n            return \"#\" + id();\n\n        StringBuilder selector = new StringBuilder(tagName());\n        String classes = StringUtil.join(classNames(), \".\");\n        if (classes.length() > 0)\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return selector.toString();\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return parent().cssSelector() + selector.toString();\n    }", "siblingElements": "    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().children();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }", "nextElementSibling": "    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }", "previousElementSibling": "    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }", "firstElementSibling": "    public Element firstElementSibling() {\n        // todo: should firstSibling() exclude this?\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(0) : null;\n    }", "elementSiblingIndex": "    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }", "lastElementSibling": "    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }", "getElementsByTag": "    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }", "getElementById": "    public Element getElementById(String id) {\n        Validate.notEmpty(id);\n        \n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }", "getElementsByClass": "    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }", "getElementsByAttribute": "    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }", "getElementsByAttributeStarting": "    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim().toLowerCase();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }", "getElementsByAttributeValue": "    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }", "getElementsByAttributeValueNot": "    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }", "getElementsByAttributeValueStarting": "    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }", "getElementsByAttributeValueEnding": "    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }", "getElementsByAttributeValueContaining": "    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }", "getElementsByAttributeValueMatching": "    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }", "getElementsByIndexLessThan": "    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }", "getElementsByIndexGreaterThan": "    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }", "getElementsByIndexEquals": "    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }", "getElementsContainingText": "    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }", "getElementsContainingOwnText": "    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }", "getElementsMatchingText": "    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }", "getElementsMatchingOwnText": "    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }", "getAllElements": "    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }", "text": "    public Element text(String text) {\n        Validate.notNull(text);\n\n        empty();\n        TextNode textNode = new TextNode(text, baseUri);\n        appendChild(textNode);\n\n        return this;\n    }", "ownText": "    private void ownText(StringBuilder accum) {\n        for (Node child : childNodes) {\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child instanceof Element) {\n                appendWhitespaceIfBr((Element) child, accum);\n            }\n        }\n    }", "appendNormalisedText": "    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n\n        if (preserveWhitespace(textNode.parentNode))\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n    }", "data": "    public String data() {\n        StringBuilder sb = new StringBuilder();\n\n        for (Node childNode : childNodes) {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Element) {\n                Element element = (Element) childNode;\n                String elementData = element.data();\n                sb.append(elementData);\n            }\n        }\n        return sb.toString();\n    }   ", "removeClass": "    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }", "toggleClass": "    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }", "val": "    public Element val(String value) {\n        if (tagName().equals(\"textarea\"))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }", "outerHtmlHead": "    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )\n            indent(accum, depth, out);\n        accum\n                .append(\"<\")\n                .append(tagName());\n        attributes.html(accum, out);\n\n        // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); // <img> in html, <img /> in xml\n        }\n        else\n            accum.append(\">\");\n    }", "outerHtmlTail": "    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }", "html": "    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }", "toString": "    public String toString() {\n        return outerHtml();\n    }", "equals": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return this == o;\n    }", "hashCode": "    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }", "clone": "    public Element clone() {\n        return (Element) super.clone();\n    }"}