{"isUrlSafe": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }", "avail": "    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }", "encode": "    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        byte[] buf = new byte[pos - readPos];\n        readResults(buf, 0, buf.length);\n        return buf;\n    }", "decode": "    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }", "isBase64": "    public static boolean isBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "isArrayByteBase64": "    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        return isBase64(arrayOctet);\n    }", "containsBase64Byte": "    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }", "encodeBase64": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }", "encodeBase64String": "    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }", "encodeBase64URLSafe": "    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "encodeBase64URLSafeString": "    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    ", "encodeBase64Chunked": "    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "decodeBase64": "    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }", "encodeToString": "    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "getEncodeLength": "    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }", "encodeInteger": "    public static byte[] encodeInteger(BigInteger bigInt) {\n        if (bigInt == null) {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }", "reset": "    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }"}