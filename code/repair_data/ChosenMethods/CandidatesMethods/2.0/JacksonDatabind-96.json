{"withValueInstantiators": "    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n        return withConfig(_factoryConfig.withValueInstantiators(instantiators));\n    }", "findValueInstantiator": "    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        ValueInstantiator instantiator = null;\n        // Check @JsonValueInstantiator before anything else\n        AnnotatedClass ac = beanDesc.getClassInfo();\n        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n        if (instDef != null) {\n            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n        }\n        if (instantiator == null) {\n            // Second: see if some of standard Jackson/JDK types might provide value\n            // instantiators.\n            instantiator = _findStdValueInstantiator(config, beanDesc);\n            if (instantiator == null) {\n                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n            }\n        }\n\n        // finally: anyone want to modify ValueInstantiator?\n        if (_factoryConfig.hasValueInstantiators()) {\n            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n                // let's do sanity check; easier to spot buggy handlers\n                if (instantiator == null) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\t\t\t\t\t\t\"Broken registered ValueInstantiators (of type %s): returned null ValueInstantiator\",\n\t\t\t\t\t\tinsts.getClass().getName());\n                }\n            }\n        }\n\n        // Sanity check: does the chosen ValueInstantiator have incomplete creators?\n        if (instantiator.getIncompleteParameter() != null) {\n            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n        }\n\n        return instantiator;\n    }", "_findStdValueInstantiator": "    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> raw = beanDesc.getBeanClass();\n        if (raw == JsonLocation.class) {\n            return new JsonLocationInstantiator();\n        }\n        // [databind#1868]: empty List/Set/Map\n        if (Collection.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_SET.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_SET);\n            }\n            if (Collections.EMPTY_LIST.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_LIST);\n            }\n        } else if (Map.class.isAssignableFrom(raw)) {\n            if (Collections.EMPTY_MAP.getClass() == raw) {\n                return new ConstantValueInstantiator(Collections.EMPTY_MAP);\n            }\n        }\n        return null;\n    }", "_constructDefaultValueInstantiator": "    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt,\n            BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        CreatorCollector creators = new CreatorCollector(beanDesc, ctxt.getConfig());\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        \n        // need to construct suitable visibility checker:\n        final DeserializationConfig config = ctxt.getConfig();\n        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(beanDesc.getBeanClass(),\n                beanDesc.getClassInfo());\n\n        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n         *  (which has creator parameters sprinkled around) with actual creator\n         *  declarations (which are needed to access creator annotation, amongst other things).\n         *  Easiest to combine that info first, then pass it to remaining processing.\n         */\n        /* 15-Mar-2015, tatu: Alas, this won't help with constructors that only have implicit\n         *   names. Those will need to be resolved later on.\n         */\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n                beanDesc);\n        // Important: first add factory methods; then constructors, so\n        // latter can override former!\n        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        // constructors only usable on concrete types:\n        if (beanDesc.getType().isConcrete()) {\n            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n        }\n        return creators.constructValueInstantiator(ctxt);\n    }", "_findCreatorsFromProperties": "    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n            BeanDescription beanDesc) throws JsonMappingException\n    {\n        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n            while (it.hasNext()) {\n                AnnotatedParameter param = it.next();\n                AnnotatedWithParams owner = param.getOwner();\n                BeanPropertyDefinition[] defs = result.get(owner);\n                final int index = param.getIndex();\n                \n                if (defs == null) {\n                    if (result.isEmpty()) { // since emptyMap is immutable need to create a 'real' one\n                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n                    }\n                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n                    result.put(owner, defs);\n                } else {\n                    if (defs[index] != null) {\n                        ctxt.reportBadTypeDefinition(beanDesc,\n\"Conflict: parameter #%d of %s bound to more than one property; %s vs %s\",\nindex, owner, defs[index], propDef);\n                    }\n                }\n                defs[index] = propDef;\n            }\n        }\n        return result;\n    }", "_valueInstantiatorInstance": "    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n            Annotated annotated, Object instDef)\n        throws JsonMappingException\n    {\n        if (instDef == null) {\n            return null;\n        }\n\n        ValueInstantiator inst;\n        \n        if (instDef instanceof ValueInstantiator) {\n            return (ValueInstantiator) instDef;\n        }\n        if (!(instDef instanceof Class)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n                    +instDef.getClass().getName()\n                    +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n        }\n        Class<?> instClass = (Class<?>)instDef;\n        if (ClassUtil.isBogusClass(instClass)) {\n            return null;\n        }\n        if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n                    +\"; expected Class<ValueInstantiator>\");\n        }\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        if (hi != null) {\n            inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n            if (inst != null) {\n                return inst;\n            }\n        }\n        return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                config.canOverrideAccessModifiers());\n    }", "_addExplicitDelegatingCreator": "    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Somewhat simple: find injectable values, if any, ensure there is one\n        // and just one delegated argument; report violations if any\n\n        int ix = -1;\n        final int argCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[argCount];\n        for (int i = 0; i < argCount; ++i) {\n            AnnotatedParameter param = candidate.parameter(i);\n            JacksonInject.Value injectId = candidate.injection(i);\n            if (injectId != null) {\n                properties[i] = constructCreatorProperty(ctxt, beanDesc, null, i, param, injectId);\n                continue;\n            }\n            if (ix < 0) {\n                ix = i;\n                continue;\n            }\n            // Illegal to have more than one value to delegate to\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"More than one argument (#%d and #%d) left as delegating for Creator %s: only one allowed\",\n                    ix, i, candidate);\n        }\n        // Also, let's require that one Delegating argument does eixt\n        if (ix < 0) {\n            ctxt.reportBadTypeDefinition(beanDesc,\n                    \"No argument left as delegating for Creator %s: exactly one required\", candidate);\n        }\n        // 17-Jan-2018, tatu: as per [databind#1853] need to ensure we will distinguish\n        //   \"well-known\" single-arg variants (String, int/long, boolean) from \"generic\" delegating...\n        if (argCount == 1) {\n            _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n            // one more thing: sever link to creator property, to avoid possible later\n            // problems with \"unresolved\" constructor property\n            BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n            if (paramDef != null) {\n                ((POJOPropertyBuilder) paramDef).removeConstructors();\n            }\n            return;\n        }\n        creators.addDelegatingCreator(candidate.creator(), true, properties, ix);\n    }", "_addExplicitPropertyCreator": "    protected void _addExplicitPropertyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        final int paramCount = candidate.paramCount();\n        SettableBeanProperty[] properties = new SettableBeanProperty[paramCount];\n\n        for (int i = 0; i < paramCount; ++i) {\n            JacksonInject.Value injectId = candidate.injection(i);\n            AnnotatedParameter param = candidate.parameter(i);\n            PropertyName name = candidate.paramName(i);\n            if (name == null) {\n                // 21-Sep-2017, tatu: Looks like we want to block accidental use of Unwrapped,\n                //   as that will not work with Creators well at all\n                NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(param);\n                if (unwrapper != null) {\n                    _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);\n                    /*\n                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n                    ++explicitNameCount;\n                    */\n                }\n                name = candidate.findImplicitParamName(i);\n                // Must be injectable or have name; without either won't work\n                if ((name == null) && (injectId == null)) {\n                    ctxt.reportBadTypeDefinition(beanDesc,\n\"Argument #%d has no property name, is not Injectable: can not use as Creator %s\", i, candidate);\n                }\n            }\n            properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n        }\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n    }", "_addExplicitAnyCreator": "    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }", "_checkIfCreatorPropertyBased": "    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n        // If explicit name, or inject id, property-based\n        if (((propDef != null) && propDef.isExplicitlyNamed())\n                || (intr.findInjectableValue(creator.getParameter(0)) != null)) {\n            return true;\n        }\n        if (propDef != null) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n            String implName = propDef.getName();\n            if (implName != null && !implName.isEmpty()) {\n                if (propDef.couldSerialize()) {\n                    return true;\n                }\n            }\n        }\n        // in absence of everything else, default to delegating\n        return false;\n    }", "_handleSingleArgumentCreator": "    protected boolean _handleSingleArgumentCreator(CreatorCollector creators,\n            AnnotatedWithParams ctor, boolean isCreator, boolean isVisible)\n    {\n        // otherwise either 'simple' number, String, or general delegate:\n        Class<?> type = ctor.getRawParameterType(0);\n        if (type == String.class || type == CLASS_CHAR_SEQUENCE) {\n            if (isCreator || isVisible) {\n                creators.addStringCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == int.class || type == Integer.class) {\n            if (isCreator || isVisible) {\n                creators.addIntCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == long.class || type == Long.class) {\n            if (isCreator || isVisible) {\n                creators.addLongCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == double.class || type == Double.class) {\n            if (isCreator || isVisible) {\n                creators.addDoubleCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        if (type == boolean.class || type == Boolean.class) {\n            if (isCreator || isVisible) {\n                creators.addBooleanCreator(ctor, isCreator);\n            }\n            return true;\n        }\n        // Delegating Creator ok iff it has @JsonCreator (etc)\n        if (isCreator) {\n            creators.addDelegatingCreator(ctor, isCreator, null, 0);\n            return true;\n        }\n        return false;\n    }", "_reportUnwrappedCreatorProperty": "    protected void _reportUnwrappedCreatorProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, AnnotatedParameter param)\n        throws JsonMappingException\n    {\n        ctxt.reportBadDefinition(beanDesc.getType(), String.format(\n                \"Cannot define Creator parameter %d as `@JsonUnwrapped`: combination not yet supported\",\n                param.getIndex()));\n    }", "constructCreatorProperty": "    protected SettableBeanProperty constructCreatorProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, PropertyName name, int index,\n            AnnotatedParameter param,\n            JacksonInject.Value injectable)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        PropertyMetadata metadata;\n        {\n            if (intr == null) {\n                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n            } else {\n                Boolean b = intr.hasRequiredMarker(param);\n                String desc = intr.findPropertyDescription(param);\n                Integer idx = intr.findPropertyIndex(param);\n                String def = intr.findPropertyDefaultValue(param);\n                metadata = PropertyMetadata.construct(b, desc, idx, def);\n            }\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());\n        BeanProperty.Std property = new BeanProperty.Std(name, type,\n                intr.findWrapperName(param), param, metadata);\n        // Type deserializer: either comes from property (and already resolved)\n        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n        // or if not, based on type being referenced:\n        if (typeDeser == null) {\n            typeDeser = findTypeDeserializer(config, type);\n        }\n        // Note: contextualization of typeDeser _should_ occur in constructor of CreatorProperty\n        // so it is not called directly here\n\n        Object injectableValueId = (injectable == null) ? null : injectable.getId();\n        \n        SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n                metadata);\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            // As per [databind#462] need to ensure we contextualize deserializer before passing it on\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        return prop;\n    }", "_findParamName": "    private PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n    {\n        if (param != null && intr != null) {\n            PropertyName name = intr.findNameForDeserialization(param);\n            if (name != null) {\n                return name;\n            }\n            // 14-Apr-2014, tatu: Need to also consider possible implicit name\n            //  (for JDK8, or via paranamer)\n\n            String str = intr.findImplicitPropertyName(param);\n            if (str != null && !str.isEmpty()) {\n                return PropertyName.construct(str);\n            }\n        }\n        return null;\n    }", "_hasCreatorAnnotation": "    protected boolean _hasCreatorAnnotation(DeserializationContext ctxt,\n            Annotated ann) {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr != null) {\n            JsonCreator.Mode mode = intr.findCreatorAnnotation(ctxt.getConfig(), ann);\n            return (mode != null) && (mode != JsonCreator.Mode.DISABLED); \n        }\n        return false;\n    }", "_findJsonValueFor": "    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)\n    {\n        if (enumType == null) {\n            return null;\n        }\n        BeanDescription beanDesc = config.introspect(enumType);\n        return beanDesc.findJsonValueMethod();\n    }"}