{"getEncoding": "    public String getEncoding() {\n        return encoding;\n    }", "close": "    public void close() throws IOException {\n        // this flag is only written here and read in finalize() which\n        // can never be run in parallel.\n        // no synchronization needed.\n        closed = true;\n\n        archive.close();\n    }", "getEntries": "    public Enumeration<ZipArchiveEntry> getEntries() {\n        return Collections.enumeration(entries.keySet());\n    }", "getEntriesInPhysicalOrder": "    public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {\n        ZipArchiveEntry[] allEntries =\n            entries.keySet().toArray(new ZipArchiveEntry[0]);\n        Arrays.sort(allEntries, OFFSET_COMPARATOR);\n        return Collections.enumeration(Arrays.asList(allEntries));\n    }", "getEntry": "    public ZipArchiveEntry getEntry(String name) {\n        return nameMap.get(name);\n    }", "getInputStream": "    public InputStream getInputStream(ZipArchiveEntry ze)\n        throws IOException, ZipException {\n        OffsetEntry offsetEntry = entries.get(ze);\n        if (offsetEntry == null) {\n            return null;\n        }\n        ZipUtil.checkRequestedFeatures(ze);\n        long start = offsetEntry.dataOffset;\n        BoundedInputStream bis =\n            new BoundedInputStream(start, ze.getCompressedSize());\n        switch (ze.getMethod()) {\n            case ZipArchiveEntry.STORED:\n                return bis;\n            case ZipArchiveEntry.DEFLATED:\n                bis.addDummy();\n                final Inflater inflater = new Inflater(true);\n                return new InflaterInputStream(bis, inflater) {\n                    @Override\n                    public void close() throws IOException {\n                        super.close();\n                        inflater.end();\n                    }\n                };\n            default:\n                throw new ZipException(\"Found unsupported compression method \"\n                                       + ze.getMethod());\n        }\n    }", "finalize": "    protected void finalize() throws Throwable {\n        try {\n            if (!closed) {\n                System.err.println(\"Cleaning up unclosed ZipFile for archive \"\n                                   + archiveName);\n                close();\n            }\n        } finally {\n            super.finalize();\n        }\n    }", "setSizesAndOffsetFromZip64Extra": "    private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze,\n                                                 OffsetEntry offset,\n                                                 int diskStart)\n        throws IOException {\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        if (z64 != null) {\n            boolean hasUncompressedSize = ze.getSize() == ZIP64_MAGIC;\n            boolean hasCompressedSize = ze.getCompressedSize() == ZIP64_MAGIC;\n            boolean hasRelativeHeaderOffset =\n                offset.headerOffset == ZIP64_MAGIC;\n            z64.reparseCentralDirectoryData(hasUncompressedSize,\n                                            hasCompressedSize,\n                                            hasRelativeHeaderOffset,\n                                            diskStart == ZIP64_MAGIC_SHORT);\n\n            if (hasUncompressedSize) {\n                ze.setSize(z64.getSize().getLongValue());\n            } else if (hasCompressedSize) {\n                z64.setSize(new ZipEightByteInteger(ze.getSize()));\n            }\n\n            if (hasCompressedSize) {\n                ze.setCompressedSize(z64.getCompressedSize().getLongValue());\n            } else if (hasUncompressedSize) {\n                z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));\n            }\n\n            if (hasRelativeHeaderOffset) {\n                offset.headerOffset =\n                    z64.getRelativeHeaderOffset().getLongValue();\n            }\n        }\n    }", "skipBytes": "    private void skipBytes(final int count) throws IOException {\n        int totalSkipped = 0;\n        while (totalSkipped < count) {\n            int skippedNow = archive.skipBytes(count - totalSkipped);\n            if (skippedNow <= 0) {\n                throw new EOFException();\n            }\n            totalSkipped += skippedNow;\n        }\n    }", "resolveLocalFileHeaderData": "    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }", "read": "        public int read(byte[] b, int off, int len) throws IOException {\n            if (remaining <= 0) {\n                if (addDummyByte) {\n                    addDummyByte = false;\n                    b[off] = 0;\n                    return 1;\n                }\n                return -1;\n            }\n\n            if (len <= 0) {\n                return 0;\n            }\n\n            if (len > remaining) {\n                len = (int) remaining;\n            }\n            int ret = -1;\n            synchronized (archive) {\n                archive.seek(loc);\n                ret = archive.read(b, off, len);\n            }\n            if (ret > 0) {\n                loc += ret;\n                remaining -= ret;\n            }\n            return ret;\n        }"}