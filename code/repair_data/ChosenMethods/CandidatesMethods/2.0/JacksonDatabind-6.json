{"withLocale": "    public StdDateFormat withLocale(Locale loc) {\n        if (loc.equals(_locale)) {\n            return this;\n        }\n        return new StdDateFormat(_timezone, loc);\n    }", "clone": "    public StdDateFormat clone() {\n        /* Although there is that much state to share, we do need to\n         * orchestrate a bit, mostly since timezones may be changed\n         */\n        return new StdDateFormat(_timezone, _locale);\n    }", "getBlueprintRFC1123Format": "    public static DateFormat getBlueprintRFC1123Format() {\n        return DATE_FORMAT_RFC1123;\n    }", "getRFC1123Format": "    public static DateFormat getRFC1123Format(TimeZone tz) {\n        return getRFC1123Format(tz, DEFAULT_LOCALE);\n    }", "parse": "    public Date parse(String dateStr, ParsePosition pos)\n    {\n        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n            return parseAsISO8601(dateStr, pos);\n        }\n        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n         *   consider \"stringified\" simple time stamp\n         */\n        int i = dateStr.length();\n        while (--i >= 0) {\n            char ch = dateStr.charAt(i);\n            if (ch < '0' || ch > '9') {\n                // 07-Aug-2013, tatu: And #267 points out that negative numbers should also work\n                if (i > 0 || ch != '-') {\n                    break;\n                }\n            }\n        }\n        if (i < 0) { // all digits\n            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive\n            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {\n                return new Date(Long.parseLong(dateStr));\n            }\n        }\n        // Otherwise, fall back to using RFC 1123\n        return parseAsRFC1123(dateStr, pos);\n    }", "format": "    public StringBuffer format(Date date, StringBuffer toAppendTo,\n            FieldPosition fieldPosition)\n    {\n        if (_formatISO8601 == null) {\n            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n    }", "toString": "    public String toString() {\n        String str = \"DateFormat \"+getClass().getName();\n        TimeZone tz = _timezone;\n        if (tz != null) {\n            str += \" (timezone: \"+tz+\")\";\n        }\n        str += \"(locale: \"+_locale+\")\";\n        return str;\n    }", "parseAsISO8601": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\");\n                dateStr = sb.toString();\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                c = dateStr.charAt(len-3);\n                if (c == ':') { // remove optional colon\n                    // remove colon\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(len-3, len-2);\n                    dateStr = sb.toString();\n                } else if (c == '+' || c == '-') { // missing minutes\n                    // let's just append '00'\n                    dateStr += \"00\";\n                }\n                // Milliseconds partial or missing; and even seconds are optional\n                len = dateStr.length();\n                // remove 'T', '+'/'-' and 4-digit timezone-offset\n                c = dateStr.charAt(len-9);\n                if (Character.isDigit(c)) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(len-5, \".000\");\n                    dateStr = sb.toString();\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else {\n                // If not, plain date. Easiest to just patch 'Z' in the end?\n                StringBuilder sb = new StringBuilder(dateStr);\n                // And possible also millisecond part if missing\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen <= 8) {\n                        sb.append(\".000\");\n                }\n                sb.append('Z');\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }", "parseAsRFC1123": "    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n    {\n        if (_formatRFC1123 == null) {\n            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n        }\n        return _formatRFC1123.parse(dateStr, pos);\n    }", "hasTimeZone": "    private final static boolean hasTimeZone(String str)\n    {\n        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n        int len = str.length();\n        if (len >= 6) {\n            char c = str.charAt(len-6);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-5);\n            if (c == '+' || c == '-') return true;\n            c = str.charAt(len-3);\n            if (c == '+' || c == '-') return true;\n        }\n        return false;\n    }", "_cloneFormat": "    private final static DateFormat _cloneFormat(DateFormat df, String format,\n            TimeZone tz, Locale loc)\n    {\n        if (!loc.equals(DEFAULT_LOCALE)) {\n            df = new SimpleDateFormat(format, loc);\n            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n        } else {\n            df = (DateFormat) df.clone();\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n        }\n        return df;\n    }"}