{"version": "        public Version version() {\n            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n        }", "append": "        public Segment append(int index, JsonToken tokenType, Object value,\n                Object objectId, Object typeId)\n        {\n            if (index < TOKENS_PER_SEGMENT) {\n                set(index, tokenType, value, objectId, typeId);\n                return null;\n            }\n            _next = new Segment();\n            _next.set(0, tokenType, value, objectId, typeId);\n            return _next;\n        }", "serialize": "    public void serialize(JsonGenerator jgen)\n        throws IOException, JsonGenerationException\n    {\n        Segment segment = _first;\n        int ptr = -1;\n\n        final boolean checkIds = _mayHaveNativeIds;\n        boolean hasIds = checkIds && (segment.hasIds());\n\n        while (true) {\n            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                ptr = 0;\n                segment = segment.next();\n                if (segment == null) break;\n                hasIds = checkIds && (segment.hasIds());\n            }\n            JsonToken t = segment.type(ptr);\n            if (t == null) break;\n\n            if (hasIds) {\n                Object id = segment.findObjectId(ptr);\n                if (id != null) {\n                    jgen.writeObjectId(id);\n                }\n                id = segment.findTypeId(ptr);\n                if (id != null) {\n                    jgen.writeTypeId(id);\n                }\n            }\n            \n            // Note: copied from 'copyCurrentEvent'...\n            switch (t) {\n            case START_OBJECT:\n                jgen.writeStartObject();\n                break;\n            case END_OBJECT:\n                jgen.writeEndObject();\n                break;\n            case START_ARRAY:\n                jgen.writeStartArray();\n                break;\n            case END_ARRAY:\n                jgen.writeEndArray();\n                break;\n            case FIELD_NAME:\n            {\n                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n                Object ob = segment.get(ptr);\n                if (ob instanceof SerializableString) {\n                    jgen.writeFieldName((SerializableString) ob);\n                } else {\n                    jgen.writeFieldName((String) ob);\n                }\n            }\n                break;\n            case VALUE_STRING:\n                {\n                    Object ob = segment.get(ptr);\n                    if (ob instanceof SerializableString) {\n                        jgen.writeString((SerializableString) ob);\n                    } else {\n                        jgen.writeString((String) ob);\n                    }\n                }\n                break;\n            case VALUE_NUMBER_INT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Integer) {\n                        jgen.writeNumber((Integer) n);\n                    } else if (n instanceof BigInteger) {\n                        jgen.writeNumber((BigInteger) n);\n                    } else if (n instanceof Long) {\n                        jgen.writeNumber((Long) n);\n                    } else if (n instanceof Short) {\n                        jgen.writeNumber((Short) n);\n                    } else {\n                        jgen.writeNumber(((Number) n).intValue());\n                    }\n                }\n                break;\n            case VALUE_NUMBER_FLOAT:\n                {\n                    Object n = segment.get(ptr);\n                    if (n instanceof Double) {\n                        jgen.writeNumber(((Double) n).doubleValue());\n                    } else if (n instanceof BigDecimal) {\n                        jgen.writeNumber((BigDecimal) n);\n                    } else if (n instanceof Float) {\n                        jgen.writeNumber(((Float) n).floatValue());\n                    } else if (n == null) {\n                        jgen.writeNull();\n                    } else if (n instanceof String) {\n                        jgen.writeNumber((String) n);\n                    } else {\n                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n                    }\n                }\n                break;\n            case VALUE_TRUE:\n                jgen.writeBoolean(true);\n                break;\n            case VALUE_FALSE:\n                jgen.writeBoolean(false);\n                break;\n            case VALUE_NULL:\n                jgen.writeNull();\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                jgen.writeObject(segment.get(ptr));\n                break;\n            default:\n                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n            }\n        }\n    }", "deserialize": "    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n            copyCurrentStructure(jp);\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        return this;\n    }", "enable": "    public JsonGenerator enable(Feature f) {\n        _generatorFeatures |= f.getMask();\n        return this;\n    }", "disable": "    public JsonGenerator disable(Feature f) {\n        _generatorFeatures &= ~f.getMask();\n        return this;\n    }", "flush": "    public void flush() throws IOException { /* NOP */ }", "close": "        public void close() throws IOException {\n            if (!_closed) {\n                _closed = true;\n            }\n        }", "copyCurrentStructure": "    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n    {\n        JsonToken t = jp.getCurrentToken();\n\n        // Let's handle field-name separately first\n        if (t == JsonToken.FIELD_NAME) {\n            if (_mayHaveNativeIds) {\n                _checkNativeIds(jp);\n            }\n            writeFieldName(jp.getCurrentName());\n            t = jp.nextToken();\n            // fall-through to copy the associated value\n        }\n\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(jp);\n        }\n        \n        switch (t) {\n        case START_ARRAY:\n            writeStartArray();\n            while (jp.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(jp);\n            }\n            writeEndArray();\n            break;\n        case START_OBJECT:\n            writeStartObject();\n            while (jp.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(jp);\n            }\n            writeEndObject();\n            break;\n        default: // others are simple:\n            copyCurrentEvent(jp);\n        }\n    }", "_append": "    protected final void _append(JsonToken type, Object value)\n    {\n        Segment next = _hasNativeId\n                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n                : _last.append(_appendAt, type, value);\n        if (next == null) {\n            ++_appendAt;\n        } else {\n            _last = next;\n            _appendAt = 1;\n        }\n    }", "type": "        public JsonToken type(int index)\n        {\n            long l = _tokenTypes;\n            if (index > 0) {\n                l >>= (index << 2);\n            }\n            int ix = ((int) l) & 0xF;\n            return TOKEN_TYPES_BY_INDEX[ix];\n        }", "get": "        public Object get(int index) {\n            return _tokens[index];\n        }", "next": "        public Segment next() { return _next; }", "set": "        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n        {\n            _tokens[index] = value;\n            long typeCode = (long) rawTokenType;\n            if (index > 0) {\n                typeCode <<= (index << 2);\n            }\n            _tokenTypes |= typeCode;\n            assignNativeIds(index, objectId, typeId);\n        }"}