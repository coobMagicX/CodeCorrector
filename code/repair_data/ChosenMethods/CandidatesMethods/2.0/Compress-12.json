{"close": "    public void close() throws IOException {\n        buffer.close();\n    }", "getRecordSize": "    public int getRecordSize() {\n        return buffer.getRecordSize();\n    }", "available": "    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }", "skip": "    public long skip(long numToSkip) throws IOException {\n        // REVIEW\n        // This is horribly inefficient, but it ensures that we\n        // properly skip over bytes via the TarBuffer...\n        //\n        byte[] skipBuf = new byte[BUFFER_SIZE];\n        long skip = numToSkip;\n        while (skip > 0) {\n            int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);\n            int numRead = read(skipBuf, 0, realSkip);\n            if (numRead == -1) {\n                break;\n            }\n            skip -= numRead;\n        }\n        return (numToSkip - skip);\n    }", "reset": "    public synchronized void reset() {\n    }", "getNextTarEntry": "    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            getNextEntry();\n            if (currEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }", "getRecord": "    private byte[] getRecord() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        byte[] headerBuf = buffer.readRecord();\n\n        if (headerBuf == null) {\n            hasHitEOF = true;\n        } else if (buffer.isEOFRecord(headerBuf)) {\n            hasHitEOF = true;\n        }\n\n        return hasHitEOF ? null : headerBuf;\n    }", "paxHeaders": "    private void paxHeaders() throws IOException{\n        Reader br = new InputStreamReader(this, \"UTF-8\") {\n                @Override\n                public void close() {\n                    // make sure GC doesn't close \"this\" before we are done\n                }\n            };\n        Map<String, String> headers = null;\n        try {\n            headers = parsePaxHeaders(br);\n        } finally {\n            // NO-OP but makes FindBugs happy\n            br.close();\n        }\n\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }", "parsePaxHeaders": "    Map<String, String> parsePaxHeaders(Reader br) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = br.read()) != -1){\n                read++;\n                if (ch == ' '){ // End of length string\n                    // Get keyword\n                    StringBuffer sb = new StringBuffer();\n                    while((ch = br.read()) != -1){\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            String keyword = sb.toString();\n                            // Get rest of entry\n                            char[] cbuf = new char[len-read];\n                            int got = br.read(cbuf);\n                            if (got != len - read){\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + (len - read)\n                                                      + \" chars, read \"\n                                                      + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(cbuf, 0,\n                                                      len - read - 1);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        sb.append((char) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }", "applyPaxHeadersToCurrentEntry": "    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, mtime, charset: cannot use these without changing TarArchiveEntry fields\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         */\n        for (Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Integer.parseInt(val));\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            }\n        }\n    }", "readGNUSparse": "    private void readGNUSparse() throws IOException {\n        /* we do not really process sparse files yet\n        sparses = new ArrayList();\n        sparses.addAll(currEntry.getSparses());\n        */\n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (hasHitEOF) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                /* we do not really process sparse files yet\n                sparses.addAll(entry.getSparses());\n                */\n            } while (entry.isExtended());\n        }\n    }", "getNextEntry": "    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextTarEntry();\n    }", "read": "    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n        int totalRead = 0;\n\n        if (entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if ((numToRead + entryOffset) > entrySize) {\n            numToRead = (int) (entrySize - entryOffset);\n        }\n\n        if (readBuf != null) {\n            int sz = (numToRead > readBuf.length) ? readBuf.length\n                : numToRead;\n\n            System.arraycopy(readBuf, 0, buf, offset, sz);\n\n            if (sz >= readBuf.length) {\n                readBuf = null;\n            } else {\n                int newLen = readBuf.length - sz;\n                byte[] newBuf = new byte[newLen];\n\n                System.arraycopy(readBuf, sz, newBuf, 0, newLen);\n\n                readBuf = newBuf;\n            }\n\n            totalRead += sz;\n            numToRead -= sz;\n            offset += sz;\n        }\n\n        while (numToRead > 0) {\n            byte[] rec = buffer.readRecord();\n\n            if (rec == null) {\n                // Unexpected EOF!\n                throw new IOException(\"unexpected EOF with \" + numToRead\n                                      + \" bytes unread. Occured at byte: \" + getBytesRead());\n            }\n            count(rec.length);\n            int sz = numToRead;\n            int recLen = rec.length;\n\n            if (recLen > sz) {\n                System.arraycopy(rec, 0, buf, offset, sz);\n\n                readBuf = new byte[recLen - sz];\n\n                System.arraycopy(rec, sz, readBuf, 0, recLen - sz);\n            } else {\n                sz = recLen;\n\n                System.arraycopy(rec, 0, buf, offset, recLen);\n            }\n\n            totalRead += sz;\n            numToRead -= sz;\n            offset += sz;\n        }\n\n        entryOffset += totalRead;\n\n        return totalRead;\n    }", "canReadEntryData": "    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }", "matches": "    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        // COMPRESS-107 - recognise Ant tar files\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }"}