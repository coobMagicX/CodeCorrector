{"pos": "    public int pos() {\n        return readerPos + bufPos;\n    }", "isEmpty": "    public boolean isEmpty() {\n        return bufPos >= bufLength;\n    }", "current": "    public char current() {\n        bufferUp();\n        return isEmpty() ? EOF : charBuf[bufPos];\n    }", "consume": "    char consume() {\n        bufferUp();\n        char val = isEmpty() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }", "unconsume": "    void unconsume() {\n        bufPos--;\n    }", "advance": "    public void advance() {\n        bufPos++;\n    }", "mark": "    void mark() {\n        bufMark = bufPos;\n    }", "rewindToMark": "    void rewindToMark() {\n        bufPos = bufMark;\n    }", "nextIndexOf": "    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }", "consumeLetterThenDigitSequence": "    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmpty()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }", "consumeDigitSequence": "    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }", "matches": "    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }", "matchesIgnoreCase": "    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }", "matchesDigit": "    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }", "matchConsumeIgnoreCase": "    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }", "containsIgnoreCase": "    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }", "toString": "    public String toString() {\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }", "cacheString": "    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n\n        // calculate hash:\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // get from cache\n        final int index = hash & stringCache.length - 1;\n        String cached = stringCache[index];\n\n        if (cached == null) { // miss, add\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else { // hashcode hit, check equality\n            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                return cached;\n            } else { // hashcode conflict\n                cached = new String(charBuf, start, count);\n                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n            }\n        }\n        return cached;\n    }", "rangeEquals": "    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }"}