{"feedInput": "    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }", "endOfInput": "    public void endOfInput() {\n        _endOfInput = true;\n    }", "releaseBuffered": "    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }", "_startDocument": "    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }", "_startFieldName": "    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }", "_startFieldNameAfterComma": "    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }", "_startValue": "    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }", "_startValueExpectComma": "    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }", "_startValueExpectColon": "    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }", "_startValueAfterComma": "    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }", "_startUnexpectedValue": "    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }", "_startSlashComment": "    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }", "_startAfterComment": "    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }", "_startFalseToken": "    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }", "_startTrueToken": "    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }", "_startNullToken": "    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }", "_reportErrorToken": "    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }", "_startPositiveNumber": "    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }", "_startNegativeNumber": "    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }", "_startNumberLeadingZero": "    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }", "_startFloat": "    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }", "_startString": "    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }", "_startAposString": "    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }"}