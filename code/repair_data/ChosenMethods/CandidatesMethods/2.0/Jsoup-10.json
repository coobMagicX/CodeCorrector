{"nodeName": "    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p/>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.", "attr": "    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }", "attributes": "    public Attributes attributes() {\n        return attributes;\n    }", "hasAttr": "    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        return attributes.hasKey(attributeKey);\n    }", "removeAttr": "    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        attributes.remove(attributeKey);\n        return this;\n    }", "baseUri": "    public String baseUri() {\n        return baseUri;\n    }", "setBaseUri": "    public void setBaseUri(String baseUri) {\n        Validate.notNull(baseUri);\n        this.baseUri = baseUri;\n    }", "absUrl": "    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        } else {\n            URL base;\n            try {\n                try {\n                    base = new URL(baseUri);\n                } catch (MalformedURLException e) {\n                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n                    URL abs = new URL(relUrl);\n                    return abs.toExternalForm();\n                }\n                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\";\n            }\n        }\n    }", "childNode": "    public Node childNode(int index) {\n        return childNodes.get(index);\n    }", "childNodes": "    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }", "childNodesAsArray": "    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodes().size()]);\n    }", "parent": "    public Node parent() {\n        return parentNode;\n    }", "ownerDocument": "    public Document ownerDocument() {\n        if (this instanceof Document)\n            return (Document) this;\n        else if (parentNode == null)\n            return null;\n        else\n            return parentNode.ownerDocument();\n    }", "remove": "    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }", "replaceWith": "    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }", "setParentNode": "    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }", "replaceChild": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        Integer index = out.siblingIndex();\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }", "removeChild": "    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        int index = out.siblingIndex();\n        childNodes.remove(index);\n        reindexChildren();\n        out.parentNode = null;\n    }", "addChildren": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren();\n    }", "reparentChild": "    private void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }", "reindexChildren": "    private void reindexChildren() {\n        for (int i = 0; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }", "siblingNodes": "    public List<Node> siblingNodes() {\n        return parent().childNodes(); // TODO: should this strip out this node? i.e. not a sibling of self?\n    }", "nextSibling": "    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }", "previousSibling": "    public Node previousSibling() {\n        List<Node> siblings = parentNode.childNodes;\n        Integer index = siblingIndex();\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }", "siblingIndex": "    public Integer siblingIndex() {\n        return siblingIndex;\n    }", "setSiblingIndex": "    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }", "outerHtml": "    protected void outerHtml(StringBuilder accum) {\n        new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n    }", "getOutputSettings": "    private Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }", "outerHtmlHead": "    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    public String toString() {\n        return outerHtml();\n    }", "outerHtmlTail": "    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    public String toString() {\n        return outerHtml();\n    }", "toString": "    public String toString() {\n        return outerHtml();\n    }", "indent": "    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }", "equals": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        // todo: have nodes hold a child index, compare against that and parent (not children)\n        return false;\n    }", "hashCode": "    public int hashCode() {\n        int result = parentNode != null ? parentNode.hashCode() : 0;\n        // not children, or will block stack as they go back up to parent)\n        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n        return result;\n    }", "clone": "    public Node clone() {\n        return doClone(null); // splits for orphan\n    }", "doClone": "    protected Node doClone(Node parent) {\n        Node clone;\n        try {\n            clone = (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode = parent; // can be null, to create an orphan split\n        clone.siblingIndex = parent == null ? 0 : siblingIndex;\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.baseUri = baseUri;\n        clone.childNodes = new ArrayList<Node>(childNodes.size());\n        for (Node child: childNodes)\n            clone.childNodes.add(child.doClone(clone)); // clone() creates orphans, doClone() keeps parent\n\n        return clone;\n    }", "head": "        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }", "tail": "        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }"}