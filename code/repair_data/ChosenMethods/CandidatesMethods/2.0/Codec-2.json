{"isUrlSafe": "    public boolean isUrlSafe() {\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n    }", "avail": "    int avail() {\n        return buf != null ? pos - readPos : 0;\n    }", "resizeBuf": "    private void resizeBuf() {\n        if (buf == null) {\n            buf = new byte[8192];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buf.length * 2];\n            System.arraycopy(buf, 0, b, 0, buf.length);\n            buf = b;\n        }\n    }", "setInitialBuffer": "    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buf = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }", "encode": "    public byte[] encode(byte[] pArray) {\n        return encodeBase64(pArray, false, isUrlSafe());\n    }", "decode": "    public byte[] decode(byte[] pArray) {\n        return decodeBase64(pArray);\n    }", "isBase64": "    public static boolean isBase64(byte octet) {\n        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n    }", "isArrayByteBase64": "    public static boolean isArrayByteBase64(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "containsBase64Byte": "    private static boolean containsBase64Byte(byte[] arrayOctet) {\n        for (int i = 0; i < arrayOctet.length; i++) {\n            if (isBase64(arrayOctet[i])) {\n                return true;\n            }\n        }\n        return false;\n    }", "encodeBase64": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        long len = (binaryData.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (isChunked) {\n            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n        }\n        if (len > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.encode(binaryData, 0, binaryData.length);\n        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (b64.buf != buf) {\n            b64.readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (urlSafe && b64.pos < buf.length) {\n            byte[] smallerBuf = new byte[b64.pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n            buf = smallerBuf;\n        }\n        return buf;\n    }", "encodeBase64URLSafe": "    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "encodeBase64Chunked": "    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "decodeBase64": "    public static byte[] decodeBase64(byte[] base64Data) {\n        if (base64Data == null || base64Data.length == 0) {\n            return base64Data;\n        }\n        Base64 b64 = new Base64();\n        long len = (base64Data.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        b64.setInitialBuffer(buf, 0, buf.length);\n        b64.decode(base64Data, 0, base64Data.length);\n        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n        // We have no idea what the line-length was, so we\n        // cannot know how much of our array wasn't used.\n        byte[] result = new byte[b64.pos];\n        b64.readResults(result, 0, result.length);\n        return result;\n    }", "discardWhitespace": "    static byte[] discardWhitespace(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            switch (data[i]) {\n                case ' ' :\n                case '\\n' :\n                case '\\r' :\n                case '\\t' :\n                    break;\n                default :\n                    groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }", "isWhiteSpace": "    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case ' ' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false;\n        }\n    }", "discardNonBase64": "    static byte[] discardNonBase64(byte[] data) {\n        byte groomedData[] = new byte[data.length];\n        int bytesCopied = 0;\n        for (int i = 0; i < data.length; i++) {\n            if (isBase64(data[i])) {\n                groomedData[bytesCopied++] = data[i];\n            }\n        }\n        byte packedData[] = new byte[bytesCopied];\n        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n        return packedData;\n    }", "decodeInteger": "    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray));\n    }", "encodeInteger": "    public static byte[] encodeInteger(BigInteger bigInt) {\n        if(bigInt == null)  {\n            throw new NullPointerException(\"encodeInteger called with null parameter\");\n        }\n        return encodeBase64(toIntegerBytes(bigInt), false);\n    }", "toIntegerBytes": "     static byte[] toIntegerBytes(BigInteger bigInt) {\n        int bitlen = bigInt.bitLength();\n        // round bitlen\n        bitlen = ((bitlen + 7) >> 3) << 3;\n        byte[] bigBytes = bigInt.toByteArray();\n\n        if(((bigInt.bitLength() % 8) != 0) &&\n            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n            return bigBytes;\n        }\n        // set up params for copying everything but sign bit\n        int startSrc = 0;\n        int len = bigBytes.length;\n\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\n        if((bigInt.bitLength() % 8) == 0) {\n            startSrc = 1;\n            len--;\n        }\n        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\n        byte[] resizedBytes = new byte[bitlen / 8];\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n        return resizedBytes;\n    }"}