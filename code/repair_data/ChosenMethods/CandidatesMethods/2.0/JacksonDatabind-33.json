{"version": "    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "isAnnotationBundle": "    public boolean isAnnotationBundle(Annotation ann) {\n        return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n    }", "findEnumValue": "    public String findEnumValue(Enum<?> value)\n    {\n        // 11-Jun-2015, tatu: As per [databind#677], need to allow explicit naming.\n        //   Unfortunately can not quite use standard AnnotatedClass here (due to various\n        //   reasons, including odd representation JVM uses); has to do for now\n        try {\n            // We know that values are actually static fields with matching name so:\n            Field f = value.getClass().getField(value.name());\n            if (f != null) {\n                JsonProperty prop = f.getAnnotation(JsonProperty.class);\n                if (prop != null) {\n                    String n = prop.value();\n                    if (n != null && !n.isEmpty()) {\n                        return n;\n                    }\n                }\n            }\n        } catch (SecurityException e) {\n            // 17-Sep-2015, tatu: Anything we could/should do here?\n        } catch (NoSuchFieldException e) {\n            // 17-Sep-2015, tatu: should not really happen. But... can we do anything?\n        }\n        return value.name();\n    }", "findRootName": "    public PropertyName findRootName(AnnotatedClass ac)\n    {\n        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n        if (ann == null) {\n            return null;\n        }\n        String ns = ann.namespace();\n        if (ns != null && ns.length() == 0) {\n            ns = null;\n        }\n        return PropertyName.construct(ann.value(), ns);\n    }", "isIgnorableType": "    public Boolean isIgnorableType(AnnotatedClass ac) {\n        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n        return (ignore == null) ? null : ignore.value();\n    }", "findNamingStrategy": "    public Object findNamingStrategy(AnnotatedClass ac)\n    {\n        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n        return (ann == null) ? null : ann.value();\n    } ", "findAutoDetectVisibility": "    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n        VisibilityChecker<?> checker)\n    {\n        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n        return (ann == null) ? checker : checker.with(ann);\n    }", "findImplicitPropertyName": "    public String findImplicitPropertyName(AnnotatedMember param) {\n        // not known by default (until JDK8) for creators; default \n        //\n        return null;\n    }", "hasIgnoreMarker": "    public boolean hasIgnoreMarker(AnnotatedMember m) {\n        return _isIgnorable(m);\n    }", "hasRequiredMarker": "    public Boolean hasRequiredMarker(AnnotatedMember m)\n    {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.required();\n        }\n        return null;\n    }", "findPropertyAccess": "    public JsonProperty.Access findPropertyAccess(Annotated m) {\n        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n        if (ann != null) {\n            return ann.access();\n        }\n        return null;\n    }", "findPropertyDefaultValue": "    public String findPropertyDefaultValue(Annotated ann) {\n        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n        if (prop == null) {\n            return null;\n        }\n        String str = prop.defaultValue();\n        // Since annotations do not allow nulls, need to assume empty means \"none\"\n        return str.isEmpty() ? null : str;\n    }", "findFormat": "    public JsonFormat.Value findFormat(Annotated ann) {\n        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n        return (f == null)  ? null : new JsonFormat.Value(f);\n    }", "findUnwrappingNameTransformer": "    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n    {\n        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n        // if not enabled, just means annotation is not enabled; not necessarily\n        // that unwrapping should not be done (relevant when using chained introspectors)\n        if (ann == null || !ann.enabled()) {\n            return null;\n        }\n        String prefix = ann.prefix();\n        String suffix = ann.suffix();\n        return NameTransformer.simpleTransformer(prefix, suffix);\n    }", "findInjectableValueId": "    public Object findInjectableValueId(AnnotatedMember m)\n    {\n        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n        if (ann == null) {\n            return null;\n        }\n        /* Empty String means that we should use name of declared\n         * value class.\n         */\n        String id = ann.value();\n        if (id.length() == 0) {\n            // slight complication; for setters, type \n            if (!(m instanceof AnnotatedMethod)) {\n                return m.getRawType().getName();\n            }\n            AnnotatedMethod am = (AnnotatedMethod) m;\n            if (am.getParameterCount() == 0) {\n                return m.getRawType().getName();\n            }\n            return am.getRawParameterType(0).getName();\n        }\n        return id;\n    }", "findTypeName": "    public String findTypeName(AnnotatedClass ac)\n    {\n        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n        return (tn == null) ? null : tn.value();\n    }", "findSerializer": "    public Object findSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.using();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        \n        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n         *  if we need to get raw indicator from other sources need to add\n         *  separate accessor within {@link AnnotationIntrospector} interface.\n         */\n        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n        if ((annRaw != null) && annRaw.value()) {\n            // let's construct instance with nominal type:\n            Class<?> cls = a.getRawType();\n            return new RawSerializer<Object>(cls);\n        }       \n        return null;\n    }", "findKeySerializer": "    public Object findKeySerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.keyUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }", "findContentSerializer": "    public Object findContentSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.contentUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }", "findNullSerializer": "    public Object findNullSerializer(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonSerializer> serClass = ann.nullsUsing();\n            if (serClass != JsonSerializer.None.class) {\n                return serClass;\n            }\n        }\n        return null;\n    }", "findSerializationInclusion": "    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include v = inc.value();\n            if (v != JsonInclude.Include.USE_DEFAULTS) {\n                return v;\n            }\n        }\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        if (ann != null) {\n            JsonSerialize.Inclusion i2 = ann.include();\n            switch (i2) {\n            case ALWAYS:\n                return JsonInclude.Include.ALWAYS;\n            case NON_NULL:\n                return JsonInclude.Include.NON_NULL;\n            case NON_DEFAULT:\n                return JsonInclude.Include.NON_DEFAULT;\n            case NON_EMPTY:\n                return JsonInclude.Include.NON_EMPTY;\n            case DEFAULT_INCLUSION: // since 2.3 -- fall through, use default\n                break;\n            }\n        }\n        return defValue;\n    }", "findSerializationInclusionForContent": "    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n    {\n        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n        if (inc != null) {\n            JsonInclude.Include incl = inc.content();\n            if (incl != JsonInclude.Include.USE_DEFAULTS) {\n                return incl;\n            }\n        }\n        return defValue;\n    }", "findSerializationType": "    public Class<?> findSerializationType(Annotated am)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }", "findSerializationKeyType": "    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }", "findSerializationContentType": "    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n    {\n        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }", "findSerializationTyping": "    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n    {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : ann.typing();\n    }", "findSerializationConverter": "    public Object findSerializationConverter(Annotated a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }", "findSerializationContentConverter": "    public Object findSerializationContentConverter(AnnotatedMember a) {\n        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }", "findSerializationPropertyOrder": "    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n        return (order == null) ? null : order.value();\n    }", "findSerializationSortAlphabetically": "    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return _findSortAlpha(ann);\n    }", "_findSortAlpha": "    private final Boolean _findSortAlpha(Annotated ann) {\n        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n        /* 23-Jun-2015, tatu: as per [databind#840], let's only consider\n         *  `true` to have any significance.\n         */\n        if ((order != null) && order.alphabetic()) {\n            return Boolean.TRUE;\n        }\n        return null;\n    }", "findAndAddVirtualProperties": "    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) {\n        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n        if (ann == null) {\n            return;\n        }\n        final boolean prepend = ann.prepend();\n        JavaType propType = null;\n\n        // First: any attribute-backed properties?\n        JsonAppend.Attr[] attrs = ann.attrs();\n        for (int i = 0, len = attrs.length; i < len; ++i) {\n            if (propType == null) {\n                propType = config.constructType(Object.class);\n            }\n            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n                    config, ac, propType);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n\n        // Then: general-purpose virtual properties?\n        JsonAppend.Prop[] props = ann.props();\n        for (int i = 0, len = props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n                    config, ac);\n            if (prepend) {\n                properties.add(i, bpw);\n            } else {\n                properties.add(bpw);\n            }\n        }\n    }", "_constructVirtualProperty": "    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n            MapperConfig<?> config, AnnotatedClass ac)\n    {\n        PropertyMetadata metadata = prop.required() ?\n                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n        JavaType type = config.constructType(prop.type());\n        // now, then, we need a placeholder for member (no real Field/Method):\n        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n                propName.getSimpleName(), type.getRawClass());\n        // and with that and property definition\n        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n                member, propName, metadata, prop.include());\n\n        Class<?> implClass = prop.value();\n\n        HandlerInstantiator hi = config.getHandlerInstantiator();\n        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n                : hi.virtualPropertyWriterInstance(config, implClass);\n        if (bpw == null) {\n            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n                    config.canOverrideAccessModifiers());\n        }\n\n        // one more thing: give it necessary contextual information\n        return bpw.withConfig(config, ac, propDef, type);\n    }", "findNameForSerialization": "    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)) {\n                name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }", "hasAsValueAnnotation": "    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        JsonValue ann = _findAnnotation(am, JsonValue.class);\n        // value of 'false' means disabled...\n        return (ann != null && ann.value());\n    }", "findDeserializer": "    public Object findDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.using();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }", "findKeyDeserializer": "    public Object findKeyDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n            if (deserClass != KeyDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }", "findContentDeserializer": "    public Object findContentDeserializer(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        if (ann != null) {\n            @SuppressWarnings(\"rawtypes\")\n            Class<? extends JsonDeserializer> deserClass = ann.contentUsing();\n            if (deserClass != JsonDeserializer.None.class) {\n                return deserClass;\n            }\n        }\n        return null;\n    }", "findDeserializationType": "    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.as());\n    }", "findDeserializationKeyType": "    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n    }", "findDeserializationContentType": "    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n    {\n        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n    }", "findDeserializationConverter": "    public Object findDeserializationConverter(Annotated a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n    }", "findDeserializationContentConverter": "    public Object findDeserializationContentConverter(AnnotatedMember a)\n    {\n        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n        return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n    }", "findValueInstantiator": "    public Object findValueInstantiator(AnnotatedClass ac)\n    {\n        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n        // no 'null' marker yet, so:\n        return (ann == null) ? null : ann.value();\n    }", "findNameForDeserialization": "    public PropertyName findNameForDeserialization(Annotated a)\n    {\n        String name;\n\n        // @JsonSetter has precedence over @JsonProperty, being more specific\n        // @JsonDeserialize implies that there is a property, but no name\n        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n        if (js != null) {\n            name = js.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            } else if (_hasAnnotation(a, JsonDeserialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n                    || _hasAnnotation(a, JsonBackReference.class)\n                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                    name = \"\";\n            } else {\n                return null;\n            }\n        }\n        return PropertyName.construct(name);\n    }", "hasAnySetterAnnotation": "    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n        return _hasAnnotation(am, JsonAnySetter.class);\n    }", "hasAnyGetterAnnotation": "    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (handled separately\n         */\n        return _hasAnnotation(am, JsonAnyGetter.class);\n    }", "hasCreatorAnnotation": "    public boolean hasCreatorAnnotation(Annotated a)\n    {\n        /* No dedicated disabling; regular @JsonIgnore used\n         * if needs to be ignored (and if so, is handled prior\n         * to this method getting called)\n         */\n         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n    }", "findCreatorBinding": "    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n        return (ann == null) ? null : ann.mode();\n    }", "_isIgnorable": "    protected boolean _isIgnorable(Annotated a)\n    {\n        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n        return (ann != null && ann.value());\n    }", "_classIfExplicit": "    protected Class<?> _classIfExplicit(Class<?> cls, Class<?> implicit) {\n        cls = _classIfExplicit(cls);\n        return (cls == null || cls == implicit) ? null : cls;\n    }", "_propertyName": "    protected PropertyName _propertyName(String localName, String namespace) {\n        if (localName.isEmpty()) {\n            return PropertyName.USE_DEFAULT;\n        }\n        if (namespace == null || namespace.isEmpty()) {\n            return PropertyName.construct(localName);\n        }\n        return PropertyName.construct(localName, namespace);\n    }", "_constructStdTypeResolverBuilder": "    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n        return new StdTypeResolverBuilder();\n    }", "_constructNoTypeResolverBuilder": "    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {\n        return StdTypeResolverBuilder.noTypeInfoBuilder();\n    }"}