{"checkCapacity": "    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curSize = keys.length;\n        if (curSize >= minNewSize)\n            return;\n\n        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newSize)\n            newSize = minNewSize;\n\n        keys = copyOf(keys, newSize);\n        vals = copyOf(vals, newSize);\n    }", "indexOfKey": "    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }", "indexOfKeyIgnoreCase": "    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }", "get": "    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }", "getIgnoreCase": "    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }", "add": "    private void add(String key, String value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }", "put": "        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }", "putIgnoreCase": "    void putIgnoreCase(String key, String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            if (!keys[i].equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }", "remove": "            public void remove() {\n                attributes.remove(attr.getKey());\n            }", "removeIgnoreCase": "    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }", "hasKey": "    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }", "hasKeyIgnoreCase": "    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }", "size": "            public int size() {\n                int count = 0;\n                Iterator iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }", "iterator": "            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }", "asList": "    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Attribute attr = vals[i] == null ?\n                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n                new Attribute(keys[i], vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }", "dataset": "    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }", "html": "    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            // inlined from Attribute.html()\n            final String key = keys[i];\n            final String val = vals[i];\n            accum.append(' ').append(key);\n\n            // collapse checked=null, checked=\"\", checked=checked; write out others\n            if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n                accum.append(\"=\\\"\");\n                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n                accum.append('\"');\n            }\n        }\n    }", "toString": "    public String toString() {\n        return html();\n    }", "equals": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n\n        if (size != that.size) return false;\n        if (!Arrays.equals(keys, that.keys)) return false;\n        return Arrays.equals(vals, that.vals);\n    }", "clone": "    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        keys = copyOf(keys, size);\n        vals = copyOf(vals, size);\n        return clone;\n    }", "normalize": "    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            keys[i] = lowerCase(keys[i]);\n        }\n    }", "next": "            public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }", "dataKey": "    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }"}