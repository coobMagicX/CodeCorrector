{"addDecoder": "    static InputStream addDecoder(final InputStream is,\n            final Coder coder, final byte[] password) throws IOException {\n        for (final CoderId coderId : coderTable) {\n            if (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId)) {\n                return coderId.coder.decode(is, coder, password);\n            }\n        }\n        throw new IOException(\"Unsupported compression method \" +\n                Arrays.toString(coder.decompressionMethodId));\n    }", "addEncoder": "    static OutputStream addEncoder(final OutputStream out, final SevenZMethod method,\n                                   final byte[] password) throws IOException {\n        for (final CoderId coderId : coderTable) {\n            if (coderId.method.equals(method)) {\n                return coderId.coder.encode(out, password);\n            }\n        }\n        throw new IOException(\"Unsupported compression method \" + method);\n    }", "decode": "        InputStream decode(final InputStream in, final Coder coder,\n                final byte[] passwordBytes) throws IOException {\n            return new InputStream() {\n                private boolean isInitialized = false;\n                private CipherInputStream cipherInputStream = null;\n                \n                private CipherInputStream init() throws IOException {\n                    if (isInitialized) {\n                        return cipherInputStream;\n                    }\n                    final int byte0 = 0xff & coder.properties[0];\n                    final int numCyclesPower = byte0 & 0x3f;\n                    final int byte1 = 0xff & coder.properties[1];\n                    final int ivSize = ((byte0 >> 6) & 1) + (byte1 & 0x0f);\n                    final int saltSize = ((byte0 >> 7) & 1) + (byte1 >> 4);\n                    if (2 + saltSize + ivSize > coder.properties.length) {\n                        throw new IOException(\"Salt size + IV size too long\");\n                    }\n                    final byte[] salt = new byte[saltSize];\n                    System.arraycopy(coder.properties, 2, salt, 0, saltSize);\n                    final byte[] iv = new byte[16];\n                    System.arraycopy(coder.properties, 2 + saltSize, iv, 0, ivSize);\n                    \n                    if (passwordBytes == null) {\n                        throw new IOException(\"Cannot read encrypted files without a password\");\n                    }\n                    final byte[] aesKeyBytes;\n                    if (numCyclesPower == 0x3f) {\n                        aesKeyBytes = new byte[32];\n                        System.arraycopy(salt, 0, aesKeyBytes, 0, saltSize);\n                        System.arraycopy(passwordBytes, 0, aesKeyBytes, saltSize,\n                                Math.min(passwordBytes.length, aesKeyBytes.length - saltSize));\n                    } else {\n                        final MessageDigest digest;\n                        try {\n                            digest = MessageDigest.getInstance(\"SHA-256\");\n                        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {\n                            IOException ioe = new IOException(\"SHA-256 is unsupported by your Java implementation\");\n                            ioe.initCause(noSuchAlgorithmException);\n                            throw ioe;\n        // TODO: simplify when Compress requires Java 1.6                \n//                            throw new IOException(\"SHA-256 is unsupported by your Java implementation\",\n//                                    noSuchAlgorithmException);\n                        }\n                        final byte[] extra = new byte[8];\n                        for (long j = 0; j < (1L << numCyclesPower); j++) {\n                            digest.update(salt);\n                            digest.update(passwordBytes);\n                            digest.update(extra);\n                            for (int k = 0; k < extra.length; k++) {\n                                ++extra[k];\n                                if (extra[k] != 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        aesKeyBytes = digest.digest();\n                    }\n                    \n                    final SecretKey aesKey = new SecretKeySpec(aesKeyBytes, \"AES\");\n                    try {\n                        final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n                        cipherInputStream = new CipherInputStream(in, cipher);\n                        isInitialized = true;\n                        return cipherInputStream;\n                    } catch (GeneralSecurityException generalSecurityException) {\n                        IOException ioe = new IOException(\"Decryption error \" +\n                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\");\n                        ioe.initCause(generalSecurityException);\n                        throw ioe;\n        // TODO: simplify when Compress requires Java 1.6                \n//                        throw new IOException(\"Decryption error \" +\n//                                \"(do you have the JCE Unlimited Strength Jurisdiction Policy Files installed?)\",\n//                                generalSecurityException);\n                    }\n                }\n                \n                @Override\n                public int read() throws IOException {\n                    return init().read();\n                }\n                \n                @Override\n                public int read(byte[] b, int off, int len) throws IOException {\n                    return init().read(b, off, len);\n                }\n                \n                @Override\n                public void close() {\n                }\n            };\n        }", "encode": "        OutputStream encode(final OutputStream out, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorOutputStream(out);\n        }", "read": "        public int read(byte[] b, int off, int len) throws IOException {\n            int result = super.read(b, off, len);\n            if (result == -1 && addDummyByte) {\n                addDummyByte = false;\n                b[off] = 0;\n                return 1;\n            }\n            return result;\n        }"}