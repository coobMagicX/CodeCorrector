{"construct": "    public static AnnotatedClass construct(Class<?> cls,\n            AnnotationIntrospector aintr, MixInResolver mir)\n    {\n        return new AnnotatedClass(cls,\n                ClassUtil.findSuperTypes(cls, null), aintr, mir, null);\n    }", "getModifiers": "    public int getModifiers() { return _class.getModifiers(); }", "getName": "    public String getName() { return _class.getName(); }", "annotations": "    public Iterable<Annotation> annotations() {\n        if (_classAnnotations == null) {\n            resolveClassAnnotations();\n        }\n        return _classAnnotations.annotations();\n    }", "getStaticMethods": "    public List<AnnotatedMethod> getStaticMethods()\n    {\n        if (!_creatorsResolved) {\n            resolveCreators();\n        }\n        return _creatorMethods;\n    }", "memberMethods": "    public Iterable<AnnotatedMethod> memberMethods()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods;\n    }", "getMemberMethodCount": "    public int getMemberMethodCount()\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.size();\n    }", "findMethod": "    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n    {\n        if (_memberMethods == null) {\n            resolveMemberMethods();\n        }\n        return _memberMethods.find(name, paramTypes);\n    }", "fields": "    public Iterable<AnnotatedField> fields()\n    {\n        if (_fields == null) {\n            resolveFields();\n        }\n        return _fields;\n    }", "resolveClassAnnotations": "    private void resolveClassAnnotations()\n    {\n        _classAnnotations = new AnnotationMap();\n        // [JACKSON-659] Should skip processing if annotation processing disabled\n        if (_annotationIntrospector != null) {\n            // add mix-in annotations first (overrides)\n            if (_primaryMixIn != null) {\n                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n            }\n            // first, annotations from the class itself:\n            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n    \n            // and then from super types\n            for (Class<?> cls : _superTypes) {\n                // and mix mix-in annotations in-between\n                _addClassMixIns(_classAnnotations, cls);\n                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n            }\n            /* and finally... any annotations there might be for plain\n             * old Object.class: separate because for all other purposes\n             * it is just ignored (not included in super types)\n             */\n            /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n             *   For now, yes, seems useful for some cases, and not harmful for any?\n             */\n            _addClassMixIns(_classAnnotations, Object.class);\n        }\n    }", "resolveMemberMethods": "    private void resolveMemberMethods()\n    {\n        _memberMethods = new AnnotatedMethodMap();\n        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n        // first: methods from the class itself\n        _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins);\n\n        // and then augment these with annotations from super-types:\n        for (Class<?> cls : _superTypes) {\n            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n            _addMemberMethods(cls, _memberMethods, mixin, mixins);\n        }\n        // Special case: mix-ins for Object.class? (to apply to ALL classes)\n        if (_mixInResolver != null) {\n            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n            if (mixin != null) {\n                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n            }\n        }\n\n        /* Any unmatched mix-ins? Most likely error cases (not matching\n         * any method); but there is one possible real use case:\n         * exposing Object#hashCode (alas, Object#getClass can NOT be\n         * exposed, see [JACKSON-140])\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (!mixins.isEmpty()) {\n                Iterator<AnnotatedMethod> it = mixins.iterator();\n                while (it.hasNext()) {\n                    AnnotatedMethod mixIn = it.next();\n                    try {\n                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes());\n                        if (m != null) {\n                            AnnotatedMethod am = _constructMethod(m);\n                            _addMixOvers(mixIn.getAnnotated(), am, false);\n                            _memberMethods.add(am);\n                        }\n                    } catch (Exception e) { }\n                }\n            }\n        }\n    }", "_addClassMixIns": "    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,\n                                   Class<?> mixin)\n    {\n        if (mixin == null) {\n            return;\n        }\n        // Ok, first: annotations from mix-in class itself:\n        _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n\n        /* And then from its supertypes, if any. But note that we will\n         * only consider super-types up until reaching the masked\n         * class (if found); this because often mix-in class\n         * is a sub-class (for convenience reasons). And if so, we\n         * absolutely must NOT include super types of masked class,\n         * as that would inverse precedence of annotations.\n         */\n        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n            _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations());\n        }\n    }", "_addConstructorMixIns": "    protected void _addConstructorMixIns(Class<?> mixin)\n    {\n        MemberKey[] ctorKeys = null;\n        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n            if (ctor.getParameterTypes().length == 0) {\n                if (_defaultConstructor != null) {\n                    _addMixOvers(ctor, _defaultConstructor, false);\n                }\n            } else {\n                if (ctorKeys == null) {\n                    ctorKeys = new MemberKey[ctorCount];\n                    for (int i = 0; i < ctorCount; ++i) {\n                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n                    }\n                }\n                MemberKey key = new MemberKey(ctor);\n\n                for (int i = 0; i < ctorCount; ++i) {\n                    if (!key.equals(ctorKeys[i])) {\n                        continue;\n                    }\n                    _addMixOvers(ctor, _constructors.get(i), true);\n                    break;\n                }\n            }\n        }\n    }", "_addFactoryMixIns": "    protected void _addFactoryMixIns(Class<?> mixin)\n    {\n        MemberKey[] methodKeys = null;\n        int methodCount = _creatorMethods.size();\n\n        for (Method m : mixin.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            if (m.getParameterTypes().length == 0) {\n                continue;\n            }\n            if (methodKeys == null) {\n                methodKeys = new MemberKey[methodCount];\n                for (int i = 0; i < methodCount; ++i) {\n                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n                }\n            }\n            MemberKey key = new MemberKey(m);\n            for (int i = 0; i < methodCount; ++i) {\n                if (!key.equals(methodKeys[i])) {\n                    continue;\n                }\n                _addMixOvers(m, _creatorMethods.get(i), true);\n                break;\n            }\n        }\n    }", "_addMemberMethods": "    protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        // first, mixIns, since they have higher priority then class methods\n        if (mixInCls != null) {\n            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n        }        \n        if (cls == null) { // just so caller need not check when passing super-class\n            return;\n        }\n\n        // then methods from the class itself\n        for (Method m : cls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod old = methods.find(m);\n            if (old == null) {\n                AnnotatedMethod newM = _constructMethod(m);\n                methods.add(newM);\n                // Ok, but is there a mix-in to connect now?\n                old = mixIns.remove(m);\n                if (old != null) {\n                    _addMixOvers(old.getAnnotated(), newM, false);\n                }\n            } else {\n                /* If sub-class already has the method, we only want to augment\n                 * annotations with entries that are not masked by sub-class.\n                 */\n                _addMixUnders(m, old);\n\n                /* 06-Jan-2010, tatu: [JACKSON-450] Except that if method we saw first is\n                 *   from an interface, and we now find a non-interface definition, we should\n                 *   use this method, but with combination of annotations.\n                 *   This helps (or rather, is essential) with JAXB annotations and\n                 *   may also result in faster method calls (interface calls are slightly\n                 *   costlier than regular method calls)\n                 */\n                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n                    methods.add(old.withMethod(m));\n                }\n            }\n        }\n    }", "_addMethodMixIns": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }", "_findFields": "    protected Map<String,AnnotatedField> _findFields(Class<?> c, Map<String,AnnotatedField> fields)\n    {\n        /* First, a quick test: we only care for regular classes (not\n         * interfaces, primitive types etc), except for Object.class.\n         * A simple check to rule out other cases is to see if there\n         * is a super class or not.\n         */\n        Class<?> parent = c.getSuperclass();\n        if (parent != null) {\n            // Let's add super-class' fields first, then ours.\n            /* 21-Feb-2010, tatu: Need to handle masking: as per [JACKSON-226]\n             *    we otherwise get into trouble...\n             */\n            fields = _findFields(parent, fields);\n            for (Field f : c.getDeclaredFields()) {\n                // static fields not included, nor transient\n                if (!_isIncludableField(f)) {\n                    continue;\n                }\n                /* Ok now: we can (and need) not filter out ignorable fields\n                 * at this point; partly because mix-ins haven't been\n                 * added, and partly because logic can be done when\n                 * determining get/settability of the field.\n                 */\n                if (fields == null) {\n                    fields = new LinkedHashMap<String,AnnotatedField>();\n                }\n                fields.put(f.getName(), _constructField(f));\n            }\n            // And then... any mix-in overrides?\n            if (_mixInResolver != null) {\n                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                if (mixin != null) {\n                    _addFieldMixIns(parent, mixin, fields);\n                }\n            }\n        }\n        return fields;\n    }", "_addFieldMixIns": "    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n            Map<String,AnnotatedField> fields)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Field mixinField : mixin.getDeclaredFields()) {\n                // there are some dummy things (static, synthetic); better ignore\n                if (!_isIncludableField(mixinField)) {\n                    continue;\n                }\n                String name = mixinField.getName();\n                // anything to mask? (if not, quietly ignore)\n                AnnotatedField maskedField = fields.get(name);\n                if (maskedField != null) {\n                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n                }\n            }\n        }\n    }", "_constructMethod": "    protected AnnotatedMethod _constructMethod(Method m)\n    {\n        /* note: parameter annotations not used for regular (getter, setter)\n         * methods; only for creator methods (static factory methods)\n         * -- at least not yet!\n         */\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n    }", "_constructCreatorMethod": "    protected AnnotatedMethod _constructCreatorMethod(Method m)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n        }\n        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n    }", "_emptyAnnotationMap": "    private AnnotationMap _emptyAnnotationMap() {\n        return new AnnotationMap();\n    }", "_emptyAnnotationMaps": "    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n        if (count == 0) {\n            return NO_ANNOTATION_MAPS;\n        }\n        AnnotationMap[] maps = new AnnotationMap[count];\n        for (int i = 0; i < count; ++i) {\n            maps[i] = _emptyAnnotationMap();\n        }\n        return maps;\n    }", "_isIncludableMemberMethod": "    protected boolean _isIncludableMemberMethod(Method m)\n    {\n        if (Modifier.isStatic(m.getModifiers())) {\n            return false;\n        }\n        /* 07-Apr-2009, tatu: Looks like generics can introduce hidden\n         *   bridge and/or synthetic methods. I don't think we want to\n         *   consider those...\n         */\n        if (m.isSynthetic() || m.isBridge()) {\n            return false;\n        }\n        // also, for now we have no use for methods with 2 or more arguments:\n        int pcount = m.getParameterTypes().length;\n        return (pcount <= 2);\n    }", "_addAnnotationsIfNotPresent": "    private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: we will NOT filter out non-Jackson anns any more\n                    target.addIfNotPresent(ann);\n                }\n            }\n            if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n                for (Annotation[] annotations : bundles) {\n                    _addAnnotationsIfNotPresent(target, annotations);\n                }\n            }\n        }\n    }", "_addOrOverrideAnnotations": "    private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns)\n    {\n        if (anns != null) {\n            List<Annotation[]> bundles = null;\n            for (Annotation ann : anns) { // first: direct annotations\n                if (_isAnnotationBundle(ann)) {\n                    if (bundles == null) {\n                        bundles = new LinkedList<Annotation[]>();\n                    }\n                    bundles.add(ann.annotationType().getDeclaredAnnotations());\n                } else { // note: no filtering by jackson-annotations\n                    target.addOrOverride(ann);\n                }\n            }\n            if (bundles != null) { // and then bundles, if any: important for precedence\n                for (Annotation[] annotations : bundles) {\n                    _addOrOverrideAnnotations(target, annotations);\n                }\n            }\n        }\n    }", "_addMixOvers": "    protected void _addMixOvers(Method mixin, AnnotatedMethod target,\n            boolean addParamAnnotations)\n    {\n        _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations());\n        if (addParamAnnotations) {\n            Annotation[][] pa = mixin.getParameterAnnotations();\n            for (int i = 0, len = pa.length; i < len; ++i) {\n                for (Annotation a : pa[i]) {\n                    target.addOrOverrideParam(i, a);\n                }\n            }\n        }\n    }", "_addMixUnders": "    protected void _addMixUnders(Method src, AnnotatedMethod target) {\n        _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n    }"}