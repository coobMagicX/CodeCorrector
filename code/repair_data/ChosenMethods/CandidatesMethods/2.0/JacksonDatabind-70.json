{"withCaseInsensitivity": "    public BeanPropertyMap withCaseInsensitivity(boolean state) {\n        if (_caseInsensitive == state) {\n            return this;\n        }\n        return new BeanPropertyMap(this, state);\n    }", "init": "    protected void init(Collection<SettableBeanProperty> props)\n    {\n        _size = props.size();\n\n        // First: calculate size of primary hash area\n        final int hashSize = findSize(_size);\n        _hashMask = hashSize-1;\n\n        // and allocate enough to contain primary/secondary, expand for spillovers as need be\n        int alloc = (hashSize + (hashSize>>1)) * 2;\n        Object[] hashed = new Object[alloc];\n        int spillCount = 0;\n\n        for (SettableBeanProperty prop : props) {\n            // Due to removal, renaming, theoretically possible we'll have \"holes\" so:\n            if (prop == null) {\n                continue;\n            }\n            \n            String key = getPropertyName(prop);\n            int slot = _hashCode(key);\n            int ix = (slot<<1);\n\n            // primary slot not free?\n            if (hashed[ix] != null) {\n                // secondary?\n                ix = (hashSize + (slot >> 1)) << 1;\n                if (hashed[ix] != null) {\n                    // ok, spill over.\n                    ix = ((hashSize + (hashSize >> 1) ) << 1) + spillCount;\n                    spillCount += 2;\n                    if (ix >= hashed.length) {\n                        hashed = Arrays.copyOf(hashed, hashed.length + 4);\n                    }\n                }\n            }\n//System.err.println(\" add '\"+key+\" at #\"+(ix>>1)+\"/\"+size+\" (hashed at \"+slot+\")\");             \n            hashed[ix] = key;\n            hashed[ix+1] = prop;\n        }\n/*\nfor (int i = 0; i < hashed.length; i += 2) {\nSystem.err.printf(\"#%02d: %s\\n\", i>>1, (hashed[i] == null) ? \"-\" : hashed[i]);\n}\n*/\n        _hashArea = hashed;\n        _spillCount = spillCount;\n    }", "findSize": "    private final static int findSize(int size)\n    {\n        if (size <= 5) {\n            return 8;\n        }\n        if (size <= 12) {\n            return 16;\n        }\n        int needed = size + (size >> 2); // at most 80% full\n        int result = 32;\n        while (result < needed) {\n            result += result;\n        }\n        return result;\n    }", "construct": "    public static BeanPropertyMap construct(Collection<SettableBeanProperty> props, boolean caseInsensitive) {\n        return new BeanPropertyMap(caseInsensitive, props);\n    }", "withProperty": "    public BeanPropertyMap withProperty(SettableBeanProperty newProp)\n    {\n        // First: may be able to just replace?\n        String key = getPropertyName(newProp);\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if ((prop != null) && prop.getName().equals(key)) {\n                _hashArea[i] = newProp;\n                _propsInOrder[_findFromOrdered(prop)] = newProp;\n                return this;\n            }\n        }\n        // If not, append\n        final int slot = _hashCode(key);\n        final int hashSize = _hashMask+1;\n        int ix = (slot<<1);\n        \n        // primary slot not free?\n        if (_hashArea[ix] != null) {\n            // secondary?\n            ix = (hashSize + (slot >> 1)) << 1;\n            if (_hashArea[ix] != null) {\n                // ok, spill over.\n                ix = ((hashSize + (hashSize >> 1) ) << 1) + _spillCount;\n                _spillCount += 2;\n                if (ix >= _hashArea.length) {\n                    _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);\n                    // Uncomment for debugging only\n                    /*\nfor (int i = 0; i < _hashArea.length; i += 2) {\n    if (_hashArea[i] != null) {\n        System.err.println(\"Property #\"+(i/2)+\" '\"+_hashArea[i]+\"'...\");\n    }\n}\nSystem.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n*/\n                \n                }\n            }\n        }\n        _hashArea[ix] = key;\n        _hashArea[ix+1] = newProp;\n\n        int last = _propsInOrder.length;\n        _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);\n        _propsInOrder[last] = newProp;\n\n        // should we just create a new one? Or is resetting ok?\n        \n        return this;\n    }", "assignIndexes": "    public BeanPropertyMap assignIndexes()\n    {\n        // order is arbitrary, but stable:\n        int index = 0;\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop != null) {\n                prop.assignIndex(index++);\n            }\n        }\n        return this;\n    }", "withoutProperties": "    public BeanPropertyMap withoutProperties(Collection<String> toExclude)\n    {\n        if (toExclude.isEmpty()) {\n            return this;\n        }\n        final int len = _propsInOrder.length;\n        ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(len);\n\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _propsInOrder[i];\n            // 01-May-2015, tatu: Not 100% sure if existing `null`s should be retained;\n            //   or, if entries to ignore should be retained as nulls. For now just\n            //   prune them out\n            if (prop != null) { // may contain holes, too, check.\n                if (!toExclude.contains(prop.getName())) {\n                    newProps.add(prop);\n                }\n            }\n        }\n        // should we try to re-index? Apparently no need\n        return new BeanPropertyMap(_caseInsensitive, newProps);\n    }", "replace": "    public void replace(SettableBeanProperty newProp)\n    {\n        String key = getPropertyName(newProp);\n        int ix = _findIndexInHash(key);\n        \n        if (ix >= 0) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[ix];\n            _hashArea[ix] = newProp;\n            // also, replace in in-order\n            _propsInOrder[_findFromOrdered(prop)] = newProp;\n            return;\n        }\n        \n        throw new NoSuchElementException(\"No entry '\"+key+\"' found, can't replace\");\n    }", "properties": "    private List<SettableBeanProperty> properties() {\n        ArrayList<SettableBeanProperty> p = new ArrayList<SettableBeanProperty>(_size);\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop != null) {\n                p.add(prop);\n            }\n        }\n        return p;\n    }", "iterator": "    public Iterator<SettableBeanProperty> iterator() {\n        return properties().iterator();\n    }", "getPropertiesInInsertionOrder": "    public SettableBeanProperty[] getPropertiesInInsertionOrder() {\n        return _propsInOrder;\n    }", "getPropertyName": "    protected final String getPropertyName(SettableBeanProperty prop) {\n        return _caseInsensitive ? prop.getName().toLowerCase() : prop.getName();\n    }", "find": "    public SettableBeanProperty find(String key)\n    {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Can not pass null property name\");\n        }\n        if (_caseInsensitive) {\n            key = key.toLowerCase();\n        }\n            \n        // inlined `_hashCode(key)`\n        int slot = key.hashCode() & _hashMask;\n//        int h = key.hashCode();\n//        int slot = (h + (h >> 13)) & _hashMask;\n\n        int ix = (slot<<1);\n        Object match = _hashArea[ix];\n        if ((match == key) || key.equals(match)) {\n            return (SettableBeanProperty) _hashArea[ix+1];\n        }\n        return _find2(key, slot, match);\n    }", "_find2": "    private final SettableBeanProperty _find2(String key, int slot, Object match)\n    {\n        if (match == null) {\n            return null;\n        }\n        // no? secondary?\n        int hashSize = _hashMask+1;\n        int ix = hashSize + (slot>>1) << 1;\n        match = _hashArea[ix];\n        if (key.equals(match)) {\n            return (SettableBeanProperty) _hashArea[ix+1];\n        }\n        if (match != null) { // _findFromSpill(...)\n            int i = (hashSize + (hashSize>>1)) << 1;\n            for (int end = i + _spillCount; i < end; i += 2) {\n                match = _hashArea[i];\n                if ((match == key) || key.equals(match)) {\n                    return (SettableBeanProperty) _hashArea[i+1];\n                }\n            }\n        }\n        return null;\n    }", "size": "    public int size() { return _size; }", "remove": "    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(prop.getName());\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }", "findDeserializeAndSet": "    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n            Object bean, String key) throws IOException\n    {\n        final SettableBeanProperty prop = find(key);\n        if (prop == null) {\n            return false;\n        }\n        try {\n            prop.deserializeAndSet(p, ctxt, bean);\n        } catch (Exception e) {\n            wrapAndThrow(e, bean, key, ctxt);\n        }\n        return true;\n    }", "toString": "    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Properties=[\");\n        int count = 0;\n\n        Iterator<SettableBeanProperty> it = iterator();\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            if (count++ > 0) {\n                sb.append(\", \");\n            }\n            sb.append(prop.getName());\n            sb.append('(');\n            sb.append(prop.getType());\n            sb.append(')');\n        }\n        sb.append(']');\n        return sb.toString();\n    }", "_rename": "    protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf)\n    {\n        if (prop == null) {\n            return prop;\n        }\n        String newName = xf.transform(prop.getName());\n        prop = prop.withSimpleName(newName);\n        JsonDeserializer<?> deser = prop.getValueDeserializer();\n        if (deser != null) {\n            @SuppressWarnings(\"unchecked\")\n            JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>)\n                deser.unwrappingDeserializer(xf);\n            if (newDeser != deser) {\n                prop = prop.withValueDeserializer(newDeser);\n            }\n        }\n        return prop;\n    }", "_findIndexInHash": "    private final int _findIndexInHash(String key)\n    {\n        final int slot = _hashCode(key);\n        int ix = (slot<<1);\n        \n        // primary match?\n        if (key.equals(_hashArea[ix])) {\n            return ix+1;\n        }\n        // no? secondary?\n        int hashSize = _hashMask+1;\n        ix = hashSize + (slot>>1) << 1;\n        if (key.equals(_hashArea[ix])) {\n            return ix+1;\n        }\n        // perhaps spill then\n        int i = (hashSize + (hashSize>>1)) << 1;\n        for (int end = i + _spillCount; i < end; i += 2) {\n            if (key.equals(_hashArea[i])) {\n                return i+1;\n            }\n        }\n        return -1;\n    }", "_findFromOrdered": "    private final int _findFromOrdered(SettableBeanProperty prop) {\n        for (int i = 0, end = _propsInOrder.length; i < end; ++i) {\n            if (_propsInOrder[i] == prop) {\n                return i;\n            }\n        }\n        throw new IllegalStateException(\"Illegal state: property '\"+prop.getName()+\"' missing from _propsInOrder\");\n    }"}