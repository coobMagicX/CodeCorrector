{"parse": "    private Document parse() {\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"<!--\")) {\n                parseComment();\n            } else if (tq.matches(\"<![CDATA[\")) {\n                parseCdata();\n            } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) {\n                parseXmlDecl();\n            } else if (tq.matches(\"</\")) {\n                parseEndTag();\n            } else if (tq.matches(\"<\")) {\n                parseStartTag();\n            } else {\n                parseTextNode();\n            }\n        }\n        return doc.normalise();\n    }", "parseEndTag": "    private void parseEndTag() {\n        tq.consume(\"</\");\n        String tagName = tq.consumeWord();\n        tq.chompTo(\">\");\n\n        if (tagName.length() != 0) {\n            Tag tag = Tag.valueOf(tagName);\n            popStackToClose(tag);\n        }\n    }", "parseStartTag": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }", "parseAttribute": "    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n        String key = tq.consumeAttributeKey();\n        String value = \"\";\n        tq.consumeWhitespace();\n        if (tq.matchChomp(\"=\")) {\n            tq.consumeWhitespace();\n\n            if (tq.matchChomp(SQ)) {\n                value = tq.chompTo(SQ);\n            } else if (tq.matchChomp(DQ)) {\n                value = tq.chompTo(DQ);\n            } else {\n                StringBuilder valueAccum = new StringBuilder();\n                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                    valueAccum.append(tq.consume());\n                }\n                value = valueAccum.toString();\n            }\n            tq.consumeWhitespace();\n        }\n        if (key.length() != 0)\n            return Attribute.createFromEncoded(key, value);\n        else {\n            tq.consume(); // unknown char, keep popping so not get stuck\n            return null;\n        }\n    }", "parseTextNode": "    private void parseTextNode() {\n        String text = tq.consumeTo(\"<\");\n        TextNode textNode = TextNode.createFromEncoded(text, baseUri);\n        last().appendChild(textNode);\n    }", "parseCdata": "    private void parseCdata() {\n        tq.consume(\"<![CDATA[\");\n        String rawText = tq.chompTo(\"]]>\");\n        TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape\n        last().appendChild(textNode);\n    }", "addChildToParent": "    private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor) {\n            // create implicit parent around this child\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            // special case: make sure there's a head before putting in body\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            // recurse to ensure somewhere to put parent\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }", "last": "    private Element last() {\n        return stack.getLast();\n    }"}