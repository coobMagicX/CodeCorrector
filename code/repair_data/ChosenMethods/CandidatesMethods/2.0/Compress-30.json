{"read": "    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException {\n        if (offs < 0) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n        }\n        if (len < 0) {\n            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n        }\n        if (offs + len > dest.length) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                + len + \") > dest.length(\" + dest.length + \").\");\n        }\n        if (this.in == null) {\n            throw new IOException(\"stream closed\");\n        }\n\n        final int hi = offs + len;\n        int destOffs = offs;\n        int b;\n        while (destOffs < hi && ((b = read0()) >= 0)) {\n            dest[destOffs++] = (byte) b;\n            count(1);\n        }\n\n        int c = (destOffs == offs) ? -1 : (destOffs - offs);\n        return c;\n    }", "read0": "    private int read0() throws IOException {\n        switch (currentState) {\n        case EOF:\n            return -1;\n\n        case START_BLOCK_STATE:\n            return setupBlock();\n\n        case RAND_PART_A_STATE:\n            throw new IllegalStateException();\n\n        case RAND_PART_B_STATE:\n            return setupRandPartB();\n\n        case RAND_PART_C_STATE:\n            return setupRandPartC();\n\n        case NO_RAND_PART_A_STATE:\n            throw new IllegalStateException();\n\n        case NO_RAND_PART_B_STATE:\n            return setupNoRandPartB();\n\n        case NO_RAND_PART_C_STATE:\n            return setupNoRandPartC();\n\n        default:\n            throw new IllegalStateException();\n        }\n    }", "init": "    private boolean init(boolean isFirstStream) throws IOException {\n        if (null == in) {\n            throw new IOException(\"No InputStream\");\n        }\n\n        int magic0 = this.in.read();\n        if (magic0 == -1 && !isFirstStream) {\n            return false;\n        }\n        int magic1 = this.in.read();\n        int magic2 = this.in.read();\n\n        if (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\n            throw new IOException(isFirstStream\n                    ? \"Stream is not in the BZip2 format\"\n                    : \"Garbage after a valid BZip2 stream\");\n        }\n\n        int blockSize = this.in.read();\n        if ((blockSize < '1') || (blockSize > '9')) {\n            throw new IOException(\"BZip2 block size is invalid\");\n        }\n\n        this.blockSize100k = blockSize - '0';\n\n        this.bsLive = 0;\n        this.computedCombinedCRC = 0;\n\n        return true;\n    }", "initBlock": "    private void initBlock() throws IOException {\n        char magic0;\n        char magic1;\n        char magic2;\n        char magic3;\n        char magic4;\n        char magic5;\n\n        while (true) {\n            // Get the block magic bytes.\n            magic0 = bsGetUByte();\n            magic1 = bsGetUByte();\n            magic2 = bsGetUByte();\n            magic3 = bsGetUByte();\n            magic4 = bsGetUByte();\n            magic5 = bsGetUByte();\n\n            // If isn't end of stream magic, break out of the loop.\n            if (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\n                    || magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) {\n                break;\n            }\n\n            // End of stream was reached. Check the combined CRC and\n            // advance to the next .bz2 stream if decoding concatenated\n            // streams.\n            if (complete()) {\n                return;\n            }\n        }\n\n        if (magic0 != 0x31 || // '1'\n            magic1 != 0x41 || // ')'\n            magic2 != 0x59 || // 'Y'\n            magic3 != 0x26 || // '&'\n            magic4 != 0x53 || // 'S'\n            magic5 != 0x59 // 'Y'\n            ) {\n            this.currentState = EOF;\n            throw new IOException(\"bad block header\");\n        } else {\n            this.storedBlockCRC = bsGetInt();\n            this.blockRandomised = bsR(1) == 1;\n\n            /**\n             * Allocate data here instead in constructor, so we do not allocate\n             * it if the input file is empty.\n             */\n            if (this.data == null) {\n                this.data = new Data(this.blockSize100k);\n            }\n\n            // currBlockNo++;\n            getAndMoveToFrontDecode();\n\n            this.crc.initialiseCRC();\n            this.currentState = START_BLOCK_STATE;\n        }\n    }", "endBlock": "    private void endBlock() throws IOException {\n        this.computedBlockCRC = this.crc.getFinalCRC();\n\n        // A bad CRC is considered a fatal error.\n        if (this.storedBlockCRC != this.computedBlockCRC) {\n            // make next blocks readable without error\n            // (repair feature, not yet documented, not tested)\n            this.computedCombinedCRC = (this.storedCombinedCRC << 1)\n                | (this.storedCombinedCRC >>> 31);\n            this.computedCombinedCRC ^= this.storedBlockCRC;\n\n            throw new IOException(\"BZip2 CRC error\");\n        }\n\n        this.computedCombinedCRC = (this.computedCombinedCRC << 1)\n            | (this.computedCombinedCRC >>> 31);\n        this.computedCombinedCRC ^= this.computedBlockCRC;\n    }", "complete": "    private boolean complete() throws IOException {\n        this.storedCombinedCRC = bsGetInt();\n        this.currentState = EOF;\n        this.data = null;\n\n        if (this.storedCombinedCRC != this.computedCombinedCRC) {\n            throw new IOException(\"BZip2 CRC error\");\n        }\n\n        // Look for the next .bz2 stream if decompressing\n        // concatenated files.\n        return !decompressConcatenated || !init(false);\n    }", "close": "    public void close() throws IOException {\n        InputStream inShadow = this.in;\n        if (inShadow != null) {\n            try {\n                if (inShadow != System.in) {\n                    inShadow.close();\n                }\n            } finally {\n                this.data = null;\n                this.in = null;\n            }\n        }\n    }", "bsR": "    private int bsR(final int n) throws IOException {\n        int bsLiveShadow = this.bsLive;\n        int bsBuffShadow = this.bsBuff;\n\n        if (bsLiveShadow < n) {\n            final InputStream inShadow = this.in;\n            do {\n                int thech = inShadow.read();\n\n                if (thech < 0) {\n                    throw new IOException(\"unexpected end of stream\");\n                }\n\n                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                bsLiveShadow += 8;\n            } while (bsLiveShadow < n);\n\n            this.bsBuff = bsBuffShadow;\n        }\n\n        this.bsLive = bsLiveShadow - n;\n        return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n    }", "bsGetBit": "    private boolean bsGetBit() throws IOException {\n        int bsLiveShadow = this.bsLive;\n        int bsBuffShadow = this.bsBuff;\n\n        if (bsLiveShadow < 1) {\n            int thech = this.in.read();\n\n            if (thech < 0) {\n                throw new IOException(\"unexpected end of stream\");\n            }\n\n            bsBuffShadow = (bsBuffShadow << 8) | thech;\n            bsLiveShadow += 8;\n            this.bsBuff = bsBuffShadow;\n        }\n\n        this.bsLive = bsLiveShadow - 1;\n        return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n    }", "bsGetUByte": "    private char bsGetUByte() throws IOException {\n        return (char) bsR(8);\n    }", "bsGetInt": "    private int bsGetInt() throws IOException {\n        return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n    }", "hbCreateDecodeTables": "    private static void hbCreateDecodeTables(final int[] limit,\n                                             final int[] base, final int[] perm, final char[] length,\n                                             final int minLen, final int maxLen, final int alphaSize) {\n        for (int i = minLen, pp = 0; i <= maxLen; i++) {\n            for (int j = 0; j < alphaSize; j++) {\n                if (length[j] == i) {\n                    perm[pp++] = j;\n                }\n            }\n        }\n\n        for (int i = MAX_CODE_LEN; --i > 0;) {\n            base[i] = 0;\n            limit[i] = 0;\n        }\n\n        for (int i = 0; i < alphaSize; i++) {\n            base[length[i] + 1]++;\n        }\n\n        for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\n            b += base[i];\n            base[i] = b;\n        }\n\n        for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\n            final int nb = base[i + 1];\n            vec += nb - b;\n            b = nb;\n            limit[i] = vec - 1;\n            vec <<= 1;\n        }\n\n        for (int i = minLen + 1; i <= maxLen; i++) {\n            base[i] = ((limit[i - 1] + 1) << 1) - base[i];\n        }\n    }", "recvDecodingTables": "    private void recvDecodingTables() throws IOException {\n        final Data dataShadow = this.data;\n        final boolean[] inUse = dataShadow.inUse;\n        final byte[] pos = dataShadow.recvDecodingTables_pos;\n        final byte[] selector = dataShadow.selector;\n        final byte[] selectorMtf = dataShadow.selectorMtf;\n\n        int inUse16 = 0;\n\n        /* Receive the mapping table */\n        for (int i = 0; i < 16; i++) {\n            if (bsGetBit()) {\n                inUse16 |= 1 << i;\n            }\n        }\n\n        for (int i = 256; --i >= 0;) {\n            inUse[i] = false;\n        }\n\n        for (int i = 0; i < 16; i++) {\n            if ((inUse16 & (1 << i)) != 0) {\n                final int i16 = i << 4;\n                for (int j = 0; j < 16; j++) {\n                    if (bsGetBit()) {\n                        inUse[i16 + j] = true;\n                    }\n                }\n            }\n        }\n\n        makeMaps();\n        final int alphaSize = this.nInUse + 2;\n\n        /* Now the selectors */\n        final int nGroups = bsR(3);\n        final int nSelectors = bsR(15);\n\n        for (int i = 0; i < nSelectors; i++) {\n            int j = 0;\n            while (bsGetBit()) {\n                j++;\n            }\n            selectorMtf[i] = (byte) j;\n        }\n\n        /* Undo the MTF values for the selectors. */\n        for (int v = nGroups; --v >= 0;) {\n            pos[v] = (byte) v;\n        }\n\n        for (int i = 0; i < nSelectors; i++) {\n            int v = selectorMtf[i] & 0xff;\n            final byte tmp = pos[v];\n            while (v > 0) {\n                // nearly all times v is zero, 4 in most other cases\n                pos[v] = pos[v - 1];\n                v--;\n            }\n            pos[0] = tmp;\n            selector[i] = tmp;\n        }\n\n        final char[][] len = dataShadow.temp_charArray2d;\n\n        /* Now the coding tables */\n        for (int t = 0; t < nGroups; t++) {\n            int curr = bsR(5);\n            final char[] len_t = len[t];\n            for (int i = 0; i < alphaSize; i++) {\n                while (bsGetBit()) {\n                    curr += bsGetBit() ? -1 : 1;\n                }\n                len_t[i] = (char) curr;\n            }\n        }\n\n        // finally create the Huffman tables\n        createHuffmanDecodingTables(alphaSize, nGroups);\n    }", "createHuffmanDecodingTables": "    private void createHuffmanDecodingTables(final int alphaSize,\n                                             final int nGroups) {\n        final Data dataShadow = this.data;\n        final char[][] len = dataShadow.temp_charArray2d;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n\n        for (int t = 0; t < nGroups; t++) {\n            int minLen = 32;\n            int maxLen = 0;\n            final char[] len_t = len[t];\n            for (int i = alphaSize; --i >= 0;) {\n                final char lent = len_t[i];\n                if (lent > maxLen) {\n                    maxLen = lent;\n                }\n                if (lent < minLen) {\n                    minLen = lent;\n                }\n            }\n            hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\n                                 maxLen, alphaSize);\n            minLens[t] = minLen;\n        }\n    }", "getAndMoveToFrontDecode": "    private void getAndMoveToFrontDecode() throws IOException {\n        this.origPtr = bsR(24);\n        recvDecodingTables();\n\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final byte[] ll8 = dataShadow.ll8;\n        final int[] unzftab = dataShadow.unzftab;\n        final byte[] selector = dataShadow.selector;\n        final byte[] seqToUnseq = dataShadow.seqToUnseq;\n        final char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\n        final int[] minLens = dataShadow.minLens;\n        final int[][] limit = dataShadow.limit;\n        final int[][] base = dataShadow.base;\n        final int[][] perm = dataShadow.perm;\n        final int limitLast = this.blockSize100k * 100000;\n\n        /*\n         * Setting up the unzftab entries here is not strictly necessary, but it\n         * does save having to do it later in a separate pass, and so saves a\n         * block's worth of cache misses.\n         */\n        for (int i = 256; --i >= 0;) {\n            yy[i] = (char) i;\n            unzftab[i] = 0;\n        }\n\n        int groupNo = 0;\n        int groupPos = G_SIZE - 1;\n        final int eob = this.nInUse + 1;\n        int nextSym = getAndMoveToFrontDecode0(0);\n        int bsBuffShadow = this.bsBuff;\n        int bsLiveShadow = this.bsLive;\n        int lastShadow = -1;\n        int zt = selector[groupNo] & 0xff;\n        int[] base_zt = base[zt];\n        int[] limit_zt = limit[zt];\n        int[] perm_zt = perm[zt];\n        int minLens_zt = minLens[zt];\n\n        while (nextSym != eob) {\n            if ((nextSym == RUNA) || (nextSym == RUNB)) {\n                int s = -1;\n\n                for (int n = 1; true; n <<= 1) {\n                    if (nextSym == RUNA) {\n                        s += n;\n                    } else if (nextSym == RUNB) {\n                        s += n << 1;\n                    } else {\n                        break;\n                    }\n\n                    if (groupPos == 0) {\n                        groupPos = G_SIZE - 1;\n                        zt = selector[++groupNo] & 0xff;\n                        base_zt = base[zt];\n                        limit_zt = limit[zt];\n                        perm_zt = perm[zt];\n                        minLens_zt = minLens[zt];\n                    } else {\n                        groupPos--;\n                    }\n\n                    int zn = minLens_zt;\n\n                    // Inlined:\n                    // int zvec = bsR(zn);\n                    while (bsLiveShadow < zn) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                        & ((1 << zn) - 1);\n                    bsLiveShadow -= zn;\n\n                    while (zvec > limit_zt[zn]) {\n                        zn++;\n                        while (bsLiveShadow < 1) {\n                            final int thech = inShadow.read();\n                            if (thech >= 0) {\n                                bsBuffShadow = (bsBuffShadow << 8) | thech;\n                                bsLiveShadow += 8;\n                                continue;\n                            } else {\n                                throw new IOException(\n                                                      \"unexpected end of stream\");\n                            }\n                        }\n                        bsLiveShadow--;\n                        zvec = (zvec << 1)\n                            | ((bsBuffShadow >> bsLiveShadow) & 1);\n                    }\n                    nextSym = perm_zt[zvec - base_zt[zn]];\n                }\n\n                final byte ch = seqToUnseq[yy[0]];\n                unzftab[ch & 0xff] += s + 1;\n\n                while (s-- >= 0) {\n                    ll8[++lastShadow] = ch;\n                }\n\n                if (lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n            } else {\n                if (++lastShadow >= limitLast) {\n                    throw new IOException(\"block overrun\");\n                }\n\n                final char tmp = yy[nextSym - 1];\n                unzftab[seqToUnseq[tmp] & 0xff]++;\n                ll8[lastShadow] = seqToUnseq[tmp];\n\n                /*\n                 * This loop is hammered during decompression, hence avoid\n                 * native method call overhead of System.arraycopy for very\n                 * small ranges to copy.\n                 */\n                if (nextSym <= 16) {\n                    for (int j = nextSym - 1; j > 0;) {\n                        yy[j] = yy[--j];\n                    }\n                } else {\n                    System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n                }\n\n                yy[0] = tmp;\n\n                if (groupPos == 0) {\n                    groupPos = G_SIZE - 1;\n                    zt = selector[++groupNo] & 0xff;\n                    base_zt = base[zt];\n                    limit_zt = limit[zt];\n                    perm_zt = perm[zt];\n                    minLens_zt = minLens[zt];\n                } else {\n                    groupPos--;\n                }\n\n                int zn = minLens_zt;\n\n                // Inlined:\n                // int zvec = bsR(zn);\n                while (bsLiveShadow < zn) {\n                    final int thech = inShadow.read();\n                    if (thech >= 0) {\n                        bsBuffShadow = (bsBuffShadow << 8) | thech;\n                        bsLiveShadow += 8;\n                        continue;\n                    } else {\n                        throw new IOException(\"unexpected end of stream\");\n                    }\n                }\n                int zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n                    & ((1 << zn) - 1);\n                bsLiveShadow -= zn;\n\n                while (zvec > limit_zt[zn]) {\n                    zn++;\n                    while (bsLiveShadow < 1) {\n                        final int thech = inShadow.read();\n                        if (thech >= 0) {\n                            bsBuffShadow = (bsBuffShadow << 8) | thech;\n                            bsLiveShadow += 8;\n                            continue;\n                        } else {\n                            throw new IOException(\"unexpected end of stream\");\n                        }\n                    }\n                    bsLiveShadow--;\n                    zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n                }\n                nextSym = perm_zt[zvec - base_zt[zn]];\n            }\n        }\n\n        this.last = lastShadow;\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n    }", "getAndMoveToFrontDecode0": "    private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\n        final InputStream inShadow = this.in;\n        final Data dataShadow = this.data;\n        final int zt = dataShadow.selector[groupNo] & 0xff;\n        final int[] limit_zt = dataShadow.limit[zt];\n        int zn = dataShadow.minLens[zt];\n        int zvec = bsR(zn);\n        int bsLiveShadow = this.bsLive;\n        int bsBuffShadow = this.bsBuff;\n\n        while (zvec > limit_zt[zn]) {\n            zn++;\n            while (bsLiveShadow < 1) {\n                final int thech = inShadow.read();\n\n                if (thech >= 0) {\n                    bsBuffShadow = (bsBuffShadow << 8) | thech;\n                    bsLiveShadow += 8;\n                    continue;\n                } else {\n                    throw new IOException(\"unexpected end of stream\");\n                }\n            }\n            bsLiveShadow--;\n            zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n        }\n\n        this.bsLive = bsLiveShadow;\n        this.bsBuff = bsBuffShadow;\n\n        return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n    }", "setupBlock": "    private int setupBlock() throws IOException {\n        if (currentState == EOF || this.data == null) {\n            return -1;\n        }\n\n        final int[] cftab = this.data.cftab;\n        final int[] tt = this.data.initTT(this.last + 1);\n        final byte[] ll8 = this.data.ll8;\n        cftab[0] = 0;\n        System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n\n        for (int i = 1, c = cftab[0]; i <= 256; i++) {\n            c += cftab[i];\n            cftab[i] = c;\n        }\n\n        for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\n            tt[cftab[ll8[i] & 0xff]++] = i;\n        }\n\n        if ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\n            throw new IOException(\"stream corrupted\");\n        }\n\n        this.su_tPos = tt[this.origPtr];\n        this.su_count = 0;\n        this.su_i2 = 0;\n        this.su_ch2 = 256; /* not a char and not EOF */\n\n        if (this.blockRandomised) {\n            this.su_rNToGo = 0;\n            this.su_rTPos = 0;\n            return setupRandPartA();\n        }\n        return setupNoRandPartA();\n    }", "setupRandPartB": "    private int setupRandPartB() throws IOException {\n        if (this.su_ch2 != this.su_chPrev) {\n            this.currentState = RAND_PART_A_STATE;\n            this.su_count = 1;\n            return setupRandPartA();\n        } else if (++this.su_count >= 4) {\n            this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\n            this.su_tPos = this.data.tt[this.su_tPos];\n            if (this.su_rNToGo == 0) {\n                this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;\n                if (++this.su_rTPos == 512) {\n                    this.su_rTPos = 0;\n                }\n            } else {\n                this.su_rNToGo--;\n            }\n            this.su_j2 = 0;\n            this.currentState = RAND_PART_C_STATE;\n            if (this.su_rNToGo == 1) {\n                this.su_z ^= 1;\n            }\n            return setupRandPartC();\n        } else {\n            this.currentState = RAND_PART_A_STATE;\n            return setupRandPartA();\n        }\n    }", "setupRandPartC": "    private int setupRandPartC() throws IOException {\n        if (this.su_j2 < this.su_z) {\n            this.crc.updateCRC(this.su_ch2);\n            this.su_j2++;\n            return this.su_ch2;\n        } else {\n            this.currentState = RAND_PART_A_STATE;\n            this.su_i2++;\n            this.su_count = 0;\n            return setupRandPartA();\n        }\n    }", "setupNoRandPartB": "    private int setupNoRandPartB() throws IOException {\n        if (this.su_ch2 != this.su_chPrev) {\n            this.su_count = 1;\n            return setupNoRandPartA();\n        } else if (++this.su_count >= 4) {\n            this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\n            this.su_tPos = this.data.tt[this.su_tPos];\n            this.su_j2 = 0;\n            return setupNoRandPartC();\n        } else {\n            return setupNoRandPartA();\n        }\n    }", "setupNoRandPartC": "    private int setupNoRandPartC() throws IOException {\n        if (this.su_j2 < this.su_z) {\n            int su_ch2Shadow = this.su_ch2;\n            this.crc.updateCRC(su_ch2Shadow);\n            this.su_j2++;\n            this.currentState = NO_RAND_PART_C_STATE;\n            return su_ch2Shadow;\n        } else {\n            this.su_i2++;\n            this.su_count = 0;\n            return setupNoRandPartA();\n        }\n    }", "initTT": "        int[] initTT(int length) {\n            int[] ttShadow = this.tt;\n\n            // tt.length should always be >= length, but theoretically\n            // it can happen, if the compressor mixed small and large\n            // blocks. Normally only the last block will be smaller\n            // than others.\n            if ((ttShadow == null) || (ttShadow.length < length)) {\n                this.tt = ttShadow = new int[length];\n            }\n\n            return ttShadow;\n        }", "matches": "    public static boolean matches(byte[] signature, int length) {\n\n        if (length < 3) {\n            return false;\n        }\n\n        if (signature[0] != 'B') {\n            return false;\n        }\n\n        if (signature[1] != 'Z') {\n            return false;\n        }\n\n        if (signature[2] != 'h') {\n            return false;\n        }\n\n        return true;\n    }"}