{"parse": "    Document parse(String input, String baseUri, ParseErrorList errors) {\n        state = HtmlTreeBuilderState.Initial;\n        return super.parse(input, baseUri, errors);\n    }", "process": "    boolean process(Token token, HtmlTreeBuilderState state) {\n        currentToken = token;\n        return state.process(token, this);\n    }", "transition": "    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }", "state": "    HtmlTreeBuilderState state() {\n        return state;\n    }", "markInsertionMode": "    void markInsertionMode() {\n        originalState = state;\n    }", "getBaseUri": "    String getBaseUri() {\n        return baseUri;\n    }", "maybeSetBaseUri": "    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }", "error": "    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }", "insert": "    void insert(Token.Character characterToken) {\n        Node node;\n        // characters in script and style go in as datanodes, not text nodes\n        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n            node = new DataNode(characterToken.getData(), baseUri);\n        else\n            node = new TextNode(characterToken.getData(), baseUri);\n        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n    }", "insertEmpty": "    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n        if (startTag.isSelfClosing()) {\n            if (tag.isKnownTag()) {\n                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n            } else {\n                // unknown tag, remember this is self closing for output\n                tag.setSelfClosing();\n                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n            }\n        }\n        return el;\n    }", "insertForm": "    FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n        Tag tag = Tag.valueOf(startTag.name());\n        FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n        setFormElement(el);\n        insertNode(el);\n        if (onStack)\n            stack.add(el);\n        return el;\n    }", "insertNode": "    private void insertNode(Node node) {\n        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n        if (stack.size() == 0)\n            doc.appendChild(node);\n        else if (isFosterInserts())\n            insertInFosterParent(node);\n        else\n            currentElement().appendChild(node);\n\n        // connect form controls to their form element\n        if (node instanceof Element && ((Element) node).tag().isFormListed()) {\n            if (formElement != null)\n                formElement.addElement((Element) node);\n        }\n    }", "pop": "    Element pop() {\n        // todo - dev, remove validation check\n        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n            Validate.isFalse(true, \"pop td not in cell\");\n        if (stack.peekLast().nodeName().equals(\"html\"))\n            Validate.isFalse(true, \"popping html!\");\n        return stack.pollLast();\n    }", "push": "    void push(Element element) {\n        stack.add(element);\n    }", "getStack": "    DescendableLinkedList<Element> getStack() {\n        return stack;\n    }", "onStack": "    boolean onStack(Element el) {\n        return isElementInQueue(stack, el);\n    }", "isElementInQueue": "    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n        Iterator<Element> it = queue.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }", "getFromStack": "    Element getFromStack(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                return next;\n            }\n        }\n        return null;\n    }", "removeFromStack": "    boolean removeFromStack(Element el) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                return true;\n            }\n        }\n        return false;\n    }", "popStackToClose": "    void popStackToClose(String... elNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), elNames)) {\n                it.remove();\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }", "popStackToBefore": "    void popStackToBefore(String elName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next.nodeName().equals(elName)) {\n                break;\n            } else {\n                it.remove();\n            }\n        }\n    }", "clearStackToTableContext": "    void clearStackToTableContext() {\n        clearStackToContext(\"table\");\n    }", "clearStackToTableBodyContext": "    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n    }", "clearStackToTableRowContext": "    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\");\n    }", "clearStackToContext": "    private void clearStackToContext(String... nodeNames) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                break;\n            else\n                it.remove();\n        }\n    }", "aboveOnStack": "    Element aboveOnStack(Element el) {\n        assert onStack(el);\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                return it.next();\n            }\n        }\n        return null;\n    }", "insertOnStackAfter": "    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }", "replaceOnStack": "    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }", "resetInsertionMode": "    void resetInsertionMode() {\n        boolean last = false;\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element node = it.next();\n            if (!it.hasNext()) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                transition(HtmlTreeBuilderState.BeforeHead);\n                break; // frag\n            } else if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            }\n        }\n    }", "inSelectScope": "    boolean inSelectScope(String targetName) {\n        Iterator<Element> it = stack.descendingIterator();\n        while (it.hasNext()) {\n            Element el = it.next();\n            String elName = el.nodeName();\n            if (elName.equals(targetName))\n                return true;\n            if (!StringUtil.in(elName, \"optgroup\", \"option\")) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }", "setHeadElement": "    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }", "getHeadElement": "    Element getHeadElement() {\n        return headElement;\n    }", "isFosterInserts": "    boolean isFosterInserts() {\n        return fosterInserts;\n    }", "setFosterInserts": "    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }", "getFormElement": "    FormElement getFormElement() {\n        return formElement;\n    }", "setFormElement": "    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }", "generateImpliedEndTags": "    void generateImpliedEndTags() {\n        generateImpliedEndTags(null);\n    }", "pushActiveFormattingElements": "    void pushActiveFormattingElements(Element in) {\n        int numSeen = 0;\n        Iterator<Element> iter = formattingElements.descendingIterator();\n        while (iter.hasNext()) {\n            Element el =  iter.next();\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                iter.remove();\n                break;\n            }\n        }\n        formattingElements.add(in);\n    }", "isSameFormattingElement": "    private boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.nodeName().equals(b.nodeName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }", "reconstructFormattingElements": "    void reconstructFormattingElements() {\n        int size = formattingElements.size();\n        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n            return;\n\n        Element entry = formattingElements.getLast();\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == 0) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n            // newEl.namespace(entry.namespace()); // todo: namespaces\n            newEl.attributes().addAll(entry.attributes());\n\n            // 10. replace entry with new entry\n            formattingElements.add(pos, newEl);\n            formattingElements.remove(pos + 1);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }", "clearFormattingElementsToLastMarker": "    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = formattingElements.peekLast();\n            formattingElements.removeLast();\n            if (el == null)\n                break;\n        }\n    }", "removeFromActiveFormattingElements": "    void removeFromActiveFormattingElements(Element el) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == el) {\n                it.remove();\n                break;\n            }\n        }\n    }", "isInActiveFormattingElements": "    boolean isInActiveFormattingElements(Element el) {\n        return isElementInQueue(formattingElements, el);\n    }", "getActiveFormattingElement": "    Element getActiveFormattingElement(String nodeName) {\n        Iterator<Element> it = formattingElements.descendingIterator();\n        while (it.hasNext()) {\n            Element next = it.next();\n            if (next == null) // scope marker\n                break;\n            else if (next.nodeName().equals(nodeName))\n                return next;\n        }\n        return null;\n    }", "replaceActiveFormattingElement": "    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }", "insertMarkerToFormattingElements": "    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }", "insertInFosterParent": "    void insertInFosterParent(Node in) {\n        Element fosterParent = null;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }"}