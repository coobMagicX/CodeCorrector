{"unwrappingDeserializer": "    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n    {\n        /* main thing really is to just enforce ignoring of unknown\n         * properties; since there may be multiple unwrapped values\n         * and properties for all may be interleaved...\n         */\n        return new BuilderBasedDeserializer(this, unwrapper);\n    }", "withObjectIdReader": "    public BeanDeserializerBase withObjectIdReader(ObjectIdReader oir) {\n        return new BuilderBasedDeserializer(this, oir);\n    }", "withIgnorableProperties": "    public BeanDeserializerBase withIgnorableProperties(Set<String> ignorableProps) {\n        return new BuilderBasedDeserializer(this, ignorableProps);\n    }", "withBeanProperties": "    public BeanDeserializerBase withBeanProperties(BeanPropertyMap props) {\n        return new BuilderBasedDeserializer(this, props);\n    }", "asArrayDeserializer": "    protected BeanDeserializerBase asArrayDeserializer() {\n        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod);\n    }", "finishBuild": "    protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n            throws IOException\n    {\n        // As per [databind#777], allow returning builder itself\n        if (null == _buildMethod) {\n            return builder;\n        }\n        try {\n            return _buildMethod.getMember().invoke(builder);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }", "deserialize": "    public Object deserialize(JsonParser p, DeserializationContext ctxt,\n    \t\tObject builder)\n        throws IOException\n    {\n        /* Important: we call separate method which does NOT call\n         * 'finishBuild()', to avoid problems with recursion\n         */\n        return finishBuild(ctxt, _deserialize(p, ctxt, builder));\n    }", "_deserialize": "    protected final Object _deserialize(JsonParser p,\n            DeserializationContext ctxt, Object builder)\n        throws IOException, JsonProcessingException\n    {\n        if (_injectables != null) {\n            injectValues(ctxt, builder);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, builder);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, builder);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, builder, view);\n            }\n        }\n        JsonToken t = p.getCurrentToken();\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                } catch (Exception e) {\n                    wrapAndThrow(e, builder, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n        return builder;\n    }", "vanillaDeserialize": "    private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException, JsonProcessingException\n    {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n            } else {\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            }\n        }\n        return bean;\n    }", "deserializeFromObject": "    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            return deserializeFromObjectUsingNonDefault(p, ctxt);\n        }\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }", "_deserializeUsingPropertyBased": "    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n            final DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n        TokenBuffer unknown = null;\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; // never gets here\n                    }\n                    //  polymorphic?\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        return handlePolymorphic(p, ctxt, bean, unknown);\n                    }\n                    if (unknown != null) { // nope, just extra unknown stuff...\n                        bean = handleUnknownProperties(ctxt, bean, unknown);\n                    }\n                    // or just clean?\n                    return _deserialize(p, ctxt, bean);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // As per [JACKSON-313], things marked as ignorable should not be\n            // passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                continue;\n            }\n            // Ok then, let's collect the whole field; name and value\n            if (unknown == null) {\n                unknown = new TokenBuffer(p, ctxt);\n            }\n            unknown.writeFieldName(propName);\n            unknown.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            bean = wrapInstantiationProblem(e, ctxt);\n        }\n        if (unknown != null) {\n            // polymorphic?\n            if (bean.getClass() != _beanType.getRawClass()) {\n                return handlePolymorphic(null, ctxt, bean, unknown);\n            }\n            // no, just some extra unknown properties\n            return handleUnknownProperties(ctxt, bean, unknown);\n        }\n        return bean;\n    }", "deserializeWithView": "    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n            Object bean, Class<?> activeView)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                if (!prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }", "deserializeWithUnwrapped": "    protected Object deserializeWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt, Object bean)\n        throws IOException, JsonProcessingException\n    {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            p.nextToken();\n            if (prop != null) { // normal case\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // how about any setter? We'll get copies but...\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            }\n        }\n        tokens.writeEndObject();\n        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        return bean;\n    }", "deserializeUsingPropertyBasedWithUnwrapped": "    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    t = p.nextToken();\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue;\n                    }\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken();\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }", "deserializeWithExternalTypeId": "    protected Object deserializeWithExternalTypeId(JsonParser p,\n    \t\tDeserializationContext ctxt, Object bean)\n        throws IOException, JsonProcessingException\n    {\n        final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n\n        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            t = p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                // [JACKSON-831]: may have property AND be used as external type id:\n                if (t.isScalarValue()) {\n                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                }\n                if (activeView != null && !prop.visibleInView(activeView)) {\n                    p.skipChildren();\n                    continue;\n                }\n                try {\n                    bean = prop.deserializeSetAndReturn(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            // ignorable things should be ignored\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, bean, propName);\n                continue;\n            }\n            // but others are likely to be part of external type id thingy...\n            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                continue;\n            }\n            // if not, the usual fallback handling:\n            if (_anySetter != null) {\n                try {\n                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n            } else {\n                // Unknown: let's call handler method\n                handleUnknownProperty(p, ctxt, bean, propName);\n            }\n        }\n        // and when we get this far, let's try finalizing the deal:\n        return ext.complete(p, ctxt, bean);\n    }", "deserializeUsingPropertyBasedWithExternalTypeId": "    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // !!! 04-Mar-2012, TODO: Need to fix -- will not work as is...\n        throw new IllegalStateException(\"Deserialization with Builder, External type id, @JsonCreator not yet implemented\");\n    }"}