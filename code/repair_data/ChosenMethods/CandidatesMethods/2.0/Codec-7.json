{"avail": "    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }", "encode": "    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }", "decode": "    public byte[] decode(byte[] pArray) {\n        reset();\n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = (pArray.length * 3) / 4;\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        decode(pArray, 0, pArray.length);\n        decode(pArray, 0, -1); // Notify decoder of EOF.\n\n        // Would be nice to just return buf (like we sometimes do in the encode\n        // logic), but we have no idea what the line-length was (could even be\n        // variable).  So we cannot determine ahead of time exactly how big an\n        // array is necessary.  Hence the need to construct a 2nd byte array to\n        // hold the final result:\n\n        byte[] result = new byte[pos];\n        readResults(result, 0, result.length);\n        return result;\n    }", "encodeBase64": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }", "encodeBase64String": "    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }", "encodeBase64URLSafe": "    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }", "encodeBase64URLSafeString": "    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n    }    ", "encodeBase64Chunked": "    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n        return encodeBase64(binaryData, true);\n    }", "encodeToString": "    public String encodeToString(byte[] pArray) {\n        return StringUtils.newStringUtf8(encode(pArray));\n    }", "reset": "    private void reset() {\n        buffer = null;\n        pos = 0;\n        readPos = 0;\n        currentLinePos = 0;\n        modulus = 0;\n        eof = false;\n    }"}