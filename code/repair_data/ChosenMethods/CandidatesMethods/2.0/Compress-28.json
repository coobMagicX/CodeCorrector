{"close": "    public void close() throws IOException {\n        is.close();\n    }", "available": "    public int available() throws IOException {\n        if (entrySize - entryOffset > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        }\n        return (int) (entrySize - entryOffset);\n    }", "skip": "    public long skip(long numToSkip) throws IOException {\n\n        long available = entrySize - entryOffset;\n        numToSkip = Math.min(numToSkip, available);\n\n        long skipped = IOUtils.skip(is, numToSkip); \n        count(skipped);\n        entryOffset += skipped;\n        return skipped;\n    }", "reset": "    public synchronized void reset() {\n    }", "isEOFRecord": "    protected boolean isEOFRecord(byte[] record) {\n        return record == null || ArchiveUtils.isArrayZero(record, recordSize);\n    }", "readRecord": "    protected byte[] readRecord() throws IOException {\n\n        byte[] record = new byte[recordSize];\n\n        int readNow = IOUtils.readFully(is, record);\n        count(readNow);\n        if (readNow != recordSize) {\n            return null;\n        }\n\n        return record;\n    }", "readGNUSparse": "    private void readGNUSparse() throws IOException {\n        /* we do not really process sparse files yet\n        sparses = new ArrayList();\n        sparses.addAll(currEntry.getSparses());\n        */\n        if (currEntry.isExtended()) {\n            TarArchiveSparseEntry entry;\n            do {\n                byte[] headerBuf = getRecord();\n                if (headerBuf == null) {\n                    currEntry = null;\n                    break;\n                }\n                entry = new TarArchiveSparseEntry(headerBuf);\n                /* we do not really process sparse files yet\n                sparses.addAll(entry.getSparses());\n                */\n            } while (entry.isExtended());\n        }\n    }", "read": "    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        count(totalRead);\n        \n        if (totalRead == -1) {\n            hasHitEOF = true;\n        } else {\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }", "canReadEntryData": "    public boolean canReadEntryData(ArchiveEntry ae) {\n        if (ae instanceof TarArchiveEntry) {\n            TarArchiveEntry te = (TarArchiveEntry) ae;\n            return !te.isGNUSparse();\n        }\n        return false;\n    }", "isAtEOF": "    protected final boolean isAtEOF() {\n        return hasHitEOF;\n    }", "matches": "    public static boolean matches(byte[] signature, int length) {\n        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\n            return false;\n        }\n\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            (\n             ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            ||\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n            )\n                ){\n            return true;\n        }\n        // COMPRESS-107 - recognise Ant tar files\n        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\n                signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n            &&\n            ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\n                signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n                ){\n            return true;\n        }\n        return false;\n    }"}