{"optimizeSubtree": "  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.NEW:\n        return tryFoldCtorCall(subtree);\n\n      case Token.TYPEOF:\n        return tryFoldTypeof(subtree);\n\n      case Token.NOT:\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldUnaryOperator(subtree);\n\n      case Token.VOID:\n        return tryReduceVoid(subtree);\n\n      default:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldBinaryOperator(subtree);\n    }\n  }", "tryFoldBinaryOperator": "  private Node tryFoldBinaryOperator(Node subtree) {\n    Node left = subtree.getFirstChild();\n\n    if (left == null) {\n      return subtree;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return subtree;\n    }\n\n    // If we've reached here, node is truly a binary operator.\n    switch(subtree.getType()) {\n      case Token.GETPROP:\n        return tryFoldGetProp(subtree, left, right);\n\n      case Token.GETELEM:\n        return tryFoldGetElem(subtree, left, right);\n\n      case Token.INSTANCEOF:\n        return tryFoldInstanceof(subtree, left, right);\n\n      case Token.AND:\n      case Token.OR:\n        return tryFoldAndOr(subtree, left, right);\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        return tryFoldShift(subtree, left, right);\n\n      case Token.ASSIGN:\n        return tryFoldAssign(subtree, left, right);\n\n      case Token.ADD:\n        return tryFoldAdd(subtree, left, right);\n\n      case Token.SUB:\n      case Token.DIV:\n      case Token.MOD:\n        return tryFoldArithmeticOp(subtree, left, right);\n\n      case Token.MUL:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n        Node result = tryFoldArithmeticOp(subtree, left, right);\n        if (result != subtree) {\n          return result;\n        }\n        return tryFoldLeftChildOp(subtree, left, right);\n\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return tryFoldComparison(subtree, left, right);\n\n      default:\n        return subtree;\n    }\n  }", "tryReduceVoid": "  private Node tryReduceVoid(Node n) {\n    Node child = n.getFirstChild();\n    if (child.getType() != Token.NUMBER || child.getDouble() != 0.0) {\n      if (!mayHaveSideEffects(n)) {\n        n.replaceChild(child, Node.newNumber(0));\n        reportCodeChange();\n      }\n    }\n    return n;\n  }", "tryReduceOperandsForOp": "  private void tryReduceOperandsForOp(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n        if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) {\n          tryConvertOperandsToNumber(n);\n        }\n        break;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n        // TODO(johnlenz): convert these to integers.\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_DIV:\n        tryConvertToNumber(n.getLastChild());\n        break;\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.POS:\n      case Token.NEG:\n        tryConvertOperandsToNumber(n);\n        break;\n    }\n  }", "tryConvertOperandsToNumber": "  private void tryConvertOperandsToNumber(Node n) {\n    Node next;\n    for (Node c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      tryConvertToNumber(c);\n    }\n  }", "tryConvertToNumber": "  private void tryConvertToNumber(Node n) {\n    switch (n.getType()) {\n      case Token.NUMBER:\n        // Nothing to do\n        return;\n      case Token.AND:\n      case Token.OR:\n      case Token.COMMA:\n        tryConvertToNumber(n.getLastChild());\n        return;\n      case Token.HOOK:\n        tryConvertToNumber(n.getChildAtIndex(1));\n        tryConvertToNumber(n.getLastChild());\n        return;\n      case Token.NAME:\n        if (!NodeUtil.isUndefined(n)) {\n          return;\n        }\n        break;\n    }\n\n    Double result = NodeUtil.getNumberValue(n);\n    if (result == null) {\n      return;\n    }\n\n    double value = result;\n\n    Node replacement;\n    if (Double.isNaN(value)) {\n      replacement = Node.newString(Token.NAME, \"NaN\");\n    } else if (value == Double.POSITIVE_INFINITY) {\n      replacement = Node.newString(Token.NAME, \"Infinity\");\n    } else if (value == Double.NEGATIVE_INFINITY) {\n      replacement = new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n      replacement.copyInformationFromForTree(n);\n    } else {\n      replacement = Node.newNumber(value);\n    }\n\n    n.getParent().replaceChild(n, replacement);\n    reportCodeChange();\n  }", "tryFoldUnaryOperator": "  private Node tryFoldUnaryOperator(Node n) {\n    Preconditions.checkState(n.hasOneChild());\n\n    Node left = n.getFirstChild();\n    Node parent = n.getParent();\n\n    if (left == null) {\n      return n;\n    }\n\n    TernaryValue leftVal = NodeUtil.getPureBooleanValue(left);\n    if (leftVal == TernaryValue.UNKNOWN) {\n      return n;\n    }\n\n    switch (n.getType()) {\n      case Token.NOT:\n        // Don't fold !0 and !1 back to false.\n        if (left.getType() == Token.NUMBER) {\n          double numValue = left.getDouble();\n          if (numValue == 0 || numValue == 1) {\n            return n;\n          }\n        }\n        int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;\n        Node replacementNode = new Node(result);\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      case Token.POS:\n        if (NodeUtil.isNumericResult(left)) {\n          // POS does nothing to numeric values.\n          parent.replaceChild(n, left.detachFromParent());\n          reportCodeChange();\n          return left;\n        }\n        return n;\n      case Token.NEG:\n        try {\n          if (left.getType() == Token.NAME) {\n            if (left.getString().equals(\"Infinity\")) {\n              // \"-Infinity\" is valid and a literal, don't modify it.\n              return n;\n            } else if (left.getString().equals(\"NaN\")) {\n              // \"-NaN\" is \"NaN\".\n              n.removeChild(left);\n              parent.replaceChild(n, left);\n              reportCodeChange();\n              return left;\n            }\n          }\n\n          double negNum = -left.getDouble();\n\n          Node negNumNode = Node.newNumber(negNum);\n          parent.replaceChild(n, negNumNode);\n          reportCodeChange();\n          return negNumNode;\n        } catch (UnsupportedOperationException ex) {\n          // left is not a number node, so do not replace, but warn the\n          // user because they can't be doing anything good\n          error(NEGATING_A_NON_NUMBER_ERROR, left);\n          return n;\n        }\n      case Token.BITNOT:\n        try {\n          double val = left.getDouble();\n          if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n            int intVal = (int) val;\n            if (intVal == val) {\n              Node notIntValNode = Node.newNumber(~intVal);\n              parent.replaceChild(n, notIntValNode);\n              reportCodeChange();\n              return notIntValNode;\n            } else {\n              error(FRACTIONAL_BITWISE_OPERAND, left);\n              return n;\n            }\n          } else {\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n            return n;\n          }\n        } catch (UnsupportedOperationException ex) {\n          // left is not a number node, so do not replace, but warn the\n          // user because they can't be doing anything good\n          error(NEGATING_A_NON_NUMBER_ERROR, left);\n          return n;\n        }\n        default:\n          return n;\n    }\n  }", "tryFoldInstanceof": "  private Node tryFoldInstanceof(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);\n\n    // TODO(johnlenz) Use type information if available to fold\n    // instanceof.\n    if (NodeUtil.isLiteralValue(left, true)\n        && !mayHaveSideEffects(right)) {\n\n      Node replacementNode = null;\n\n      if (NodeUtil.isImmutableValue(left)) {\n        // Non-object types are never instances.\n        replacementNode = new Node(Token.FALSE);\n      } else if (right.getType() == Token.NAME\n          && \"Object\".equals(right.getString())) {\n        replacementNode = new Node(Token.TRUE);\n      }\n\n      if (replacementNode != null) {\n        n.getParent().replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      }\n    }\n\n    return n;\n  }", "tryFoldAssign": "  private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return n;\n    }\n\n    if (mayHaveSideEffects(left)) {\n      return n;\n    }\n\n    Node newRight;\n    if (areNodesEqualForInlining(left, right.getFirstChild())) {\n      newRight = right.getLastChild();\n    } else if (NodeUtil.isCommutative(right.getType()) &&\n          areNodesEqualForInlining(left, right.getLastChild())) {\n      newRight = right.getFirstChild();\n    } else {\n      return n;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return n;\n    }\n\n    Node newNode = new Node(newType,\n        left.detachFromParent(), newRight.detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }", "tryFoldAndOr": "  private Node tryFoldAndOr(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n\n    Node result = null;\n\n    int type = n.getType();\n\n    TernaryValue leftVal = NodeUtil.getImpureBooleanValue(left);\n\n    if (leftVal != TernaryValue.UNKNOWN) {\n      boolean lval = leftVal.toBoolean(true);\n\n      // (TRUE || x) => TRUE (also, (3 || x) => 3)\n      // (FALSE && x) => FALSE\n      if (lval && type == Token.OR ||\n          !lval && type == Token.AND) {\n        result = left;\n\n      } else if (!mayHaveSideEffects(left)) {\n        // (FALSE || x) => x\n        // (TRUE && x) => x\n        result = right;\n      }\n    }\n\n    // Note: Right hand side folding is handled by\n    // PeepholeSubstituteAlternateSyntax#tryMinimizeCondition\n\n    if (result != null) {\n      // Fold it!\n      n.removeChild(result);\n      parent.replaceChild(n, result);\n      reportCodeChange();\n\n      return result;\n    } else {\n      return n;\n    }\n  }", "tryFoldChildAddString": "  private Node tryFoldChildAddString(Node n, Node left, Node right) {\n\n    if (NodeUtil.isLiteralValue(right, false) &&\n        left.getType() == Token.ADD) {\n\n      Node ll = left.getFirstChild();\n      Node lr = ll.getNext();\n\n      // Left's right child MUST be a string. We would not want to fold\n      // foo() + 2 + 'a' because we don't know what foo() will return, and\n      // therefore we don't know if left is a string concat, or a numeric add.\n      if (lr.getType() == Token.STRING) {\n        String leftString = NodeUtil.getStringValue(lr);\n        String rightString = NodeUtil.getStringValue(right);\n        if (leftString != null && rightString != null) {\n          left.removeChild(ll);\n          String result = leftString + rightString;\n          n.replaceChild(left, ll);\n          n.replaceChild(right, Node.newString(result));\n          reportCodeChange();\n          return n;\n        }\n      }\n    }\n\n    if (NodeUtil.isLiteralValue(left, false) &&\n        right.getType() == Token.ADD) {\n\n      Node rl = right.getFirstChild();\n      Node rr = right.getLastChild();\n\n      // Left's right child MUST be a string. We would not want to fold\n      // foo() + 2 + 'a' because we don't know what foo() will return, and\n      // therefore we don't know if left is a string concat, or a numeric add.\n      if (rl.getType() == Token.STRING) {\n        String leftString = NodeUtil.getStringValue(left);\n        String rightString = NodeUtil.getStringValue(rl);\n        if (leftString != null && rightString != null) {\n          right.removeChild(rr);\n          String result = leftString + rightString;\n          n.replaceChild(right, rr);\n          n.replaceChild(left, Node.newString(result));\n          reportCodeChange();\n          return n;\n        }\n      }\n    }\n\n    return n;\n  }", "tryFoldAddConstantString": "  private Node tryFoldAddConstantString(Node n, Node left, Node right) {\n    if (left.getType() == Token.STRING ||\n        right.getType() == Token.STRING) {\n      // Add strings.\n      String leftString = NodeUtil.getStringValue(left);\n      String rightString = NodeUtil.getStringValue(right);\n      if (leftString != null && rightString != null) {\n        Node newStringNode = Node.newString(leftString + rightString);\n        n.getParent().replaceChild(n, newStringNode);\n        reportCodeChange();\n        return newStringNode;\n      }\n    }\n\n\n\n    return n;\n  }", "tryFoldArithmeticOp": "  private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n    Node result = performArithmeticOp(n.getType(), left, right);\n    if (result != null) {\n      result.copyInformationFromForTree(n);\n      n.getParent().replaceChild(n, result);\n      reportCodeChange();\n      return result;\n    }\n    return n;\n  }", "performArithmeticOp": "  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <=\n        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n  }", "tryFoldLeftChildOp": "  private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\n    int opType = n.getType();\n    Preconditions.checkState(\n        (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n        || n.getType() == Token.ADD);\n\n    Preconditions.checkState(\n        n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n\n    // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n    // other values are converted to numbers elsewhere.\n    Double rightValObj = NodeUtil.getNumberValue(right);\n    if (rightValObj != null && left.getType() == opType) {\n      Preconditions.checkState(left.getChildCount() == 2);\n\n      Node ll = left.getFirstChild();\n      Node lr = ll.getNext();\n\n      Node valueToCombine = ll;\n      Node replacement = performArithmeticOp(opType, valueToCombine, right);\n      if (replacement == null) {\n        valueToCombine = lr;\n        replacement = performArithmeticOp(opType, valueToCombine, right);\n      }\n      if (replacement != null) {\n        // Remove the child that has been combined\n        left.removeChild(valueToCombine);\n        // Replace the left op with the remaining child.\n        n.replaceChild(left, left.removeFirstChild());\n        // New \"-Infinity\" node need location info explicitly\n        // added.\n        replacement.copyInformationFromForTree(right);\n        n.replaceChild(right, replacement);\n        reportCodeChange();\n      }\n    }\n\n    return n;\n  }", "tryFoldShift": "  private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n\n      // check ranges.  We do not do anything that would clip the double to\n      // a 32-bit range, since the user likely does not intend that.\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n      }\n\n      // only the lower 5 bits are used when shifting, so don't do anything\n      // if the shift amount is outside [0,32)\n      if (!(rval >= 0 && rval < 32)) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      }\n\n      // Convert the numbers to ints\n      int lvalInt = (int) lval;\n      if (lvalInt != lval) {\n        error(FRACTIONAL_BITWISE_OPERAND, left);\n        return n;\n      }\n\n      int rvalInt = (int) rval;\n      if (rvalInt != rval) {\n        error(FRACTIONAL_BITWISE_OPERAND, right);\n        return n;\n      }\n\n      switch (n.getType()) {\n        case Token.LSH:\n          result = lvalInt << rvalInt;\n          break;\n        case Token.RSH:\n          result = lvalInt >> rvalInt;\n          break;\n        case Token.URSH:\n          // JavaScript handles zero shifts on signed numbers differently than\n          // Java as an Java int can not represent the unsigned 32-bit number\n          // where JavaScript can so use a long here.\n          long lvalLong = lvalInt & 0xffffffffL;\n          result = lvalLong >>> rvalInt;\n          break;\n        default:\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n      }\n\n      Node newNumber = Node.newNumber(result);\n      n.getParent().replaceChild(n, newNumber);\n      reportCodeChange();\n\n      return newNumber;\n    }\n\n    return n;\n  }", "tryFoldComparison": "  private Node tryFoldComparison(Node n, Node left, Node right) {\n    if (!NodeUtil.isLiteralValue(left, false) ||\n        !NodeUtil.isLiteralValue(right, false)) {\n      // We only handle non-literal operands for LT and GT.\n      if (n.getType() != Token.GT && n.getType() != Token.LT) {\n        return n;\n      }\n    }\n\n    int op = n.getType();\n    boolean result;\n\n    // TODO(johnlenz): Use the JSType to compare nodes of different types.\n\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n    boolean undefinedRight = ((Token.NAME == right.getType()\n          && right.getString().equals(\"undefined\"))\n          || (Token.VOID == right.getType()\n              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n    int lhType = getNormalizedNodeType(left);\n    int rhType = getNormalizedNodeType(right);\n    switch (lhType) {\n      case Token.VOID:\n        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n          return n;\n        } else if (!rightLiteral) {\n          return n;\n        } else {\n          result = compareToUndefined(right, op);\n        }\n        break;\n\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        if (undefinedRight) {\n          result = compareToUndefined(left, op);\n          break;\n        }\n        if (rhType != Token.TRUE &&\n            rhType != Token.FALSE &&\n            rhType != Token.NULL) {\n          return n;\n        }\n        switch (op) {\n          case Token.SHEQ:\n          case Token.EQ:\n            result = lhType == rhType;\n            break;\n\n          case Token.SHNE:\n          case Token.NE:\n            result = lhType != rhType;\n            break;\n\n          case Token.GE:\n          case Token.LE:\n          case Token.GT:\n          case Token.LT:\n            Boolean compareResult = compareAsNumbers(op, left, right);\n            if (compareResult != null) {\n              result = compareResult;\n            } else {\n              return n;\n            }\n            break;\n\n          default:\n            return n;  // we only handle == and != here\n        }\n        break;\n\n      case Token.THIS:\n        if (right.getType() != Token.THIS) {\n          return n;\n        }\n        switch (op) {\n          case Token.SHEQ:\n          case Token.EQ:\n            result = true;\n            break;\n\n          case Token.SHNE:\n          case Token.NE:\n            result = false;\n            break;\n\n          // We can only handle == and != here.\n          // GT, LT, GE, LE depend on the type of \"this\" and how it will\n          // be converted to number.  The results are different depending on\n          // whether it is a string, NaN or other number value.\n          default:\n            return n;\n        }\n        break;\n\n      case Token.STRING:\n        if (undefinedRight) {\n          result = compareToUndefined(left, op);\n          break;\n        }\n        if (Token.STRING != right.getType()) {\n          return n;  // Only eval if they are the same type\n        }\n        switch (op) {\n          case Token.SHEQ:\n          case Token.EQ:\n            result = left.getString().equals(right.getString());\n            break;\n\n          case Token.SHNE:\n          case Token.NE:\n            result = !left.getString().equals(right.getString());\n            break;\n\n          default:\n            return n;  // we only handle == and != here\n        }\n        break;\n\n      case Token.NUMBER:\n        if (undefinedRight) {\n          result = compareToUndefined(left, op);\n          break;\n        }\n        if (Token.NUMBER != right.getType()) {\n          return n;  // Only eval if they are the same type\n        }\n        Boolean compareResult = compareAsNumbers(op, left, right);\n        if (compareResult != null) {\n          result = compareResult;\n        } else {\n          return null;\n        }\n        break;\n\n      case Token.NAME:\n        if (undefinedRight) {\n          result = compareToUndefined(left, op);\n          break;\n        }\n\n        if (rightLiteral) {\n          boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n          if (undefinedLeft) {\n            result = compareToUndefined(right, op);\n            break;\n          }\n        }\n\n        if (Token.NAME != right.getType()) {\n          return n;  // Only eval if they are the same type\n        }\n        String ln = left.getString();\n        String rn = right.getString();\n        if (!ln.equals(rn)) {\n          return n;  // Not the same value name.\n        }\n\n        switch (op) {\n          // If we knew the named value wouldn't be NaN, it would be nice\n          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n          case Token.LT:\n          case Token.GT:\n            result = false;\n            break;\n          default:\n            return n;  // don't handle that op\n        }\n        break;\n\n      default:\n        // assert, this should cover all consts\n        return n;\n    }\n\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n    n.getParent().replaceChild(n, newNode);\n    reportCodeChange();\n\n    return newNode;\n  }", "getNormalizedNodeType": "  private int getNormalizedNodeType(Node n) {\n    int type = n.getType();\n    if (type == Token.NOT) {\n      TernaryValue value = NodeUtil.getPureBooleanValue(n);\n      switch (value) {\n        case TRUE:\n          return Token.TRUE;\n        case FALSE:\n          return Token.FALSE;\n      }\n    }\n    return type;\n  }", "compareAsNumbers": "  private Boolean compareAsNumbers(int op, Node left, Node right) {\n    Double leftValue = NodeUtil.getNumberValue(left);\n    if (leftValue == null) {\n      return null;\n    }\n    Double rightValue = NodeUtil.getNumberValue(right);\n    if (rightValue == null) {\n      return null;\n    }\n\n    double lv = leftValue;\n    double rv = rightValue;\n\n    Boolean result;\n    switch (op) {\n      case Token.SHEQ:\n      case Token.EQ:\n        Preconditions.checkState(\n            left.getType() == Token.NUMBER && right.getType() == Token.NUMBER);\n        result = lv == rv;\n        break;\n      case Token.SHNE:\n      case Token.NE:\n        Preconditions.checkState(\n            left.getType() == Token.NUMBER && right.getType() == Token.NUMBER);\n        result = lv != rv;\n        break;\n      case Token.LE: result = lv <= rv; break;\n      case Token.LT: result = lv <  rv; break;\n      case Token.GE: result = lv >= rv; break;\n      case Token.GT: result = lv >  rv; break;\n      default:\n        return null;  // don't handle that op\n    }\n    return result;\n  }", "compareToUndefined": "  private boolean compareToUndefined(Node value, int op) {\n    boolean valueUndefined = ((Token.NAME == value.getType()\n        && value.getString().equals(\"undefined\"))\n        || (Token.VOID == value.getType()\n            && NodeUtil.isLiteralValue(value.getFirstChild(), false)));\n    boolean valueNull = (Token.NULL == value.getType());\n    boolean equivalent = valueUndefined || valueNull;\n    switch (op) {\n      case Token.EQ:\n        // undefined is only equal to null or an undefined value\n        return equivalent;\n      case Token.NE:\n        return !equivalent;\n      case Token.SHEQ:\n        return valueUndefined;\n      case Token.SHNE:\n        return !valueUndefined;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n        return false;\n      default:\n        throw new IllegalStateException(\"unexpected.\");\n    }\n  }", "inForcedStringContext": "  private boolean inForcedStringContext(Node n) {\n    return n.getParent().getType() == Token.GETELEM &&\n        n.getParent().getLastChild() == n;\n  }", "tryFoldInForcedStringContext": "  private Node tryFoldInForcedStringContext(Node n) {\n    // For now, we only know how to fold ctors.\n    Preconditions.checkArgument(n.getType() == Token.NEW);\n\n    Node objectType = n.getFirstChild();\n    if (objectType.getType() != Token.NAME) {\n      return n;\n    }\n\n    if (objectType.getString().equals(\"String\")) {\n      Node value = objectType.getNext();\n      String stringValue = null;\n      if (value == null) {\n        stringValue = \"\";\n      } else {\n        if (!NodeUtil.isImmutableValue(value)) {\n          return n;\n        }\n\n        stringValue = NodeUtil.getStringValue(value);\n      }\n\n      if (stringValue == null) {\n        return n;\n      }\n\n      Node parent = n.getParent();\n      Node newString = Node.newString(stringValue);\n\n      parent.replaceChild(n, newString);\n      newString.copyInformationFrom(parent);\n      reportCodeChange();\n\n      return newString;\n    }\n    return n;\n  }", "tryFoldGetElem": "  private Node tryFoldGetElem(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.GETELEM);\n\n    if (left.getType() == Token.OBJECTLIT) {\n      return tryFoldObjectPropAccess(n, left, right);\n    }\n\n    if (left.getType() == Token.ARRAYLIT) {\n      return tryFoldArrayAccess(n, left, right);\n    }\n    return n;\n  }", "isAssignmentTarget": "  private boolean isAssignmentTarget(Node n) {\n    Node parent = n.getParent();\n    if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n        || parent.getType() == Token.INC\n        || parent.getType() == Token.DEC) {\n      // If GETPROP/GETELEM is used as assignment target the object literal is\n      // acting as a temporary we can't fold it here:\n      //    \"{a:x}.a += 1\" is not \"x += 1\"\n      return true;\n    }\n    return false;\n  }", "tryFoldArrayAccess": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.getType() == Token.EMPTY) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }"}