{"buildTypeDeserializer": "        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;\n        }", "buildTypeSerializer": "        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n                JavaType baseType, Collection<NamedType> subtypes)\n        {\n            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }", "useForType": "        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }", "copy": "    public ObjectMapper copy()\n    {\n        _checkInvalidCopy(ObjectMapper.class);\n        return new ObjectMapper(this);\n    }", "version": "    public Version version() {\n        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n    }", "registerModule": "    public ObjectMapper registerModule(Module module)\n    {\n        /* Let's ensure we have access to name and version information, \n         * even if we do not have immediate use for either. This way we know\n         * that they will be available from beginning\n         */\n        String name = module.getModuleName();\n        if (name == null) {\n            throw new IllegalArgumentException(\"Module without defined name\");\n        }\n        Version version = module.version();\n        if (version == null) {\n            throw new IllegalArgumentException(\"Module without defined version\");\n        }\n\n        final ObjectMapper mapper = this;\n        \n        // And then call registration\n        module.setupModule(new Module.SetupContext()\n        {\n            // // // Accessors\n\n            @Override\n            public Version getMapperVersion() {\n                return version();\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public <C extends ObjectCodec> C getOwner() {\n                // why do we need the cast here?!?\n                return (C) mapper;\n            }\n\n            @Override\n            public TypeFactory getTypeFactory() {\n                return _typeFactory;\n            }\n            \n            @Override\n            public boolean isEnabled(MapperFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(DeserializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(SerializationFeature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonFactory.Feature f) {\n                return mapper.isEnabled(f);\n            }\n\n            @Override\n            public boolean isEnabled(JsonParser.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            @Override\n            public boolean isEnabled(JsonGenerator.Feature f) {\n                return mapper.isEnabled(f);\n            }\n            \n            // // // Methods for registering handlers: deserializers\n            \n            @Override\n            public void addDeserializers(Deserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addKeyDeserializers(KeyDeserializers d) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n            \n            // // // Methods for registering handlers: serializers\n            \n            @Override\n            public void addSerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n            }\n\n            @Override\n            public void addKeySerializers(Serializers s) {\n                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n            }\n            \n            @Override\n            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n            }\n\n            // // // Methods for registering handlers: other\n            \n            @Override\n            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void addTypeModifier(TypeModifier modifier) {\n                TypeFactory f = mapper._typeFactory;\n                f = f.withModifier(modifier);\n                mapper.setTypeFactory(f);\n            }\n\n            @Override\n            public void addValueInstantiators(ValueInstantiators instantiators) {\n                DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                mapper._deserializationContext = mapper._deserializationContext.with(df);\n            }\n\n            @Override\n            public void setClassIntrospector(ClassIntrospector ci) {\n                mapper._deserializationConfig = mapper._deserializationConfig.with(ci);\n                mapper._serializationConfig = mapper._serializationConfig.with(ci);\n            }\n\n            @Override\n            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n            }\n            \n            @Override\n            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n            }\n\n            @Override\n            public void registerSubtypes(Class<?>... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n\n            @Override\n            public void registerSubtypes(NamedType... subtypes) {\n                mapper.registerSubtypes(subtypes);\n            }\n            \n            @Override\n            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                mapper.addMixInAnnotations(target, mixinSource);\n            }\n            \n            @Override\n            public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                mapper.addHandler(handler);\n            }\n\n            @Override\n            public void setNamingStrategy(PropertyNamingStrategy naming) {\n                mapper.setPropertyNamingStrategy(naming);\n            }\n        });\n        return this;\n    }", "registerModules": "    public ObjectMapper registerModules(Iterable<Module> modules)\n    {\n        for (Module module : modules) {\n            registerModule(module);\n        }\n        return this;\n    }", "findAndRegisterModules": "    public ObjectMapper findAndRegisterModules() {\n        return registerModules(findModules());\n    }", "getSerializationConfig": "    public SerializationConfig getSerializationConfig() {\n        return _serializationConfig;\n    }", "getDeserializationConfig": "    public DeserializationConfig getDeserializationConfig() {\n        return _deserializationConfig;\n    }", "getDeserializationContext": "    public DeserializationContext getDeserializationContext() {\n        return _deserializationContext;\n    }", "setSerializerFactory": "    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n        _serializerFactory = f;\n        return this;\n    }", "getSerializerFactory": "    public SerializerFactory getSerializerFactory() {\n        return _serializerFactory;\n    }", "setSerializerProvider": "    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n        _serializerProvider = p;\n        return this;\n    }", "getSerializerProvider": "    public SerializerProvider getSerializerProvider() {\n        return _serializerProvider;\n    }", "setMixInAnnotations": "    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n    {\n        _mixInAnnotations.clear();\n        if (sourceMixins != null && sourceMixins.size() > 0) {\n            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n            }\n        }\n    }", "addMixInAnnotations": "    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n    {\n        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n    }", "mixInCount": "    public final int mixInCount() {\n        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n    }", "getVisibilityChecker": "    public VisibilityChecker<?> getVisibilityChecker() {\n        return _serializationConfig.getDefaultVisibilityChecker();\n    }", "setVisibilityChecker": "    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n        _deserializationConfig = _deserializationConfig.with(vc);\n        _serializationConfig = _serializationConfig.with(vc);\n    }", "setVisibility": "    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n    {\n        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n        return this;\n    }", "getSubtypeResolver": "    public SubtypeResolver getSubtypeResolver() {\n        return _subtypeResolver;\n    }", "setSubtypeResolver": "    public ObjectMapper setSubtypeResolver(SubtypeResolver str) {\n        _subtypeResolver = str;\n        _deserializationConfig = _deserializationConfig.with(str);\n        _serializationConfig = _serializationConfig.with(str);\n        return this;\n    }", "setAnnotationIntrospector": "    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n        _serializationConfig = _serializationConfig.with(ai);\n        _deserializationConfig = _deserializationConfig.with(ai);\n        return this;\n    }", "setAnnotationIntrospectors": "    public ObjectMapper setAnnotationIntrospectors(AnnotationIntrospector serializerAI,\n            AnnotationIntrospector deserializerAI) {\n        _serializationConfig = _serializationConfig.with(serializerAI);\n        _deserializationConfig = _deserializationConfig.with(deserializerAI);\n        return this;\n    }", "setPropertyNamingStrategy": "    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n        _serializationConfig = _serializationConfig.with(s);\n        _deserializationConfig = _deserializationConfig.with(s);\n        return this;\n    }", "setSerializationInclusion": "    public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n        return this;\n    }", "enableDefaultTyping": "    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(includeAs);\n        return setDefaultTyping(typer);\n    }", "enableDefaultTypingAsProperty": "    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n    {\n        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n        // we'll always use full class name, when using defaulting\n        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n        typer = typer.typeProperty(propertyName);\n        return setDefaultTyping(typer);\n    }", "disableDefaultTyping": "    public ObjectMapper disableDefaultTyping() {\n        return setDefaultTyping(null);\n    }", "setDefaultTyping": "    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n        _deserializationConfig = _deserializationConfig.with(typer);\n        _serializationConfig = _serializationConfig.with(typer);\n        return this;\n    }", "registerSubtypes": "    public void registerSubtypes(NamedType... types) {\n        getSubtypeResolver().registerSubtypes(types);\n    }", "getTypeFactory": "    public TypeFactory getTypeFactory() {\n        return _typeFactory;\n    }", "setTypeFactory": "    public ObjectMapper setTypeFactory(TypeFactory f)\n    {\n        _typeFactory = f;\n        _deserializationConfig = _deserializationConfig.with(f);\n        _serializationConfig = _serializationConfig.with(f);\n        return this;\n    }", "constructType": "    public JavaType constructType(Type t) {\n        return _typeFactory.constructType(t);\n    }", "setNodeFactory": "    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n        _deserializationConfig = _deserializationConfig.with(f);\n        return this;\n    }", "setConfig": "    public ObjectMapper setConfig(SerializationConfig config) {\n    \t_serializationConfig = config;\n    \treturn this;\n    }", "setFilters": "    public void setFilters(FilterProvider filterProvider) {\n        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n    }", "setBase64Variant": "    public ObjectMapper setBase64Variant(Base64Variant v) {\n        _serializationConfig = _serializationConfig.with(v);\n        _deserializationConfig = _deserializationConfig.with(v);\n        return this;\n    }", "getFactory": "    public JsonFactory getFactory() { return _jsonFactory; }", "getJsonFactory": "    public JsonFactory getJsonFactory() { return getFactory(); }", "setDateFormat": "    public ObjectMapper setDateFormat(DateFormat dateFormat)\n    {\n        _deserializationConfig = _deserializationConfig.with(dateFormat);\n        _serializationConfig = _serializationConfig.with(dateFormat);\n        return this;\n    }", "setHandlerInstantiator": "    public Object setHandlerInstantiator(HandlerInstantiator hi)\n    {\n        _deserializationConfig = _deserializationConfig.with(hi);\n        _serializationConfig = _serializationConfig.with(hi);\n        return this;\n    }", "setInjectableValues": "    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n        _injectableValues = injectableValues;\n        return this;\n    }", "setLocale": "    public ObjectMapper setLocale(Locale l) {\n        _deserializationConfig = _deserializationConfig.with(l);\n        _serializationConfig = _serializationConfig.with(l);\n        return this;\n    }", "setTimeZone": "    public ObjectMapper setTimeZone(TimeZone tz) {\n        _deserializationConfig = _deserializationConfig.with(tz);\n        _serializationConfig = _serializationConfig.with(tz);\n        return this;\n    }", "configure": "    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n        _jsonFactory.configure(f, state);\n        return this;\n    }", "enable": "    public ObjectMapper enable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.with(first, f);\n        return this;\n    }", "disable": "    public ObjectMapper disable(SerializationFeature first,\n            SerializationFeature... f) {\n        _serializationConfig = _serializationConfig.without(first, f);\n        return this;\n    }", "getNodeFactory": "    public JsonNodeFactory getNodeFactory() {\n        return _deserializationConfig.getNodeFactory();\n    }", "readTree": "    public JsonNode readTree(URL source)\n        throws IOException, JsonProcessingException\n    {\n        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(source), JSON_NODE_TYPE);\n        return (n == null) ? NullNode.instance : n;\n    }", "writeValue": "    public void writeValue(Writer w, Object value)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        _configAndWriteValue(_jsonFactory.createGenerator(w), value);\n    }", "writeTree": "    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n        throws IOException, JsonProcessingException\n    {\n        SerializationConfig config = getSerializationConfig();\n        _serializerProvider(config).serializeValue(jgen, rootNode);\n        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n            jgen.flush();\n        }\n    }", "createObjectNode": "    public ObjectNode createObjectNode() {\n        return _deserializationConfig.getNodeFactory().objectNode();\n    }", "createArrayNode": "    public ArrayNode createArrayNode() {\n        return _deserializationConfig.getNodeFactory().arrayNode();\n    }", "treeAsTokens": "    public JsonParser treeAsTokens(TreeNode n)\n    {\n        return new TreeTraversingParser((JsonNode) n, this);\n    }", "treeToValue": "    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n        throws JsonProcessingException\n    {\n        try {\n            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n            // ... one caveat; while everything is Object.class, let's not take shortcut\n            if (valueType != Object.class && valueType.isAssignableFrom(n.getClass())) {\n                return (T) n;\n            }\n            return readValue(treeAsTokens(n), valueType);\n        } catch (JsonProcessingException e) {\n            throw e;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }", "valueToTree": "    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    } ", "writeValueAsString": "    public String writeValueAsString(Object value)\n        throws JsonProcessingException\n    {        \n        // alas, we have to pull the recycler directly here...\n        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(sw), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        return sw.getAndClear();\n    }", "writeValueAsBytes": "    public byte[] writeValueAsBytes(Object value)\n        throws JsonProcessingException\n    {\n        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n        try {\n            _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value);\n        } catch (JsonProcessingException e) { // to support [JACKSON-758]\n            throw e;\n        } catch (IOException e) { // shouldn't really happen, but is declared as possibility so:\n            throw JsonMappingException.fromUnexpectedIOE(e);\n        }\n        byte[] result = bb.toByteArray();\n        bb.release();\n        return result;\n    }", "writer": "    public ObjectWriter writer(ContextAttributes attrs) {\n        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n    }", "writerWithView": "    public ObjectWriter writerWithView(Class<?> serializationView) {\n        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n    }", "writerWithType": "    public ObjectWriter writerWithType(JavaType rootType) {\n        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n    }", "writerWithDefaultPrettyPrinter": "    public ObjectWriter writerWithDefaultPrettyPrinter() {\n        return new ObjectWriter(this, getSerializationConfig(),\n                /*root type*/ null, _defaultPrettyPrinter());\n    }", "reader": "    public ObjectReader reader(ContextAttributes attrs) {\n        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n    }", "readerForUpdating": "    public ObjectReader readerForUpdating(Object valueToUpdate)\n    {\n        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                null, _injectableValues);\n    }", "readerWithView": "    public ObjectReader readerWithView(Class<?> view) {\n        return new ObjectReader(this, getDeserializationConfig().withView(view));\n    }", "convertValue": "    public <T> T convertValue(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {\n        // sanity check for null first:\n        if (fromValue == null) return null;\n        return (T) _convert(fromValue, toValueType);\n    } ", "_convert": "    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        /* Then use TokenBuffer, which is a JsonGenerator:\n         * (see [JACKSON-175])\n         */\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue();\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }", "generateJsonSchema": "    public com.fasterxml.jackson.databind.jsonschema.JsonSchema generateJsonSchema(Class<?> t)\n            throws JsonMappingException {\n        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n    }", "acceptJsonFormatVisitor": "    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n        throws JsonMappingException\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type must be provided\");\n        }\n        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(type, visitor);\n    }", "_defaultPrettyPrinter": "    protected PrettyPrinter _defaultPrettyPrinter() {\n        return _defaultPrettyPrinter;\n    }", "_configAndWriteValue": "    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n            jgen.useDefaultPrettyPrinter();\n        }\n        // [Issue#232]\n        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        }\n\n        // [JACKSON-282]: consider Closeable\n        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n            _configAndWriteCloseable(jgen, value, cfg);\n            return;\n        }\n        boolean closed = false;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            closed = true;\n            jgen.close();\n        } finally {\n            if (!closed) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }", "_configAndWriteCloseable": "    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            JsonGenerator tmpJgen = jgen;\n            jgen = null;\n            tmpJgen.close();\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            /* Need to close both generator and value, as long as they haven't yet\n             * been closed\n             */\n            if (jgen != null) {\n                // 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                //    structures, which typically causes more damage.\n                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                try {\n                    jgen.close();\n                } catch (IOException ioe) { }\n            }\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }", "_writeCloseableValue": "    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n        throws IOException, JsonGenerationException, JsonMappingException\n    {\n        Closeable toClose = (Closeable) value;\n        try {\n            _serializerProvider(cfg).serializeValue(jgen, value);\n            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                jgen.flush();\n            }\n            Closeable tmpToClose = toClose;\n            toClose = null;\n            tmpToClose.close();\n        } finally {\n            if (toClose != null) {\n                try {\n                    toClose.close();\n                } catch (IOException ioe) { }\n            }\n        }\n    }", "createDeserializationContext": "    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n            DeserializationConfig cfg)\n    {\n        return _deserializationContext.createInstance(cfg,\n                jp, _injectableValues);\n    }", "_initForReading": "    protected JsonToken _initForReading(JsonParser jp)\n        throws IOException, JsonParseException, JsonMappingException\n    {\n        /* First: must point to a token; if not pointing to one, advance.\n         * This occurs before first read from JsonParser, as well as\n         * after clearing of current token.\n         */\n        JsonToken t = jp.getCurrentToken();\n        if (t == null) {\n            // and then we must get something...\n            t = jp.nextToken();\n            if (t == null) {\n                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                 *   not an actual parsing problem\n                 */\n                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n            }\n        }\n        return t;\n    }", "_findRootDeserializer": "    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n            JavaType valueType)\n        throws JsonMappingException\n    {\n        // First: have we already seen it?\n        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n        if (deser != null) {\n            return deser;\n        }\n        // Nope: need to ask provider to resolve it\n        deser = ctxt.findRootValueDeserializer(valueType);\n        if (deser == null) { // can this happen?\n            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n        }\n        _rootDeserializers.put(valueType, deser);\n        return deser;\n    }", "_verifySchemaType": "    protected void _verifySchemaType(FormatSchema schema)\n    {\n        if (schema != null) {\n            if (!_jsonFactory.canUseSchema(schema)) {\n                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n                            +\" for format \"+_jsonFactory.getFormatName());\n            }\n        }\n    }"}