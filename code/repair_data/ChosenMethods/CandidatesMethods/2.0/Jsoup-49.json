{"nodeName": "    public abstract String nodeName();\n\n    /**\n     * Get an attribute's value by its key.\n     * <p>\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n     * which is a shortcut to the {@link #absUrl} method.", "attr": "    public Node attr(String attributeKey, String attributeValue) {\n        attributes.put(attributeKey, attributeValue);\n        return this;\n    }", "attributes": "    public Attributes attributes() {\n        return attributes;\n    }", "baseUri": "    public String baseUri() {\n        return baseUri;\n    }", "setBaseUri": "    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n\n        traverse(new NodeVisitor() {\n            public void head(Node node, int depth) {\n                node.baseUri = baseUri;\n            }\n\n            public void tail(Node node, int depth) {\n            }\n        });\n    }", "childNode": "    public Node childNode(int index) {\n        return childNodes.get(index);\n    }", "childNodes": "    public List<Node> childNodes() {\n        return Collections.unmodifiableList(childNodes);\n    }", "childNodesCopy": "    public List<Node> childNodesCopy() {\n        List<Node> children = new ArrayList<Node>(childNodes.size());\n        for (Node node : childNodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }", "childNodeSize": "    public final int childNodeSize() {\n        return childNodes.size();\n    }", "childNodesAsArray": "    protected Node[] childNodesAsArray() {\n        return childNodes.toArray(new Node[childNodeSize()]);\n    }", "parent": "    public Node parent() {\n        return parentNode;\n    }", "parentNode": "    public final Node parentNode() {\n        return parentNode;\n    }", "remove": "    public void remove() {\n        Validate.notNull(parentNode);\n        parentNode.removeChild(this);\n    }", "before": "    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }", "after": "    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }", "addSiblingHtml": "    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;        \n        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n    }", "wrap": "    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        Element context = parent() instanceof Element ? (Element) parent() : null;\n        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n        Node wrapNode = wrapChildren.get(0);\n        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return null;\n\n        Element wrap = (Element) wrapNode;\n        Element deepest = getDeepChild(wrap);\n        parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this);\n\n        // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n        if (wrapChildren.size() > 0) {\n            for (int i = 0; i < wrapChildren.size(); i++) {\n                Node remainder = wrapChildren.get(i);\n                remainder.parentNode.removeChild(remainder);\n                wrap.appendChild(remainder);\n            }\n        }\n        return this;\n    }", "unwrap": "    public Node unwrap() {\n        Validate.notNull(parentNode);\n\n        Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }", "getDeepChild": "    private Element getDeepChild(Element el) {\n        List<Element> children = el.children();\n        if (children.size() > 0)\n            return getDeepChild(children.get(0));\n        else\n            return el;\n    }", "replaceWith": "    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }", "setParentNode": "    protected void setParentNode(Node parentNode) {\n        if (this.parentNode != null)\n            this.parentNode.removeChild(this);\n        this.parentNode = parentNode;\n    }", "replaceChild": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n        \n        final int index = out.siblingIndex;\n        childNodes.set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }", "removeChild": "    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode == this);\n        final int index = out.siblingIndex;\n        childNodes.remove(index);\n        reindexChildren(index);\n        out.parentNode = null;\n    }", "addChildren": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            reparentChild(in);\n            childNodes.add(index, in);\n        }\n        reindexChildren(index);\n    }", "ensureChildNodes": "    protected void ensureChildNodes() {\n        if (childNodes == EMPTY_NODES) {\n            childNodes = new ArrayList<Node>(4);\n        }\n    }", "reparentChild": "    protected void reparentChild(Node child) {\n        if (child.parentNode != null)\n            child.parentNode.removeChild(child);\n        child.setParentNode(this);\n    }", "reindexChildren": "    private void reindexChildren(int start) {\n        for (int i = start; i < childNodes.size(); i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }", "siblingNodes": "    public List<Node> siblingNodes() {\n        if (parentNode == null)\n            return Collections.emptyList();\n\n        List<Node> nodes = parentNode.childNodes;\n        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node != this)\n                siblings.add(node);\n        return siblings;\n    }", "nextSibling": "    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }", "previousSibling": "    public Node previousSibling() {\n        if (parentNode == null)\n            return null; // root\n\n        if (siblingIndex > 0)\n            return parentNode.childNodes.get(siblingIndex-1);\n        else\n            return null;\n    }", "siblingIndex": "    public int siblingIndex() {\n        return siblingIndex;\n    }", "setSiblingIndex": "    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }", "traverse": "    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n        traversor.traverse(this);\n        return this;\n    }", "getOutputSettings": "    Document.OutputSettings getOutputSettings() {\n        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n    }", "outerHtmlTail": "    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }", "toString": "    public String toString() {\n        return outerHtml();\n    }", "indent": "    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n    }", "equals": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Node node = (Node) o;\n\n        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n    }", "clone": "    public Node clone() {\n        Node thisClone = doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent = nodesToProcess.remove();\n\n            for (int i = 0; i < currParent.childNodes.size(); i++) {\n                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n                currParent.childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }", "head": "        public void head(Node node, int depth) {\n            node.outerHtmlHead(accum, depth, out);\n        }", "tail": "        public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n                node.outerHtmlTail(accum, depth, out);\n        }"}