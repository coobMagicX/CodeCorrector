{"managed": "        public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }", "back": "        public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }", "getType": "        public Type getType() { return _type; }", "getName": "        public String getName() { return _name; }", "isManagedReference": "        public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }", "isBackReference": "        public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }", "nopInstance": "    public static AnnotationIntrospector nopInstance() {\n        return NopAnnotationIntrospector.instance;\n    }", "pair": "    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n        return new AnnotationIntrospectorPair(a1, a2);\n    }", "allIntrospectors": "    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n        result.add(this);\n        return result;\n    }", "version": "    public abstract Version version();\n    \n    /*\n    /**********************************************************\n    /* Meta-annotations (annotations for annotation types)\n    /**********************************************************\n     */\n\n    /**\n     * Method for checking whether given annotation is considered an\n     * annotation bundle: if so, all meta-annotations it has will\n     * be used instead of annotation (\"bundle\") itself.\n     * \n     * @since 2.0\n     */\n    public boolean isAnnotationBundle(Annotation ann) {\n        return false;\n    }", "isAnnotationBundle": "    public boolean isAnnotationBundle(Annotation ann) {\n        return false;\n    }", "findRootName": "    public PropertyName findRootName(AnnotatedClass ac) {\n        return null;\n    }", "isIgnorableType": "    public Boolean isIgnorableType(AnnotatedClass ac) { return null; }", "findNamingStrategy": "    public Object findNamingStrategy(AnnotatedClass ac) { return null; }", "findClassDescription": "    public String findClassDescription(AnnotatedClass ac) { return null; }", "findAutoDetectVisibility": "    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n        return checker;\n    }", "findTypeResolver": "    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n            AnnotatedClass ac, JavaType baseType) {\n        return null;\n    }", "findPropertyTypeResolver": "    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType baseType) {\n        return null;\n    }", "findPropertyContentTypeResolver": "    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n            AnnotatedMember am, JavaType containerType) {\n        return null;\n    }", "findSubtypes": "    public List<NamedType> findSubtypes(Annotated a) { return null; }", "findTypeName": "    public String findTypeName(AnnotatedClass ac) { return null; }", "isTypeId": "    public Boolean isTypeId(AnnotatedMember member) { return null; }", "findReferenceType": "    public ReferenceProperty findReferenceType(AnnotatedMember member) { return null; }", "findUnwrappingNameTransformer": "    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { return null; }", "hasIgnoreMarker": "    public boolean hasIgnoreMarker(AnnotatedMember m) { return false; }", "findInjectableValueId": "    public Object findInjectableValueId(AnnotatedMember m) { return null; }", "hasRequiredMarker": "    public Boolean hasRequiredMarker(AnnotatedMember m) { return null; }", "findFormat": "    public JsonFormat.Value findFormat(Annotated memberOrClass) { return null; }", "findWrapperName": "    public PropertyName findWrapperName(Annotated ann) { return null; }", "findPropertyDefaultValue": "    public String findPropertyDefaultValue(Annotated ann) { return null; }", "findImplicitPropertyName": "    public String findImplicitPropertyName(AnnotatedMember member) { return null; }", "findPropertyAccess": "    public JsonProperty.Access findPropertyAccess(Annotated ann) { return null; }", "findSerializer": "    public Object findSerializer(Annotated am) {\n        return null;\n    }", "findKeySerializer": "    public Object findKeySerializer(Annotated am) {\n        return null;\n    }", "findContentSerializer": "    public Object findContentSerializer(Annotated am) {\n        return null;\n    }", "findNullSerializer": "    public Object findNullSerializer(Annotated am) {\n        return null;\n    }", "findSerializationTyping": "    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n        return null;\n    }", "findSerializationConverter": "    public Object findSerializationConverter(Annotated a) {\n        return null;\n    }", "findSerializationContentConverter": "    public Object findSerializationContentConverter(AnnotatedMember a) {\n        return null;\n    }", "findSerializationInclusion": "    public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }", "findSerializationInclusionForContent": "    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n        return defValue;\n    }", "findSerializationType": "    public Class<?> findSerializationType(Annotated a) {\n        return null;\n    }", "findSerializationKeyType": "    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n        return null;\n    }", "findSerializationContentType": "    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n        return null;\n    }", "refineSerializationType": "    public JavaType refineSerializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n        \n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> serClass = findSerializationType(a);\n        if (serClass != null) {\n            if (type.hasRawClass(serClass)) {\n                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n                //    static typing this way\n                type = type.withStaticTyping();\n            } else {\n                try {\n                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                    //   may be needed here too in future?\n                        type = tf.constructGeneralizedType(type, serClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                    type, serClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findSerializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (keyType.hasRawClass(keyClass)) {\n                    keyType = keyType.withStaticTyping();\n                } else {\n                    Class<?> currRaw = keyType.getRawClass();\n                    try {\n                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                        //   specialize (narrow) type sometimes, even if more commonly opposite\n                        //   is needed.\n                        if (keyClass.isAssignableFrom(currRaw)) { // common case\n                            keyType = tf.constructGeneralizedType(keyType, keyClass);\n                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n                            keyType = tf.constructSpecializedType(keyType, keyClass);\n                        } else {\n                            throw new JsonMappingException(null,\n                                    String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                            keyType, keyClass.getName()));\n                        }\n                    } catch (IllegalArgumentException iae) {\n                        throw new JsonMappingException(null,\n                                String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                        type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                        iae);\n                    }\n                }\n                type = ((MapLikeType) type).withKeyType(keyType);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findSerializationContentType(a, contentType);\n           if (contentClass != null) {\n               if (contentType.hasRawClass(contentClass)) {\n                   contentType = contentType.withStaticTyping();\n               } else {\n                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n                   //   specialize (narrow) type sometimes, even if more commonly opposite\n                   //   is needed.\n                   Class<?> currRaw = contentType.getRawClass();\n                   try {\n                       if (contentClass.isAssignableFrom(currRaw)) { // common case\n                           contentType = tf.constructGeneralizedType(contentType, contentClass);\n                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n                           contentType = tf.constructSpecializedType(contentType, contentClass);\n                       } else {\n                           throw new JsonMappingException(null,\n                                   String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                           contentType, contentClass.getName()));\n                       }\n                   } catch (IllegalArgumentException iae) { // shouldn't really happen\n                       throw new JsonMappingException(null,\n                               String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                       type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                       iae);\n                   }\n               }\n               type = type.withContentType(contentType);\n           }\n        }\n        return type;\n    }", "findSerializationPropertyOrder": "    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n        return null;\n    }", "findSerializationSortAlphabetically": "    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n        return null;\n    }", "findAndAddVirtualProperties": "    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n            List<BeanPropertyWriter> properties) { }", "findNameForSerialization": "    public PropertyName findNameForSerialization(Annotated a) {\n        /*\n        if (name != null) {\n            if (name.length() == 0) { // empty String means 'default'\n                return PropertyName.USE_DEFAULT;\n            }\n            return new PropertyName(name);\n        }\n        */\n        return null;\n    }", "hasAsValueAnnotation": "    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n        return false;\n    }", "findEnumValue": "    public String findEnumValue(Enum<?> value) {\n        return value.name();\n    }", "findEnumValues": "    public  String[] findEnumValues(Class<?> enumType, Enum<?>[] enumValues, String[] names) {\n        for (int i = 0, len = enumValues.length; i < len; ++i) {\n            /* 12-Mar-2016, tatu: This is quite tricky, considering that we should NOT\n             *   overwrite values with default `name`... so for now, let's only delegate\n             *   if no value has been set. Still not optimal but has to do\n             */\n            // TODO: In 2.8, stop delegation?\n            if (names[i] == null) {\n                names[i] = findEnumValue(enumValues[i]);\n            }\n        }\n        return names;\n    }", "findDeserializer": "    public Object findDeserializer(Annotated am) {\n        return null;\n    }", "findKeyDeserializer": "    public Object findKeyDeserializer(Annotated am) {\n        return null;\n    }", "findContentDeserializer": "    public Object findContentDeserializer(Annotated am) {\n        return null;\n    }", "findDeserializationConverter": "    public Object findDeserializationConverter(Annotated a) {\n        return null;\n    }", "findDeserializationContentConverter": "    public Object findDeserializationContentConverter(AnnotatedMember a) {\n        return null;\n    }", "refineDeserializationType": "    public JavaType refineDeserializationType(final MapperConfig<?> config,\n            final Annotated a, final JavaType baseType) throws JsonMappingException\n    {\n        JavaType type = baseType;\n        final TypeFactory tf = config.getTypeFactory();\n\n        // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n        //    now-deprecated secondary methods; this because while\n        //    direct sub-class not yet retrofitted may only override\n        //    those methods. With 2.8 or later we may consider removal\n        //    of these methods\n\n        \n        // Ok: start by refining the main type itself; common to all types\n        Class<?> valueClass = findDeserializationType(a, type);\n        if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n            try {\n                type = tf.constructSpecializedType(type, valueClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null,\n                        String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\",\n                                type, valueClass.getName(), a.getName(), iae.getMessage()),\n                                iae);\n            }\n        }\n        // Then further processing for container types\n\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            Class<?> keyClass = findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    type, keyClass.getName(), a.getName(), iae.getMessage()),\n                                    iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) { // collection[like], map[like], array, reference\n            // And then value types for all containers:\n           Class<?> contentClass = findDeserializationContentType(a, contentType);\n           if (contentClass != null) {\n               try {\n                   contentType = tf.constructSpecializedType(contentType, contentClass);\n                   type = type.withContentType(contentType);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(null,\n                           String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   type, contentClass.getName(), a.getName(), iae.getMessage()),\n                                   iae);\n               }\n           }\n        }\n        return type;\n    }", "findDeserializationType": "    public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n        return null;\n    }", "findDeserializationKeyType": "    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n        return null;\n    }", "findDeserializationContentType": "    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) {\n        return null;\n    }", "findValueInstantiator": "    public Object findValueInstantiator(AnnotatedClass ac) {\n        return null;\n    }", "findPOJOBuilderConfig": "    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac) {\n        return null;\n    }", "findNameForDeserialization": "    public PropertyName findNameForDeserialization(Annotated a) {\n        /*\n        if (name != null) {\n            if (name.length() == 0) { // empty String means 'default'\n                return PropertyName.USE_DEFAULT;\n            }\n            return new PropertyName(name);\n        }\n        */\n        return null;\n    }", "hasAnySetterAnnotation": "    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }", "hasAnyGetterAnnotation": "    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n        return false;\n    }", "hasCreatorAnnotation": "    public boolean hasCreatorAnnotation(Annotated a) {\n        return false;\n    }", "findCreatorBinding": "    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n        return null;\n    }", "_findAnnotation": "    protected <A extends Annotation> A _findAnnotation(Annotated annotated,\n            Class<A> annoClass) {\n        return annotated.getAnnotation(annoClass);\n    }", "_hasAnnotation": "    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n        return annotated.hasAnnotation(annoClass);\n    }", "_hasOneOf": "    protected boolean _hasOneOf(Annotated annotated, Class<? extends Annotation>[] annoClasses) {\n        return annotated.hasOneOf(annoClasses);\n    }"}