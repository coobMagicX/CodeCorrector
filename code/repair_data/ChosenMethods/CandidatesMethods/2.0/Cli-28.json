{"setOptions": "    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }", "getOptions": "    protected Options getOptions()\n    {\n        return options;\n    }", "getRequiredOptions": "    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }", "flatten": "    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.", "parse": "    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }", "processProperties": "    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }", "checkRequiredOptions": "    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }", "processArgs": "    public void processArgs(Option opt, ListIterator iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }", "processOption": "    protected void processOption(String arg, ListIterator iter) throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        // get the option represented by arg\n        Option opt = (Option) getOptions().getOption(arg).clone();\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }"}