{"newNodePointer": "    public static NodePointer newNodePointer(\n        QName name,\n        Object bean,\n        Locale locale) \n    {\n        NodePointer pointer = null;\n        if (bean == null) {\n            pointer = new NullPointer(name, locale);\n            return pointer;\n        }\n        \n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            pointer = factories[i].createNodePointer(name, bean, locale);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }", "newChildNodePointer": "    public static NodePointer newChildNodePointer(\n        NodePointer parent,\n        QName name,\n        Object bean) \n    {\n        NodePointerFactory[] factories =\n            JXPathContextReferenceImpl.getNodePointerFactories();\n        for (int i = 0; i < factories.length; i++) {\n            NodePointer pointer =\n                factories[i].createNodePointer(parent, name, bean);\n            if (pointer != null) {\n                return pointer;\n            }\n        }\n        throw new JXPathException(\n            \"Could not allocate a NodePointer for object of \"\n                + bean.getClass());\n    }", "getNamespaceResolver": "    public NamespaceResolver getNamespaceResolver() {\n        if (namespaceResolver == null && parent != null) {\n            namespaceResolver = parent.getNamespaceResolver();\n        }\n        return namespaceResolver;\n    }", "setNamespaceResolver": "    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n        this.namespaceResolver = namespaceResolver;\n    }", "getParent": "    public NodePointer getParent() {\n        NodePointer pointer = parent;\n        while (pointer != null && pointer.isContainer()) {\n            pointer = pointer.getImmediateParentPointer();\n        }\n        return pointer;\n    }", "getImmediateParentPointer": "    public NodePointer getImmediateParentPointer() {\n        return parent;\n    }", "setAttribute": "    public void setAttribute(boolean attribute) {\n        this.attribute = attribute;\n    }", "isAttribute": "    public boolean isAttribute() {\n        return attribute;\n    }", "isRoot": "    public boolean isRoot() {\n        return parent == null;\n    }", "isContainer": "    public boolean isContainer() {\n        return false;\n    }", "getValuePointer": "    public NodePointer getValuePointer() {\n        NodePointer ivp = getImmediateValuePointer();\n        return ivp == this ? this : ivp.getValuePointer();\n    }", "getImmediateValuePointer": "    public NodePointer getImmediateValuePointer() {\n        return this;\n    }", "getRootNode": "    public Object getRootNode() {\n        if (rootNode == null) {\n            rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n        }\n        return rootNode;\n    }", "compareChildNodePointers": "    public abstract int compareChildNodePointers(\n            NodePointer pointer1, NodePointer pointer2);\n\n    /**\n     * Checks if this Pointer matches the supplied NodeTest.\n     */\n    public boolean testNode(NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (isContainer()) {\n                return false;\n            }\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            QName nodeName = getName();\n            if (nodeName == null) {\n                return false;\n            }\n            \n            String testPrefix = testName.getPrefix();\n            String nodePrefix = nodeName.getPrefix();\n            if (!equalStrings(testPrefix, nodePrefix)) {\n                String testNS = getNamespaceURI(testPrefix);\n                String nodeNS = getNamespaceURI(nodePrefix);\n                if (!equalStrings(testNS, nodeNS)) {\n                    return false;\n                }\n            }\n            if (nodeNameTest.isWildcard()) {\n                return true;\n            }\n            return testName.getName().equals(nodeName.getName());\n        }\n        return test instanceof NodeTypeTest\n                && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n    }", "equalStrings": "    private static boolean equalStrings(String s1, String s2) {\n        return s1 == s2 || s1 != null && s1.equals(s2);\n    }", "createPath": "    public NodePointer createPath(JXPathContext context) {\n        return this;\n    }", "remove": "    public void remove() {\n        // It is a no-op\n\n//        System.err.println(\"REMOVING: \" + asPath() + \" \" + getClass());\n//        printPointerChain();\n    }", "createChild": "    public NodePointer createChild(JXPathContext context, QName name, int index)\n    {\n        throw new JXPathException(\"Cannot create an object for path \"\n                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                + \", operation is not allowed for this type of node\");\n    }", "createAttribute": "    public NodePointer createAttribute(JXPathContext context, QName name) {\n        throw new JXPathException(\"Cannot create an attribute for path \"\n                + asPath() + \"/@\" + name\n                + \", operation is not allowed for this type of node\");\n    }", "childIterator": "    public NodeIterator childIterator(\n        NodeTest test,\n        boolean reverse,\n        NodePointer startWith) \n    {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.childIterator(test, reverse, startWith);\n    }", "attributeIterator": "    public NodeIterator attributeIterator(QName qname) {\n        NodePointer valuePointer = getValuePointer();\n        return valuePointer == null || valuePointer == this ? null\n                : valuePointer.attributeIterator(qname);\n    }", "namespaceIterator": "    public NodeIterator namespaceIterator() {\n        return null;\n    }", "namespacePointer": "    public NodePointer namespacePointer(String namespace) {\n        return null;\n    }", "getNamespaceURI": "    public String getNamespaceURI() {\n        return null;\n    }", "getDefaultNamespaceURI": "    protected String getDefaultNamespaceURI() {\n        return null;\n    }", "getPointerByID": "    public Pointer getPointerByID(JXPathContext context, String id) {\n        return context.getPointerByID(id);\n    }", "getPointerByKey": "    public Pointer getPointerByKey(\n        JXPathContext context,\n        String key,\n        String value) \n    {\n        return context.getPointerByKey(key, value);\n    }", "clone": "    public Object clone() {\n        try {\n            NodePointer ptr = (NodePointer) super.clone();\n            if (parent != null) {\n                ptr.parent = (NodePointer) parent.clone();\n            }\n            return ptr;\n        }\n        catch (CloneNotSupportedException ex) {\n            // Of course it is supported\n            ex.printStackTrace();\n        }\n        return null;\n    }", "toString": "    public String toString() {\n        return asPath();\n    }", "compareTo": "    public int compareTo(Object object) {\n        // Let it throw a ClassCastException\n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        // Task 1: find the common parent\n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }", "compareNodePointers": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }", "printPointerChain": "    public void printPointerChain() {\n        printDeep(this, \"\");\n    }", "printDeep": "    private static void printDeep(NodePointer pointer, String indent) {\n        if (indent.length() == 0) {\n            System.err.println(\n                \"POINTER: \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        else {\n            System.err.println(\n                indent\n                    + \" of \"\n                    + pointer\n                    + \"(\"\n                    + pointer.getClass().getName()\n                    + \")\");\n        }\n        if (pointer.getImmediateParentPointer() != null) {\n            printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n        }\n    }"}