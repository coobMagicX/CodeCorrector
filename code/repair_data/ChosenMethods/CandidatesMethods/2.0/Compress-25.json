{"read": "        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }", "readFromInflater": "    private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }", "close": "    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            in.close();\n            inf.end();\n        }\n    }", "skip": "        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }", "matches": "    public static boolean matches(byte[] signature, int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) // empty zip\n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) // split zip\n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }", "checksig": "    private static boolean checksig(byte[] signature, byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }", "drainCurrentEntryData": "    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \" + current.entry.getName());\n            } else {\n                count(n);\n                remaining -= n;\n            }\n        }\n    }", "getBytesInflated": "    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }", "fill": "    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }", "bufferContainsSignature": "    private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    // found a LFH or CFH:\n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    // found DD:\n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    // * push back bytes read in excess as well as the data\n                    //   descriptor\n                    // * copy the remaining bytes to cache\n                    // * read data descriptor\n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }", "pushback": "    private void pushback(byte[] buf, int offset, int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }", "skipRemainderOfArchive": "    private void skipRemainderOfArchive() throws IOException {\n        // skip over central directory. One LFH has been read too much\n        // already.  The calculation discounts file names and extra\n        // data so it will be too short.\n        realSkip(entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip(ZipFile.MIN_EOCD_SIZE - WORD /* signature */ - SHORT /* comment len */);\n        readFully(SHORT_BUF);\n        // file comment\n        realSkip(ZipShort.getValue(SHORT_BUF));\n    }", "findEocdRecord": "    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }", "available": "        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }"}