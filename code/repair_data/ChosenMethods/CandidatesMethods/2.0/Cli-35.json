{"addOptionGroup": "    public Options addOptionGroup(OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }", "getOptionGroups": "    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }", "addOption": "    public Options addOption(Option opt)\n    {\n        String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }", "getOptions": "    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }", "helpOptions": "    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }", "getRequiredOptions": "    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }", "getOption": "    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }", "getMatchingOptions": "    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }", "hasOption": "    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }", "hasLongOption": "    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }", "hasShortOption": "    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }", "getOptionGroup": "    public OptionGroup getOptionGroup(Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }", "toString": "    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }"}