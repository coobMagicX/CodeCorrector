{"isNoType": "  public boolean isNoType() {\n    return false;\n  }", "isNoResolvedType": "  public boolean isNoResolvedType() {\n    return false;\n  }", "isNoObjectType": "  public boolean isNoObjectType() {\n    return false;\n  }", "equals": "  public boolean equals(Object jsType) {\n    return (jsType instanceof JSType) ?\n        isEquivalentTo((JSType) jsType) : false;\n  }", "dereference": "  public final ObjectType dereference() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return ObjectType.cast(autobox == null ? restricted : autobox);\n  }", "visit": "  public abstract <T> T visit(Visitor<T> visitor);\n\n  /**\n   * Force this type to resolve, even if the registry is in a lazy\n   * resolving mode.\n   * @see #resolve\n   */\n  public final JSType forceResolve(ErrorReporter t, StaticScope<JSType> scope) {\n    ResolveMode oldResolveMode = registry.getResolveMode();\n    registry.setResolveMode(ResolveMode.IMMEDIATE);\n    JSType result = resolve(t, scope);\n    registry.setResolveMode(oldResolveMode);\n    return result;\n  }", "resolve": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }"}