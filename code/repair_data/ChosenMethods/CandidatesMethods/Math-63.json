{"binomialCoefficientDouble": "    public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n\n        return FastMath.floor(result + 0.5);\n    }", "cosh": "    public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }", "equals": "    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }", "factorial": "    public static long factorial(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }", "factorialDouble": "    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n    }", "gcd": "    public static long gcd(final long p, final long q) {\n        long u = p;\n        long v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n                throw MathRuntimeException.createArithmeticException(\n                        LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                        p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^63, while positive numbers can only be as large as 2^63-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 63) {\n            throw MathRuntimeException.createArithmeticException(\n                    LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                    p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1L << k); // gcd is u*2^k\n    }", "hash": "    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }", "indicator": "    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }", "lcm": "    public static long lcm(long a, long b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Long.MIN_VALUE){\n            throw MathRuntimeException.createArithmeticException(\n                LocalizedFormats.LCM_OVERFLOW_64_BITS,\n                a, b);\n        }\n        return lcm;\n    }", "log": "    public static double log(double base, double x) {\n        return FastMath.log(x)/FastMath.log(base);\n    }", "scalb": "    public static double scalb(final double d, final int scaleFactor) {\n\n        // handling of some important special cases\n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        // split the double in raw components\n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        // shift the exponent\n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }", "normalizeArray": "     public static double[] normalizeArray(double[] values, double normalizedSum)\n       throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }", "round": "    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)FastMath.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }", "sign": "    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }", "sinh": "    public static double sinh(double x) {\n        return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;\n    }", "pow": "    public static BigInteger pow(final BigInteger k, BigInteger e)\n        throws IllegalArgumentException {\n\n        if (e.compareTo(BigInteger.ZERO) < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (!BigInteger.ZERO.equals(e)) {\n            if (e.testBit(0)) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e.shiftRight(1);\n        }\n\n        return result;\n\n    }", "distance1": "    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }", "distance": "    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }"}