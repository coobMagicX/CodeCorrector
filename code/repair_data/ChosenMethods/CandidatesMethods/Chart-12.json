{"getDataset": "    public CategoryDataset getDataset() {\n        return this.dataset;\n    }", "setDataset": "    public void setDataset(CategoryDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of\n        // change listeners...\n        if (this.dataset != null) {\n            this.dataset.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self to trigger plot change event\n        datasetChanged(new DatasetChangeEvent(this, dataset));\n    }", "getPieChart": "    public JFreeChart getPieChart() {\n        return this.pieChart;\n    }", "setPieChart": "    public void setPieChart(JFreeChart pieChart) {\n        if (pieChart == null) {\n            throw new IllegalArgumentException(\"Null 'pieChart' argument.\");\n        }\n        if (!(pieChart.getPlot() instanceof PiePlot)) {\n            throw new IllegalArgumentException(\"The 'pieChart' argument must \"\n                    + \"be a chart based on a PiePlot.\");\n        }\n        this.pieChart = pieChart;\n        fireChangeEvent();\n    }", "getDataExtractOrder": "    public TableOrder getDataExtractOrder() {\n        return this.dataExtractOrder;\n    }", "setDataExtractOrder": "    public void setDataExtractOrder(TableOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument\");\n        }\n        this.dataExtractOrder = order;\n        fireChangeEvent();\n    }", "getAggregatedItemsKey": "    public Comparable getAggregatedItemsKey() {\n        return this.aggregatedItemsKey;\n    }", "setAggregatedItemsKey": "    public void setAggregatedItemsKey(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.aggregatedItemsKey = key;\n        fireChangeEvent();\n    }", "getAggregatedItemsPaint": "    public Paint getAggregatedItemsPaint() {\n        return this.aggregatedItemsPaint;\n    }", "setAggregatedItemsPaint": "    public void setAggregatedItemsPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.aggregatedItemsPaint = paint;\n        fireChangeEvent();\n    }", "draw": "    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        // check that there is some data to display...\n        if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawNoDataMessage(g2, area);\n            return;\n        }\n\n        int pieCount = 0;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            pieCount = this.dataset.getRowCount();\n        }\n        else {\n            pieCount = this.dataset.getColumnCount();\n        }\n\n        // the columns variable is always >= rows\n        int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\n        int displayRows\n            = (int) Math.ceil((double) pieCount / (double) displayCols);\n\n        // swap rows and columns to match plotArea shape\n        if (displayCols > displayRows && area.getWidth() < area.getHeight()) {\n            int temp = displayCols;\n            displayCols = displayRows;\n            displayRows = temp;\n        }\n\n        prefetchSectionPaints();\n\n        int x = (int) area.getX();\n        int y = (int) area.getY();\n        int width = ((int) area.getWidth()) / displayCols;\n        int height = ((int) area.getHeight()) / displayRows;\n        int row = 0;\n        int column = 0;\n        int diff = (displayRows * displayCols) - pieCount;\n        int xoffset = 0;\n        Rectangle rect = new Rectangle();\n\n        for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\n            rect.setBounds(x + xoffset + (width * column), y + (height * row),\n                    width, height);\n\n            String title = null;\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                title = this.dataset.getRowKey(pieIndex).toString();\n            }\n            else {\n                title = this.dataset.getColumnKey(pieIndex).toString();\n            }\n            this.pieChart.setTitle(title);\n\n            PieDataset piedataset = null;\n            PieDataset dd = new CategoryToPieDataset(this.dataset,\n                    this.dataExtractOrder, pieIndex);\n            if (this.limit > 0.0) {\n                piedataset = DatasetUtilities.createConsolidatedPieDataset(\n                        dd, this.aggregatedItemsKey, this.limit);\n            }\n            else {\n                piedataset = dd;\n            }\n            PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\n            piePlot.setDataset(piedataset);\n            piePlot.setPieIndex(pieIndex);\n\n            // update the section colors to match the global colors...\n            for (int i = 0; i < piedataset.getItemCount(); i++) {\n                Comparable key = piedataset.getKey(i);\n                Paint p;\n                if (key.equals(this.aggregatedItemsKey)) {\n                    p = this.aggregatedItemsPaint;\n                }\n                else {\n                    p = (Paint) this.sectionPaints.get(key);\n                }\n                piePlot.setSectionPaint(key, p);\n            }\n\n            ChartRenderingInfo subinfo = null;\n            if (info != null) {\n                subinfo = new ChartRenderingInfo();\n            }\n            this.pieChart.draw(g2, rect, subinfo);\n            if (info != null) {\n                info.getOwner().getEntityCollection().addAll(\n                        subinfo.getEntityCollection());\n                info.addSubplotInfo(subinfo.getPlotInfo());\n            }\n\n            ++column;\n            if (column == displayCols) {\n                column = 0;\n                ++row;\n\n                if (row == displayRows - 1 && diff != 0) {\n                    xoffset = (diff * width) / 2;\n                }\n            }\n        }\n\n    }", "prefetchSectionPaints": "    private void prefetchSectionPaints() {\n\n        // pre-fetch the colors for each key...this is because the subplots\n        // may not display every key, but we need the coloring to be\n        // consistent...\n\n        PiePlot piePlot = (PiePlot) getPieChart().getPlot();\n\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            // column keys provide potential keys for individual pies\n            for (int c = 0; c < this.dataset.getColumnCount(); c++) {\n                Comparable key = this.dataset.getColumnKey(c);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n        else {\n            // row keys provide potential keys for individual pies\n            for (int r = 0; r < this.dataset.getRowCount(); r++) {\n                Comparable key = this.dataset.getRowKey(r);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n\n    }", "equals": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiplePiePlot)) {\n            return false;\n        }\n        MultiplePiePlot that = (MultiplePiePlot) obj;\n        if (this.dataExtractOrder != that.dataExtractOrder) {\n            return false;\n        }\n        if (this.limit != that.limit) {\n            return false;\n        }\n        if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\n                that.aggregatedItemsPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }"}