{"append": "  public ChainableReverseAbstractInterpreter append(\n      ChainableReverseAbstractInterpreter lastLink) {\n    Preconditions.checkArgument(lastLink.nextLink == null);\n    this.nextLink = lastLink;\n    lastLink.firstLink = this.firstLink;\n    return lastLink;\n  }", "firstPreciserScopeKnowingConditionOutcome": "  protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    return firstLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome);\n  }", "nextPreciserScopeKnowingConditionOutcome": "  protected FlowScope nextPreciserScopeKnowingConditionOutcome(Node condition,\n      FlowScope blindScope, boolean outcome) {\n    return nextLink != null ? nextLink.getPreciserScopeKnowingConditionOutcome(\n        condition, blindScope, outcome) : blindScope;\n  }", "getTypeIfRefinable": "  protected JSType getTypeIfRefinable(Node node, FlowScope scope) {\n    switch (node.getType()) {\n      case Token.NAME:\n        StaticSlot<JSType> nameVar = scope.getSlot(node.getString());\n        if (nameVar != null) {\n          JSType nameVarType = nameVar.getType();\n          if (nameVarType == null) {\n            nameVarType = node.getJSType();\n          }\n          return nameVarType;\n        }\n        return null;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        if (qualifiedName == null) {\n          return null;\n        }\n        StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);\n        JSType propVarType = null;\n        if (propVar != null) {\n          propVarType = propVar.getType();\n        }\n        if (propVarType == null) {\n          propVarType = node.getJSType();\n        }\n        if (propVarType == null) {\n          propVarType = getNativeType(UNKNOWN_TYPE);\n        }\n        return propVarType;\n    }\n    return null;\n  }", "declareNameInScope": "  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n        // \"this\" references aren't currently modeled in the CFG.\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }", "caseTopType": "    protected JSType caseTopType(JSType topType) {\n      JSType result = topType;\n      if (resultEqualsValue) {\n        JSType typeByName = getNativeTypeForTypeOf(value);\n        if (typeByName != null) {\n          result = typeByName;\n        }\n      }\n      return result;\n    }", "caseAllType": "    public JSType caseAllType() {\n      return caseTopType(getNativeType(ALL_TYPE));\n    }", "caseUnknownType": "    public JSType caseUnknownType() {\n      return caseTopType(getNativeType(UNKNOWN_TYPE));\n    }", "caseUnionType": "    public JSType caseUnionType(UnionType type) {\n      JSType restricted = null;\n      for (JSType alternate : type.getAlternates()) {\n        JSType restrictedAlternate = alternate.visit(this);\n        if (restrictedAlternate != null) {\n          if (restricted == null) {\n            restricted = restrictedAlternate;\n          } else {\n            restricted = restrictedAlternate.getLeastSupertype(restricted);\n          }\n        }\n      }\n      return restricted;\n    }", "caseNoType": "    public JSType caseNoType() {\n      return getNativeType(NO_TYPE);\n    }", "caseEnumElementType": "    public JSType caseEnumElementType(EnumElementType enumElementType) {\n      // NOTE(nicksantos): This is a white lie. Suppose we have:\n      // /** @enum {string|number} */ var MyEnum = ...;\n      // if (goog.isNumber(myEnumInstance)) {\n      //   /* what is myEnumInstance here? */\n      // }\n      // There is no type that represents {MyEnum - string}. What we really\n      // need is a notion of \"enum subtyping\", so that we could dynamically\n      // create a subtype of MyEnum restricted by string. In any case,\n      // this should catch the common case.\n      JSType type = enumElementType.getPrimitiveType().visit(this);\n      if (type != null && enumElementType.getPrimitiveType().equals(type)) {\n        return enumElementType;\n      } else {\n        return type;\n      }\n    }", "caseParameterizedType": "    public JSType caseParameterizedType(ParameterizedType type) {\n      return caseObjectType(type);\n    }", "caseTemplateType": "    public JSType caseTemplateType(TemplateType templateType) {\n      return caseObjectType(templateType);\n    }", "caseNoObjectType": "    public JSType caseNoObjectType() {\n      return (value.equals(\"object\") || value.equals(\"function\")) ==\n          resultEqualsValue ? getNativeType(NO_OBJECT_TYPE) : null;\n    }", "caseBooleanType": "    public JSType caseBooleanType() {\n      return matchesExpectation(\"boolean\") ? getNativeType(BOOLEAN_TYPE) : null;\n    }", "caseFunctionType": "    public JSType caseFunctionType(FunctionType type) {\n      return matchesExpectation(\"function\") ? type : null;\n    }", "caseNullType": "    public JSType caseNullType() {\n      return matchesExpectation(\"object\") ? getNativeType(NULL_TYPE) : null;\n    }", "caseNumberType": "    public JSType caseNumberType() {\n      return matchesExpectation(\"number\") ? getNativeType(NUMBER_TYPE) : null;\n    }", "caseObjectType": "    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }", "caseStringType": "    public JSType caseStringType() {\n      return matchesExpectation(\"string\") ? getNativeType(STRING_TYPE) : null;\n    }", "caseVoidType": "    public JSType caseVoidType() {\n      return matchesExpectation(\"undefined\") ? getNativeType(VOID_TYPE) : null;\n    }", "getRestrictedByTypeOfResult": "  JSType getRestrictedByTypeOfResult(JSType type, String value,\n                                     boolean resultEqualsValue) {\n    if (type == null) {\n      if (resultEqualsValue) {\n        JSType result = getNativeTypeForTypeOf(value);\n        return result == null ? getNativeType(UNKNOWN_TYPE) : result;\n      } else {\n        return null;\n      }\n    }\n    return type.visit(\n        new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));\n  }", "getNativeType": "  JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }", "getNativeTypeForTypeOf": "  private JSType getNativeTypeForTypeOf(String value) {\n    if (value.equals(\"number\")) {\n      return getNativeType(NUMBER_TYPE);\n    } else if (value.equals(\"boolean\")) {\n      return getNativeType(BOOLEAN_TYPE);\n    } else if (value.equals(\"string\")) {\n      return getNativeType(STRING_TYPE);\n    } else if (value.equals(\"undefined\")) {\n      return getNativeType(VOID_TYPE);\n    } else if (value.equals(\"function\")) {\n      return getNativeType(U2U_CONSTRUCTOR_TYPE);\n    } else {\n      return null;\n    }\n  }"}