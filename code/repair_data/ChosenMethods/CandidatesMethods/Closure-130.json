{"process": "  public void process(Node externs, Node root) {\n    GlobalNamespace namespace;\n    if (collapsePropertiesOnExternTypes) {\n      namespace = new GlobalNamespace(compiler, externs, root);\n    } else {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n\n    if (inlineAliases) {\n      inlineAliases(namespace);\n    }\n    nameMap = namespace.getNameIndex();\n    globalNames = namespace.getNameForest();\n    checkNamespaces();\n\n    for (Name n : globalNames) {\n      flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName());\n    }\n\n    // We collapse property definitions after collapsing property references\n    // because this step can alter the parse tree above property references,\n    // invalidating the node ancestry stored with each reference.\n    for (Name n : globalNames) {\n      collapseDeclarationOfNameAndDescendants(n, n.getBaseName());\n    }\n  }", "inlineAliases": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }", "inlineAliasIfPossible": "  private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n    // Ensure that the alias is assigned to a local variable at that\n    // variable's declaration. If the alias's parent is a NAME,\n    // then the NAME must be the child of a VAR node, and we must\n    // be in a VAR assignment.\n    Node aliasParent = alias.node.getParent();\n    if (aliasParent.isName()) {\n      // Ensure that the local variable is well defined and never reassigned.\n      Scope scope = alias.scope;\n      Var aliasVar = scope.getVar(aliasParent.getString());\n      ReferenceCollectingCallback collector =\n          new ReferenceCollectingCallback(compiler,\n              ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n              Predicates.<Var>equalTo(aliasVar));\n      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n\n      ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n      if (aliasRefs.isWellDefined()\n          && aliasRefs.firstReferenceIsAssigningDeclaration()\n          && aliasRefs.isAssignedOnceInLifetime()) {\n        // The alias is well-formed, so do the inlining now.\n        int size = aliasRefs.references.size();\n        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n        for (int i = 1; i < size; i++) {\n          ReferenceCollectingCallback.Reference aliasRef =\n              aliasRefs.references.get(i);\n\n          Node newNode = alias.node.cloneTree();\n          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n          newNodes.add(newNode);\n        }\n\n        // just set the original alias to null.\n        aliasParent.replaceChild(alias.node, IR.nullNode());\n        compiler.reportCodeChange();\n\n        // Inlining the variable may have introduced new references\n        // to descendants of {@code name}. So those need to be collected now.\n        namespace.scanNewNodes(alias.scope, newNodes);\n        return true;\n      }\n    }\n\n    return false;\n  }", "checkNamespaces": "  private void checkNamespaces() {\n    for (Name name : nameMap.values()) {\n      if (name.isNamespace() &&\n          (name.aliasingGets > 0 || name.localSets + name.globalSets > 1 ||\n           name.deleteProps > 0)) {\n        boolean initialized = name.getDeclaration() != null;\n        for (Ref ref : name.getRefs()) {\n          if (ref == name.getDeclaration()) {\n            continue;\n          }\n\n          if (ref.type == Ref.Type.DELETE_PROP) {\n            if (initialized) {\n              warnAboutNamespaceRedefinition(name, ref);\n            }\n          } else if (\n              ref.type == Ref.Type.SET_FROM_GLOBAL ||\n              ref.type == Ref.Type.SET_FROM_LOCAL) {\n            if (initialized) {\n              warnAboutNamespaceRedefinition(name, ref);\n            }\n\n            initialized = true;\n          } else if (ref.type == Ref.Type.ALIASING_GET) {\n            warnAboutNamespaceAliasing(name, ref);\n          }\n        }\n      }\n    }\n  }", "warnAboutNamespaceAliasing": "  private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) {\n    compiler.report(\n        JSError.make(ref.getSourceName(), ref.node,\n                     UNSAFE_NAMESPACE_WARNING, nameObj.getFullName()));\n  }", "warnAboutNamespaceRedefinition": "  private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) {\n    compiler.report(\n        JSError.make(ref.getSourceName(), ref.node,\n                     NAMESPACE_REDEFINED_WARNING, nameObj.getFullName()));\n  }", "flattenReferencesToCollapsibleDescendantNames": "  private void flattenReferencesToCollapsibleDescendantNames(\n      Name n, String alias) {\n    if (n.props == null) return;\n\n    for (Name p : n.props) {\n      String propAlias = appendPropForAlias(alias, p.getBaseName());\n\n      if (p.canCollapse()) {\n        flattenReferencesTo(p, propAlias);\n      } else if (p.isSimpleStubDeclaration()) {\n        flattenSimpleStubDeclaration(p, propAlias);\n      }\n\n      flattenReferencesToCollapsibleDescendantNames(p, propAlias);\n    }\n  }", "flattenReferencesTo": "  private void flattenReferencesTo(Name n, String alias) {\n    String originalName = n.getFullName();\n    for (Ref r : n.getRefs()) {\n      if (r == n.getDeclaration()) {\n        // Declarations are handled separately.\n        continue;\n      }\n\n      Node rParent = r.node.getParent();\n\n      // There are two cases when we shouldn't flatten a reference:\n      // 1) Object literal keys, because duplicate keys show up as refs.\n      // 2) References inside a complex assign. (a = x.y = 0). These are\n      //    called TWIN references, because they show up twice in the\n      //    reference list. Only collapse the set, not the alias.\n      if (!NodeUtil.isObjectLitKey(r.node) &&\n          (r.getTwin() == null || r.isSet())) {\n        flattenNameRef(alias, r.node, rParent, originalName);\n      }\n    }\n\n    // Flatten all occurrences of a name as a prefix of its subnames. For\n    // example, if {@code n} corresponds to the name \"a.b\", then \"a.b\" will be\n    // replaced with \"a$b\" in all occurrences of \"a.b.c\", \"a.b.c.d\", etc.\n    if (n.props != null) {\n      for (Name p : n.props) {\n        flattenPrefixes(alias, p, 1);\n      }\n    }\n  }", "flattenPrefixes": "  private void flattenPrefixes(String alias, Name n, int depth) {\n    // Only flatten the prefix of a name declaration if the name being\n    // initialized is fully qualified (i.e. not an object literal key).\n    String originalName = n.getFullName();\n    Ref decl = n.getDeclaration();\n    if (decl != null && decl.node != null &&\n        decl.node.isGetProp()) {\n      flattenNameRefAtDepth(alias, decl.node, depth, originalName);\n    }\n\n    for (Ref r : n.getRefs()) {\n      if (r == decl) {\n        // Declarations are handled separately.\n        continue;\n      }\n\n      // References inside a complex assign (a = x.y = 0)\n      // have twins. We should only flatten one of the twins.\n      if (r.getTwin() == null || r.isSet()) {\n        flattenNameRefAtDepth(alias, r.node, depth, originalName);\n      }\n    }\n\n    if (n.props != null) {\n      for (Name p : n.props) {\n        flattenPrefixes(alias, p, depth + 1);\n      }\n    }\n  }", "flattenNameRefAtDepth": "  private void flattenNameRefAtDepth(String alias, Node n, int depth,\n      String originalName) {\n    // This method has to work for both GETPROP chains and, in rare cases,\n    // OBJLIT keys, possibly nested. That's why we check for children before\n    // proceeding. In the OBJLIT case, we don't need to do anything.\n    int nType = n.getType();\n    boolean isQName = nType == Token.NAME || nType == Token.GETPROP;\n    boolean isObjKey = NodeUtil.isObjectLitKey(n);\n    Preconditions.checkState(isObjKey || isQName);\n    if (isQName) {\n      for (int i = 1; i < depth && n.hasChildren(); i++) {\n        n = n.getFirstChild();\n      }\n      if (n.hasChildren()) {\n        flattenNameRef(alias, n.getFirstChild(), n, originalName);\n      }\n    }\n  }", "flattenNameRef": "  private void flattenNameRef(String alias, Node n, Node parent,\n      String originalName) {\n    // BEFORE:\n    //   getprop\n    //     getprop\n    //       name a\n    //       string b\n    //     string c\n    // AFTER:\n    //   name a$b$c\n    Node ref = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, n, originalName);\n    NodeUtil.copyNameAnnotations(n.getLastChild(), ref);\n    if (parent.isCall() && n == parent.getFirstChild()) {\n      // The node was a call target, we are deliberately flatten these as\n      // we node the \"this\" isn't provided by the namespace. Mark it as such:\n      parent.putBooleanProp(Node.FREE_CALL, true);\n    }\n\n    JSType type = n.getJSType();\n    if (type != null) {\n      ref.setJSType(type);\n    }\n    parent.replaceChild(n, ref);\n    compiler.reportCodeChange();\n  }", "collapseDeclarationOfNameAndDescendants": "  private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\n    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\n\n    // Handle this name first so that nested object literals get unrolled.\n    if (n.canCollapse()) {\n      updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);\n    }\n\n    if (n.props != null) {\n      for (Name p : n.props) {\n        // Recurse first so that saved node ancestries are intact when needed.\n        collapseDeclarationOfNameAndDescendants(\n            p, appendPropForAlias(alias, p.getBaseName()));\n\n        if (!p.inExterns && canCollapseChildNames &&\n            p.getDeclaration() != null &&\n            p.canCollapse() &&\n            p.getDeclaration().node != null &&\n            p.getDeclaration().node.getParent() != null &&\n            p.getDeclaration().node.getParent().isAssign()) {\n          updateSimpleDeclaration(\n              appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration());\n        }\n      }\n    }\n  }", "updateObjLitOrFunctionDeclaration": "  private void updateObjLitOrFunctionDeclaration(\n      Name n, String alias, boolean canCollapseChildNames) {\n    Ref decl = n.getDeclaration();\n    if (decl == null) {\n      // Some names do not have declarations, because they\n      // are only defined in local scopes.\n      return;\n    }\n\n    if (decl.getTwin() != null) {\n      // Twin declarations will get handled when normal references\n      // are handled.\n      return;\n    }\n\n    switch (decl.node.getParent().getType()) {\n      case Token.ASSIGN:\n        updateObjLitOrFunctionDeclarationAtAssignNode(\n            n, alias, canCollapseChildNames);\n        break;\n      case Token.VAR:\n        updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);\n        break;\n      case Token.FUNCTION:\n        updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);\n        break;\n    }\n  }", "updateObjLitOrFunctionDeclarationAtAssignNode": "  private void updateObjLitOrFunctionDeclarationAtAssignNode(\n      Name n, String alias, boolean canCollapseChildNames) {\n    // NOTE: It's important that we don't add additional nodes\n    // (e.g. a var node before the exprstmt) because the exprstmt might be\n    // the child of an if statement that's not inside a block).\n\n    Ref ref = n.getDeclaration();\n    Node rvalue = ref.node.getNext();\n    Node varNode = new Node(Token.VAR);\n    Node varParent = ref.node.getAncestor(3);\n    Node gramps = ref.node.getAncestor(2);\n    boolean isObjLit = rvalue.isObjectLit();\n    boolean insertedVarNode = false;\n\n    if (isObjLit && n.canEliminate()) {\n      // Eliminate the object literal altogether.\n      varParent.replaceChild(gramps, varNode);\n      ref.node = null;\n      insertedVarNode = true;\n\n    } else if (!n.isSimpleName()) {\n      // Create a VAR node to declare the name.\n      if (rvalue.isFunction()) {\n        checkForHosedThisReferences(rvalue, n.docInfo, n);\n      }\n\n      ref.node.getParent().removeChild(rvalue);\n\n      Node nameNode = NodeUtil.newName(\n          compiler.getCodingConvention(),\n          alias, ref.node.getAncestor(2), n.getFullName());\n\n      JSDocInfo info = ref.node.getParent().getJSDocInfo();\n      if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) ||\n          (info != null && info.isConstant())) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n\n      if (info != null) {\n        varNode.setJSDocInfo(info);\n      }\n      varNode.addChildToBack(nameNode);\n      nameNode.addChildToFront(rvalue);\n      varParent.replaceChild(gramps, varNode);\n\n      // Update the node ancestry stored in the reference.\n      ref.node = nameNode;\n      insertedVarNode = true;\n    }\n\n    if (canCollapseChildNames) {\n      if (isObjLit) {\n        declareVarsForObjLitValues(\n            n, alias, rvalue,\n            varNode, varParent.getChildBefore(varNode), varParent);\n      }\n\n      addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n    }\n\n    if (insertedVarNode) {\n      if (!varNode.hasChildren()) {\n        varParent.removeChild(varNode);\n      }\n      compiler.reportCodeChange();\n    }\n  }", "checkForHosedThisReferences": "  private void checkForHosedThisReferences(Node function, JSDocInfo docInfo,\n      final Name name) {\n    // A function is getting collapsed. Make sure that if it refers to\n    // \"this\", it must be a constructor or documented with @this.\n    if (docInfo == null ||\n        (!docInfo.isConstructor() && !docInfo.hasThisType())) {\n      NodeTraversal.traverse(compiler, function.getLastChild(),\n          new NodeTraversal.AbstractShallowCallback() {\n            @Override\n            public void visit(NodeTraversal t, Node n, Node parent) {\n              if (n.isThis()) {\n                compiler.report(\n                    JSError.make(name.getDeclaration().getSourceName(), n,\n                        UNSAFE_THIS, name.getFullName()));\n              }\n            }\n          });\n    }\n  }", "updateObjLitOrFunctionDeclarationAtVarNode": "  private void updateObjLitOrFunctionDeclarationAtVarNode(\n      Name n, boolean canCollapseChildNames) {\n    if (!canCollapseChildNames) {\n      return;\n    }\n\n    Ref ref = n.getDeclaration();\n    String name = ref.node.getString();\n    Node rvalue = ref.node.getFirstChild();\n    Node varNode = ref.node.getParent();\n    Node gramps = varNode.getParent();\n\n    boolean isObjLit = rvalue.isObjectLit();\n    int numChanges = 0;\n\n    if (isObjLit) {\n      numChanges += declareVarsForObjLitValues(\n          n, name, rvalue, varNode, gramps.getChildBefore(varNode),\n          gramps);\n    }\n\n    numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\n\n    if (isObjLit && n.canEliminate()) {\n      varNode.removeChild(ref.node);\n      if (!varNode.hasChildren()) {\n        gramps.removeChild(varNode);\n      }\n      numChanges++;\n\n      // Clear out the object reference, since we've eliminated it from the\n      // parse tree.\n      ref.node = null;\n    }\n\n    if (numChanges > 0) {\n      compiler.reportCodeChange();\n    }\n  }", "updateFunctionDeclarationAtFunctionNode": "  private void updateFunctionDeclarationAtFunctionNode(\n      Name n, boolean canCollapseChildNames) {\n    if (!canCollapseChildNames) {\n      return;\n    }\n\n    Ref ref = n.getDeclaration();\n    String fnName = ref.node.getString();\n    addStubsForUndeclaredProperties(\n        n, fnName, ref.node.getAncestor(2), ref.node.getParent());\n  }"}