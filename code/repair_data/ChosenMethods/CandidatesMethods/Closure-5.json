{"process": "  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }", "afterExitScope": "    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        if (isVarInlineForbidden(v)) {\n          continue;\n        }\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        if (isInlinableObject(referenceInfo.references)) {\n          // Blacklist the object itself, as well as any other values\n          // that it refers to, since they will have been moved around.\n          staleVars.add(v);\n\n          Reference declaration = referenceInfo.references.get(0);\n          Reference init = referenceInfo.getInitializingReference();\n\n          // Split up the object into individual variables if the object\n          // is never referenced directly in full.\n          splitObject(v, declaration, init, referenceInfo);\n        }\n      }\n    }", "blacklistVarReferencesInTree": "    private void blacklistVarReferencesInTree(Node root, final Scope scope) {\n      NodeUtil.visitPreOrder(root, new NodeUtil.Visitor() {\n        @Override\n        public void visit(Node node) {\n          if (node.isName()) {\n            staleVars.add(scope.getVar(node.getString()));\n          }\n        }\n      }, NodeUtil.MATCH_NOT_FUNCTION);\n    }", "isInlinableObject": "    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore most indirect references, like x.y (but not x.y(),\n        // since the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }", "isVarOrAssignExprLhs": "    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      return parent.isVar() ||\n          (parent.isAssign()\n              && parent.getFirstChild() == n\n              && parent.getParent().isExprResult());\n    }", "computeVarList": "    private Map<String, String> computeVarList(\n        Var v, ReferenceCollection referenceInfo) {\n      Map<String, String> varmap = Maps.newLinkedHashMap();\n\n      for (Reference ref : referenceInfo.references) {\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          Node val = ref.getAssignedValue();\n          if (val != null) {\n            Preconditions.checkState(val.isObjectLit());\n            for (Node child = val.getFirstChild(); child != null;\n                 child = child.getNext()) {\n              String varname = child.getString();\n              if (varmap.containsKey(varname)) {\n                continue;\n              }\n\n              String var = VAR_PREFIX + varname + \"_\" +\n                safeNameIdSupplier.get();\n              varmap.put(varname, var);\n            }\n          }\n        } else if (ref.getParent().isVar()) {\n          // This is the var. There is no value.\n        } else {\n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          // The key being looked up in the original map.\n          String varname = getprop.getLastChild().getString();\n          if (varmap.containsKey(varname)) {\n            continue;\n          }\n\n          String var = VAR_PREFIX + varname + \"_\" + safeNameIdSupplier.get();\n          varmap.put(varname, var);\n        }\n      }\n\n      return varmap;\n    }", "fillInitialValues": "    private void fillInitialValues(Reference init, Map<String, Node> initvals) {\n      Node object = init.getAssignedValue();\n      Preconditions.checkState(object.isObjectLit());\n      for (Node key = object.getFirstChild(); key != null;\n           key = key.getNext()) {\n        initvals.put(key.getString(), key.removeFirstChild());\n      }\n    }", "replaceAssignmentExpression": "    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.isObjectLit());\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = IR.trueNode();\n      } else {\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(IR.trueNode());\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n      }\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.isVar()) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }", "splitObject": "    private void splitObject(Var v, Reference declaration,\n                             Reference init,\n                             ReferenceCollection referenceInfo) {\n      // First figure out the FULL set of possible keys, so that they\n      // can all be properly set as necessary.\n      Map<String, String> varmap = computeVarList(v, referenceInfo);\n\n      Map<String, Node> initvals = Maps.newHashMap();\n      // Figure out the top-level of the var assign node. If it's a plain\n      // ASSIGN, then there's an EXPR_STATEMENT above it, if it's a\n      // VAR then it should be directly replaced.\n      Node vnode;\n      boolean defined = referenceInfo.isWellDefined() &&\n          init.getParent().isVar();\n      if (defined) {\n        vnode = init.getParent();\n        fillInitialValues(init, initvals);\n      } else {\n        // TODO(user): More test / rewrite this part.\n        // Find the beginning of the function / script.\n        vnode = v.getScope().getRootNode().getLastChild().getFirstChild();\n      }\n\n      for (Map.Entry<String, String> entry : varmap.entrySet()) {\n        Node val = initvals.get(entry.getKey());\n        Node varnode = NodeUtil.newVarNode(entry.getValue(), val);\n        if (val == null) {\n          // is this right?\n          varnode.copyInformationFromForTree(vnode);\n        } else {\n          blacklistVarReferencesInTree(val, v.scope);\n        }\n        vnode.getParent().addChildBefore(varnode, vnode);\n      }\n\n      if (defined) {\n        vnode.getParent().removeChild(vnode);\n      }\n\n      for (Reference ref : referenceInfo.references) {\n        // The init/decl have already been converted.\n        if (defined && ref == init) continue;\n\n        if (ref.isLvalue()) {\n          // Assignments have to be handled specially, since they\n          // expand out into multiple assignments.\n          replaceAssignmentExpression(v, ref, varmap);\n        } else if (ref.getParent().isVar()) {\n          // The old variable declaration. It didn't have a\n          // value. Remove it entirely as it should now be unused.\n          ref.getGrandparent().removeChild(ref.getParent());\n        } else {\n          // Make sure that the reference is a GETPROP as we expect it to be.\n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          // The key being looked up in the original map.\n          String var = getprop.getChildAtIndex(1).getString();\n\n          // If the variable hasn't already been declared, add an empty\n          // declaration near all the other declarations.\n          Preconditions.checkState(varmap.containsKey(var));\n\n          // Replace the GETPROP node with a NAME.\n          Node replacement = IR.name(varmap.get(var));\n          replacement.copyInformationFrom(getprop);\n          ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n        }\n      }\n\n      compiler.reportCodeChange();\n    }"}