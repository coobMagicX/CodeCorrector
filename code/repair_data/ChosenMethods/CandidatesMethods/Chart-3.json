{"getDomainDescription": "    public String getDomainDescription() {\n        return this.domain;\n    }", "setDomainDescription": "    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }", "getRangeDescription": "    public String getRangeDescription() {\n        return this.range;\n    }", "setRangeDescription": "    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }", "getItemCount": "    public int getItemCount() {\n        return this.data.size();\n    }", "getItems": "    public List getItems() {\n        // FIXME: perhaps we should clone the data list\n        return Collections.unmodifiableList(this.data);\n    }", "getMaximumItemCount": "    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }", "setMaximumItemCount": "    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }", "getMaximumItemAge": "    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }", "setMaximumItemAge": "    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }", "getMinY": "    public double getMinY() {\n        return this.minY;\n    }", "getMaxY": "    public double getMaxY() {\n        return this.maxY;\n    }", "getTimePeriodClass": "    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }", "getDataItem": "    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getDataItem(index);\n        }\n        else {\n            return null;\n        }\n    }", "getRawDataItem": "    TimeSeriesDataItem getRawDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }", "getTimePeriod": "    public RegularTimePeriod getTimePeriod(int index) {\n        return getRawDataItem(index).getPeriod();\n    }", "getNextTimePeriod": "    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }", "getTimePeriods": "    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }", "getTimePeriodsUniqueToOtherSeries": "    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n    }", "getIndex": "    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }", "getValue": "    public Number getValue(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n    }", "add": "    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }", "update": "    public void update(int index, Number value) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        boolean iterate = false;\n        Number oldYN = item.getValue();\n        if (oldYN != null) {\n            double oldY = oldYN.doubleValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n        }\n        item.setValue(value);\n        if (iterate) {\n            findBoundsByIteration();\n        }\n        else if (value != null) {\n            double yy = value.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }", "addAndOrUpdate": "    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }", "addOrUpdate": "    public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = \"You are trying to add data where the time \"\n                    + \"period class is \" + periodClass.getName()\n                    + \", but the TimeSeries is expecting an instance of \"\n                    + this.timePeriodClass.getName() + \".\";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            // to find the revised minY / maxY\n            boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);  // remove old items if necessary, but\n                                 // don't notify anyone, because that\n                                 // happens next anyway...\n        fireSeriesChanged();\n        return overwritten;\n\n    }", "removeAgedItems": "    public void removeAgedItems(long latest, boolean notify) {\n        if (this.data.isEmpty()) {\n            return;  // nothing to do\n        }\n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        // check if there are any values earlier than specified by the history\n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed) {\n            findBoundsByIteration();\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n    }", "clear": "    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            this.timePeriodClass = null;\n            this.minY = Double.NaN;\n            this.maxY = Double.NaN;\n            fireSeriesChanged();\n        }\n    }", "delete": "    public void delete(int start, int end, boolean notify) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        findBoundsByIteration();\n        if (this.data.isEmpty()) {\n            this.timePeriodClass = null;\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }", "clone": "    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }", "createCopy": "    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }", "equals": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                that.getRangeDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.timePeriodClass,\n                that.timePeriodClass)) {\n            return false;\n        }\n        if (getMaximumItemAge() != that.getMaximumItemAge()) {\n            return false;\n        }\n        if (getMaximumItemCount() != that.getMaximumItemCount()) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return super.equals(obj);\n    }", "hashCode": "    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getRawDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getRawDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getRawDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }", "updateBoundsForAddedItem": "    private void updateBoundsForAddedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (item.getValue() != null) {\n            double y = yN.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, y);\n            this.maxY = maxIgnoreNaN(this.maxY, y);\n        }\n    }", "updateBoundsForRemovedItem": "    private void updateBoundsForRemovedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (yN != null) {\n            double y = yN.doubleValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    findBoundsByIteration();\n                }\n            }\n        }\n    }", "findBoundsByIteration": "    private void findBoundsByIteration() {\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) iterator.next();\n            updateBoundsForAddedItem(item);\n        }\n    }", "minIgnoreNaN": "    private double minIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.min(a, b);\n            }\n        }\n    }", "maxIgnoreNaN": "    private double maxIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.max(a, b);\n            }\n        }\n    }"}