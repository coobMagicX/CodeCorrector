{"getExpressionBooleanValue": "  static TernaryValue getExpressionBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getExpressionBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getExpressionBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getExpressionBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      default:\n        return getBooleanValue(n);\n    }\n  }", "getBooleanValue": "  static TernaryValue getBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NULL:\n      case Token.FALSE:\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }", "getStringValue": "  static String getStringValue(Node n) {\n    // TODO(user): Convert constant array, object, and regex literals as well.\n    switch (n.getType()) {\n      case Token.NAME:\n      case Token.STRING:\n        return n.getString();\n\n      case Token.NUMBER:\n        double value = n.getDouble();\n        long longValue = (long) value;\n\n        // Return \"1\" instead of \"1.0\"\n        if (longValue == value) {\n          return Long.toString(longValue);\n        } else {\n          return Double.toString(n.getDouble());\n        }\n\n      case Token.FALSE:\n      case Token.TRUE:\n      case Token.NULL:\n        return Node.tokenToName(n.getType());\n\n      case Token.VOID:\n        return \"undefined\";\n    }\n    return null;\n  }", "getFunctionName": "  static String getFunctionName(Node n) {\n    Node parent = n.getParent();\n    String name = n.getFirstChild().getString();\n    switch (parent.getType()) {\n      case Token.NAME:\n        // var name = function() ...\n        // var name2 = function name1() ...\n        return parent.getString();\n\n      case Token.ASSIGN:\n        // qualified.name = function() ...\n        // qualified.name2 = function name1() ...\n        return parent.getFirstChild().getQualifiedName();\n\n      default:\n        // function name() ...\n        return name != null && name.length() != 0 ? name : null;\n    }\n  }", "getNearestFunctionName": "  static String getNearestFunctionName(Node n) {\n    String name = getFunctionName(n);\n    if (name != null) {\n      return name;\n    }\n\n    // Check for the form { 'x' : function() { } }\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.OBJECTLIT:\n        // Return the name of the literal's key.\n        return getStringValue(parent.getFirstChild());\n    }\n\n    return null;\n  }", "isImmutableValue": "  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }", "isLiteralValue": "  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }", "isValidDefineValue": "  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n\n      // Uniary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }", "nodeTypeMayHaveSideEffects": "  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    if (isAssignmentOp(n)) {\n      return true;\n    }\n\n    switch(n.getType()) {\n      case Token.DELPROP:\n      case Token.DEC:\n      case Token.INC:\n      case Token.THROW:\n        return true;\n      case Token.CALL:\n        return NodeUtil.functionCallHasSideEffects(n, compiler);\n      case Token.NEW:\n        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n      case Token.NAME:\n        // A variable definition.\n        return n.hasChildren();\n      default:\n        return false;\n    }\n  }", "precedence": "  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.ARRAYLIT:\n      case Token.CALL:\n      case Token.EMPTY:\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GET_REF:\n      case Token.IF:\n      case Token.LP:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.RETURN:\n      case Token.STRING:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Node.tokenToName(type) +\n                               \" (type \" + type + \")\");\n    }\n  }", "isExpressionNode": "  static boolean isExpressionNode(Node n) {\n    return n.getType() == Token.EXPR_RESULT;\n  }", "containsFunction": "  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }", "isGetProp": "  static boolean isGetProp(Node n) {\n    return n.getType() == Token.GETPROP;\n  }", "isName": "  static boolean isName(Node n) {\n    return n.getType() == Token.NAME;\n  }", "getAssignedValue": "  static Node getAssignedValue(Node n) {\n    Preconditions.checkState(isName(n));\n    Node parent = n.getParent();\n    if (isVar(parent)) {\n      return n.getFirstChild();\n    } else if (isAssign(parent) && parent.getFirstChild() == n) {\n      return n.getNext();\n    } else {\n      return null;\n    }\n  }", "isString": "  static boolean isString(Node n) {\n    return n.getType() == Token.STRING;\n  }", "isReferenceName": "  static boolean isReferenceName(Node n) {\n    return isName(n) && !n.getString().isEmpty();\n  }", "isLabelName": "  static boolean isLabelName(Node n) {\n    return (n != null && n.getType() == Token.LABEL_NAME);\n  }", "isTryFinallyNode": "  static boolean isTryFinallyNode(Node parent, Node child) {\n    return parent.getType() == Token.TRY && parent.getChildCount() == 3\n        && child == parent.getLastChild();\n  }", "containsCall": "  static boolean containsCall(Node n) {\n    return containsType(n, Token.CALL);\n  }", "containsType": "  static boolean containsType(Node node, int type) {\n    return containsType(node, type, Predicates.<Node>alwaysTrue());\n  }", "copyNameAnnotations": "  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }", "newFunctionNode": "  public static Node newFunctionNode(String name, List<Node> params,\n      Node body, int lineno, int charno) {\n    Node parameterParen = new Node(Token.LP, lineno, charno);\n    for (Node param : params) {\n      parameterParen.addChildToBack(param);\n    }\n    Node function = new Node(Token.FUNCTION, lineno, charno);\n    function.addChildrenToBack(\n        Node.newString(Token.NAME, name, lineno, charno));\n    function.addChildToBack(parameterParen);\n    function.addChildToBack(body);\n    return function;\n  }", "newQualifiedNameNode": "  static Node newQualifiedNameNode(String name, Node basisNode,\n      String originalName) {\n    Node node = newQualifiedNameNode(name, -1, -1);\n    setDebugInformation(node, basisNode, originalName);\n    return node;\n  }", "getRootOfQualifiedName": "  static Node getRootOfQualifiedName(Node qName) {\n    for (Node current = qName; true;\n         current = current.getFirstChild()) {\n      int type = current.getType();\n      if (type == Token.NAME || type == Token.THIS) {\n        return current;\n      }\n      Preconditions.checkState(type == Token.GETPROP);\n    }\n  }", "setDebugInformation": "  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }", "newName": "  static Node newName(String name, Node basisNode, String originalName) {\n    Node nameNode = newName(name, basisNode);\n    nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n    return nameNode;\n  }", "isValidPropertyName": "  static boolean isValidPropertyName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }", "visit": "    public void visit(Node n) {\n      if (n.getType() == Token.NAME) {\n        Node parent = n.getParent();\n        if (parent != null && parent.getType() == Token.VAR) {\n          String name = n.getString();\n          if (!vars.containsKey(name)) {\n            vars.put(name, n);\n          }\n        }\n      }\n    }", "getPrototypeClassName": "  static Node getPrototypeClassName(Node qName) {\n    Node cur = qName;\n    while (isGetProp(cur)) {\n      if (cur.getLastChild().getString().equals(\"prototype\")) {\n        return cur.getFirstChild();\n      } else {\n        cur = cur.getFirstChild();\n      }\n    }\n    return null;\n  }", "getPrototypePropertyName": "  static String getPrototypePropertyName(Node qName) {\n    String qNameStr = qName.getQualifiedName();\n    int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n    int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n    return qNameStr.substring(memberIndex);\n  }", "newUndefinedNode": "  static Node newUndefinedNode(Node srcReferenceNode) {\n    // TODO(johnlenz): Why this instead of the more common \"undefined\"?\n    Node node = new Node(Token.VOID, Node.newNumber(0));\n    if (srcReferenceNode != null) {\n        node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }", "newVarNode": "  static Node newVarNode(String name, Node value) {\n    Node nodeName = Node.newString(Token.NAME, name);\n    if (value != null) {\n      Preconditions.checkState(value.getNext() == null);\n      nodeName.addChildToBack(value);\n      nodeName.copyInformationFrom(value);\n    }\n    Node var = new Node(Token.VAR, nodeName)\n        .copyInformationFrom(nodeName);\n\n    return var;\n  }", "apply": "    public boolean apply(Node n) {\n      Node parent = n.getParent();\n      return n.getType() == Token.BLOCK\n          || (!isFunction(n) && (parent == null\n              || isControlStructure(parent)\n              || isStatementBlock(parent)));\n    }", "getNodeTypeReferenceCount": "  static int getNodeTypeReferenceCount(\n      Node node, int type, Predicate<Node> traverseChildrenPred) {\n    return getCount(node, new MatchNodeType(type), traverseChildrenPred);\n  }", "isNameReferenced": "  static boolean isNameReferenced(Node node, String name) {\n    return isNameReferenced(node, name, Predicates.<Node>alwaysTrue());\n  }", "getNameReferenceCount": "  static int getNameReferenceCount(Node node, String name) {\n    return getCount(\n        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());\n  }", "has": "  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "isConstantName": "  static boolean isConstantName(Node node) {\n    return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n  }", "getInfoForNameNode": "  static JSDocInfo getInfoForNameNode(Node nameNode) {\n    JSDocInfo info = null;\n    Node parent = null;\n    if (nameNode != null) {\n      info = nameNode.getJSDocInfo();\n      parent = nameNode.getParent();\n    }\n\n    if (info == null && parent != null &&\n        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||\n          parent.getType() == Token.FUNCTION)) {\n      info = parent.getJSDocInfo();\n    }\n    return info;\n  }", "getSourceName": "  static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n      n = n.getParent();\n    }\n    return sourceName;\n  }", "newCallNode": "  static Node newCallNode(Node callTarget, Node... parameters) {\n    boolean isFreeCall = isName(callTarget);\n    Node call = new Node(Token.CALL, callTarget);\n    call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n    for (Node parameter : parameters) {\n      call.addChildToBack(parameter);\n    }\n    return call;\n  }", "evaluatesToLocalValue": "  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value) || locals.apply(value);\n      case Token.NEW:\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"}