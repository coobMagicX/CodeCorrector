{"inline": "  Node inline(\n      Node callNode, String fnName, Node fnNode, InliningMode mode) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    if (mode == InliningMode.DIRECT) {\n      return inlineReturnValue(callNode, fnNode);\n    } else {\n      return inlineFunction(callNode, fnNode, fnName);\n    }\n  }", "isDirectCallNodeReplacementPossible": "  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n    // Only inline single-statement functions\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Check if this function is suitable for direct replacement of a CALL node:\n    // a function that consists of single return that returns an expression.\n    if (!block.hasChildren()) {\n      // special case empty functions.\n      return true;\n    } else if (block.hasOneChild()) {\n      // Only inline functions that return something.\n      if (block.getFirstChild().isReturn()\n          && block.getFirstChild().getFirstChild() != null) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "canInlineReferenceAsStatementBlock": "  private CanInlineResult canInlineReferenceAsStatementBlock(\n      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    if (callSiteType == CallSiteType.UNSUPPORTED) {\n      return CanInlineResult.NO;\n    }\n\n    if (!allowDecomposition\n        && (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n            || callSiteType == CallSiteType.EXPRESSION)) {\n      return CanInlineResult.NO;\n    }\n\n    if (!callMeetsBlockInliningRequirements(\n            t, callNode, fnNode, namesToAlias)) {\n      return CanInlineResult.NO;\n    }\n\n    if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n        || callSiteType == CallSiteType.EXPRESSION) {\n      return CanInlineResult.AFTER_PREPARATION;\n    } else {\n      return CanInlineResult.YES;\n    }\n  }", "callMeetsBlockInliningRequirements": "  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n\n    // Note: functions that contain function definitions are filtered out\n    // in isCandidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // run-time cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      // Don't allow any new vars into a scope that contains eval or one\n      // that contains functions (excluding the function being inlined).\n      Predicate<Node> match = new Predicate<Node>(){\n        @Override\n        public boolean apply(Node n) {\n          if (n.isName()) {\n            return n.getString().equals(\"eval\");\n          }\n          if (!assumeMinimumCapture && n.isFunction()) {\n            return n != fnNode;\n          }\n          return false;\n        }\n      };\n      forbidTemps = NodeUtil.has(fnCallerBody,\n          match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    if (fnContainsVars && forbidTemps) {\n      return false;\n    }\n\n    // If the caller contains functions or evals, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (forbidTemps) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }", "canInlineReferenceDirectly": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "setKnownConstants": "  public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }"}