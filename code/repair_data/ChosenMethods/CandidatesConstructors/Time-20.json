{"DateTimeFormatterBuilder": "    public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }", "CharacterLiteral": "        CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }", "StringLiteral": "        StringLiteral(String value) {\n            super();\n            iValue = value;\n        }", "NumberFormatter": "        NumberFormatter(DateTimeFieldType fieldType,\n                int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }", "UnpaddedNumber": "        protected UnpaddedNumber(DateTimeFieldType fieldType,\n                       int maxParsedDigits, boolean signed)\n        {\n            super(fieldType, maxParsedDigits, signed);\n        }", "PaddedNumber": "        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n                     boolean signed, int minPrintedDigits)\n        {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }", "FixedNumber": "        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n            super(fieldType, numDigits, signed, numDigits);\n        }", "TwoDigitYear": "        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n            super();\n            iType = type;\n            iPivot = pivot;\n            iLenientParse = lenientParse;\n        }", "TextField": "        TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }", "Fraction": "        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            // Limit the precision requirements.\n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }", "TimeZoneOffset": "        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n                                boolean showSeparators,\n                                int minFields, int maxFields)\n        {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }", "TimeZoneName": "        TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n            super();\n            iType = type;\n            iParseLookup = parseLookup;\n        }", "Composite": "        Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }", "MatchingParser": "        MatchingParser(DateTimeParser[] parsers) {\n            super();\n            iParsers = parsers;\n            int est = 0;\n            for (int i=parsers.length; --i>=0 ;) {\n                DateTimeParser parser = parsers[i];\n                if (parser != null) {\n                    int len = parser.estimateParsedLength();\n                    if (len > est) {\n                        est = len;\n                    }\n                }\n            }\n            iParsedLengthEstimate = est;\n        }"}