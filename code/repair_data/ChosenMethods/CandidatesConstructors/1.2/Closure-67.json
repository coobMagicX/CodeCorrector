{"AnalyzePrototypeProperties": "  AnalyzePrototypeProperties(AbstractCompiler compiler,\n      JSModuleGraph moduleGraph, boolean canModifyExterns,\n      boolean anchorUnusedVars) {\n    this.compiler = compiler;\n    this.moduleGraph = moduleGraph;\n    this.canModifyExterns = canModifyExterns;\n    this.anchorUnusedVars = anchorUnusedVars;\n\n    if (moduleGraph != null) {\n      firstModule = moduleGraph.getRootModule();\n    } else {\n      firstModule = null;\n    }\n\n    globalNode.markReference(null);\n    externNode.markReference(null);\n    symbolGraph.createNode(globalNode);\n    symbolGraph.createNode(externNode);\n\n    for (String property : IMPLICITLY_USED_PROPERTIES) {\n      NameInfo nameInfo = getNameInfoForName(property, PROPERTY);\n      if (moduleGraph == null) {\n        symbolGraph.connect(externNode, null, nameInfo);\n      } else {\n        for (JSModule module : moduleGraph.getAllModules()) {\n          symbolGraph.connect(externNode, module, nameInfo);\n        }\n      }\n    }\n  }", "ProcessProperties": "    private ProcessProperties() {\n      symbolStack.push(new NameContext(globalNode));\n    }", "GlobalFunction": "    GlobalFunction(Node nameNode, Node parent, Node gramps, JSModule module) {\n      Preconditions.checkState(\n          parent.getType() == Token.VAR ||\n          NodeUtil.isFunctionDeclaration(parent));\n      this.nameNode = nameNode;\n      this.module = module;\n    }", "AssignmentProperty": "    AssignmentProperty(Node node, JSModule module) {\n      this.exprNode = node;\n      this.module = module;\n    }", "LiteralProperty": "    LiteralProperty(Node key, Node value, Node map, Node assign,\n        JSModule module) {\n      this.key = key;\n      this.value = value;\n      this.map = map;\n      this.assign = assign;\n      this.module = module;\n    }", "NameContext": "    NameContext(NameInfo name) {\n      this.name = name;\n    }", "NameInfo": "    NameInfo(String name) {\n      this.name = name;\n    }"}