{"InlineFunctions": "  InlineFunctions(AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean inlineGlobalFunctions,\n      boolean inlineLocalFunctions,\n      boolean blockFunctionInliningEnabled) {\n    Preconditions.checkArgument(compiler != null);\n    Preconditions.checkArgument(safeNameIdSupplier != null);\n    this.compiler = compiler;\n\n    this.inlineGlobalFunctions = inlineGlobalFunctions;\n    this.inlineLocalFunctions = inlineLocalFunctions;\n    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n\n    this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true);\n  }", "CallVisitor": "    CallVisitor(Map<String, FunctionState> fns,\n                Map<Node, String> anonFns,\n                CallVisitorCallback callback) {\n      this.functionMap = fns;\n      this.anonFunctionMap = anonFns;\n      this.callback = callback;\n    }", "FindCandidatesReferences": "    FindCandidatesReferences(\n        Map<String, FunctionState> fns,\n        Map<Node, String> anonFns) {\n      super(fns, anonFns, null);\n      this.callback = this;\n    }", "Inline": "    Inline(FunctionInjector injector,\n        SpecializeModule.SpecializationState specializationState) {\n      this.injector = injector;\n      this.specializationState = specializationState;\n    }", "NamedFunction": "    public NamedFunction(Node fn) {\n      this.fn = fn;\n    }", "FunctionVar": "    public FunctionVar(Node var) {\n      this.var = var;\n    }", "FunctionExpression": "    public FunctionExpression(Node fn, int index) {\n      this.fn = fn;\n      // A number is not a valid function javascript indentifier\n      // so we don't need to worry about collisions.\n      this.fakeName = String.valueOf(index);\n    }", "Reference": "    Reference(\n        Node callNode, JSModule module, InliningMode mode, boolean decompose) {\n      super(callNode, module, mode);\n      this.requiresDecomposition = decompose;\n    }"}