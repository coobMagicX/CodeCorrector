{"TypeInference": "  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE);\n\n    this.syntacticScope = functionScope;\n    inferArguments(functionScope);\n\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n    this.assertionFunctionsMap = assertionFunctionsMap;\n\n    // For each local variable declared with the VAR keyword, the entry\n    // type is VOID.\n    Iterator<Var> varIt =\n        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (isUnflowable(var)) {\n        continue;\n      }\n\n      this.functionScope.inferSlotType(\n          var.getName(), getNativeType(VOID_TYPE));\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        Scope.createLatticeBottom(functionScope.getRootNode()));\n  }", "TemplateTypeReplacer": "    TemplateTypeReplacer(\n        JSTypeRegistry registry, Map<TemplateType, JSType> replacements) {\n      super(registry);\n      this.registry = registry;\n      this.replacements = replacements;\n    }", "BooleanOutcomePair": "    BooleanOutcomePair(\n        BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues,\n        FlowScope leftScope, FlowScope rightScope) {\n      this.toBooleanOutcomes = toBooleanOutcomes;\n      this.booleanValues = booleanValues;\n      this.leftScope = leftScope;\n      this.rightScope = rightScope;\n    }"}